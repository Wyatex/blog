<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ajax学习笔记（1）：Axios入门</title>
    <url>/%E5%89%8D%E7%AB%AF/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9AAxios%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Ajax-介绍"><a href="#Ajax-介绍" class="headerlink" title="Ajax 介绍"></a>Ajax 介绍</h1><h2 id="什么是-axios"><a href="#什么是-axios" class="headerlink" title="什么是 axios"></a>什么是 axios</h2><p>官方介绍：</p>
<blockquote>
<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。<br>特性：</p>
<ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这篇文章先介绍如何在 html 文件里引入和基本的使用，下一篇文章介绍如何在 npm 里使用并封装到项目里使用。<br>使用 cdn 引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>发送一个 GET 方法的 ajax 请求(几种方法)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?id=123&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">123</span> &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>

<p>三种方法都可以发送请求，而且上面三个的效果都是一样的。axios()和 axios.get()都会返回一个 promise，只需要使用 then 去处理返回的响应（比如上面的 res）即可。也可以使用 async&#x2F;await 语法，不过大佬建议不要用 async&#x2F;await 语法，因为如果使用 babel 等工具转译成 es3、es5 语法之后会生成很大量的代码，如果对这些没要求的话也是可以使用的。</p>
<p>同理，发送 post、put、options 请求也是差不多方法，为了方便，axios 提供了所有支持的请求方法的别名：</p>
<ul>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.options(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<p>在使用别名方法时， url、method、data 这些属性都不必在配置中指定(get 请求的 params 除外)。</p>
<h1 id="创建示例"><a href="#创建示例" class="headerlink" title="创建示例"></a>创建示例</h1><p>使用 create 方法创建一个 axios 示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://your-api-server.com/&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123; <span class="title class_">Authorization</span>: <span class="string">&#x27;Bearer abcdefg&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">params</span>: &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后也是一样可以调用 request、get、post……等方法发送请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.<span class="title function_">request</span>(<span class="string">&#x27;/user&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>

<h1 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h1><p>这部分是创建请求时可用的配置选项，其中只有 url 是必需的，其他可用按需求进行配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认方法：get</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params` 是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="keyword">function</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属：FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属： Stream</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）.</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头（Basic类型）</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;12345678&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseType` 表示浏览器将要响应的数据类型</span></span><br><span class="line">  <span class="comment">// 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="comment">// 浏览器专属：&#x27;blob&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认json</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span></span><br><span class="line">  <span class="comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// 则promise 将会 resolved，否则是 rejected。</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认值</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会进行重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定 `socketPath` 或 `proxy` 。</span></span><br><span class="line">  <span class="comment">// 若都指定，这使用 `socketPath` 。</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span></span><br><span class="line">  <span class="comment">// and https requests, respectively, in node.js. This allows options to be added like</span></span><br><span class="line">  <span class="comment">// `keepAlive` that are not enabled by default.</span></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#x27;proxy&#x27; 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h1><p>如果你尝试过上面的 get 请求，如果你在 then 里将 res 打印出来，你将会得到如下数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应体，可用将数据放在这里</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="attr">&quot;statusText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  <span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h1><h2 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h2><p>可用修改各个请求的配置默认值，比如查看上面的<a href="/%E5%89%8D%E7%AB%AF/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9AAxios%E5%85%A5%E9%97%A8/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE">请求配置</a>部分，可用看到请求默认的方法是 get，我们可用这样修改成默认 post 方法发送请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;post&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果请求你的 api 服务器需要 token 的话，可用直接在 header 上加上默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br></pre></td></tr></table></figure>

<h2 id="实例的默认值"><a href="#实例的默认值" class="headerlink" title="实例的默认值"></a>实例的默认值</h2><p>设置某个实例的默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br></pre></td></tr></table></figure>

<h2 id="配置的优先顺序-面试可能会考？"><a href="#配置的优先顺序-面试可能会考？" class="headerlink" title="配置的优先顺序(面试可能会考？)"></a>配置的优先顺序(面试可能会考？)</h2><p>配置会以一个优先顺序进行合并。这个顺序是：在 axios 源码中找到默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者，这是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 `0`</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.<span class="title function_">create</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写库的超时默认值</span></span><br><span class="line"><span class="comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已知需要花费很长时间的请求覆写超时设置，该请求将会等待5秒</span></span><br><span class="line">instance.<span class="title function_">get</span>(<span class="string">&#x27;/longRequest&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>在请求或响应被 then 或 catch 处理前可用拦截它们。比如上面演示的加 token 操作，推荐做法不是在配置里面加而是让拦截器为我们加上。<br>比如设置一个请求拦截器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么，比如加上token或者设置超时等</span></span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="variable constant_">AUTH_TOKEN</span></span><br><span class="line">    config.<span class="property">timeout</span> = <span class="number">5000</span></span><br><span class="line">    config.<span class="property">method</span> = <span class="string">&#x27;post&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>同样也可以为响应加上拦截器，在 then 进行处理之前响应的数据将会被拦截器处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么，比如加上一点数据？</span></span><br><span class="line">    response.<span class="property">data</span>.<span class="property">username</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果你想在稍后移除这个拦截器，可用这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor)</span><br></pre></td></tr></table></figure>

<p>同样上面为全局 axios 设置的拦截器，如果后面使用 axios.create()创建实例的话上面设置的拦截器是不起作用的，如果需要为实例配置的话，可用这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>()</span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同理去除拦截器也是使用 eject 方法去除。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>官方示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error.<span class="property">response</span>) &#123;</span><br><span class="line">    <span class="comment">// The request was made and the server responded with a status code</span></span><br><span class="line">    <span class="comment">// that falls out of the range of 2xx</span></span><br><span class="line">    <span class="comment">// 渣翻：当请求发出后，服务器返回了一个响应</span></span><br><span class="line">    <span class="comment">// 而且响应的状态码（status code）不是2xx范围内</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">response</span>.<span class="property">data</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">response</span>.<span class="property">status</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">response</span>.<span class="property">headers</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">request</span>) &#123;</span><br><span class="line">    <span class="comment">// The request was made but no response was received</span></span><br><span class="line">    <span class="comment">// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span></span><br><span class="line">    <span class="comment">// http.ClientRequest in node.js</span></span><br><span class="line">    <span class="comment">// 渣翻：请求发出但是没接收到响应</span></span><br><span class="line">    <span class="comment">// `error.request`在浏览器端是发送请求的xhr实例，在node是http.ClientRequest实例</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">request</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Something happened in setting up the request that triggered an Error</span></span><br><span class="line">    <span class="comment">// 在设置请求时发生了错误，在这里会被捕捉到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error&#x27;</span>, error.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">config</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可用使用 <code>validateStatus</code> 配置选项定义一个自定义 HTTP 状态码错误范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="comment">// Reject only if the status code is greater than or equal to 500</span></span><br><span class="line">    <span class="comment">// 渣翻：当状态码大于等于500时才触发reject</span></span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面是我根据对官方文档的使用介绍理解后写的文章，和官方文档不完全一样，如有其他需要请查看官方文档，下一篇文章介绍如何在npm项目里使用并封装一些自己需要的功能。</p>
</blockquote>
<p><a href="">官方文档</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax学习笔记（2）：Axios基本封装</title>
    <url>/%E5%89%8D%E7%AB%AF/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9AAxios%E5%9F%BA%E6%9C%AC%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>这章简单讲解如何在 npm 项目里使用，并封装，下一章将会讲到如何配合 ts 使用，并进一步封装一些功能。</p>
<span id="more"></span>

<p>废话不多说，直接上代码：</p>
<figure class="highlight js"><figcaption><span>axios.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先引入axios，记得提前npm或者yarn添加axios依赖哦</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里假设使用element的message组件来弹出消息提示</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span>, <span class="title class_">MessageBox</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入封装好的路由实例，详细代码到路由篇讲解</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://api-server.com&#x27;</span>, <span class="comment">// 设置你的后端url</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5</span> * <span class="number">1000</span>, <span class="comment">// 请求超时时间，这里设置5s</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设登录过时后继续使用过时token会返回403，或者没带上token会返回401</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOGIN_TIMEOUT</span> = <span class="number">403</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NO_LOGIN</span> = <span class="number">401</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个当后端返回错误时弹出消息提示的方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">errMessage</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = err.<span class="property">response</span>.<span class="property">data</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;ACCESS_TOKEN&#x27;</span>)  <span class="comment">// 正式项目不应该直接用localstorage</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="variable constant_">LOGIN_TIMEOUT</span>) &#123;</span><br><span class="line">      <span class="title class_">Message</span>.<span class="title function_">error</span>(<span class="string">&#x27;您的登录状态已经过时了，请重新登陆！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">message</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(data.<span class="property">message</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="variable constant_">NO_LOGIN</span>) &#123;</span><br><span class="line">      <span class="title class_">Message</span>.<span class="title function_">error</span>(<span class="string">&#x27;您还未登录！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器，这里只是为请求加上token，你还可以加上一些其他的数据</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;ACCESS_TOKEN&#x27;</span>)</span><br><span class="line">  <span class="comment">// 这里只是判断如果存在token时加上token，实际上应该加上：如果没有token，应该再次登录，这个功能下一篇实现</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, errMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果响应是blob二进制数据直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">request</span>.<span class="property">responseType</span> === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> code = response.<span class="property">data</span>.<span class="property">code</span></span><br><span class="line">  <span class="keyword">if</span> (code === <span class="variable constant_">LOGIN_TIMEOUT</span> || code === <span class="variable constant_">NO_LOGIN</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br><span class="line">    router.<span class="title function_">replace</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="title class_">Login</span>,</span><br><span class="line">      <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">redirect</span>: router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">fullPath</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === xxx <span class="comment">/* || ... */</span> ) &#123;</span><br><span class="line">    message.<span class="title function_">error</span>(response.<span class="property">data</span>.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, errMessage)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure>

<p>这样基本的 axios 就封装好了，下面演示如何封装成一些方法并使用。</p>
<figure class="highlight js"><figcaption><span>api.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户列表</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">list</span>(<span class="params">parameter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/user/list&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: parameter,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加用户</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">parameter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/user/add&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: parameter,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><figcaption><span>MainPage.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; add <span class="keyword">as</span> <span class="title class_">AddUser</span>, list <span class="keyword">as</span> <span class="title class_">UserList</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;api.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">userForm</span>: &#123;</span><br><span class="line">                <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">getUserList</span>(<span class="params">params</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title class_">UserList</span>(params)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">addNewUser</span>(<span class="params">info</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title class_">AddUser</span>(info)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如上，就是本章的主要内容，下一章讲解如果配合ts使用，并实现更丰富一点的功能（实际上也没多多少功能）。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax学习笔记：XMLHttpRequest</title>
    <url>/%E5%89%8D%E7%AB%AF/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AXMLHttpRequest/</url>
    <content><![CDATA[<blockquote>
<p>MDN：<code>XMLHttpRequest</code>（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>本文内容大部分来至：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">MDN</a> 、<a href="https://juejin.im/post/6844903472714743816">你不知道的 XMLHttpRequest</a></p>
</blockquote>
<p>尽管名称叫这个，但是 <code>XMLHttpRequest</code> 可以用于获取任何类型的数据。它甚至支持 HTTP 以外的协议（包括 file:&#x2F;&#x2F; 和 FTP），尽管可能受到更多出于安全等原因的限制。</p>
<p>但是如果只是需要单纯从服务器端接收事件或消息数据，应该通过 <code>EventSource</code> 接口使用 <code>Server-sent events</code> ，如果是全双工通信应该使用 <code>WebSocket</code>, 使用方法在这章简述：<a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/#WebSocket">Html5学习笔记</a></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>通过 <code>XMLHttpRequest()</code> 方法可以得到一个该对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>
<p>在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>此接口继承了 <code>XMLHttpRequestEventTarget</code> 和 <code>EventTarget</code> 的属性。</p>
<h2 id="XMLHttpRequest-readyState"><a href="#XMLHttpRequest-readyState" class="headerlink" title="XMLHttpRequest.readyState"></a>XMLHttpRequest.readyState</h2><p><strong>该属性为只读</strong></p>
<p>XMLHttpRequest.readyState 属性返回一个 XMLHttpRequest  代理当前所处的状态。一个 XHR 代理总是处于下列状态中的一个：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>UNSENT</code></td>
<td>代理被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code></td>
<td><code>open()</code> 方法已经被调用。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code></td>
<td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code></td>
<td>下载中； responseText 属性已经包含部分数据。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code></td>
<td>下载操作已完成。</td>
</tr>
</tbody></table>
<p><strong>OPENED</strong> ： 在这个状态中，可以通过 <code>setRequestHeader()</code> 方法来设置请求的头部， 可以调用 <code>send()</code> 方法来发起请求。</p>
<p><strong>LOADING</strong>： 响应体部分正在被接收。如果 responseType 属性是“text”或空字符串， responseText 将会在载入的过程中拥有部分响应数据。</p>
<p><strong>DONE</strong>： 请求操作已经完成。这意味着数据传输已经彻底完成或失败。</p>
<blockquote>
<p>在IE中，状态有着不同的名称，并不是 <code>UNSENT</code>，<code>OPENED</code> ， <code>HEADERS_RECEIVED</code> ， <code>LOADING</code> 和 <code>DONE</code>, 而是 <code>READYSTATE_UNINITIALIZED</code> (0)，<code>READYSTATE_LOADING</code> (1) ， <code>READYSTATE_LOADED</code> (2) ， <code>READYSTATE_INTERACTIVE</code> (3) 和 <code>READYSTATE_COMPLETE</code> (4) 。</p>
</blockquote>
<p>实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;UNSENT&#x27;</span>, xhr.<span class="property">readyState</span>); <span class="comment">// readyState 为 0</span></span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;OPENED&#x27;</span>, xhr.<span class="property">readyState</span>); <span class="comment">// readyState 为 1</span></span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LOADING&#x27;</span>, xhr.<span class="property">readyState</span>); <span class="comment">// readyState 为 3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>, xhr.<span class="property">readyState</span>); <span class="comment">// readyState 为 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="XMLHttpRequest-onreadystatechange"><a href="#XMLHttpRequest-onreadystatechange" class="headerlink" title="XMLHttpRequest.onreadystatechange"></a>XMLHttpRequest.onreadystatechange</h2><p>该属性是一个方法，当 readyState 属性改变时会调用它</p>
<h2 id="XMLHttpRequest-status"><a href="#XMLHttpRequest-status" class="headerlink" title="XMLHttpRequest.status"></a>XMLHttpRequest.status</h2><p>返回一个无符号短整型（unsigned short）数字，代表请求的响应状态。</p>
<h2 id="XMLHttpRequest-statusText"><a href="#XMLHttpRequest-statusText" class="headerlink" title="XMLHttpRequest.statusText"></a>XMLHttpRequest.statusText</h2><p>只读属性 <code>XMLHttpRequest.statusText</code> 返回了 <code>XMLHttpRequest</code> 请求中由服务器返回的一个 <code>DOMString</code> 类型的文本信息，这则信息中也包含了响应的数字状态码。不同于使用一个数字来指示的状态码 <code>XMLHTTPRequest.status</code> ，这个属性包含了返回状态对应的文本信息，例如”OK”或是”Not Found”。如果请求的状态 <code>readyState</code> 的值为”UNSENT”或者”OPENED”，则这个属性的值将会是一个空字符串。<br>如果服务器未明确指定一个状态文本信息，则<code>statusText</code>的值将会被自动赋值为”OK”。</p>
<h2 id="XMLHttpRequest-upload"><a href="#XMLHttpRequest-upload" class="headerlink" title="XMLHttpRequest.upload"></a>XMLHttpRequest.upload</h2><p><strong>该属性为只读</strong></p>
<p><code>XMLHttpRequest.upload</code> 属性返回一个 <code>XMLHttpRequestUpload</code> 对象，用来表示上传的进度。这个对象是不透明的，但是作为一个 <code>XMLHttpRequestEventTarget</code> ，可以通过对其绑定事件来追踪它的进度。</p>
<p>可以被绑定在upload对象上的事件监听器如下:</p>
<ol>
<li>onloadstart: 获取开始</li>
<li>onprogress: 数据传输进行中</li>
<li>onabort: 获取操作终止</li>
<li>onerror: 获取失败</li>
<li>onload: 获取成功</li>
<li>ontimeout: 获取操作在用户规定的时间内未完成</li>
<li>onloadend: 获取完成（不论成功与否）</li>
</ol>
<h2 id="XMLHttpRequest-timeout"><a href="#XMLHttpRequest-timeout" class="headerlink" title="XMLHttpRequest.timeout"></a>XMLHttpRequest.timeout</h2><p><code>XMLHttpRequest.timeout</code> 是一个无符号长整型数，代表着一个请求在被自动终止前所消耗的毫秒数。默认值为 0，意味着没有超时。超时并不应该用在一个 <a href="https://developer.mozilla.org/en-US/docs/Glossary/document_environment">document environment</a> 中的同步 XMLHttpRequests  请求中，否则将会抛出一个 <code>InvalidAccessError</code> 类型的错误。当超时发生， <code>timeout</code> 事件将会被触发。</p>
<h2 id="一些response属性"><a href="#一些response属性" class="headerlink" title="一些response属性"></a>一些response属性</h2><p><code>XMLHttpRequest.response</code> ：响应体的类型由 <code>responseType</code> 来指定，可以是 <code>ArrayBuffer、Blob、Document、JSON</code>，或者是字符串。如果请求未完成或失败，则该值为 null。<strong>该属性为只读</strong></p>
<p><code>XMLHttpRequest.responseText</code> ：返回一个 <code>DOMString</code>，该 <code>DOMString</code> 包含对请求的响应，如果请求未成功或尚未发送，则返回 <code>null</code>。<strong>该属性为只读</strong></p>
<p><code>XMLHttpRequest.responseType</code> ：一个用于定义响应类型的枚举值（enumerated value）。responseType支持以下几种值：</p>
<ul>
<li><code>&quot;&quot;</code> :<code>responseType</code> 为空字符串时，采用默认类型 DOMString，与设置为 text 相同。</li>
<li><code>arraybuffer</code> :<code>response</code> 是一个包含二进制数据的 JavaScript <code>ArrayBuffer</code>。</li>
<li><code>blob</code> : <code>response</code> 是一个包含二进制数据的 Blob 对象 。</li>
<li><code>document</code> :<code>response</code> 是一个 <code>HTML Document</code> 或 <code>XML XMLDocument</code>，这取决于接收到的数据的 <code>MIME</code> 类型。</li>
<li><code>json</code> : <code>response</code> 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON 解析得到的。</li>
<li><code>text</code> : <code>response</code> 是一个以 <code>DOMString</code> 对象表示的文本。</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>包括下面方法：</p>
<ol>
<li><code>XMLHttpRequest.open()</code> ：初始化一个请求。</li>
<li><code>XMLHttpRequest.send()</code> ：发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。</li>
<li><code>XMLHttpRequest.abort()</code> ：如果请求已经被发送，则立刻中止请求。</li>
<li><code>XMLHttpRequest.getAllResponseHeaders()</code> ：返回所有响应头信息(响应头名和值)，如果响应头还没有接收，则返回 null。<strong>注意：使用该方法获取的 response headers 与在开发者工具 Network 面板中看到的响应头不一致</strong></li>
<li><code>XMLHttpRequest.overrideMimeType()</code> ：重写由服务器返回的 MIME 类型。例如，可以用于强制把响应流当做 text&#x2F;xml 来解析，即使服务器没有指明数据是这个类型。<strong>注意：这个方法必须在 send() 之前被调用。</strong></li>
<li><code>XMLHttpRequest.setRequestHeader()</code> ：设置 HTTP 请求头信息。<strong>注意：在这之前，你必须确认已经调用了 open() 方法打开了一个 url</strong></li>
</ol>
<p>open() 方法签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void open(</span><br><span class="line">   DOMString method,                //请求所使用的 HTTP 方法，如 GET、POST、PUT、DELETE</span><br><span class="line">   DOMString url,                   //请求的 URL 地址</span><br><span class="line">   optional boolean async,          //一个可选的布尔值参数，默认值为 true，表示执行异步操作。如果值为 false，则 send() 方法不会返回任何东西，直到接收到了服务器的返回数据</span><br><span class="line">   optional DOMString user,         //用户名，可选参数，用于授权。默认参数为空字符串</span><br><span class="line">   optional DOMString password      //密码，可选参数，用于授权。默认参数为空字符串</span><br><span class="line">)   </span><br></pre></td></tr></table></figure>

<p>send() 方法签名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void send();</span><br><span class="line">void send(ArrayBuffer data);</span><br><span class="line">void send(Blob data);</span><br><span class="line">void send(Document data);</span><br><span class="line">void send(DOMString? data);</span><br><span class="line">void send(FormData data);</span><br></pre></td></tr></table></figure>
<p>如果发送的数据是Document对象，需要在发送之前将其序列化。</p>
<p>发送二进制内容的最佳方法（如上传文件）是使用一个与send()方法结合的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView">ArrayBufferView</a> 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blobs</a></p>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><h2 id="简单的GET"><a href="#简单的GET" class="headerlink" title="简单的GET"></a>简单的GET</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 请求结束后,在此处写处理代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// xhr.send(&#x27;string&#x27;);</span></span><br><span class="line"><span class="comment">// xhr.send(new Blob());</span></span><br><span class="line"><span class="comment">// xhr.send(new Int8Array());</span></span><br><span class="line"><span class="comment">// xhr.send(&#123; form: &#x27;data&#x27; &#125;);</span></span><br><span class="line"><span class="comment">// xhr.send(document);</span></span><br></pre></td></tr></table></figure>

<h2 id="简单的POST"><a href="#简单的POST" class="headerlink" title="简单的POST"></a>简单的POST</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送合适的请求头信息</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 请求结束后,在此处写处理代码 </span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&quot;foo=bar&amp;lorem=ipsum&quot;</span>); </span><br><span class="line"><span class="comment">// xhr.send(&#x27;string&#x27;); </span></span><br><span class="line"><span class="comment">// xhr.send(new Blob()); </span></span><br><span class="line"><span class="comment">// xhr.send(new Int8Array()); </span></span><br><span class="line"><span class="comment">// xhr.send(&#123; form: &#x27;data&#x27; &#125;); </span></span><br><span class="line"><span class="comment">// xhr.send(document);</span></span><br></pre></td></tr></table></figure>

<h2 id="传FormData"><a href="#传FormData" class="headerlink" title="传FormData"></a>传FormData</h2><p>为了方便表单数据，HTML 5新增了一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData">FormData</a> 对象，可以用于模拟表单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先新建一个 FormData 对象</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line"><span class="comment">//然后，为它添加表单项</span></span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;wyatex&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="comment">//最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。</span></span><br><span class="line">xhr.<span class="title function_">send</span>(formData)</span><br></pre></td></tr></table></figure>
<p>FormData 对象也可以用来获取网页表单的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var form = document.getElementById(&#x27;myform&#x27;);   // 获取页面上表单对象</span><br><span class="line">var formData = new FormData(form);</span><br><span class="line">formData.append(&#x27;role&#x27;, &#x27;user&#x27;);                // 添加一个表单项</span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>为了上传文件, 我们得先选中一个文件. 一个 <code>type</code> 为 <code>file</code> 的 <code>input</code> 输入框</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;input&quot;</span> type=<span class="string">&quot;file&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后用 FormData 对象包裹选中的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>),</span><br><span class="line">formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>,input.<span class="property">files</span>[<span class="number">0</span>]); <span class="comment">// file名称与后台接收的名称一致</span></span><br><span class="line"><span class="comment">//设置上传地址和请求方法(使用POST方法)，最后发送 `FormData` 对象</span></span><br><span class="line">xhr.<span class="title function_">send</span>(formData);</span><br></pre></td></tr></table></figure>

<h2 id="进度信息"><a href="#进度信息" class="headerlink" title="进度信息"></a>进度信息</h2><p>新版本的 XMLHttpRequest 对象，传送数据的时候，有一个 progress 事件，用来返回进度信息。</p>
<p>它分成上传和下载两种情况。下载的 progress 事件属于 XMLHttpRequest 对象，上传的 progress 事件属于XMLHttpRequest.upload 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> precent = e.<span class="property">loaded</span> / e.<span class="property">total</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = xhr.<span class="property">onprogress</span></span><br></pre></td></tr></table></figure>
<p>其中total是需要传输的总字节，loaded是已经传输的字节。如果event.lengthComputable 不为真，则 event.total 等于0。</p>
<h1 id="XHR定时轮询和长轮询"><a href="#XHR定时轮询和长轮询" class="headerlink" title="XHR定时轮询和长轮询"></a>XHR定时轮询和长轮询</h1><p>感觉这部分不怎么需要，到时候需要再写</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>32个手写JS（知识点总结）</title>
    <url>/%E5%89%8D%E7%AB%AF/32%E4%B8%AA%E6%89%8B%E5%86%99JS%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    <content><![CDATA[<p>下面是B站找回来的资源</p>
<span id="more"></span>

<h1 id="32个手写JS，巩固你的JS基础（面试高频）"><a href="#32个手写JS，巩固你的JS基础（面试高频）" class="headerlink" title="32个手写JS，巩固你的JS基础（面试高频）"></a>32个手写JS，巩固你的JS基础（面试高频）</h1><p>作为前端开发，JS是重中之重，最近结束了面试的高峰期，基本上offer也定下来了就等开奖，趁着这个时间总结下32个手写JS问题，这些都是高频面试题，希望对你能有所帮助。</p>
<p>关于源码都紧遵规范，都可跑通MDN示例</p>
<h2 id="01-数组扁平化"><a href="#01-数组扁平化" class="headerlink" title="01.数组扁平化"></a>01.数组扁平化</h2><p>数组扁平化是指将一个多维数组变为一个一维数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="方法一：使用flat"><a href="#方法一：使用flat" class="headerlink" title="方法一：使用flat()"></a>方法一：使用flat()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res1 = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法二：利用正则"><a href="#方法二：利用正则" class="headerlink" title="方法二：利用正则"></a>方法二：利用正则</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res2 = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr).<span class="title function_">replace</span>(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但数据类型都会变为字符串</p>
<h3 id="方法三：正则改良版本"><a href="#方法三：正则改良版本" class="headerlink" title="方法三：正则改良版本"></a>方法三：正则改良版本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res3 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;[&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr).<span class="title function_">replace</span>(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;]&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法四：使用reduce"><a href="#方法四：使用reduce" class="headerlink" title="方法四：使用reduce"></a>方法四：使用reduce</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res4 = <span class="title function_">flatten</span>(arr);</span><br></pre></td></tr></table></figure>

<h3 id="方法五：函数递归"><a href="#方法五：函数递归" class="headerlink" title="方法五：函数递归"></a>方法五：函数递归</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res5 = [];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      <span class="title function_">fn</span>(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res5.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(arr);</span><br></pre></td></tr></table></figure>

<h2 id="02-数组去重"><a href="#02-数组去重" class="headerlink" title="02.数组去重"></a>02.数组去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">17</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="comment">// =&gt; [1, &#x27;1&#x27;, 17, true, false, &#x27;true&#x27;, &#x27;a&#x27;, &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="方法一：利用Set"><a href="#方法一：利用Set" class="headerlink" title="方法一：利用Set"></a>方法一：利用Set</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br></pre></td></tr></table></figure>

<h3 id="方法二：两层for循环-splice"><a href="#方法二：两层for循环-splice" class="headerlink" title="方法二：两层for循环+splice"></a>方法二：两层for循环+splice</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique1</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 每删除一个树，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能</span></span><br><span class="line">        len--;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：利用indexOf"><a href="#方法三：利用indexOf" class="headerlink" title="方法三：利用indexOf"></a>方法三：利用indexOf</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique2</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) res.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以用include、filter，思路大同小异。</p>
<h3 id="方法四：利用include"><a href="#方法四：利用include" class="headerlink" title="方法四：利用include"></a>方法四：利用include</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique3</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.<span class="title function_">includes</span>(arr[i])) res.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法五：利用filter"><a href="#方法五：利用filter" class="headerlink" title="方法五：利用filter"></a>方法五：利用filter</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique4</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法六：利用Map"><a href="#方法六：利用Map" class="headerlink" title="方法六：利用Map"></a>方法六：利用Map</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique5</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.<span class="title function_">has</span>(arr[i])) &#123;</span><br><span class="line">      map.<span class="title function_">set</span>(arr[i], <span class="literal">true</span>)</span><br><span class="line">      res.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="03-类数组转化为数组"><a href="#03-类数组转化为数组" class="headerlink" title="03.类数组转化为数组"></a>03.类数组转化为数组</h2><p>类数组是具有<strong>length</strong>属性，但不具有数组原型上的方法。常见的类数组有<strong>arguments</strong>、DOM操作方法返回的结果。</p>
<h3 id="方法一：Array-from"><a href="#方法一：Array-from" class="headerlink" title="方法一：Array.from"></a>方法一：Array.from</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="方法二：Array-prototype-slice-call"><a href="#方法二：Array-prototype-slice-call" class="headerlink" title="方法二：Array.prototype.slice.call()"></a>方法二：Array.prototype.slice.call()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="方法三：扩展运算符"><a href="#方法三：扩展运算符" class="headerlink" title="方法三：扩展运算符"></a>方法三：扩展运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="方法四：利用concat"><a href="#方法四：利用concat" class="headerlink" title="方法四：利用concat"></a>方法四：利用concat</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="04-Array-prototype-filter"><a href="#04-Array-prototype-filter" class="headerlink" title="04.Array.prototype.filter()"></a>04.Array.prototype.filter()</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804ee51d522746c3b219548d038413c2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or not undefined&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27;is not a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 让O成为回调函数的对象传递（强制转换对象）</span></span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;0 保证len为number，且为正整数</span></span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 检查i是否在O的属性（会检查原型链）</span></span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="comment">// 回调函数调用传参</span></span><br><span class="line">      <span class="keyword">if</span> (callback.<span class="title function_">call</span>(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(O[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="05-Array-prototype-map"><a href="#05-Array-prototype-map" class="headerlink" title="05.Array.prototype.map()"></a>05.Array.prototype.map()</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b099cf3e06bc4421abac4dc460a13c17~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 同理</span></span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="comment">// 调用回调函数并传入新数组</span></span><br><span class="line">      res[i] = callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="06-Array-prototype-forEach"><a href="#06-Array-prototype-forEach" class="headerlink" title="06.Array.prototype.forEach()"></a>06.Array.prototype.forEach()</h2><p><code>forEach</code>跟map类似，唯一不同的是<code>forEach</code>是没有返回值的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      callback.<span class="title function_">call</span>(thisArg, O[k], k, O);</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="07-Array-prototype-reduce"><a href="#07-Array-prototype-reduce" class="headerlink" title="07.Array.prototype.reduce()"></a>07.Array.prototype.reduce()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span> = <span class="keyword">function</span>(<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackfn + <span class="string">&#x27; is not a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果第二个参数为undefined的情况下</span></span><br><span class="line">  <span class="comment">// 则数组的第一个有效值作为累加器的初始值</span></span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> O)) &#123;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果超出数组界限还没有找到累加器的初始值，则TypeError</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= len) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    accumulator = O[k++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callback.<span class="title function_">call</span>(<span class="literal">undefined</span>, accumulator, O[k], k, O);</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="08-Function-prototype-apply"><a href="#08-Function-prototype-apply" class="headerlink" title="08.Function.prototype.apply()"></a>08.Function.prototype.apply()</h2><p>第一个参数是绑定的this，默认为<code>window</code>，第二个参数是数组或类数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span>(<span class="params">context = <span class="variable language_">window</span>, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Type Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="09-Function-prototype-call"><a href="#09-Function-prototype-call" class="headerlink" title="09.Function.prototype.call"></a>09.Function.prototype.call</h2><p>于<code>call</code>唯一不同的是，<code>call()</code>方法接受的是一个参数列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params">context = <span class="variable language_">window</span>, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Type Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-Function-prototype-bind"><a href="#10-Function-prototype-bind" class="headerlink" title="10.Function.prototype.bind"></a>10.Function.prototype.bind</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Type Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存this的值</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 考虑new的情况</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">self</span>(...args, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(context, [...args, ...<span class="variable language_">arguments</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-debounce（防抖）"><a href="#11-debounce（防抖）" class="headerlink" title="11.debounce（防抖）"></a>11.debounce（防抖）</h2><p>触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, time</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>防抖常应用于用户进行搜索输入节约请求资源，<code>window</code>触发<code>resize</code>事件时进行防抖只触发一次。</p>
<h2 id="12-throttle（节流）"><a href="#12-throttle（节流）" class="headerlink" title="12.throttle（节流）"></a>12.throttle（节流）</h2><p>高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, time</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节流常应用于鼠标不断点击触发、监听滚动事件。</p>
<h2 id="13-函数珂里化"><a href="#13-函数珂里化" class="headerlink" title="13.函数珂里化"></a>13.函数珂里化</h2><blockquote>
<p>  指的是将一个接受多个参数的函数 变为 接受一个参数返回一个函数的固定形式，这样便于再次调用，例如f(1)(2)</p>
</blockquote>
<p>经典面试题：实现<code>add(1)(2)(3)(4)=10;</code> 、 <code>add(1)(1,2,3)(2)=9;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    _args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  &#125;</span><br><span class="line">  fn.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-模拟new操作"><a href="#14-模拟new操作" class="headerlink" title="14.模拟new操作"></a>14.模拟new操作</h2><p>3个步骤：</p>
<ol>
<li>以<code>ctor.prototype</code>为原型创建一个对象。</li>
<li>执行构造函数并将this绑定到新创建的对象上。</li>
<li>判断构造函数执行返回的结果是否是引用数据类型，若是则返回构造函数执行的结果，否则返回创建的对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newOperator</span>(<span class="params">ctor, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Type Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(ctor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">const</span> res = ctor.<span class="title function_">apply</span>(obj, args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> isObject || isFunction ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-instanceof"><a href="#15-instanceof" class="headerlink" title="15.instanceof"></a>15.instanceof</h2><p><code>instanceof</code>运算符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myInstanceof</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 基本数据类型都返回false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-原型继承"><a href="#16-原型继承" class="headerlink" title="16.原型继承"></a>16.原型继承</h2><p>这里只写寄生组合继承了，中间还有几个演变过来的继承但都有一些缺陷</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;children&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br></pre></td></tr></table></figure>

<h2 id="17-Object-is"><a href="#17-Object-is" class="headerlink" title="17.Object.is"></a>17.Object.is</h2><p><code>Object.is</code>解决的主要是这两个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span>  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is</span>= (<span class="params">x, y</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// +0和-0应该不相等</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span>/x === <span class="number">1</span>/y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-Object-assign"><a href="#18-Object-assign" class="headerlink" title="18.Object.assign"></a>18.Object.assign</h2><p><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象（请注意这个操作是浅拷贝）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">target, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象需要统一是引用数据类型，若不是会自动转换</span></span><br><span class="line">    <span class="keyword">const</span> to = <span class="title class_">Object</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 每一个源对象</span></span><br><span class="line">      <span class="keyword">const</span> nextSource = args[i];</span><br><span class="line">      <span class="keyword">if</span> (nextSource !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用for...in和hasOwnProperty双重判断，确保只拿到本身的属性、方法（不包含继承的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> nextKey <span class="keyword">in</span> nextSource) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(nextSource, nextKey)) &#123;</span><br><span class="line">            to[nextKey] = nextSource[nextKey];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 不可枚举</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="19-深拷贝"><a href="#19-深拷贝" class="headerlink" title="19.深拷贝"></a>19.深拷贝</h2><p>递归的完整版本（考虑到了Symbol属性）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">cloneDeep1</span> = (<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对于传入参数处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 哈希表中存在直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(target)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">  hash.<span class="title function_">set</span>(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对Symbol属性</span></span><br><span class="line">  <span class="keyword">const</span> symKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (symKeys.<span class="property">length</span>) &#123;</span><br><span class="line">    symKeys.<span class="title function_">forEach</span>(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[symKey] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target[symKey] !== <span class="literal">null</span>) &#123;</span><br><span class="line">        cloneTarget[symKey] = <span class="title function_">cloneDeep1</span>(target[symKey]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cloneTarget[symKey] = target[symKey];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, i)) &#123;</span><br><span class="line">      cloneTarget[i] =</span><br><span class="line">        <span class="keyword">typeof</span> target[i] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target[i] !== <span class="literal">null</span></span><br><span class="line">        ? <span class="title function_">cloneDeep1</span>(target[i], hash)</span><br><span class="line">        : target[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-Promise"><a href="#20-Promise" class="headerlink" title="20.Promise"></a>20.Promise</h2><p>实现思路：<a href="https://juejin.im/post/6860037916622913550">Promise源码实现</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>;      <span class="comment">// 进行中</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;FULFILLED&#x27;</span>;  <span class="comment">// 已成功</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;REJECTED&#x27;</span>;    <span class="comment">// 已失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">exector</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    <span class="comment">// 将成功、失败结果放在this上，便于then、catch访问</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 成功态回调函数队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = [];</span><br><span class="line">    <span class="comment">// 失败态回调函数队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">      <span class="comment">// 只有进行中状态才能更改状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="comment">// 成功态函数依次执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">value</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line">      <span class="comment">// 只有进行中状态才能更改状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="comment">// 失败态函数依次执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">reason</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 立即执行executor</span></span><br><span class="line">      <span class="comment">// 把内部的resolve和reject传入executor，用户可调用resolve和reject</span></span><br><span class="line">      <span class="title function_">exector</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">// executor执行出错，将错误内容reject抛出去</span></span><br><span class="line">      <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span>? <span class="attr">onRejected</span>:</span><br><span class="line">      <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(reason <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? reason.<span class="property">message</span>:reason) &#125;</span><br><span class="line">    <span class="comment">// 保存this</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        self.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// try捕获错误</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟微任务</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> result = <span class="title function_">onFulfilled</span>(self.<span class="property">value</span>);</span><br><span class="line">              <span class="comment">// 分两种情况：</span></span><br><span class="line">              <span class="comment">// 1. 回调函数返回值是Promise，执行then操作</span></span><br><span class="line">              <span class="comment">// 2. 如果不是Promise，调用新Promise的resolve函数</span></span><br><span class="line">              result <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? result.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 以下同理</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> result = <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">              <span class="comment">// 不同点：此时是reject</span></span><br><span class="line">              result <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? result.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">reject</span>(result);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="title function_">onFulfilled</span>(self.<span class="property">value</span>);</span><br><span class="line">            result <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? result.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="title function_">onRejected</span>(self.<span class="property">reason</span>);</span><br><span class="line">            result <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? result.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">reject</span>(result);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是Promise实例，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-Promise-all"><a href="#21-Promise-all" class="headerlink" title="21.Promise.all"></a>21.Promise.all</h2><p><code>Promise.all</code>是支持链式调用的，本质上就是返回了一个Promise实例，通过<code>resolve</code>和<code>reject</code>来改变实例状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">myAll</span> = <span class="keyword">function</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promiseArr[i]</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        ans[i] = res;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">reject</span>(err));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-Promise-race"><a href="#22-Promise-race" class="headerlink" title="22.Promise.race"></a>22.Promise.race</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是Promise实例需要转化为Promise实例</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">val</span> =&gt;</span> <span class="title function_">resolve</span>(val),</span><br><span class="line">        <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">reject</span>(err),</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-Promise并行限制"><a href="#23-Promise并行限制" class="headerlink" title="23.Promise并行限制"></a>23.Promise并行限制</h2><p>就是实现有并行限制的Promise调度器问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxCount</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">runCounts</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">promiseCreator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(promiseCreator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">taskStart</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">maxCount</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">queue</span> || !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> || <span class="variable language_">this</span>.<span class="property">runCounts</span> &gt;= <span class="variable language_">this</span>.<span class="property">maxCount</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">runCounts</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">runCounts</span>--;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">timeout</span> = time =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addTask</span> = (<span class="params">time,order</span>) =&gt; &#123;</span><br><span class="line">  scheduler.<span class="title function_">add</span>(<span class="function">() =&gt;</span> <span class="title function_">timeout</span>(time).<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(order)))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">1000</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">500</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">300</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">400</span>, <span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">scheduler.<span class="title function_">taskStart</span>()</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="24-JSONP"><a href="#24-JSONP" class="headerlink" title="24.JSONP"></a>24.JSONP</h2><p>script标签不遵循同源协议，可以用来进行<strong>跨域请求</strong>，优点就是兼容性好但仅限于GET请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">jsonp</span> = (<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">generateUrl</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dataSrc = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(params, key)) &#123;</span><br><span class="line">        dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> scriptEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    scriptEle.<span class="property">src</span> = <span class="title function_">generateUrl</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptEle);</span><br><span class="line">    <span class="variable language_">window</span>[callbackName] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeChild</span>(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-AJAX"><a href="#25-AJAX" class="headerlink" title="25.AJAX"></a>25.AJAX</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="title class_">XMLHttpRequest</span> ? <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() : <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Mscrosoft.XMLHttp&#x27;</span>);</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>);</span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span> || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(xhr.<span class="property">responseText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-event模块"><a href="#26-event模块" class="headerlink" title="26.event模块"></a>26.event模块</h2><p>实现node中回调函数的机制，node中回调函数其实是内部使用了<strong>观察者模式</strong>。</p>
<blockquote>
<p>  观察者模式：定义了对象间一种一对多的依赖关系，当目标对象Subject发生改变时，所有依赖它的对象Observer都会得到通知。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">EventEmitter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">events</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要实现的一些方法：</span></span><br><span class="line"><span class="comment">// addListener、removeListener、once、removeAllListeners、emit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现addlistener方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">wrapCallback</span> = (<span class="params">fn, once = <span class="literal">false</span></span>) =&gt; (&#123; <span class="attr">callback</span>: fn, once &#125;);</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addListener</span> = <span class="keyword">function</span>(<span class="params">type, fn, once = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hanlder = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(type);</span><br><span class="line">  <span class="keyword">if</span> (!hanlder) &#123;</span><br><span class="line">    <span class="comment">// 没有type绑定事件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(type, <span class="title function_">wrapCallback</span>(fn, once));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hanlder &amp;&amp; <span class="keyword">typeof</span> hanlder.<span class="property">callback</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 目前type事件只有一个回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(type, [hanlder, <span class="title function_">wrapCallback</span>(fn, once)]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 目前type事件数&gt;=2</span></span><br><span class="line">    hanlder.<span class="title function_">push</span>(<span class="title function_">wrapCallback</span>(fn, once));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟实现removeListener</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeListener</span> = <span class="keyword">function</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hanlder = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(type);</span><br><span class="line">  <span class="keyword">if</span> (!hanlder) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>.<span class="property">events</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hanlder.<span class="property">callback</span> === listener.<span class="property">callback</span>) <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">delete</span>(type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hanlder.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = hanlder[i];</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">callback</span> === listener.<span class="property">callback</span>) &#123;</span><br><span class="line">      hanlder.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">      i--;</span><br><span class="line">      <span class="keyword">if</span> (hanlder.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(type, hanlder[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟实现once方法</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">once</span> = <span class="keyword">function</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">addListener</span>(type, listener, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟实现emit方法</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hanlder = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(type);</span><br><span class="line">  <span class="keyword">if</span> (!hanlder) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(hanlder)) &#123;</span><br><span class="line">    hanlder.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="property">callback</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">once</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeListener</span>(type, item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hanlder.<span class="property">callback</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="keyword">if</span> (hanlder.<span class="property">once</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">delete</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeAllListeners</span> = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hanlder = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(type);</span><br><span class="line">  <span class="keyword">if</span> (!hanlder) <span class="keyword">return</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">delete</span>(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-图片懒加载"><a href="#27-图片懒加载" class="headerlink" title="27.图片懒加载"></a>27.图片懒加载</h2><p>可以给img标签统一自定义属性<code>data-src=&#39;default.png&#39;</code>，当检测到图片出现在窗口之后再补充<strong>src</strong>属性，此时才会进行图片资源加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> len = imgs.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 视口的高度</span></span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="comment">// 滚动条高度</span></span><br><span class="line">  <span class="keyword">const</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> offsetHeight = imgs[i].<span class="property">offsetTop</span>;</span><br><span class="line">    <span class="keyword">if</span> (offsetHeight &lt; viewHeight + scrollHeight) &#123;</span><br><span class="line">      <span class="keyword">const</span> src = imgs[i].<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">      imgs[i].<span class="property">src</span> = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用节流优化一下</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, lazyload);</span><br></pre></td></tr></table></figure>

<h2 id="28-滚动加载"><a href="#28-滚动加载" class="headerlink" title="28.滚动加载"></a>28.滚动加载</h2><p>原理就是监听页面滚动事件，<strong>分析clientHeight</strong>、<strong>scrollTop</strong>、<strong>scrollHeight</strong>三者的属性关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> clientHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">const</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br><span class="line">  <span class="keyword">const</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollHeight</span>;</span><br><span class="line">  <span class="keyword">if</span> (clientHeight + scrollTop &gt;= scrollHeight) &#123;</span><br><span class="line">    <span class="comment">// 检测到滚动至页面底部，进行后续操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="29-渲染几万条数据不卡住页面"><a href="#29-渲染几万条数据不卡住页面" class="headerlink" title="29.渲染几万条数据不卡住页面"></a>29.渲染几万条数据不卡住页面</h2><p>渲染大数据时，合理使用<strong>createDocumentFragment</strong>和<strong>requestAnimationFrame</strong>，将操作切分为一小段一小段执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 插入十万条数据</span></span><br><span class="line">  <span class="keyword">const</span> total = <span class="number">100000</span>;</span><br><span class="line">  <span class="comment">// 一次插入的数据</span></span><br><span class="line">  <span class="keyword">const</span> once = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 插入数据需要的次数</span></span><br><span class="line">  <span class="keyword">const</span> loopCount = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(total / once);</span><br><span class="line">  <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">  <span class="comment">// 添加数据的方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">      li.<span class="property">innerText</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * total);</span><br><span class="line">      fragment.<span class="title function_">appendChild</span>(li);</span><br><span class="line">    &#125;</span><br><span class="line">    ul.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line">    countOfRender += <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">loop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(countOfRender &lt; loopCount) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(add);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">loop</span>();</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="30-打印出当前网页使用了多少种HTML元素"><a href="#30-打印出当前网页使用了多少种HTML元素" class="headerlink" title="30.打印出当前网页使用了多少种HTML元素"></a>30.打印出当前网页使用了多少种HTML元素</h2><p>一行代码可以解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>([...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;*&#x27;</span>)].<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">tagName</span>))].<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是：DOM操作返回的是<strong>类数组</strong>，需要转换为数组之后才可以调用数组的方法。</p>
<h2 id="31-将VirtualDom转化为真实DOM结构"><a href="#31-将VirtualDom转化为真实DOM结构" class="headerlink" title="31.将VirtualDom转化为真实DOM结构"></a>31.将VirtualDom转化为真实DOM结构</h2><p>这是当前SPA应用的核心概念之一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vnode结构：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   tag,</span></span><br><span class="line"><span class="comment">//   attrs,</span></span><br><span class="line"><span class="comment">//   children,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Virtual DOM =&gt; DOM</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">  container.<span class="title function_">appendChild</span>(<span class="title function_">_render</span>(vnode));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_render</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是数字类型转化为字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    vnode = <span class="title class_">String</span>(vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字符串类型直接就是文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 普通DOM</span></span><br><span class="line">  <span class="keyword">const</span> dom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>);</span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">attrs</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(vnode.<span class="property">attrs</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.<span class="property">attrs</span>[key];</span><br><span class="line">      dom.<span class="title function_">setAttribute</span>(key, value);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子数组进行递归操作</span></span><br><span class="line">  vnode.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">render</span>(child, dom));</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-字符串解析问题"><a href="#32-字符串解析问题" class="headerlink" title="32.字符串解析问题"></a>32.字符串解析问题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&#x27;789&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">`a&#123;a.b&#125;aa&#123;a.c&#125;aa &#123;a.d&#125;aaaa`</span>;</span><br><span class="line"><span class="comment">// =&gt; &#x27;a123aa456aa &#123;a.d&#125;aaaa&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实现函数使得将str字符串中的<code>&#123;&#125;</code>内的变量替换，如果属性不存在保持原样（比如<code>&#123;a.d&#125;</code>）</p>
<p>类似于模版字符串，但有一点出入，实际上原理大差不差</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params">str, obj</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 标志位，标志前面是否有&#123;</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) res += str[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] === <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                res += <span class="title function_">match</span>(str.<span class="title function_">slice</span>(start, i), obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象匹配操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">match</span> = (<span class="params">str, obj</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> o = obj;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[index];</span><br><span class="line">        <span class="keyword">if</span> (!o[key]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;str&#125;</span>&#125;`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = o[key];</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax学习笔记（3）：Axios进一步封装</title>
    <url>/%E5%89%8D%E7%AB%AF/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9AAxios%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>这一章降幅大幅提高复杂性，而且使用到 Typescript，如果还不熟悉 ts 的小伙伴可以去 B 站查找一下教程，先掌握好 ts 基本知识。<br>如果之前没用过 axios 的话建议先看完前两章内容：<a href="">Axios 入门</a> 、 <a href="">Axios 基本封装</a><br>而且将会配合 vue3 和 naiveUI 一起使用，如果不熟悉可以先去查一下文档稍微熟悉一下再回来看。</p>
<span id="more"></span>

<p>下面也是废话不多说，直接开始：<br>首先闯将 checkStatus.ts 文件，负责将状态码转换成对应的信息并提示出来：</p>
<figure class="highlight ts"><figcaption><span>checkStatus.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入响应的状态、信息、信息展示组件。对应的状态码可以根据你的项目需求修改</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">checkStatus</span>(<span class="params">status: <span class="built_in">number</span>, msg: <span class="built_in">string</span>, message: <span class="built_in">any</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 401: 未登录</span></span><br><span class="line">    <span class="comment">// 未登录则跳转登录页面，并携带当前页面的路径</span></span><br><span class="line">    <span class="comment">// 在登录成功后返回当前页面，这一步需要在登录页操作。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;用户没有权限（令牌、用户名、密码错误）!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;用户得到授权，但是访问是被禁止的。!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 404请求不存在</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;网络请求错误,未找到该资源!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">405</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;网络请求错误,请求方法未允许!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;网络请求超时!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;服务器错误,请联系管理员!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;网络未实现!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;网络错误!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;服务不可用，服务器暂时过载或维护!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;网络超时!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(<span class="string">&#x27;http版本不支持该请求!&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      message.<span class="title function_">error</span>(msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建文件 type.ts，定义一些类型并导出</p>
<figure class="highlight ts"><figcaption><span>type.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">RequestOptions</span> &#123;</span><br><span class="line">  <span class="comment">// 请求参数拼接到url</span></span><br><span class="line">  joinParamsToUrl?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 格式化请求参数时间</span></span><br><span class="line">  formatDate?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 是否显示提示信息</span></span><br><span class="line">  isShowMessage?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 是否解析成JSON</span></span><br><span class="line">  isParseToJson?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 成功的文本信息</span></span><br><span class="line">  successMessageText?: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 是否显示成功信息</span></span><br><span class="line">  isShowSuccessMessage?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 是否显示失败信息</span></span><br><span class="line">  isShowErrorMessage?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 错误的文本信息</span></span><br><span class="line">  errorMessageText?: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 是否加入url</span></span><br><span class="line">  joinPrefix?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 接口地址， 不填则使用默认apiUrl</span></span><br><span class="line">  apiUrl?: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 错误消息提示类型</span></span><br><span class="line">  errorMessageMode?: <span class="string">&#x27;none&#x27;</span> | <span class="string">&#x27;modal&#x27;</span></span><br><span class="line">  <span class="comment">// 是否添加时间戳</span></span><br><span class="line">  joinTime?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 进行处理还是直接返回</span></span><br><span class="line">  isTransformResponse?: <span class="built_in">boolean</span></span><br><span class="line">  <span class="comment">// 是否返回原生响应头</span></span><br><span class="line">  isReturnNativeResponse?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Result</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">data</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是数据处理类：</p>
<figure class="highlight ts"><figcaption><span>axiosTransform.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">AxiosRequestConfig</span>, <span class="title class_">AxiosResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RequestOptions</span>, <span class="title class_">Result</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AxiosTransform</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求之前处理配置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: Process configuration before request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  beforeRequestHook?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    config: AxiosRequestConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">    options: RequestOptions</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="title class_">AxiosRequestConfig</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求成功处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  transformRequestData?: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    res: AxiosResponse&lt;Result&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    options: RequestOptions</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求失败处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  requestCatch?: <span class="function">(<span class="params">e: <span class="built_in">Error</span></span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求之前的拦截器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  requestInterceptors?: <span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> <span class="title class_">AxiosRequestConfig</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求之后的拦截器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  responseInterceptors?: <span class="function">(<span class="params">res: AxiosResponse&lt;<span class="built_in">any</span>&gt;</span>) =&gt;</span> <span class="title class_">AxiosResponse</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求之前的拦截器错误处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  requestInterceptorsCatch?: <span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求之后的拦截器错误处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  responseInterceptorsCatch?: <span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 CreateAxiosOptions 接口</p>
<figure class="highlight ts"><figcaption><span>createAxiosOptions.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AxiosRequestConfig</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AxiosTransform</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./axiosTransform&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RequestOptions</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CreateAxiosOptions</span> <span class="keyword">extends</span> <span class="title class_">AxiosRequestConfig</span> &#123;</span><br><span class="line">  prefixUrl?: <span class="built_in">string</span></span><br><span class="line">  transform?: <span class="title class_">AxiosTransform</span></span><br><span class="line">  requestOptions?: <span class="title class_">RequestOptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 axiosCancel.ts 用于处理取消请求，关于 axios 的 cancel 功能请看<a href="https://axios-http.com/zh/docs/cancellation">官方文档</a></p>
<figure class="highlight ts"><figcaption><span>axiosCancel.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosRequestConfig</span>, <span class="title class_">Canceler</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> isFunction&lt;T = <span class="title class_">Function</span>&gt;(<span class="attr">val</span>: <span class="built_in">unknown</span>): val is T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(val) === <span class="string">&#x27;[object Function]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 Map 用于存储每个请求的标识 和 取消函数</span></span><br><span class="line"><span class="keyword">let</span> pendingMap = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Canceler</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPendingUrl</span> = (<span class="params">config: AxiosRequestConfig</span>) =&gt;</span><br><span class="line">  [</span><br><span class="line">    config.<span class="property">method</span>,</span><br><span class="line">    config.<span class="property">url</span>,</span><br><span class="line">    qs.<span class="title function_">stringify</span>(config.<span class="property">data</span>),</span><br><span class="line">    qs.<span class="title function_">stringify</span>(config.<span class="property">params</span>),</span><br><span class="line">  ].<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AxiosCanceler</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加请求</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">config</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addPending</span>(<span class="params">config: AxiosRequestConfig</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removePending</span>(config)</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getPendingUrl</span>(config)</span><br><span class="line">    config.<span class="property">cancelToken</span> =</span><br><span class="line">      config.<span class="property">cancelToken</span> ||</span><br><span class="line">      <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="function">(<span class="params">cancel</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pendingMap.<span class="title function_">has</span>(url)) &#123;</span><br><span class="line">          <span class="comment">// 如果 pending 中不存在当前请求，则添加进去</span></span><br><span class="line">          pendingMap.<span class="title function_">set</span>(url, cancel)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 清空所有pending</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeAllPending</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pendingMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cancel</span>) =&gt;</span> &#123;</span><br><span class="line">      cancel &amp;&amp; <span class="title function_">isFunction</span>(cancel) &amp;&amp; <span class="title function_">cancel</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    pendingMap.<span class="title function_">clear</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除请求</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">config</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removePending</span>(<span class="params">config: AxiosRequestConfig</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getPendingUrl</span>(config)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingMap.<span class="title function_">has</span>(url)) &#123;</span><br><span class="line">      <span class="comment">// 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除</span></span><br><span class="line">      <span class="keyword">const</span> cancel = pendingMap.<span class="title function_">get</span>(url)</span><br><span class="line">      cancel &amp;&amp; <span class="title function_">cancel</span>(url)</span><br><span class="line">      pendingMap.<span class="title function_">delete</span>(url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 重置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">reset</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    pendingMap = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Canceler</span>&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 MyAxios.ts，用于实例化 axios、设置拦截器等操作</p>
<figure class="highlight ts"><figcaption><span>myAxios.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">AxiosRequestConfig</span>, <span class="title class_">AxiosInstance</span>, <span class="title class_">AxiosResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AxiosCanceler</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./axiosCancel&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; cloneDeep &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash-es&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RequestOptions</span>, <span class="title class_">Result</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">CreateAxiosOptions</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./createAxiosOptions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> isFunction&lt;T = <span class="title class_">Function</span>&gt;(<span class="attr">val</span>: <span class="built_in">unknown</span>): val is T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(val) === <span class="string">&#x27;[object Function]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./axiosTransform&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:  axios模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyAxios</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">axiosInstance</span>: <span class="title class_">AxiosInstance</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">options</span>: <span class="title class_">CreateAxiosOptions</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options: CreateAxiosOptions</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = options</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">axiosInstance</span> = axios.<span class="title function_">create</span>(options)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setupInterceptors</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>:  创建axios实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">createAxios</span>(<span class="attr">config</span>: <span class="title class_">CreateAxiosOptions</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">axiosInstance</span> = axios.<span class="title function_">create</span>(config)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getAxios</span>(): <span class="title class_">AxiosInstance</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">axiosInstance</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 重新配置axios</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">configAxios</span>(<span class="params">config: CreateAxiosOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">axiosInstance</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">createAxios</span>(config)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getTransform</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; transform &#125; = <span class="variable language_">this</span>.<span class="property">options</span></span><br><span class="line">    <span class="keyword">return</span> transform</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 设置通用header</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">setHeader</span>(<span class="attr">headers</span>: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">axiosInstance</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>.<span class="property">axiosInstance</span>.<span class="property">defaults</span>.<span class="property">headers</span>, headers)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 拦截器配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">setupInterceptors</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> transform = <span class="variable language_">this</span>.<span class="title function_">getTransform</span>()</span><br><span class="line">    <span class="keyword">if</span> (!transform) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      requestInterceptors,</span><br><span class="line">      requestInterceptorsCatch,</span><br><span class="line">      responseInterceptors,</span><br><span class="line">      responseInterceptorsCatch,</span><br><span class="line">    &#125; = transform</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> axiosCanceler = <span class="keyword">new</span> <span class="title class_">AxiosCanceler</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求拦截器配置处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">axiosInstance</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">      <span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          <span class="attr">headers</span>: &#123; ignoreCancelToken &#125; = &#123; <span class="attr">ignoreCancelToken</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">        &#125; = config</span><br><span class="line">        !ignoreCancelToken &amp;&amp; axiosCanceler.<span class="title function_">addPending</span>(config)</span><br><span class="line">        <span class="keyword">if</span> (requestInterceptors &amp;&amp; <span class="title function_">isFunction</span>(requestInterceptors)) &#123;</span><br><span class="line">          config = <span class="title function_">requestInterceptors</span>(config)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">undefined</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求拦截器错误捕获</span></span><br><span class="line">    requestInterceptorsCatch &amp;&amp;</span><br><span class="line">      <span class="title function_">isFunction</span>(requestInterceptorsCatch) &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">axiosInstance</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">        <span class="literal">undefined</span>,</span><br><span class="line">        requestInterceptorsCatch</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应结果拦截器处理</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">axiosInstance</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">res: AxiosResponse&lt;<span class="built_in">any</span>&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      res &amp;&amp; axiosCanceler.<span class="title function_">removePending</span>(res.<span class="property">config</span>)</span><br><span class="line">      <span class="keyword">if</span> (responseInterceptors &amp;&amp; <span class="title function_">isFunction</span>(responseInterceptors)) &#123;</span><br><span class="line">        res = <span class="title function_">responseInterceptors</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;, <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应结果拦截器错误捕获</span></span><br><span class="line">    responseInterceptorsCatch &amp;&amp;</span><br><span class="line">      <span class="title function_">isFunction</span>(responseInterceptorsCatch) &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">axiosInstance</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">        <span class="literal">undefined</span>,</span><br><span class="line">        responseInterceptorsCatch</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>:   请求方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  request&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    <span class="attr">config</span>: <span class="title class_">AxiosRequestConfig</span>,</span><br><span class="line">    options?: <span class="title class_">RequestOptions</span></span><br><span class="line">  ): <span class="title class_">Promise</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">conf</span>: <span class="title class_">AxiosRequestConfig</span> = <span class="title function_">cloneDeep</span>(config)</span><br><span class="line">    <span class="keyword">const</span> transform = <span class="variable language_">this</span>.<span class="title function_">getTransform</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; requestOptions &#125; = <span class="variable language_">this</span>.<span class="property">options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">opt</span>: <span class="title class_">RequestOptions</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, requestOptions, options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; beforeRequestHook, requestCatch, transformRequestData &#125; =</span><br><span class="line">      transform || &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beforeRequestHook &amp;&amp; <span class="title function_">isFunction</span>(beforeRequestHook)) &#123;</span><br><span class="line">      conf = <span class="title function_">beforeRequestHook</span>(conf, opt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">axiosInstance</span></span><br><span class="line">        .<span class="property">request</span>&lt;<span class="built_in">any</span>, <span class="title class_">AxiosResponse</span>&lt;<span class="title class_">Result</span>&gt;&gt;(conf)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">res: AxiosResponse&lt;Result&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 请求是否被取消</span></span><br><span class="line">          <span class="keyword">const</span> isCancel = axios.<span class="title function_">isCancel</span>(res)</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            transformRequestData &amp;&amp;</span><br><span class="line">            <span class="title function_">isFunction</span>(transformRequestData) &amp;&amp;</span><br><span class="line">            !isCancel</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="keyword">const</span> ret = <span class="title function_">transformRequestData</span>(res, opt)</span><br><span class="line">            <span class="comment">// ret !== undefined ? resolve(ret) : reject(new Error(&#x27;request error!&#x27;));</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">resolve</span>(ret)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">reject</span>(res <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">Promise</span>&lt;T&gt;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">e: <span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (requestCatch &amp;&amp; <span class="title function_">isFunction</span>(requestCatch)) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="title function_">requestCatch</span>(e))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一些工具</p>
<figure class="highlight ts"><figcaption><span>util.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 判断值是否未某个类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">is</span>(<span class="params">val: <span class="built_in">unknown</span>, <span class="keyword">type</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> toString.<span class="title function_">call</span>(val) === <span class="string">`[object <span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:  是否为函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> isFunction&lt;T = <span class="title class_">Function</span>&gt;(<span class="attr">val</span>: <span class="built_in">unknown</span>): val is T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">is</span>(val, <span class="string">&#x27;Function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:  是否为字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">val: <span class="built_in">unknown</span></span>): val is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">is</span>(val, <span class="string">&#x27;String&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 是否为对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isObject = (<span class="attr">val</span>: <span class="built_in">any</span>): val is <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> val !== <span class="literal">null</span> &amp;&amp; <span class="title function_">is</span>(val, <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DATE_TIME_FORMAT</span> = <span class="string">&#x27;YYYY-MM-DD HH:mm&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> joinTimestamp&lt;T <span class="keyword">extends</span> <span class="built_in">boolean</span>&gt;(</span><br><span class="line">  <span class="attr">join</span>: <span class="built_in">boolean</span>,</span><br><span class="line">  <span class="attr">restful</span>: T</span><br><span class="line">): T <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="built_in">string</span> : <span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> joinTimestamp&lt;T <span class="keyword">extends</span> <span class="built_in">boolean</span>&gt;(</span><br><span class="line">  <span class="attr">join</span>: <span class="built_in">boolean</span>,</span><br><span class="line">  <span class="attr">restful</span>: T</span><br><span class="line">): T <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="built_in">string</span> : <span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">joinTimestamp</span>(<span class="params">join: <span class="built_in">boolean</span>, restful = <span class="literal">false</span></span>): <span class="built_in">string</span> | <span class="built_in">object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!join) &#123;</span><br><span class="line">    <span class="keyword">return</span> restful ? <span class="string">&#x27;&#x27;</span> : &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">if</span> (restful) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`?_t=<span class="subst">$&#123;now&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">_t</span>: now &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Format request parameter time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">formatRequestDate</span>(<span class="params">params: Recordable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(params) !== <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params[key] &amp;&amp; params[key].<span class="property">_isAMomentObject</span>) &#123;</span><br><span class="line">      params[key] = params[key].<span class="title function_">format</span>(<span class="variable constant_">DATE_TIME_FORMAT</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isString</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = params[key];</span><br><span class="line">      <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          params[key] = <span class="title function_">isString</span>(value) ? value.<span class="title function_">trim</span>() : value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(params[key])) &#123;</span><br><span class="line">      <span class="title function_">formatRequestDate</span>(params[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将对象添加当作参数拼接到URL上面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> baseUrl 需要拼接的url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 参数对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 拼接后的对象</span></span><br><span class="line"><span class="comment"> * 例子:</span></span><br><span class="line"><span class="comment"> *  let obj = &#123;a: &#x27;3&#x27;, b: &#x27;4&#x27;&#125;</span></span><br><span class="line"><span class="comment"> *  setObjToUrlParams(&#x27;www.baidu.com&#x27;, obj)</span></span><br><span class="line"><span class="comment"> *  ==&gt;www.baidu.com?a=3&amp;b=4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setObjToUrlParams</span>(<span class="params">baseUrl: <span class="built_in">string</span>, obj: <span class="built_in">object</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> parameters = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    parameters += key + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(obj[key]) + <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  parameters = parameters.<span class="title function_">replace</span>(<span class="regexp">/&amp;$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/\?$/</span>.<span class="title function_">test</span>(baseUrl)) &#123;</span><br><span class="line">    url = baseUrl + parameters;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    url = baseUrl.<span class="title function_">replace</span>(<span class="regexp">/\/?$/</span>, <span class="string">&#x27;?&#x27;</span>) + parameters;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后写一个 index.ts，填写一些配置，然后导出这个实例。</p>
<figure class="highlight ts"><figcaption><span>index.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios配置  可自行根据项目进行更改，只需更改该文件即可，其他文件可以不动</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyAxios</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./myAxios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AxiosTransform</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./axiosTransform&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; checkStatus &#125; <span class="keyword">from</span> <span class="string">&#x27;./checkStatus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; joinTimestamp, formatRequestDate &#125; <span class="keyword">from</span> <span class="string">&#x27;./helper&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RequestEnum</span>, <span class="title class_">ResultEnum</span>, <span class="title class_">ContentTypeEnum</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/enums/httpEnum&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PageEnum</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/enums/pageEnum&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useGlobSetting &#125; <span class="keyword">from</span> <span class="string">&#x27;@/hooks/setting&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isString &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/is/&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; setObjToUrlParams &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/urlUtils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RequestOptions</span>, <span class="title class_">Result</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useUserStoreWidthOut &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/modules/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> globSetting = <span class="title function_">useGlobSetting</span>()</span><br><span class="line"><span class="keyword">const</span> urlPrefix = globSetting.<span class="property">urlPrefix</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; storage &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/Storage&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 数据处理，方便区分多种处理方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">transform</span>: <span class="title class_">AxiosTransform</span> = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 处理请求数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">transformRequestData</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    res: AxiosResponse&lt;Result&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    options: RequestOptions</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">$message</span>: <span class="title class_">Message</span>, <span class="attr">$dialog</span>: <span class="title class_">Modal</span> &#125; = <span class="variable language_">window</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      isShowMessage = <span class="literal">true</span>,</span><br><span class="line">      isShowErrorMessage,</span><br><span class="line">      isShowSuccessMessage,</span><br><span class="line">      successMessageText,</span><br><span class="line">      errorMessageText,</span><br><span class="line">      isTransformResponse,</span><br><span class="line">      isReturnNativeResponse,</span><br><span class="line">    &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="title class_">Promise</span>.<span class="property">reject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">      <span class="comment">// return &#x27;[HTTP] Request has no return value&#x27;;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  这里 code，result，message为 后台统一的字段，需要在 types.ts内修改为项目自己的接口返回格式</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code, result, message &#125; = data</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录超时</span></span><br><span class="line">    <span class="keyword">if</span> (code === <span class="title class_">ResultEnum</span>.<span class="property">TIMEOUT</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title class_">LoginName</span> = <span class="title class_">PageEnum</span>.<span class="property">BASE_LOGIN_NAME</span></span><br><span class="line">      <span class="keyword">if</span> (router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">name</span> == <span class="title class_">LoginName</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 到登录页</span></span><br><span class="line">      <span class="keyword">const</span> timeoutMsg = <span class="string">&#x27;登录超时,请重新登录!&#x27;</span></span><br><span class="line">      <span class="title class_">Modal</span>.<span class="title function_">warning</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&#x27;登录身份已失效，请重新登录!&#x27;</span>,</span><br><span class="line">        <span class="attr">positiveText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        <span class="attr">negativeText</span>: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">        <span class="attr">onPositiveClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          storage.<span class="title function_">clear</span>()</span><br><span class="line">          router.<span class="title function_">replace</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="title class_">LoginName</span>,</span><br><span class="line">            <span class="attr">query</span>: &#123;</span><br><span class="line">              <span class="attr">redirect</span>: router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">fullPath</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onNegativeClick</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(timeoutMsg))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否返回原生响应头 比如：需要获取响应头时使用该属性</span></span><br><span class="line">    <span class="keyword">if</span> (isReturnNativeResponse) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不进行任何处理，直接返回</span></span><br><span class="line">    <span class="comment">// 用于页面代码可能需要直接获取code，data，message这些信息时开启</span></span><br><span class="line">    <span class="keyword">if</span> (!isTransformResponse) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求成功</span></span><br><span class="line">    <span class="keyword">const</span> hasSuccess =</span><br><span class="line">      data &amp;&amp; <span class="title class_">Reflect</span>.<span class="title function_">has</span>(data, <span class="string">&#x27;code&#x27;</span>) &amp;&amp; code === <span class="title class_">ResultEnum</span>.<span class="property">SUCCESS</span></span><br><span class="line">    <span class="comment">// 是否显示提示信息</span></span><br><span class="line">    <span class="keyword">if</span> (isShowMessage) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasSuccess &amp;&amp; (successMessageText || isShowSuccessMessage)) &#123;</span><br><span class="line">        <span class="comment">// 是否显示自定义信息提示</span></span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">success</span>(successMessageText || message || <span class="string">&#x27;操作成功！&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasSuccess &amp;&amp; (errorMessageText || isShowErrorMessage)) &#123;</span><br><span class="line">        <span class="comment">// 是否显示自定义信息提示</span></span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(message || errorMessageText || <span class="string">&#x27;操作失败！&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasSuccess &amp;&amp; options.<span class="property">errorMessageMode</span> === <span class="string">&#x27;modal&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// errorMessageMode=‘custom-modal’的时候会显示modal错误弹窗，而不是消息提示，用于一些比较重要的错误</span></span><br><span class="line">        <span class="title class_">Modal</span>.<span class="title function_">info</span>(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">          <span class="attr">content</span>: message,</span><br><span class="line">          <span class="attr">positiveText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">          <span class="attr">onPositiveClick</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口请求成功，直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (code === <span class="title class_">ResultEnum</span>.<span class="property">SUCCESS</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接口请求错误，统一提示错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (code === <span class="title class_">ResultEnum</span>.<span class="property">ERROR</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (message) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(data.<span class="property">message</span>)</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> msg = <span class="string">&#x27;操作失败,系统异常!&#x27;</span></span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(msg))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里逻辑可以根据项目进行修改</span></span><br><span class="line">    <span class="keyword">if</span> (!hasSuccess) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求之前处理config</span></span><br><span class="line">  <span class="attr">beforeRequestHook</span>: <span class="function">(<span class="params">config, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      apiUrl,</span><br><span class="line">      joinPrefix,</span><br><span class="line">      joinParamsToUrl,</span><br><span class="line">      formatDate,</span><br><span class="line">      joinTime = <span class="literal">true</span>,</span><br><span class="line">    &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (joinPrefix) &#123;</span><br><span class="line">      config.<span class="property">url</span> = <span class="string">`<span class="subst">$&#123;urlPrefix&#125;</span><span class="subst">$&#123;config.url&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (apiUrl &amp;&amp; <span class="title function_">isString</span>(apiUrl)) &#123;</span><br><span class="line">      config.<span class="property">url</span> = <span class="string">`<span class="subst">$&#123;apiUrl&#125;</span><span class="subst">$&#123;config.url&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> params = config.<span class="property">params</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> data = config.<span class="property">data</span> || <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (config.<span class="property">method</span>?.<span class="title function_">toUpperCase</span>() === <span class="title class_">RequestEnum</span>.<span class="property">GET</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isString</span>(params)) &#123;</span><br><span class="line">        <span class="comment">// 给 get 请求加上时间戳参数，避免从缓存中拿数据。</span></span><br><span class="line">        config.<span class="property">params</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">          params || &#123;&#125;,</span><br><span class="line">          <span class="title function_">joinTimestamp</span>(joinTime, <span class="literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 兼容restful风格</span></span><br><span class="line">        config.<span class="property">url</span> = config.<span class="property">url</span> + params + <span class="string">`<span class="subst">$&#123;joinTimestamp(joinTime, <span class="literal">true</span>)&#125;</span>`</span></span><br><span class="line">        config.<span class="property">params</span> = <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isString</span>(params)) &#123;</span><br><span class="line">        formatDate &amp;&amp; <span class="title function_">formatRequestDate</span>(params)</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          <span class="title class_">Reflect</span>.<span class="title function_">has</span>(config, <span class="string">&#x27;data&#x27;</span>) &amp;&amp;</span><br><span class="line">          config.<span class="property">data</span> &amp;&amp;</span><br><span class="line">          <span class="title class_">Object</span>.<span class="title function_">keys</span>(config.<span class="property">data</span>).<span class="property">length</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          config.<span class="property">data</span> = data</span><br><span class="line">          config.<span class="property">params</span> = params</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          config.<span class="property">data</span> = params</span><br><span class="line">          config.<span class="property">params</span> = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (joinParamsToUrl) &#123;</span><br><span class="line">          config.<span class="property">url</span> = <span class="title function_">setObjToUrlParams</span>(</span><br><span class="line">            config.<span class="property">url</span> <span class="keyword">as</span> <span class="built_in">string</span>,</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, config.<span class="property">params</span>, config.<span class="property">data</span>)</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 兼容restful风格</span></span><br><span class="line">        config.<span class="property">url</span> = config.<span class="property">url</span> + params</span><br><span class="line">        config.<span class="property">params</span> = <span class="literal">undefined</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 请求拦截器处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">requestInterceptors</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求之前处理config</span></span><br><span class="line">    <span class="keyword">const</span> userStore = <span class="title function_">useUserStoreWidthOut</span>()</span><br><span class="line">    <span class="keyword">const</span> token = userStore.<span class="property">getToken</span></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="comment">// jwt token</span></span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">&#x27;Bearer &#x27;</span> + token</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 响应错误处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">responseInterceptorsCatch</span>: <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">$message</span>: <span class="title class_">Message</span>, <span class="attr">$dialog</span>: <span class="title class_">Modal</span> &#125; = <span class="variable language_">window</span></span><br><span class="line">    <span class="keyword">const</span> &#123; response, code, message &#125; = error || &#123;&#125;</span><br><span class="line">    <span class="comment">// TODO 此处要根据后端接口返回格式修改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">msg</span>: <span class="built_in">string</span> =</span><br><span class="line">      response &amp;&amp; response.<span class="property">data</span> &amp;&amp; response.<span class="property">data</span>.<span class="property">message</span></span><br><span class="line">        ? response.<span class="property">data</span>.<span class="property">message</span></span><br><span class="line">        : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">err</span>: <span class="built_in">string</span> = error.<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (code === <span class="string">&#x27;ECONNABORTED&#x27;</span> &amp;&amp; message.<span class="title function_">indexOf</span>(<span class="string">&#x27;timeout&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">error</span>(<span class="string">&#x27;接口请求超时,请刷新页面重试!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (err &amp;&amp; err.<span class="title function_">includes</span>(<span class="string">&#x27;Network Error&#x27;</span>)) &#123;</span><br><span class="line">        <span class="title class_">Modal</span>.<span class="title function_">info</span>(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;网络异常&#x27;</span>,</span><br><span class="line">          <span class="attr">content</span>: <span class="string">&#x27;请检查您的网络连接是否正常!&#x27;</span>,</span><br><span class="line">          <span class="attr">positiveText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">          <span class="attr">onPositiveClick</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求是否被取消</span></span><br><span class="line">    <span class="keyword">const</span> isCancel = axios.<span class="title function_">isCancel</span>(error)</span><br><span class="line">    <span class="keyword">if</span> (!isCancel) &#123;</span><br><span class="line">      <span class="title function_">checkStatus</span>(error.<span class="property">response</span> &amp;&amp; error.<span class="property">response</span>.<span class="property">status</span>, msg, <span class="title class_">Message</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(error, <span class="string">&#x27;请求被取消！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Axios</span> = <span class="keyword">new</span> <span class="title class_">MyAxios</span>(&#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10</span> * <span class="number">1000</span>,</span><br><span class="line">  <span class="comment">// 接口前缀</span></span><br><span class="line">  <span class="attr">prefixUrl</span>: urlPrefix,</span><br><span class="line">  <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="title class_">ContentTypeEnum</span>.<span class="property">JSON</span> &#125;,</span><br><span class="line">  <span class="comment">// 数据处理方式</span></span><br><span class="line">  transform,</span><br><span class="line">  <span class="comment">// 配置项，下面的选项都可以在独立的接口请求中覆盖</span></span><br><span class="line">  <span class="attr">requestOptions</span>: &#123;</span><br><span class="line">    <span class="comment">// 默认将prefix 添加到url</span></span><br><span class="line">    <span class="attr">joinPrefix</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否返回原生响应头 比如：需要获取响应头时使用该属性</span></span><br><span class="line">    <span class="attr">isReturnNativeResponse</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 需要对返回数据进行处理</span></span><br><span class="line">    <span class="attr">isTransformResponse</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// post请求的时候添加参数到url</span></span><br><span class="line">    <span class="attr">joinParamsToUrl</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 格式化提交参数时间</span></span><br><span class="line">    <span class="attr">formatDate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 消息提示类型</span></span><br><span class="line">    <span class="attr">errorMessageMode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="comment">// 接口地址</span></span><br><span class="line">    <span class="attr">apiUrl</span>: globSetting.<span class="property">apiUrl</span> <span class="keyword">as</span> <span class="built_in">string</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Axios</span></span><br></pre></td></tr></table></figure>

<p>本章页面大部分代码来自项目：<a href="https://github.com/jekip/naive-ui-admin">Naive-Ui-Admin</a><br>正所以冤有头债有主，如果有什么问题请查看项目的介绍。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Intent调用方式</title>
    <url>/%E5%AE%89%E5%8D%93/Android-Intent%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>记录一下Intent的显式调用和隐式调用方法</p>
<span id="more"></span>

<blockquote>
<p>假设现在有两个Activity，对应的java文件是MainActivity和SecondActivity</p>
</blockquote>
<h1 id="显式调用"><a href="#显式调用" class="headerlink" title="显式调用"></a>显式调用</h1><h2 id="通过class跳转"><a href="#通过class跳转" class="headerlink" title="通过class跳转"></a>通过class跳转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line"><span class="built_in">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure>

<h2 id="通过包名-类名跳转"><a href="#通过包名-类名跳转" class="headerlink" title="通过包名.类名跳转"></a>通过包名.类名跳转</h2><p>假设包名是 <code>com.example</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="built_in">this</span>, <span class="string">&quot;com.example.SecondActivity&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h2 id="通过ComponentName跳转"><a href="#通过ComponentName跳转" class="headerlink" title="通过ComponentName跳转"></a>通过ComponentName跳转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">componentName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">intent.setCpmponent(componentName);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h1 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h1><p>首先要在 <code>AndroidManifest.xml</code> 文件中修改第二个activity的参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.nextActivity&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在java文件里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;android.intent.action.nextActivity&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>当然之间在创建对象时直接传进构建函数也是可以的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;android.intent.action.nextActivity&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax学习笔记：封装XHR</title>
    <url>/%E5%89%8D%E7%AB%AF/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B0%81%E8%A3%85XHR/</url>
    <content><![CDATA[<p>尝试像jQuery ajax一样封装XMLHttpRequest</p>
<span id="more"></span>

<p>来源：<a href="https://www.jianshu.com/p/918c63045bc3/">XMLHttpRequest—必知必会</a></p>
<p>一个稍微完整一点的http请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 请求成功回调函数</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;request success&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求结束</span></span><br><span class="line">xhr.<span class="property">onloadend</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;request loadend&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求出错</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;request error&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求超时</span></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;request timeout&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求回调函数.XMLHttpRequest标准又分为Level 1和Level 2,这是Level 1和的回调处理方式</span></span><br><span class="line"><span class="comment">// xhr.onreadystatechange = () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//  if (xhr.readyState !== 4) &#123;</span></span><br><span class="line"><span class="comment">//  return;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  const status = xhr.status;</span></span><br><span class="line"><span class="comment">//  if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status === 304) &#123;</span></span><br><span class="line"><span class="comment">//  console.log(&#x27;request success&#x27;);</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//  console.log(&#x27;request error&#x27;);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  &#125;;</span></span><br><span class="line"></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">0</span>; <span class="comment">// 设置超时时间,0表示永不超时</span></span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET/POST/DELETE/...&#x27;</span>, <span class="string">&#x27;/url&#x27;</span>, <span class="literal">true</span> || <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 设置期望的返回数据类型 &#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span> || <span class="keyword">new</span> <span class="title class_">FormData</span> || <span class="string">&#x27;a=1&amp;b=2&#x27;</span> || <span class="string">&#x27;json字符串&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="封装XMLHttpRequest"><a href="#封装XMLHttpRequest" class="headerlink" title="封装XMLHttpRequest"></a>封装XMLHttpRequest</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * js封装ajax请求</span></span><br><span class="line"><span class="comment"> * &gt;&gt;使用new XMLHttpRequest 创建请求对象,所以不考虑低端IE浏览器(IE6及以下不支持XMLHttpRequest)</span></span><br><span class="line"><span class="comment"> * &gt;&gt;使用es6语法,如果需要在正式环境使用,则可以用babel转换为es5语法 https://babeljs.cn/docs/setup/#installation</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> settings 请求参数模仿jQuery ajax</span></span><br><span class="line"><span class="comment"> *  调用该方法,data参数需要和请求头Content-Type对应</span></span><br><span class="line"><span class="comment"> *  Content-Type                        data                                     描述</span></span><br><span class="line"><span class="comment"> *  application/x-www-form-urlencoded   &#x27;name=哈哈&amp;age=12&#x27;或&#123;name:&#x27;哈哈&#x27;,age:12&#125;  查询字符串,用&amp;分割</span></span><br><span class="line"><span class="comment"> *  application/json                     name=哈哈&amp;age=12&#x27;                        json字符串</span></span><br><span class="line"><span class="comment"> *  multipart/form-data                  new FormData()                           FormData对象,当为FormData类型,不要手动设置Content-Type</span></span><br><span class="line"><span class="comment"> *  注意:请求参数如果包含日期类型.是否能请求成功需要后台接口配合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="attr">ajax</span>: <span class="function">(<span class="params">settings = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化请求参数</span></span><br><span class="line">        <span class="keyword">let</span> _s = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// string</span></span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="comment">// string &#x27;GET&#x27; &#x27;POST&#x27; &#x27;DELETE&#x27;</span></span><br><span class="line">            <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// string 期望的返回数据类型:&#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span></span><br><span class="line">            <span class="attr">async</span>: <span class="literal">true</span>, <span class="comment">//  boolean true:异步请求 false:同步请求 required</span></span><br><span class="line">            <span class="attr">data</span>: <span class="literal">null</span>, <span class="comment">// any 请求参数,data需要和请求头Content-Type对应</span></span><br><span class="line">            <span class="attr">headers</span>: &#123;&#125;, <span class="comment">// object 请求头</span></span><br><span class="line">            <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// string 超时时间:0表示不设置超时</span></span><br><span class="line">            <span class="attr">beforeSend</span>: <span class="function">(<span class="params">xhr</span>) =&gt;</span> &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">result, status, xhr</span>) =&gt;</span> &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="function">(<span class="params">xhr, status, error</span>) =&gt;</span> &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">complete</span>: <span class="function">(<span class="params">xhr, status</span>) =&gt;</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, settings);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数验证</span></span><br><span class="line">        <span class="keyword">if</span> (!_s.<span class="property">url</span> || !_s.<span class="property">type</span> || !_s.<span class="property">dataType</span> || !_s.<span class="property">async</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;参数有误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建XMLHttpRequest请求对象</span></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求开始回调函数</span></span><br><span class="line">        xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadstart&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            _s.<span class="title function_">beforeSend</span>(xhr);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求成功回调函数</span></span><br><span class="line">        xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> status = xhr.<span class="property">status</span>;</span><br><span class="line">            <span class="keyword">if</span> ((status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) || status === <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> result;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">responseType</span> === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">                    result = xhr.<span class="property">responseText</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">responseType</span> === <span class="string">&#x27;document&#x27;</span>) &#123;</span><br><span class="line">                    result = xhr.<span class="property">responseXML</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = xhr.<span class="property">response</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注意:状态码200表示请求发送/接受成功,不表示业务处理成功</span></span><br><span class="line">                _s.<span class="title function_">success</span>(result, status, xhr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _s.<span class="title function_">error</span>(xhr, status, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求结束</span></span><br><span class="line">        xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            _s.<span class="title function_">complete</span>(xhr, xhr.<span class="property">status</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求出错</span></span><br><span class="line">        xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            _s.<span class="title function_">error</span>(xhr, xhr.<span class="property">status</span>, e);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 请求超时</span></span><br><span class="line">        xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;timeout&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            _s.<span class="title function_">error</span>(xhr, <span class="number">408</span>, e);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> useUrlParam = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> sType = _s.<span class="property">type</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">        <span class="comment">// 如果是&quot;简单&quot;请求,则把data参数组装在url上</span></span><br><span class="line">        <span class="keyword">if</span> (sType === <span class="string">&#x27;GET&#x27;</span> || sType === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">            useUrlParam = <span class="literal">true</span>;</span><br><span class="line">            _s.<span class="property">url</span> += http.<span class="title function_">getUrlParam</span>(_s.<span class="property">url</span>, _s.<span class="property">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 初始化请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(_s.<span class="property">type</span>, _s.<span class="property">url</span>, _s.<span class="property">async</span>);</span><br><span class="line">    <span class="comment">// 设置期望的返回数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = _s.<span class="property">dataType</span>;</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(_s.<span class="property">headers</span>)) &#123;</span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, _s.<span class="property">headers</span>[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (_s.<span class="property">async</span> &amp;&amp; _s.<span class="property">timeout</span>) &#123;</span><br><span class="line">      xhr.<span class="property">timeout</span> = _s.<span class="property">timeout</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送请求.如果是简单请求,请求参数应为null.否则,请求参数类型需要和请求头Content-Type对应</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(useUrlParam ? <span class="literal">null</span> : http.<span class="title function_">getQueryData</span>(_s.<span class="property">data</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 把参数data转为url查询参数</span></span><br><span class="line">  <span class="attr">getUrlParam</span>: <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> paramsStr = data <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? http.<span class="title function_">getQueryString</span>(data) : data;</span><br><span class="line">    <span class="keyword">return</span> (url.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) !== -<span class="number">1</span>) ? paramsStr : <span class="string">&#x27;?&#x27;</span> + paramsStr;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取ajax请求参数</span></span><br><span class="line">  <span class="attr">getQueryData</span>: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="title class_">FormData</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> http.<span class="title function_">getQueryString</span>(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 把对象转为查询字符串</span></span><br><span class="line">  <span class="attr">getQueryString</span>: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> paramsArr = [];</span><br><span class="line">    <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = data[key];</span><br><span class="line">        <span class="comment">// todo 参数Date类型需要根据后台api酌情处理</span></span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">          <span class="comment">// val = dateFormat(val, &#x27;yyyy-MM-dd hh:mm:ss&#x27;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        paramsArr.<span class="title function_">push</span>(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(val));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paramsArr.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单易懂的C语言-1</title>
    <url>/C%E8%AF%AD%E8%A8%80/C-language-learn-1/</url>
    <content><![CDATA[<p>欢迎学习本系列教程：简单易懂的C语言</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>C语言是一门广泛用于底层开发的语言，由D.M.Ritchie在1972年并在贝尔实验室最终设计完成，也就是第一个C语言版本的产生。1989年，美国ANSI发布了第一个完整的C语言版本——C89，或者叫ANSI C。C89在1990年被国际标准组织ISO(International Standard Organization)一字不改地采纳,也被叫做为“C90”，然后ISO又在1999年和2011年发布了新的标准，也就是C99和C11</p>
<p>说了这么多，相信大家对c有了一点点的了解，如果对C语言的发展和历史有兴趣的可以上百度谷歌查询治疗。</p>
<h1 id="C语言能用来干什么"><a href="#C语言能用来干什么" class="headerlink" title="C语言能用来干什么"></a>C语言能用来干什么</h1><p>C语言最初的目的是用与系统的开发，直到现在，连Windows10的部分底层代码也是由C语言来编写的。除了系统，一个非常出名的关系型数据库管理系统：MySQL也是由C语言编写的。</p>
<span id="more"></span>

<p>（课外知识：</p>
<ul>
<li><a href="https://www.baidu.com/s?wd=RDBMS">RDBMS</a></li>
<li><a href="https://www.baidu.com/s?wd=RDBMS">MySQL</a>）</li>
</ul>
<h1 id="学前知识"><a href="#学前知识" class="headerlink" title="学前知识"></a>学前知识</h1><p>众所周知，电脑能读懂的只有 0 和 1，那就需要将我们的语言翻译成一串只有 0 和 1 的指令，这些指令能直接对电脑进行操作，这个过程我们姑且叫他——编译（当然一些大佬们会说这样讲不对，但是如果你是一个萌新，什么都不懂，就只能先这样理解了）。所以我们需要一个软件——编译器，他的功能就是编译（其实还要其他功能，比如调试，以后会讲）</p>
<p>课外知识：<a href="https://www.baidu.com/s?ie=UTF-8&wd=%E7%BC%96%E8%AF%91">编译</a></p>
<p>而将我们的C语言，写进一个文件里面，就变成了——源文件，而文件里面的代码就是——源代码。<br>编译器通过将你写的代码转换成那些只有 0 和 1 的指令，比如你能看到的可执行文件，比如xxx.exe。<br>而还有一个问题是，如何将C语言的代码写进一个文件里面？这就需要用到另一个软件——编辑器。就比如PS软件，能对图片进行处理，而编辑器就是对源代码进行编辑的软件。</p>
<h1 id="编译器和编辑器的选择"><a href="#编译器和编辑器的选择" class="headerlink" title="编译器和编辑器的选择"></a>编译器和编辑器的选择</h1><p>这里我推荐的选择有：</p>
<ul>
<li>GCC + VS code</li>
<li>VS2017（或者2012 2015 2019都行，但是vc6不是很建议使用）</li>
<li>苹果电脑的话应该只能Xcode</li>
<li><a href="https://studio.dev.tencent.com/">Cloud Studio</a> (这是一个网站，不行想装软件的可以用这个网站，但是由于使用Linux系统，你写出来的程序下载到你的电脑应该是用不了的，除非你的系统也是Linux。大概用法就是创建账号，新建工作空间，然后就可以开始打代码了)</li>
</ul>
<p>由于vs非常的臃肿，建议的选择是GCC + VS code，下文也是采用这个搭配来进行教学。</p>
<p>下集预告：性感小编手把手教你安装环境</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>简单易懂的C语言-3</title>
    <url>/C%E8%AF%AD%E8%A8%80/C-language-learn-3/</url>
    <content><![CDATA[<blockquote>
<p>在学习C语言之前我们先来了解一下一个程序应该包括哪些内容。</p>
</blockquote>
<span id="more"></span>
<h1 id="C语言的结构"><a href="#C语言的结构" class="headerlink" title="C语言的结构"></a>C语言的结构</h1><p>C语言主要包括下面这几个内容：</p>
<ul>
<li><p>预处理器指令</p>
</li>
<li><p>函数</p>
</li>
<li><p>变量</p>
</li>
<li><p>语句（语句块）和表达式</p>
</li>
<li><p>注释<br>我们看回上一节的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!&quot;</span>);		<span class="comment">//打印HelloWorld</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一行的 <code>#include&lt;stdio.h&gt;</code> 叫做预处理器指令，用途就是在编译的时候加入这个stdio.h文件里的内容。</p>
</li>
<li><p>到下两行的<code>int main()</code>，这里的main指这个函数是主函数，程序都需要从主函数开始，没有写C语言程序一定要有主函数，不然就运行不起来。而main前面的int指这个函数是int类型，类型后面说到。</p>
</li>
<li><p>第五行有两个部分，一个是<code>printf(&quot;HelloWorld!&quot;);</code>和<code>//打印HelloWorld</code>，printf()是在stdio.h中写好的函数，用来在命令行中打印各种字符（不要忘记后面的“；”哦，没写“；”是会报错的）。右边还有一句<code>//打印HelloWorld</code>，主要内容是“&#x2F;&#x2F;”，从双斜杠开始，后面的任何字符都会被编译器无视，后面写的任何内容将不会出现在编译好的程序里。</p>
</li>
<li><p>下一行的<code>return 0;</code>,这句话代表了这个函数的结束，并返回0，所以就算你下面还有其他语句，也不会执行，因为一旦这个函数执行了return语句就会立刻结束。</p>
</li>
</ul>
<p>如果看完上一节我相信你也掌握了编译的技巧了，如果还不懂就复习一下前面的内容。</p>
<h2 id="语句的结构"><a href="#语句的结构" class="headerlink" title="语句的结构"></a>语句的结构</h2><p>这里用上面的<code>printf(&quot;HelloWorld!&quot;);</code>来说，这是一个语句，它应该包括五部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf</span><br><span class="line">(</span><br><span class="line">&quot;HelloWorld!&quot;</span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>而<code>return 0;</code>可以看成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return</span><br><span class="line">0</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>从两个例子可以看出所有的语句结束时均要加上；不然会报错，而函数后面均要使用()，括号里面的内容是你要传入的内容，比如printf函数输入”Fuck”就可以在命令行打印出Fuck。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>上面讲到了单行注释&#x2F;&#x2F;，其实还有一个多行注释，用法是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line">    窝窝头</span><br><span class="line">    一块钱四个</span><br><span class="line">    嘿嘿</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  窝窝头</span><br><span class="line">//  一块钱四个</span><br><span class="line">//  嘿嘿</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
<p>当然<code>//记得双击么么哒</code>也相当于<code>/* 记得双击么么哒 */</code></p>
<p>你喜欢怎么用就看你了。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符用于给函数、变量、常量等注入灵魂（指命名），但是命名要遵循规范哦，不然也会报错，最好按照一种命名方法进行命名不然恶心到的是自己或者下一个接手这个项目的人。</p>
<h3 id="规范指："><a href="#规范指：" class="headerlink" title="规范指："></a>规范指：</h3><p>一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。C语言是区分大小写的语言所以需要注意一下，比如awsl和AWSL是不一样的哦，OI和0l也是不一样的哦（左边那个是大学的o和大写i，右边是数字零和小写的L）。</p>
<h3 id="命名方法："><a href="#命名方法：" class="headerlink" title="命名方法："></a>命名方法：</h3><p>这里说两种最常用的命名方法，分别是驼峰命名法和下划线法。<br>驼峰命名法例如：printEmployeeSalay、getValueFromSQLServer、_httpListenAndServe等</p>
<p>下面改成下划线法：print_employee_salay,get_value_from_OS_Environment</p>
<p>我是比较喜欢在编程时使用驼峰命名法，在数据库中使用下划线，看你们喜欢。</p>
<p>不过上面命名并非最好的方法，你觉得是不是太长了，当写代码的时候如果没有自动补全会非常难受，当然也并非都是缺点，如果这是别人写的代码你可能一眼就知道是用来干什么的。</p>
<p>大部分情况应该要做到见名知意且简短，比如求和（sum），数值（val），圆周率（Pi）。</p>
<p>思考题：上面的两个标识符可以怎么简写呢？</p>
<p>新手写代码非常喜欢使用：a、abc、a1、a2这样子的标识符，这些标识符不应该乱用，应该仅仅用于循环的控制变量，不然代码行数一多，时间一长，你就会忘了哪个变量用来干什么。</p>
<h3 id="命名规范补充"><a href="#命名规范补充" class="headerlink" title="命名规范补充"></a>命名规范补充</h3><p>下面是不能使用的命名字符：auto、break、case	、char	、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static、struct、switch、typedefunsigned、union、void、volatile、while、_Bool、_Complex、_Imaginary、inline、restrict、_Alignas、_Alignof、_Atomic、_Generic、_Noreturn、_Static_assert、_Thread_local</p>
<p>至于为什么不能使用，请继续学习并思考为什么不能使用这些词（从auto直到while）。</p>
<h2 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h2><p>空格一般用于某个元素的结束，比如int age，中间的空格表示了int的结束。</p>
<p>空格还可以用于提高代码的可读性，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">food = noodle + pizza;</span><br><span class="line">food=noodle+pizza;</span><br></pre></td></tr></table></figure>
<p>第一行和第二行效果是完全一样的，但是明显第一行好看很多。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>基本类型<blockquote>
<p>它们是算术类型，包括两种类型：整数类型和浮点类型。</p>
</blockquote>
</li>
<li>枚举类型<blockquote>
<p>它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</p>
</blockquote>
</li>
<li>void类型<blockquote>
<p>类型说明符 void 表明没有可用的值。</p>
</blockquote>
</li>
<li>派生类型<blockquote>
<p>它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</p>
</blockquote>
</li>
</ol>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1 字节</td>
<td>-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>int</td>
<td>2 或 4 字节</td>
<td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 或 4 字节</td>
<td>0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-32,768 到 32,767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td>long</td>
<td>4 字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 字节</td>
<td>0 到 4,294,967,295</td>
</tr>
</tbody></table>
<blockquote>
<p>long float double等类型在不同平台不同编译器的储存大小可能不一样，下面实例使用sizeof运算符来得到对象或者类型的储存字节大小。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;int 存储大小 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char 存储大小 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;long 存储大小 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<p>类型 | 储存大小 | 值范围 | 精度 </p>
<ul>
<li>| - | - |<br>float | 4 字节 | 1.2E-38 到 3.4E+38 | 6 位小数<br>double | 8 字节 | 2.3E-308 到 1.7E+308 | 15 位小数<br>long double | 16 字节 | 3.4E-4932 到 1.1E+4932 | 	19 位小数</li>
</ul>
<p>上面我们学会了用sizeof获得整形类型的储存大小，下面实例展示了获得float的储存空间和范围值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 存储最大字节数 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最小值: %E\n&quot;</span>, FLT_MIN );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最大值: %E\n&quot;</span>, FLT_MAX );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;精度值: %d\n&quot;</span>, FLT_DIG );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>void指空类型，一般分三种：1）函数返回值为空，2）函数参数为空，3）指针指向void。后续章节会详细介绍这些类型的用法。</p>
<blockquote>
<p><em><strong>获得成就</strong></em><br>这是？基本语法！：初步掌握基本语法和结构</p>
</blockquote>
<hr>
<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><p>上面学完了结构和数据类型并获得一项成就，是不是有点开心呢，那么你可以开始学习定义变量和使用运算符进行数据的操作了</p>
<p>在C语言中，如果你想使用某一个数据类型，比如int，你就需要创建一个变量来储存这个数据类型的值，这叫变量的定义或者变量的声明。</p>
<p>食用方法是：<code>type variable1 variable2 ...;</code></p>
<p>这里的type是上面说到的数据类型,下面是几个实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    i, j, k;</span><br><span class="line"><span class="type">char</span>   c, ch, input;</span><br><span class="line"><span class="type">float</span>  f, salary;</span><br><span class="line"><span class="type">double</span> d;</span><br></pre></td></tr></table></figure>

<p>既然声明可以储存值的变量，那么就可以把值赋给变量，继续列举几个实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">1</span>, i = <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>赋值可以在声明的时候进行，或者先声明下一句再复制。<em><strong>注意要赋值后再使用这个变量</strong></em></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号，C语言内置了非常“丰（e）富（xin）”的运算符，包括以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符<br>下面我们先选最常用的算术、关系、逻辑、赋值运算符来讲。</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符包括：+ - * &#x2F; %  ++ –<br>我寻思大部分人都学过数学，那么下面请跟着在编辑器里写一遍下面的实例，观察程序运行的结果，思考一下这些运算符都是什么意思。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">121</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">11</span>;</span><br><span class="line">   <span class="type">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   c = a + b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 + - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a - b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 - - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a * b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 * - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a / b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 / - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a % b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 % - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a++;  <span class="comment">// 赋值后再加 1 ，c 为 21，a 为 22</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 ++ - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a--;  <span class="comment">// 赋值后再减 1 ，c 为 22 ，a 为 21</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;使用 -- - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>我们先假设两个变量a和b，值分别233，666。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>(A &#x3D;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>(A !&#x3D; B) 为真。</td>
</tr>
</tbody></table>
<blockquote>
<p>| 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A &gt; B) 不为真。<br>&lt; | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A &lt; B) 为真。<br>&#x3D; | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A &gt;&#x3D; B) 不为真。<br>&lt;&#x3D; | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A &lt;&#x3D; B) 为真。</p>
</blockquote>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>同上我们照样假设a和b，a为真和b为假，则：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!a为假，!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>这里因为没说位运算符所以这里只讲 <em><em>&#x3D; 、+&#x3D; 、-&#x3D; 、</em>&#x3D; 、&#x2F;&#x3D; 、%&#x3D;</em>*</p>
<p>&#x3D;是最简单的赋值操作符，用于把右边操作数赋给左边，比如：<code>c = a + b</code>，就是把a+b的值相加赋给c</p>
<p>c +&#x3D; a 相当于 c &#x3D; c + a，相信聪明的你能想到+&#x3D;是什么意思了吧。同理c *&#x3D; a 等于c &#x3D; c * a。那么其他的用法也相同。  </p>
<h1 id="第三章的思考题："><a href="#第三章的思考题：" class="headerlink" title="第三章的思考题："></a><em><strong>第三章的思考题：</strong></em></h1><p>用上面学到的知识，声明一个变量，接收一个年分，判断是否是闰年，并在命令行输出这一年是否是闰年。（解析和答案在下面评论区）</p>
<blockquote>
<p><em><strong>获得成就</strong></em><br>运算时间到！：初步掌握运算符并且能使用运算符处理一些算术问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Android复习题</title>
    <url>/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>老师发的复习题</p>
<span id="more"></span>

<h1 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h1><ol>
<li><pre><code>下列哪些语句关于内存回收的说明是正确的?(  B  ) 
</code></pre>
<p>A、	程序员必须创建一个线程来释放内存<br>B、	内存回收程序负责释放无用内存<br>C、	内存回收程序允许程序员直接释放内存<br>D、	内存回收程序可以在指定的时间释放内存对象 </p>
</li>
<li><pre><code>Android 中下列属于 Intent 的作用的是(  C  ) 
</code></pre>
<p>A、	实现应用程序间的数据共享<br>B、	是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失<br>C、	可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带<br>D、	处理一个应用程序整体性的工作 </p>
</li>
<li><pre><code>下面在 AndroidManifest.xml 文件中注册 BroadcastReceiver 方式正确的(  A  )    
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">A、 <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;NewBroad&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>   </span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;android.provider.action.NewBroad&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span> </span><br><span class="line">B、	<span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;NewBroad&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">            android:name=&quot;android.provider.action.NewBroad&quot;/&gt; </span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span> </span><br><span class="line">C、	<span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;NewBroad&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>   </span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;android.provider.action.NewBroad&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span> </span><br><span class="line">D、	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;NewBroad&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>  </span><br><span class="line">                android:name=&quot;android.provider.action.NewBroad&quot;/&gt; </span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><pre><code>关于 ContenValues 类说法正确的是(  D  ) 
</code></pre>
<p>A、	他和 Hashtable 比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名是任意类型，而值都是基本类型<br>B、	他和 Hashtable 比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名，可以为空，而值都是 String 类型<br>C、	他和 Hashtable 比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名是String 类型，而值也是 String 类型<br>D、	他和 Hashtable 比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名是String 类型，而值都是基本类型 </p>
</li>
<li><pre><code>下面退出 Activity 错误的方法是(  C  ) 
</code></pre>
<p>A、	finish() B、抛异常强制退出 	C、System.exit()  	D、onStop() </p>
</li>
<li><pre><code>下面关于 Android dvm 的进程和 Linux 的进程,应用程序的进程说法正确的是(  D  ) 
</code></pre>
<p>A、	DVM 指 dalivk 的虚拟机.每一个 Android 应用程序都在它自己的进程中运行,不一定拥有一个独立的 Dalvik 虚拟机实例.而每一个 DVM 都是在 Linux 中的一个进程,所以说可以认为是同一个概念.<br>B、	DVM 指 dalivk 的虚拟机.每一个 Android 应用程序都在它自己的进程中运行,不一定拥有一个独立的 Dalvik 虚拟机实例.而每一个 DVM 不一定都是在 Linux 中的一个进程,所以说不是一个概念.<br>C、	DVM 指 dalivk 的虚拟机.每一个 Android 应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik 虚拟机实例.而每一个 DVM 不一定都是在 Linux 中的一个进程,所以说不是一个概念.<br>D、	DVM 指 dalivk 的虚拟机.每一个 Android 应用程序都在它自己的进程中运行,都拥有一个独立的 Dalvik 虚拟机实例.而每一个 DVM 都是在 Linux 中的一个进程,所以说可以认为是同一个概念. </p>
</li>
<li><pre><code>Android 项目工程下面的 assets 目录的作用是什么(  B  ) 
</code></pre>
<p>A、	放置应用到的图片资源。 	 	 	  B、主要放置多媒体等数据文件<br>C、放置字符串，颜色，数组等常量数据   D、放置一些与 UI 相应的布局文件，都是 xml 文件 </p>
</li>
<li><pre><code>关于 res/raw 目录说法正确的是(  A  ) 
</code></pre>
<p>A、	这里的文件是原封不动的存储到设备上不会转换为二进制的格式<br>B、	这里的文件是原封不动的存储到设备上会转换为二进制的格式<br>C、	这里的文件最终以二进制的格式存储到指定的包中<br>D、	这里的文件最终不会以二进制的格式存储到指定的包中 </p>
</li>
<li><pre><code>Android 是如何组织 Activity 的(  A  ) 
</code></pre>
<p>A、	以栈的方式组式 Activity 	 	 	B、 以队列的方式组织 Activity<br>C、 以树形方式组织 Activity 	 	 	D、 以链式方式组织 Activity。 </p>
</li>
<li><pre><code>onPause 什么时候调用(  C  ) 
</code></pre>
<p> A．当界面启动时  	 	 	 	 	B．当 onCreate 方法被执行之后<br> C．当界面被隐藏时 	 	 	 	 	D．当界面重新显示时 </p>
</li>
<li><pre><code>在 Activity 中，如何获取 service 对象(  A  ) 
</code></pre>
<p> A．可以通过直接实例化得到。  	 	B．可以通过绑定得到。<br> C．通过 startService() 	 	 	 	D．通过 getService()获取。 </p>
</li>
<li><pre><code>在表格布局中，android:collapseColumns=&quot;1,2&quot;的含义是( C ) 
</code></pre>
<p>A、	在屏幕中，当表格的列能显示完时，显示1，2列<br>B、	在屏幕中，当表格的列显示不完时，折叠<br>C、在屏幕中，不管是否能都显示完，折叠1、2列<br>D、在屏幕中,动态决定是否显示表格。 </p>
</li>
<li><pre><code>绝对布局中，android:layout_x 的含义有( B ) 
</code></pre>
<p>A、	以手机左下为原点，组件显示到屏幕中的横向坐标值。<br>B、	以手机左上为原点，组件显示到屏幕中的横向坐标值。<br>C、以手机右下为原点，组件显示到屏幕中的横向坐标值。<br>D、以手机右下为原点，组件显示到屏幕中的横向坐标值。 </p>
</li>
<li><pre><code>创建 Menu 需要重写的方法是( C ) 
</code></pre>
<p>A、	onOptionsCreateMenu（Menu menu）<br>B、onOptionsCreateMenu（MenuItem menu）<br>C、onCreateOptionsMenu(Menu menu) 	<br>D、onCreateOptionsMenu(MenuItem menu) </p>
</li>
<li><pre><code>在使用 SQLiteOpenHelper 这个类时，它的哪一个方法是用来实现版本升级之用的( D ) 
</code></pre>
<p>A．onCreate()  B．onCreade()  C．onUpdate()  D． onUpgrade() </p>
</li>
<li><pre><code>ScrollView 中，可以直接包含多少个组件( B ) 
</code></pre>
<p> A．三个 B．两个  C．一个 D．无数个</p>
</li>
<li><p>TabHost.newTabSpec(“tab1”)( B ) 	<br>A．为 tab 页创建标题为 tab1 	 B．为 tab 页创建 ID 为 tab1<br>C．为 tab 页创建内容  	D．为 tab 页创建新空格</p>
</li>
<li><p>关于适配器的说法正确的有( B ) 	<br>A．它主要是用来存储数据  	 	 	 	B．它主要用来把数据绑定到组件上<br>C．它主要用来解析数据   	 	 	 D．它主要用来存储 xml 数据</p>
</li>
<li><p>关于 Activity 说的法不正确的是( C ) 	<br>A． Activity 是为用户操作而展示的可视化用户界面<br>B． 一个应用程序可以有若干个 Activity<br>C． Activity 可以通过一个别名去访问<br>D． Activity 可以表现为一个漂浮的窗口 </p>
</li>
<li><pre><code>service 中如何实现更改 Activity 界面元素( B ) 
</code></pre>
<p>A．通过把当前 actvity 对象传递给 service 对象。<br>B．通过向 Activity 发送广播。<br>C．通过 Context 对象更改 Act]ivity 界面元素<br>D．可以在 service 中，调用 Activity 的方法实现更改界面元素。 </p>
</li>
<li><pre><code>激活 Activity 的方法是( C ) 
</code></pre>
<p> A．runActivity()  	B．goActivity() 	 	C．startActivity()  	D．startActivityForIn() </p>
</li>
<li><pre><code>关于 android 进程，说法不正确的是( C ) 
</code></pre>
<p>A．组件运行所在的进程，是由 androidmanifest.xml 决定，它可以指定该组件运行于哪个进程。<br>B、当急需内存时，android 会决定优先关闭那些空闲的进程<br>C．背景进程是不为用户所见的 Activity，但是还会有可能被用户看到，所以它不能被杀死<br>D．可视进程一般不会不被系统所杀死 </p>
</li>
<li><pre><code>在 Activity 的生命周期中，当它从可见状态转向半透明状态时，它的哪个方法必须被调用( B ) 
</code></pre>
<p>A．onStop()   B．onPause()   C．onRestart()   D．onStart() </p>
</li>
<li><pre><code>当 Activity 被消毁时，如何保存它原来的状态( A ) 
</code></pre>
<p>A．实现 Activity 的 onSaveInstanceState()方法<br>B．实现 Activity 的 onSaveInstance()方法<br>C．实现 Activity 的 onInstanceState()方法<br>D． 实现 Activity 的 onSaveState()方法 </p>
</li>
<li><pre><code>关于 Intent 对象说法错误的是( D ) 
</code></pre>
<p>A．在 android 中，Intent 对象是用来传递信息的<br>B．Intent 对象可以把值传递给广播或 Activity<br>C．利用 Intent 传值时，可以传递一部分值类型<br>D．利用 Intent 传值时，它的 key 值可以是对象 </p>
</li>
<li><pre><code>在 android 中，ArrayAdapter 类是用于( A ) 
</code></pre>
<p>A．用于把数据绑定到组件上<br>B．它能把数据显示到 Activity 上<br>C．它能把数据传递给广播<br>D．它能把数据传递给服务 </p>
</li>
<li><pre><code>使进度条变横向的系统样式是( A ) 
</code></pre>
<p>A.	@android:style&#x2F;Widget.ProgressBar.Horizontal<br>B.	@android:style&#x2F;ProgressBar.Horizontal<br>C.	@style&#x2F;Widget.ProgressBar.Horizontal<br>D.	@style&#x2F;ProgressBar.Horizontal </p>
</li>
<li><pre><code>activity 对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行( D ) 
</code></pre>
<p>A.	onPause()  	 	B、onCreate()   	C、 onResume()  	D、onStart()</p>
</li>
<li><p>下面哪一个不属于 Android 体系结构中的应用程序层( C ) 		<br>A、电话簿 	 	 	B、日历  	 	 	C、SQLite 	 	 	D、SMS 程序 </p>
</li>
<li><pre><code>下面哪种说法不正确( B ) 
</code></pre>
<p>A、	Android 应用的 gen 目录下的 R.java 被删除后还能自动生成;<br>B、	res 目录是一个特殊目录，包含了应用程序的全部资源，命名规则可以支持数字(0-9)下横线<br>(_),大小写字母(a-z , A-Z);<br>C、	AndroidManifest.xml 文件是每个 Android 项目必须有的，是项目应用的全局描述。其中指定程序的包名(package&#x3D;”…”)+指定 android 应用的某个组件的名字(android:name&#x3D;”…”)组成了该组件类的完整路径<br>D、	assets 和 res 目录都能存放资源文件，但是与 res 不同的是 assets 支持任意深度的子目录，在它里面的文件不会在 R.java 里生成任何资源 ID </p>
</li>
<li><pre><code>在一个相对布局中怎样使一个控件居中( C ) 
</code></pre>
<p>A、android:gravity&#x3D;”center”  	 	 	 	B、android:layout_gravity&#x3D;”center”<br>C、android:layout_centerInParent&#x3D;”true” 	D、android:scaleType&#x3D;”center” </p>
</li>
<li><pre><code>下列说法哪个不正确( C ) 
</code></pre>
<p>A、	拥有 android:configChanges&#x3D;”orientation|keyboardHidden”标签的 Activity 在横竖屏转换时不会再执行 onCreate 方法<br>B、	默认情况下对一个 Activity 的对象进行横竖屏切换，该对象的 onCreate 方法在每次切换时都会执行<br>C、	一个 Activity 的对象 a1上弹出了一个模拟对话框形式的 Activity 的对象 a2，按返回键后 a1 执行了 onStart 和 onResume 方法,a2执行了 onPause,onStop 和 onDestroy 方法<br>D、	一个界面上的 EditText 中输入文字后，再按下 Home，该界面消失，等再回到该界面文字内容仍在，onCreate 方法也不会执行 </p>
<blockquote>
<p>a1调用OnResume，a2调用了OnStop</p>
</blockquote>
</li>
<li><pre><code>下列关于 Service 的描述，正确的是( D ) 
</code></pre>
<p>A．Servie 主要负责一些耗时比较长的操作，这说明 Service 会运行在独立的子线程中<br>B．每次调用 Context 类中的 StartService()方法后都会新建一个 Service 实例<br>C．每次启动一个服务时候都会先后调用 onCreate()和 onStart()方法<br>D．当调用了 ConText 类中的 StopService()方法后，Serviece 中的 onDestroy()方法会自动回调 </p>
</li>
<li><pre><code>在 Android 中使用 Menu 时可能需要重写的方法有( AC )。[多选]
</code></pre>
<p>A、onCreateOptionsMenu() 	 	 	B、onCreateMenu()<br>C、onOptionsItemSelected() 	 	 	D、onItemSelected() </p>
</li>
<li><pre><code>在 Android 中使用 SQLiteOpenHelper 这个辅助类时，可以生成一个数据库，并可以对数据库版本进行管理的方法可以是( AB )[多选] 
</code></pre>
<p>A、	getWriteableDatabase() 	 	 	B、getReadableDatabase()<br>C、getDatabase()  	 	 	 	 	D、getAbleDatabase() </p>
</li>
<li><pre><code>Android 关于 service 生命周期的 onCreate()和 onStart()说法正确的是( AD )[多选] 
</code></pre>
<p>A、	当第一次启动的时候先后调用 onCreate()和 onStart()方法<br>B、	当第一次启动的时候只会调用 onCreate()方法<br>C、	如果 service 已经启动，将先后调用 onCreate()和 onStart()方法<br>D、	如果 service 已经启动，只会执行 onStart()方法，不再执行 onCreate()方法 </p>
</li>
<li><pre><code>下列属于 Activity 的状态是( ABC )[多选] 
</code></pre>
<p>A.运行状态  B 暂停状态 C 停止状态  D 睡眠状态 </p>
</li>
<li><p>关于 Handler 的说话正确的是( AB )[多选] 	<br>A.它实现不同线程间通信的一种机制 	 	B.它避免了新线程操作 UI 组件<br>C.它采用栈的方式来组织任务的 	 	 	D.它可以属于一个新的线程 </p>
</li>
<li><pre><code>关于广播的作用，正确的说法是( ABCD ) [多选] 
</code></pre>
<p>A 它是用接收系统发布的一些消息的 	 	B 它可以帮助 service 修改用户界面<br>C 它可以启动一个 Activity  	 	 	 	D 它可以启动一个 Service </p>
</li>
<li><pre><code>下面属于 View 的子类的是( CD ) [多选] 
</code></pre>
<p>A	Activity 	 	 	B Service 	 	 	C ViewGroup 	 	D TextView </p>
</li>
<li><pre><code>在 main.xml 中，定义一个组件时，有两个属性必须写( AB ) [多选] 
</code></pre>
<p>A android:layout_width   B android:layout_height<br>C android:id&#x3D;”@+id&#x2F;start” D android:text </p>
</li>
<li><pre><code>请找出你学过的适配器类( AC ) [多选] 
</code></pre>
<p>A	SimpleAdapter  	 	 	 	 	 	B SimpleArrayAdapter<br>C SimpleCursorAdapter 	 	 	 	 	D SimpleCursorsAdapter </p>
</li>
<li><pre><code>关于 Sqlite 数据库，正确的说法( ABD ) [多选] 
</code></pre>
<p>A	SqliteOpenHelper 类主要是用来创建数据库和更新数据库<br>B	SqliteDatabase 类是用来操作数据库的<br>C	在每次调用 SqliteDatabase 的 getWritableDatabase()方法时，会执行 SqliteOpenHelper 的 onCreate 方法。<br>D	当数据库版本发生变化时，可以自动更新数据库结构 </p>
</li>
<li><pre><code>Intent 传递数据时，下列的数据类型哪些可以被传递( ABCD )[多选] 
</code></pre>
<p>A	Serializable    	B、charsequence   C、Parcelable    	D、Bundle </p>
</li>
<li><pre><code>下列不属于 service 生命周期的方法是( CD )
</code></pre>
<p>A,onCreate<br>B,onDestroy<br>C,onStop<br>D,onStart </p>
<blockquote>
<p>service生命周期：onCreat()、onStartCommand()、onDestroy()、onBind()、onUnbind()</p>
</blockquote>
</li>
<li><pre><code>在 android 中使用 RadioButton 时，要想实现互斥的选择需要用的组件是( D )
</code></pre>
<p>A,ButtonGroup  B, RadioButtons  C,CheckBox  D,RadioGroup </p>
</li>
<li><pre><code>创建子菜单的方法是( B )
</code></pre>
<p>A,add 	B,addSubMenu C,createSubMenu 	D,createMenu </p>
</li>
<li><pre><code>处理菜单项单击事件的方法不包含( D )
</code></pre>
<p>A,使用 onOptionsItemSelected(MenuItem item)响应<br>B,使用 onMenuItemSelected(int featureId ,MenuItem item) 响应<br>C,使用 onMenuItemClick(MenuItem item) 响应<br>D,使用 onCreateOptionsMenu(Menu menu)响应 </p>
</li>
<li><pre><code>关于 AlertDialog 的说法不正确的是( A )
</code></pre>
<p>A,要想使用对话框首先要使用 new 关键字创建 AlertDialog 的实例<br>B,对话框的显示需要调用 show 方法<br>C,setPositiveButton 方法是用来加确定按钮的<br>D,setNegativeButton 方法是用来加取消按钮的 </p>
</li>
<li><pre><code>上下文菜单与其他菜单不同的是( B )
</code></pre>
<p>A,上下文菜单项上的单击事件可以使用 onMenuItemSelected 方法来响应<br>B,上下文菜单必须注册到指定的 view 上才能显示<br>C,上下文菜单的菜单项可以添加，可以删除<br>D,上下文菜单的菜单项可以有子项 </p>
</li>
<li><pre><code>以下关于 Android 应用程序的目录结构描述中，不正确的是？( D )
</code></pre>
<p>A、 src 目录是应用程序的主要目录，由 Java 类文件文件组成<br>B、	assets 目录是原始资源目录，该目录中的内容将不会被 R 类所引用<br>C、	res 目录是应用资源目录，该目录中的所有资源内容都会被 R 类所索引<br>D、	AndroidManifest.xml 文件是应用程序目录清单文件，该文件由 ADT 自动生成，不需要程序员手动修改   </p>
</li>
<li><p>对于 XML 布局文件中的视图控件，layout_width 属性的属性值不可以是什么？ ( D )<br>a. match_parent<br>b. fill_parent<br>c. wrap_content<br>d. match_content</p>
</li>
<li><p>关于 BroadcastReceiver 的说法不正确的是？  ( B )<br>a. 是用来接收广播 Intent 的<br>b. 一个广播 Intent 只能被一个订阅了此广播的 BroadcastReceiver 所接收<br>c. 对有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者<br>d. 接收者声明的优先级别在的 android:priority 属性中声明，数值越大 优先级别越高 </p>
</li>
<li><p>关于 Sqlite 数据库，不正确的说法是（ C ） 选择一项：<br>a. SqliteOpenHelper 类主要是用来创建数据库和更新数据库<br>b. SqliteDatabase 类是用来操作数据库的<br>c. 在每次调用 SqliteDatabase 的 getWritableDatabase() 方法时，会执行 teOpenHelper 的 onCreate 方法。<br>d. 当数据库版本发生变化时，可以自动更新数据库结构 </p>
</li>
<li><p>下列对 SharePreferences 存、取文件的说法中正确的是：ABD<br>A,属于移动存储解决方案     B,sharePreferences处理的就是key-value对<br>C,读取xml文件的路径是&#x2F;sdcard&#x2F;shared_prefx  D,信息的保存格式是xml </p>
</li>
<li><p>android 数据存储与访问的方式有？( ABCD )<br>a.	sharedpreference 	<br>b.	数据库 	<br>c.	文件 	<br>d.	内容提供者 	  </p>
</li>
<li><p>下列说法正确的有（ABC）<br>A. javac.exe 能指定编译结果要置于哪个目录（directory）<br>B. 在编译程序时，所能指定的环境变量不包括class path<br>C. javac 一次可同时编译数个java 源文件<br>D. 环境变量可在编译source code时指定</p>
</li>
<li><p>下列说法错误的有（BCD）<br>A. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同<br>B. Java面向对象语言容许单独的过程和函数存在<br>C. Java面向对象语言容许单独的方法存在<br>D. Java语言中的方法属于类的成员（member） </p>
</li>
<li><p>解析 xml 的方式有（CD）<br>A. 字符器类型<br>B. 流方式<br>C. DOM<br>D. SAX</p>
</li>
<li><p>Intent传递数据时，下列的哪种类型数据不可以被传递？B<br>A. Serializable<br>B. JSON对象<br>C. Bundle<br>D. Charsequence</p>
</li>
<li><p>在多个应用中读取共享存储数据时， 需要用到哪个对象的 query 方法？A<br>A. ContentResolver<br>B. ContentProvider<br>C. Cursor<br>D. SQLiteHelper</p>
</li>
<li><p>下列说法正确的是？A<br>A. 每个进程都运行于自己的 java 虚拟机(JVM)中。<br>B. 默认情况下，每个应用程序中均运行于自己的进程中，而且此进程不会被消毁。<br>C. 每个应用程序会被赋予一个唯一的 linux 用户 ID，从而使得该应用程序下的文件， 其它用户也可以访问。<br>D. 一个应用程序数据，可以随意被其它应用程序所访问</p>
</li>
<li><p>使用 AIDL 完成远程 service 方法调用下列说法不正确的是？A<br>选择一项：<br>A. aidl 对应的接口名称不能与 aidl 文件名相同<br>B. aidl 的文件的内容类似 java 代码<br>C. 创建一个 Service（服务），在服务的 onBind(Intent intent)方法中返回实现了 aidl 接口的对象<br>D. aidl 对应的接口的方法前面不能加访问权限修饰符</p>
</li>
<li><p>关于视图控件的常用事件描述中，不正确的是？A<br>A. Click事件只能使用在按钮上，表示按钮的点击动作<br>B. 当TextView类视图控件失去焦点或获得焦点时，将触发FocusChange事件<br>C. 当单选框中某一选项被选择时，将触发CheckedChange事件<br>D. 当多选框中某一选项被选择时，将触发CheckedChange事件</p>
</li>
<li><p>下列说法正确的有（C）<br>A．class中的constructor不可省略<br>B．constructor必须与class同名，但方法不能与class同名<br>C．constructor在一个对象被new时执行<br>D．一个class只能定义一个constructor</p>
</li>
<li><p>下列语句哪一个正确（B）<br>A．Java程序经编译后会产生machine code<br>B．Java程序经编译后会产生byte code<br>C．Java程序经编译后会产生DLL<br>D．以上都不正确</p>
</li>
<li><p>下列属于SAX解析xml文件的优点是（B）<br>A．将整个文档树存储在内存中，便于操作，支持删除，修改，重新排列等多种功能（DOM）<br>B．不用事先调入整个文档，占用资源少<br>C．整个文档调入内存，浪费时间和空间<br>D．不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会消失</p>
</li>
<li><p>DDMS中Log信息分为几个级别（C）<br>A．3<br>B．4<br>C．5<br>D．7</p>
</li>
<li><p>Android下的单元测试要配置，以下说法不正确的是（A）<br>A．需要在manifest.xml清单文件application节点下配置instrumentation<br>B．需要在manifest.xml清单文件manifest节点下配置instrumentation<br>C．需要在manifest.xml清单文件application节点下配置uses-library<br>D．需要让测试类继承AndroidTestCase类</p>
</li>
<li><p>下列说法错误的一项是（D）<br>A．Button是普通按钮组件，除此之外还有其他的按钮组件<br>B．TextView是显示文本的组件，TextView是EditText的父类<br>C．EditText是编辑文本的组件，可以使用EditText输入特定的字符<br>D．ImageView是显示图片的组件，可以通过设置显示局部图片</p>
</li>
<li><p>下列关于XML布局文件在Java代码中被引用的说明中，不正确的是（B）<br>A．在Activity中，可以使用findViewById( )方法，通过资源id，获得指定视图元素<br>B．在Activity中，可以使用R.drawable-system.***方式引用Android系统所提供的图片资源<br>C．在Activity中，可以使用setContentView( )方法，确定加载哪一个布局文件<br>D．可以使用View类的findViewById( )方法，获得当前View对象中的某一个视图元素</p>
</li>
</ol>
<h1 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h1><p>1、 Android 中常用的五种布局是 <strong>FrameLayout，LinearLayout，RelativeLayout，AbsoluteLayout 和 TableLayout</strong> 。<br>2、 Android 的四大组件是 <strong>activity，service，broadcast 和 contentprovide</strong>。<br>3、 Android 中 service 的实现方法是：<strong>startservice 和 bindservice</strong>。<br>4、 activity 一般会重载 7 个方法用来维护其生命周期，除了 <strong>onCreate(),onStart(),onDestory()</strong> 外还有 <strong>onrestart,onresume,onpause,onstop</strong>。<br>5、 android 的数据存储的方式 <strong>sharedpreference</strong>，文件，<strong>SQlite,contentprovider</strong>，网络。<br>6、 当启动一个Activity并且新的 Activity执行完后需要返回到启动它的 Activity来执行的回调函数是 <strong>startActivityResult()</strong> 。<br>7、 属于 android 中的三种适配器 <strong>SimpleAdapter、ArrayAdapter、 BaseAdapter</strong> 。<br>8、 元素中 layout_width 的取值有 <strong>wrap_content</strong> 、match_parent、fill_parent。<br>9、 SQLite 支持五种数据类型包括 <strong>TEXT</strong> 、NULL、BLOB、REAL、INTEGER。<br>10、一个 Activity 就是一个<strong>可视化的界面</strong>或者看成是控件的容器。<br>11、onPause()方法在 activity 被暂停或收回 CPU 和其他资源时调用，该方法用于<strong>保存活动状态的</strong>，也是对运行时数据的现场保护。<br>12、onDestroy 是 activity 被干掉前最后一个被调用方法，当调用 <strong>finish</strong> 方法或者系统为了节省空间将它暂时性的干掉时候调用。<br>13、使用 <strong>startService()</strong> 方法启动服务后，调用者和服务间没有关联，即使调用者退出了，服务仍然进行。<br>14、当应用程序中某广播在 AndroidMainifest.xml 进行注册后，即使该应用程序关闭后，也可以接受操作系统发出的 <strong>广播信息</strong> 。<br>15、定义 LinearLayout 水平方向布局时至少设置的三个属性：<strong>android:orientation</strong>， <strong>android:layout width 和 android:layout height</strong><br>16、Android 平台提供了 2D，3D 的图形支持，<strong>SQLite</strong> 数据库支持，并且集成了浏览器<br>17、Android SDK 主要以 <strong>java</strong> 语言为基础。<br>18、Android.jar 是一个标准的压缩包，其内容包含的是编译后的 <strong>class</strong>，包含了全部的 <strong>API</strong>。</p>
<h1 id="作品题"><a href="#作品题" class="headerlink" title="作品题"></a>作品题</h1><ol>
<li><p>导入“TextViewDemo”的安卓程序，建立如下图所示的界面，界面包含 TextView(id:TextView01)和 EditText(id:EditText01)两个控件，请分别在 main.xml 和 TextViewDemoActivity.java 补充程序：</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/1.png" class="">
<p>在XML文件里：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;User:&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/EditText01&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入“ButtonDemo”的安卓程序，建立如下图所示的界面，界面包含 TextView(id:TextView01)、Button(id:Button01)和 ImageButton(id:  ImageButton01)两个按钮，上方是“Button 按钮”，下方是一个 ImageButton 控件，请分别在 main.xml 和 ButtonDemoActivity.java 补充程序：</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/2.jpg" class="">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;ButtonDemo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/ImageButton01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/xxx.xxx&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入“ListViewDemo”的安卓程序，建立如下图所示的界面，界面包含 TextView(id:TextView01) 和 ListView01 (id: ListView01)两个按钮，ListView01 中所显示的内容“ListView 子项 1、ListView 子项 2 ListView 子项 3”并单击相应菜单项时 TextView 显示相应菜单名称，请分别在 main.xml 和ButtonDemoActivity.java 补充程序：</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/3.png" class="">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;ListViewDemo!&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/ListView01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> findViewById(R.id.TextView01);</span><br><span class="line"><span class="type">ListView</span> <span class="variable">listView</span> <span class="operator">=</span> findViewById(R.id.ListView01);</span><br><span class="line">String[] list = &#123;<span class="string">&quot;ListView子项1&quot;</span>, <span class="string">&quot;ListView子项2&quot;</span>, <span class="string">&quot;ListView子项3&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> <span class="title class_">ArrayAdapter</span>&lt;String&gt;(<span class="built_in">this</span>, android.R.layout.simple_list_item_1, list);</span><br><span class="line">listView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">AdapterView.<span class="type">OnItemClickListener</span> <span class="variable">onClickListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdapterView</span>.OnItemClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="type">int</span> position, <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;点击了ListView子项1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position == <span class="number">1</span>) &#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;点击了ListView子项2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;点击了ListView子项3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">listView.setOnItemClickListener(onClickListener);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建工程，命名为 LinearLayoutDemo，布局界面如图，A、B、C 三个按钮呈垂直线性排列，请写出相关布局文件代码。</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/4.jpg" class="">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;A&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;B&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;C&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建工程，命名为 TableLayoutDemo，布局界面如图，组件请使用表格布局排列，请写出相关布局文件代码。</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/5.jpg" class="">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TableLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/TableRow1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/label&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;用户名：&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;right&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/input&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;160dp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/TableRow2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;确定&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;取消&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TableLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建工程，命名为 RelativeLayoutDemo，布局界面如图，组件请使用相对布局排列，请写出相关布局文件代码。</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/6.png" class="">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;用户名：&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/entry&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/label&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;确认&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toLeftOf</span>=<span class="string">&quot;@id/cancel&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignTop</span>=<span class="string">&quot;@id/cancel&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toStartOf</span>=<span class="string">&quot;@id/cancel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;取消&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/entry&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentEnd</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建工程，命名为 AbsoluteLayoutDemo，布局界面如图，组件请使用绝对布局排列，请写出相关布局文件代码。</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/7.png" class=""></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AbsoluteLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/absolute&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;89dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;165dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/username&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;218dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;89dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;184dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPersonName&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;89dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;246dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/confirm&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_x</span>=<span class="string">&quot;207dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_y</span>=<span class="string">&quot;245dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/cancel&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">AbsoluteLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>导入“OptionMenu”的安卓程序，建立如下图所示的界面，界面包含 TextView(id:TextView01)控件和菜单，并单击相应菜单项时 TextView 显示相应菜单名称，请分别在 main.xml 、main_menu.xml 和 OptionMenuActivity.java 补充程序：</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/8.jpg" class="">
<p>在res&#x2F;menu下的main_menu.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item0&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;打印&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item1&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;新建&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item2&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;邮件&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item3&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;设置&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item4&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;订阅&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">		<span class="type">MenuInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> getMenuInflater();</span><br><span class="line">		inflater.inflate(R.menu.main_menu, menu);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> &#123;</span><br><span class="line">		<span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(R.id.TextView01);</span><br><span class="line">		<span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.item0:</span><br><span class="line">			textView.setText(<span class="string">&quot;打印，菜单ID：&quot;</span> + item.getItemId());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.item1:</span><br><span class="line">			textView.setText(<span class="string">&quot;新建，菜单ID：&quot;</span> + item.getItemId());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.item2:</span><br><span class="line">			textView.setText(<span class="string">&quot;邮件，菜单ID：&quot;</span> + item.getItemId());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.item3:</span><br><span class="line">			textView.setText(<span class="string">&quot;设置，菜单ID：&quot;</span> + item.getItemId());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.item4:</span><br><span class="line">			textView.setText(<span class="string">&quot;订阅，菜单ID：&quot;</span> + item.getItemId());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.onOptionsItemSelected(item);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;MenuDemo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入“SubMenu”的安卓程序，建立如下图所示的界面，界面包含 TextView(id:TextView01)控件和菜单，菜单结构如下：</p>
</li>
</ol>
<ul>
<li>设置<ul>
<li>打印</li>
</ul>
</li>
<li>新建<ul>
<li>邮件</li>
<li>订阅</li>
</ul>
</li>
</ul>
<p>并单击相应菜单项时 TextView 显示相应菜单名称， 请分别在 main.xml 、sub_menu.xml 和SubMenuActivity.java 补充程序：</p>
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/9-1.jpg" class="">
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/9-2.jpg" class="">
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/9-3.jpg" class="">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    <span class="type">MenuInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> getMenuInflater();</span><br><span class="line">    inflater.inflate(R.menu.sub_menu, menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>菜单文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item0&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;设置&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item2&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;打印&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item1&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;新建&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item3&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;邮件&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/item4&quot;</span> <span class="attr">android:title</span>=<span class="string">&quot;订阅&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>布局文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/TextView01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/SubMenuDemo&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>导入“ IntentDemo ” 的安卓工程， 建立如下图所示的界面，包含两个 Activity ，分别是IntentDemoActivity 和NewActivity，程序默认启动的 Activity 是IntentDemo，在用户点击“启动 Activity”按钮后，程序启动的 Activity 是 NewActivity，请分别补充程序：<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/10.png" class="">
main_activity<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/button&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>main_activity2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>MainClass:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button) findViewById(R.id.Button01);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, IntentDemo.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>导入“WebViewIntentDemo”的安卓工程，建立如下图所示的界面，布局界面如图，当用户在文本框中输入 Web 地址后，通过点击“浏览此 URL”按钮，程序根据用户输入的 Web 地址生成一个Intent，并以隐式启动的方式调用 Android 内置的 Web 浏览器，并打开指定的 Web 页面。本例输入的 Web 地址 <a href="http://www.google.com.hk,打开页面后的效果如图/">http://www.google.com.hk，打开页面后的效果如图</a><img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/11-1.jpg" class="">
<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/11-2.jpg" class="">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/editText&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">&quot;@string/text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">&quot;textUri&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentStart</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">&quot;@+id/editText&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/button&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">EditText</span> <span class="variable">editText</span> <span class="operator">=</span> (EditText) findViewById(R.id.editText);</span><br><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button) findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> editText.getText().toString();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>导入“ActivityCommunication”的安卓工程，建立如下图所示的界面，工程将以 Sub-Activity 方式启动子Activity，及使用 Intent 进行组件间通信。<br>1)、当用户点击“启动 Activity1”和“启动 Activity2”按钮时，程序将分别启动子 SubActivity1 和SubActivity2。<br>2)、SubActivity1 提供了一个输入框，以及“接受”和“撤销”两个按钮。如果在输入框中输入信息后点击“接受”按钮，程序会把输入框中的信息传递给其父 Activity，并在父 Activity 的界面上显示。<br>3)、如果用户点击“撤销”按钮，则程序不会向父 Activity 传递任何信息。<br>4)、SubActivity2 主要是为了说明如何在父 Activity 中处理多个子 Activity，因此仅提供了用于关闭SubActivity2 的“关闭”按钮<img src="/%E5%A4%8D%E4%B9%A0%E9%A2%98/Android%E5%A4%8D%E4%B9%A0%E9%A2%98/12-1.jpg" class="">

main<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/text1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/main_activity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/text2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/text1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;32dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/activity1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/text2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/activity2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/button1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUB1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUB2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">TextView text;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    text = findViewById(R.id.text2);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.button1).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SubActivity1.class);</span><br><span class="line">            startActivityForResult(intent, SUB1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.button2).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SubActivity2.class);</span><br><span class="line">            startActivityForResult(intent, SUB2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(&quot;SetTextI18n&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SUB1:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                text.setText(<span class="string">&quot;result: &quot;</span> + data.getData().toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUB2:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>activity1</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/subactivity1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;240dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">&quot;@string/enter&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/text&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;32dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/confirm&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/edit&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/cancel&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/button1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EditText</span> <span class="variable">editText</span> <span class="operator">=</span> findViewById(R.id.edit);</span><br><span class="line">findViewById(R.id.button1).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        setResult(RESULT_OK, <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="literal">null</span>, Uri.parse(editText.getText().toString())));</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">findViewById(R.id.button2).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        setResult(RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>activity2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/subactivity2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;32dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/close&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.button).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        setResult(RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>manifest:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.ActivityCommunication&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SubActivity2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SubActivity1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="13">
<li>Spinner<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span>&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Spinner</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/spinner1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:spinnerMode</span>=<span class="string">&quot;dropdown&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> findViewById(R.id.tv);</span><br><span class="line"><span class="type">Spinner</span> <span class="variable">spinner</span> <span class="operator">=</span> findViewById(R.id.spinner1);</span><br><span class="line">String[] list = &#123;<span class="string">&quot;Spinner1&quot;</span>, <span class="string">&quot;Spinner2&quot;</span>, <span class="string">&quot;Spinner3&quot;</span>&#125;;</span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> <span class="title class_">ArrayAdapter</span>&lt;String&gt;(<span class="built_in">this</span>,</span><br><span class="line">        android.R.layout.simple_spinner_dropdown_item, list);</span><br><span class="line">adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);</span><br><span class="line">spinner.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">spinner.setOnItemSelectedListener(<span class="keyword">new</span> <span class="title class_">AdapterView</span>.OnItemSelectedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; adapterView, View view, <span class="type">int</span> i, <span class="type">long</span> l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;点击了Spinner1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;点击了Spinner2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;点击了Spinner3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; adapterView)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>项目文件：<a href="http://d0.ananas.chaoxing.com/download/5d0c3b5024bad045c70079ec9f608ba8?at_=1610294878846&ak_=86b8e2318cce2fe4e7135f92d7b7847e&ad_=0096ee08d535b1c86617b21c71d25989&fn=Android.zip">整个</a> 、 <a href="http://115.159.109.73:8081/android1.txt">本页面源文件</a></p>
]]></content>
      <categories>
        <category>复习题</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>复习题</tag>
      </tags>
  </entry>
  <entry>
    <title>简单易懂的C语言-2</title>
    <url>/C%E8%AF%AD%E8%A8%80/C-language-learn-2/</url>
    <content><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><h2 id="安装VScode"><a href="#安装VScode" class="headerlink" title="安装VScode"></a>安装VScode</h2><p>好的回到课程，这次我们来讲一下安装环境。</p>
<span id="more"></span>

<p>就像我们玩游戏，有时候想玩新的3A大作，但是下载回来后发现 “缺少XXX文件”，这就是因为没有装运行环境造成的（好像跑远了）。总之，这里就教一下如何安装VScode，打开<a href="https://code.visualstudio.com/">官网</a>,我知道你们懒得百度，直接点开左边的链接就是了。</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/vscode1.png" class="" title="这就是官网了">

<p>然后就是下载安装，安装就是同意啊，下一步啊这些，不存在难度吧。</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/vscode2.png" class="" title="打开就是酱紫滴">

<p>但是你会发现一个问题，为什么界面是英文的，不要慌！问题不大，就算你慌也没用，跟着我操作就能设置成中文。</p>
<p>请看下面这张图——&gt;</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E4%B8%AD%E6%96%87.png" class="" title="装汉化">

<p>点击第一个右下角的安装，然后重启VScode（也就是关闭后再打开），然后你的中文界面就出来了。</p>
<p>最后一个步骤，安装C&#x2F;C++的插件，步骤如下</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/vscode3.png" class="" title="安装插件">
<p>安装之后重新加载就能用了。</p>
<h2 id="安装GCC编译器"><a href="#安装GCC编译器" class="headerlink" title="安装GCC编译器"></a>安装GCC编译器</h2><p>由于GCC原本是Linux系统的软件，这里我们需要用到Windows版本的GCC——MinGW，这里我就帮你们找到最新版，<a href="https://share.weiyun.com/5KGXixT">微云</a><br>如果你的电脑是32位就下载i686开头的文件，64位就下载x86_64开头的文件（如果不懂的话可以百度一下：怎么知道电脑是32位还是64位，我知道有些人会懒得查，那就下载32位的吧）<br>下载之后就需要解压，找一个你喜欢的位置（也就是哪里都行，比如D盘根目录），比如我的是64位，解压到E盘，位置就是 E:\mingw64 ，记住这个位置，就可以开始配置环境变量。<br>课外知识：<br><a href="https://www.baidu.com/s?wd=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></p>
<p>如果你的电脑是win10就好办了，打开搜索：</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E6%90%9C%E7%B4%A2.png" class="">
<p>或者这样</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E6%90%9C%E7%B4%A21.png" class="">

<p>然后开始安装图片操作吧</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png" class="">
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" class="">
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F3.png" class="">
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F4.png" class="">

<p>最后确定</p>
<p><a href="https://jingyan.baidu.com/article/b24f6c82cba6dc86bfe5da9f.html">Win7环境变量设置</a><br>XP也是差不多的</p>
<p>到这里我们打开cmd（WIN键+R，输入cmd，确认打开），输入<br><code>gcc -v</code><br>显示下面信息就说明全部完成了</p>
<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F5.png" class="">

<h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p>输出一句hello world是学习每一门语言都会做的一步，那跟着我来写出你的第一个程序吧！</p>
<ul>
<li>当你上面的步骤都做完之后，重启VScode<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/vscode4.png" class="" title="，点击文件——打开文件夹"></li>
<li>找一个你喜欢的位置，新建一个文件夹，写上你喜欢的名字，比如找到D盘——新建一个文件夹——沙雕游戏<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9.png" class=""></li>
<li>然后新建一个文件，沙雕程序.c<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6.png" class=""></li>
<li>复制这段代码到右边窗口<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!&quot;</span>);		<span class="comment">//打印HelloWorld</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后保存（上面说过了 快捷键是 Ctrl + S）<br>最后就是运行了，这里其实不需要向之前一样打开cmd，有一个很快捷的方法就是：<br>找到 终端 —— 新建终端，输入<code>gcc 沙雕程序.c</code>进行编译，得出一个a.exe文件，直接输入a.exe打开这个程序，终端就会打印出HelloWorld！<img src="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/%E6%96%B0%E5%BB%BA%E7%BB%88%E7%AB%AF.png" class=""></li>
</ul>
<p>好了你写的第一个沙雕程序就完成了（此处应有掌声）</p>
<blockquote>
<p><em><strong>获得成就</strong></em><br>获得开发环境：掌握如何搭建一个开发环境</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-1</title>
    <url>/%E5%89%8D%E7%AB%AF/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><h2 id="三种常见的选择器"><a href="#三种常见的选择器" class="headerlink" title="三种常见的选择器"></a>三种常见的选择器</h2><h3 id="ID选择器-x2F-ID-Selector"><a href="#ID选择器-x2F-ID-Selector" class="headerlink" title="ID选择器&#x2F;ID Selector"></a>ID选择器&#x2F;ID Selector</h3><p>使用#xxx选择id为xxx的元素，xxx必须是以英文字母开头，可以大小写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;the-id-selector&quot;</span>&gt;</span></span><br><span class="line">        Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">    #the-id-selector &#123;</span><br><span class="line">        font-size: 24px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ID在html里面应该是唯一的，一个ID选择器只能用在一个元素上面，一个元素只能有一个ID</p>
</blockquote>
<h3 id="类选择器-x2F-Class-Selector"><a href="#类选择器-x2F-Class-Selector" class="headerlink" title="类选择器&#x2F;Class Selector"></a>类选择器&#x2F;Class Selector</h3><p>使用.xxx来选择某一类元素，同样是英文字母开头，可以大小写。一个class可以套用到很多个元素，一个元素也可以有很多个class。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;the-class bg&quot;</span>&gt;</span></span><br><span class="line">        Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">    .the-class &#123;</span><br><span class="line">        font-size: 24px;</span><br><span class="line">        color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    .bg &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="标签选择器-x2F-Tag-Selector"><a href="#标签选择器-x2F-Tag-Selector" class="headerlink" title="标签选择器&#x2F;Tag Selector"></a>标签选择器&#x2F;Tag Selector</h3><p>使用xxx(比如div)就能套用到页面中所有的xxx标签。还可以在后面接上类选择器，选择某个标签下的某个类。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;the-class&quot;</span>&gt;</span></span><br><span class="line">        Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">    div.the-class &#123;</span><br><span class="line">        font-size: 24px;</span><br><span class="line">        color: yellow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="运用一些方法的选择器"><a href="#运用一些方法的选择器" class="headerlink" title="运用一些方法的选择器"></a>运用一些方法的选择器</h2><h3 id="使用空格"><a href="#使用空格" class="headerlink" title="使用空格"></a>使用空格</h3><p>比如下面的类选择器空格加上标签可以选择类里面的某些标签，可以随意搭配使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">    div &#123;</span><br><span class="line">        min-height: 20px;</span><br><span class="line">        border: 2px solid #333;</span><br><span class="line">        margin: 4px;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .container div &#123;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：这里并不包括container本身。</p>
</blockquote>
<h3 id="运用-gt-进行选择"><a href="#运用-gt-进行选择" class="headerlink" title="运用&gt;进行选择"></a>运用&gt;进行选择</h3><p>用于选择某个元素下的第一层元素，比如下面选择的是container下的第一层div:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">    div &#123;</span><br><span class="line">        min-height: 20px;</span><br><span class="line">        border: 2px solid #333;</span><br><span class="line">        margin: 4px;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .container &gt; div &#123;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-进行选择"><a href="#使用-进行选择" class="headerlink" title="使用+进行选择"></a>使用+进行选择</h3><p>比如<code>.container + div</code>选择的是跟container同一层而且紧接着的div，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    这里container后面的div被选上了</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    这里container后面的div没有被选上</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">    div &#123;</span><br><span class="line">        min-height: 20px;</span><br><span class="line">        border: 2px solid #333;</span><br><span class="line">        margin: 4px;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .container + div &#123;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用波浪符号-进行选择"><a href="#使用波浪符号-进行选择" class="headerlink" title="使用波浪符号~进行选择"></a>使用波浪符号~进行选择</h3><p>波浪符号的作用和加号很像，比如上面的例子改成<code>.container ~ div</code>，意思既是选择container后面所有的div（同一层）。</p>
<h3 id="使用-进行选择-1"><a href="#使用-进行选择-1" class="headerlink" title="使用*进行选择"></a>使用*进行选择</h3><p>星号代表所有的html元素，一般搭配使用，比如还是上面的例子，改成<code>.container ~ *</code>即可选择container后面的所有标签（还是和container同一层的）。</p>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.google.com&quot;</span> <span class="attr">title</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.apple.com&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.codepen.com&quot;</span>&gt;</span>CodePen<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">css:</span><br><span class="line">a &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  padding: 8px;</span><br><span class="line">&#125;</span><br><span class="line">/* 选择所有拥有title属性的标签 */</span><br><span class="line">a[title] &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">/* 根据href里面的值去选择 */</span><br><span class="line">a[href=&quot;www.apple.com&quot;] &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line">/* 根据xxx开头去选择 */</span><br><span class="line">a[href^=&quot;https&quot;] &#123;</span><br><span class="line">  color: gray;</span><br><span class="line">&#125;</span><br><span class="line">/* 根据xxx结尾去选择 */</span><br><span class="line">a[href$=&quot;e.com&quot;] &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">&#125;</span><br><span class="line">/* 根据关键词xxx去选择 */</span><br><span class="line">a[href*=&quot;code&quot;] &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>功能非常强大，用法参考<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">官方文档</a></p>
<h2 id="CSS选择器权重"><a href="#CSS选择器权重" class="headerlink" title="CSS选择器权重"></a>CSS选择器权重</h2><ol>
<li>内联样式，如：style&#x3D;””，权重为1000.</li>
<li>ID选择器，如：#app，权重为0100.</li>
<li>类选择器、伪类选择器、属性选择器，如：.sidebar，权重0010.</li>
<li>代表</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Casbin学习笔记：基础模型</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Casbin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://casbin.org/zh-CN/">casbin官网</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Casbin是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。</p>
<span id="more"></span>

<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>在 Casbin 中, 访问控制模型被抽象为基于 PERM (Policy, Effect, Request, Matcher) 的一个文件。 因此，切换或升级项目的授权机制与修改配置一样简单。 您可以通过组合可用的模型来定制您自己的访问控制模型。 例如，可以在一个model中获得RBAC角色和ABAC属性，并共享一组policy规则。</p>
<h2 id="Policy-策略"><a href="#Policy-策略" class="headerlink" title="Policy 策略"></a>Policy 策略</h2><p>p&#x3D;{sub, obj, act, eft}，策略一般存到数据，因为项目会很多</p>
<p>定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[policy_definition]</span><br><span class="line">p = sub,obj,act</span><br></pre></td></tr></table></figure>


<h2 id="Matchers-匹配规则"><a href="#Matchers-匹配规则" class="headerlink" title="Matchers 匹配规则"></a>Matchers 匹配规则</h2><p>Request和Policy的匹配规则</p>
<p>比如(r请求 p策略)：<code>m= r.sub == p.sub &amp;&amp; r.act == p.act &amp;&amp; r.obj == p.obj</code></p>
<p>这时候会把r和p按照上述描述进行匹配，从而返回匹配结果（eft）。如果不定义会返回allow，如果定义过就返回定义过的结果</p>
<h2 id="Effact-影响"><a href="#Effact-影响" class="headerlink" title="Effact 影响"></a>Effact 影响</h2><p>决定是否放行</p>
<p>比如：<code>e = some(where(p.eft == allow))</code> 这种情况下，我们的一个matcher匹配完成，得到allow那么这条请求将被放行</p>
<p>或者： e &#x3D; some(where(p.eft &#x3D;&#x3D; allow)) &amp;&amp; !some(where(p.eft &#x3D;&#x3D; deny))</p>
<p>这里的规则是定死的</p>
<h2 id="Request-请求"><a href="#Request-请求" class="headerlink" title="Request 请求"></a>Request 请求</h2><p>r &#x3D; {sub, obj, act}</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Golang</tag>
        <tag>后端</tag>
        <tag>Casbin</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记-2</title>
    <url>/%E5%89%8D%E7%AB%AF/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>字节前端青训营课程内容笔记</p>
<span id="more"></span>

<h1 id="CSS-继承"><a href="#CSS-继承" class="headerlink" title="CSS 继承"></a>CSS 继承</h1><p>某些属性会自动继承其父元素的计算值，除非显式指定一个值。一般和文字相关的属性都可以继承，但是和宽度、高度等模型尺寸相关的属性不可以继承。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is a</span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>em-test<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">  of</span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>inherit<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">em</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 p 继承了 body 的 font-size，strong 继承了 p 的 color。</p>
<p>如果一个属性不可继承，但是又想让其继承父级属性，可以用通配选择器 * 指定该属性为 inherit，inherit 关键字表示指定一个属性应从父元素继承它的值。如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.some-content-box</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSS-初始值"><a href="#CSS-初始值" class="headerlink" title="CSS 初始值"></a>CSS 初始值</h1><p>CSS 中，每个属性都有一个初始值，比如：background-color 的初始值为 transparent、margin-left 的初始值为 0</p>
<p>可以使用 initial 关键字显式重置为初始值 background-color: initial</p>
<h1 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h1><p>除了继承和初始值，还有个 unset 的值，如果使用 unset 会先判断改值是否为可继承属性，如果是可继承将继承父级，否则相当于 initial（初始值）。</p>
<h1 id="CSS-从解析到展示过程"><a href="#CSS-从解析到展示过程" class="headerlink" title="CSS 从解析到展示过程"></a>CSS 从解析到展示过程</h1><p>大概的流程是：</p>
<ol>
<li>首先通过 DOM 树和样式表通过 filtering（过滤）得到 DeclaredValue（声明值）</li>
<li>然后通过 cascading（层叠）的得到 CascadedValue（层叠值）</li>
<li>然后对层叠值进行 defaulting（缺省化）得到 SpecifiedValue（指定值）</li>
<li>指定值进行一些 resolving（处理）转换得到 ComputedValue（计算值）</li>
<li>计算值再进一步 formatting（格式化）得到 UsedValue（使用值）</li>
<li>使用值通过 constraining（常数化）得到实际值，这时候就能实际使用了</li>
</ol>
<p>关于上面一些操作的解释：</p>
<ul>
<li>filtering：对应用到该页面的规则用以下条件进行筛选:选择器匹配、属性有效、符合当前 media 等。</li>
<li>Declared Value：一个元素的属性可以有 0 到多个声明值属性可以有 0 到多个声明值。</li>
<li>cascading：按照来源、!important、选择器特异性、书写顺序等选出优先级最高的一个属性值。</li>
<li>Cascaded Value：Cascaded Value,在层叠过程中，赢得优先级比赛的那个值。比如 1.2em</li>
<li>defaulting：当层叠值为空的时候，使用继承&#x2F;初始值。</li>
<li>Specified Value：经过 cascading 和 defaulting 之后，保证指定值一定不为空</li>
<li>resolving：将一些相对值或者关键字转化为绝对值，比如 em 转为 px，相对路径转为绝对路径。</li>
<li>Computed Value：一般来说是，浏览器会在不进行实际布局的情况下，所能得到的最具体的值。比如 60%</li>
<li>formatting：将计算值进一步转换， 比如关键字、百分比都转为绝对值。</li>
<li>Used Value：进行实际布局时使用的值，不会再有相对值或关键字。比如 400.2px</li>
<li>constraining：将小数像素转为整数</li>
<li>实际值：渲染时实际生效的值，比如 400px</li>
</ul>
<h1 id="常规流"><a href="#常规流" class="headerlink" title="常规流"></a>常规流</h1><h2 id="行级摆放上下文（IFC）"><a href="#行级摆放上下文（IFC）" class="headerlink" title="行级摆放上下文（IFC）"></a>行级摆放上下文（IFC）</h2><p>全称：<strong>Inline Formatting Content</strong></p>
<ul>
<li>盒子在一行内水平摆放；</li>
<li>一行放不下就换行；</li>
<li>vertical-align 控制垂直对齐（有基线）；</li>
<li>text-align 控制水平对齐；</li>
<li>需要避开 float 浮动元素。</li>
</ul>
<p>实现文字居中对齐：<code>vertical-align:middle;</code></p>
<h2 id="块级排版上下文-BFC"><a href="#块级排版上下文-BFC" class="headerlink" title="块级排版上下文(BFC)"></a>块级排版上下文(BFC)</h2><p>全称：Block Formatting Content</p>
<p>某些容器会创建一个 BFC:</p>
<ul>
<li>根元素</li>
<li>浮动、绝对定位、inline-block</li>
<li>Flex 子项和 Grid 子项</li>
<li>overflow 值不是 visible 的块盒</li>
<li>display:flow-root;</li>
</ul>
<p>BFC 内的排版规则:</p>
<ul>
<li>盒子从下到上摆放</li>
<li>垂直 margin 合并</li>
<li>BFC 内盒子的 margin 不会与外面的合并</li>
<li>BFC 不会和浮动元素重叠</li>
</ul>
<blockquote>
<p>下一节讲解 flex grid 布局</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart核心特性</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Dart%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>记录Dart的一些特性</p>
<span id="more"></span>

<h1 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h1><p>这里选择的是一段购物车程序，先不使用Dart独有的特性，然后逐步加入Dart语言特性。</p>
<p>首先在不使用任何Dart语法特性的情况下，一个有着基本功能的购物车程序如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义商品 Item 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> price;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Item(name, price) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义购物车类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">DateTime</span> date;</span><br><span class="line">  <span class="built_in">String</span> code;</span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; bookings;</span><br><span class="line"> </span><br><span class="line">  price() &#123;</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> bookings) &#123;</span><br><span class="line">      sum += i.price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ShoppingCart(name, code) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.date = <span class="built_in">DateTime</span>.now();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;购物车信息:&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;\n-----------------------------&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;\n 用户名: &#x27;</span> + name+ </span><br><span class="line">          <span class="string">&#x27;\n 优惠码: &#x27;</span> + code + </span><br><span class="line">          <span class="string">&#x27;\n 总价: &#x27;</span> + price().toString() +</span><br><span class="line">          <span class="string">&#x27;\n 日期: &#x27;</span> + date.toString() +</span><br><span class="line">          <span class="string">&#x27;\n-----------------------------&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart sc = ShoppingCart(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">  sc.bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看上去和Java或者JS都没有太大的差异，接下来从表达信息入手，优化这段代码</p>
<h1 id="类抽象改造"><a href="#类抽象改造" class="headerlink" title="类抽象改造"></a>类抽象改造</h1><p>在Item类和ShoppingCart类的构造函数中，他们都只是将main函数传入的参数进行属性赋值。</p>
<p>在Dart中使用语法糖和初始化列表进行简化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">  double price;</span><br><span class="line">  <span class="title class_">String</span> name;</span><br><span class="line">  <span class="title class_">Item</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">price</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">  <span class="title class_">String</span> name;</span><br><span class="line">  <span class="title class_">DateTime</span> date;</span><br><span class="line">  <span class="title class_">String</span> code;</span><br><span class="line">  <span class="title class_">List</span>&lt;<span class="title class_">Item</span>&gt; bookings;</span><br><span class="line">  <span class="title function_">price</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">  <span class="comment">// 删掉了构造函数函数体</span></span><br><span class="line">  <span class="title class_">ShoppingCart</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">code</span>) : date = <span class="title class_">DateTime</span>.<span class="title function_">now</span>();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们发现：Item类和ShoppingCart类中都有一个name属性，都有一个price属性&#x2F;方法，既然他们的类型和名称都一样，那么可以抽象出一个Meta基类，用于存放这两个属性。</p>
<p>因为在ShoppingCart中price只是用于计算购物车中商品的价格，那么继承Meta类后需要改写price属性的get方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta</span> &#123;</span><br><span class="line">  double price;</span><br><span class="line">  <span class="title class_">String</span> name;</span><br><span class="line">  <span class="title class_">Meta</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">price</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Meta</span>&#123;</span><br><span class="line">  <span class="title class_">Item</span>(name, price) : <span class="variable language_">super</span>(name, price);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Meta</span>&#123;</span><br><span class="line">  <span class="title class_">DateTime</span> date;</span><br><span class="line">  <span class="title class_">String</span> code;</span><br><span class="line">  <span class="title class_">List</span>&lt;<span class="title class_">Item</span>&gt; bookings;</span><br><span class="line">  </span><br><span class="line">  double get price &#123;...&#125;</span><br><span class="line">  <span class="title class_">ShoppingCart</span>(name, <span class="variable language_">this</span>.<span class="property">code</span>) : date = <span class="title class_">DateTime</span>.<span class="title function_">now</span>(),<span class="variable language_">super</span>(name,<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过ShoppingCart类中的price属性的get方法和打印购物车基本信息的getinfo方法都显得冗长，接下来改进一下这两个方法。</p>
<h1 id="方法改造"><a href="#方法改造" class="headerlink" title="方法改造"></a>方法改造</h1><p>我们需要重载Item类的“+”运算符，并通过对列表对象进行归纳合并操作即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 重载了 + 运算符，合并商品为套餐商品</span></span><br><span class="line">  Item <span class="keyword">operator</span>+(Item item) =&gt; Item(name + item.name, price + item.price); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 把迭代求和改写为归纳合并</span></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> price =&gt; bookings.reduce((value, element) =&gt; value + element).price;</span><br><span class="line">  ...</span><br><span class="line">  getInfo() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便修改getInfo方法，因为字符串拼接实在是太不美观了。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">getInfo () =&gt; <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">购物车信息:</span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">  用户名: <span class="subst">$name</span></span></span><br><span class="line"><span class="string">  优惠码: <span class="subst">$code</span></span></span><br><span class="line"><span class="string">  总价: <span class="subst">$price</span></span></span><br><span class="line"><span class="string">  Date: <span class="subst">$date</span></span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="对象初始化方式的优化"><a href="#对象初始化方式的优化" class="headerlink" title="对象初始化方式的优化"></a>对象初始化方式的优化</h1><p>因为有可能用户没有优惠券，所以我们需要对构造函数进行改进</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 默认初始化方法，转发到 withCode 里</span></span><br><span class="line">  ShoppingCart(&#123;name&#125;) : <span class="keyword">this</span>.withCode(name:name, code:<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//withCode 初始化方法，使用语法糖和初始化列表进行赋值，并调用父类初始化方法</span></span><br><span class="line">  ShoppingCart.withCode(&#123;name, <span class="keyword">this</span>.code&#125;) : date = <span class="built_in">DateTime</span>.now(), <span class="keyword">super</span>(name,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//?? 运算符表示为 code 不为 null，则用原值，否则使用默认值 &quot; 没有 &quot;</span></span><br><span class="line">  getInfo () =&gt; <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">购物车信息:</span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">  用户名: <span class="subst">$name</span></span></span><br><span class="line"><span class="string">  优惠码: <span class="subst">$&#123;code??<span class="string">&quot; 没有 &quot;</span>&#125;</span></span></span><br><span class="line"><span class="string">  总价: <span class="subst">$price</span></span></span><br><span class="line"><span class="string">  Date: <span class="subst">$date</span></span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart sc = ShoppingCart.withCode(name:<span class="string">&#x27;张三&#x27;</span>, code:<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">  sc.bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc.getInfo());</span><br><span class="line"> </span><br><span class="line">  ShoppingCart sc2 = ShoppingCart(name:<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">  sc2.bookings = [Item(<span class="string">&#x27;香蕉&#x27;</span>,<span class="number">15.0</span>), Item(<span class="string">&#x27;西瓜&#x27;</span>,<span class="number">40.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc2.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为打印这个行为非常通用，可能后面需要打印Item，所以我们需要把打印信息单独封装成一个类：PrintHelper。因为ShoppingCart 类本身已经继承自 Meta 类，考虑到 Dart 并不支持多继承，所以我们使用混合（Mixin）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintHelper</span> </span>&#123;</span><br><span class="line">  printInfo() =&gt; <span class="built_in">print</span>(getInfo());</span><br><span class="line">  getInfo();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span> <span class="title">with</span> <span class="title">PrintHelper</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在main里面使用级联操作符，这样就不需要创建临时变量了，下面是完整代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> price;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="comment">// 成员变量初始化语法糖</span></span><br><span class="line">  Meta(<span class="keyword">this</span>.name, <span class="keyword">this</span>.price);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  Item(name, price) : <span class="keyword">super</span>(name, price);</span><br><span class="line">  <span class="comment">// 重载 + 运算符，将商品对象合并为套餐商品</span></span><br><span class="line">  Item <span class="keyword">operator</span>+(Item item) =&gt; Item(name + item.name, price + item.price); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintHelper</span> </span>&#123;</span><br><span class="line">  printInfo() =&gt; <span class="built_in">print</span>(getInfo());</span><br><span class="line">  getInfo();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//with 表示以非继承的方式复用了另一个类的成员变量及函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span> <span class="title">with</span> <span class="title">PrintHelper</span></span>&#123;</span><br><span class="line">  <span class="built_in">DateTime</span> date;</span><br><span class="line">  <span class="built_in">String</span> code;</span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; bookings;</span><br><span class="line">  <span class="comment">// 以归纳合并方式求和</span></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> price =&gt; bookings.reduce((value, element) =&gt; value + element).price;</span><br><span class="line">  <span class="comment">// 默认初始化函数，转发至 withCode 函数</span></span><br><span class="line">  ShoppingCart(&#123;name&#125;) : <span class="keyword">this</span>.withCode(name:name, code:<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//withCode 初始化方法，使用语法糖和初始化列表进行赋值，并调用父类初始化方法</span></span><br><span class="line">  ShoppingCart.withCode(&#123;name, <span class="keyword">this</span>.code&#125;) : date = <span class="built_in">DateTime</span>.now(), <span class="keyword">super</span>(name,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//?? 运算符表示为 code 不为 null，则用原值，否则使用默认值 &quot; 没有 &quot;</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getInfo() =&gt; <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">购物车信息:</span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">  用户名: <span class="subst">$name</span></span></span><br><span class="line"><span class="string">  优惠码: <span class="subst">$&#123;code??<span class="string">&quot; 没有 &quot;</span>&#125;</span></span></span><br><span class="line"><span class="string">  总价: <span class="subst">$price</span></span></span><br><span class="line"><span class="string">  Date: <span class="subst">$date</span></span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart.withCode(name:<span class="string">&#x27;张三&#x27;</span>, code:<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">  ..bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)]</span><br><span class="line">  ..printInfo();</span><br><span class="line"> </span><br><span class="line">  ShoppingCart(name:<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">  ..bookings = [Item(<span class="string">&#x27;香蕉&#x27;</span>,<span class="number">15.0</span>), Item(<span class="string">&#x27;西瓜&#x27;</span>,<span class="number">40.0</span>)]</span><br><span class="line">  ..printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的调试方法</title>
    <url>/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>为了让新手更好的学习C语言，这里手把手教你如何调试你的代码</p>
<span id="more"></span>

<h1 id="当我们不会用调试但是怎么知道程序怎么运行"><a href="#当我们不会用调试但是怎么知道程序怎么运行" class="headerlink" title="当我们不会用调试但是怎么知道程序怎么运行"></a>当我们不会用调试但是怎么知道程序怎么运行</h1><p>当我入门学习写c语言时不会调试就每一步加个输出，就知道代码运行到哪了，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)&#123;</span><br><span class="line">    <span class="keyword">do</span> sth...</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 次执行、n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样缺点也很明显，你需要在你的代码加入大量的垃圾代码，交作业时也要全部删除，非常麻烦。</p>
<h1 id="Clion调试"><a href="#Clion调试" class="headerlink" title="Clion调试"></a>Clion调试</h1><p>CLion是Jetbrains公司旗下的一款专为开发C&#x2F;C++所设计的跨平台IDE，可以说是开发C语言的神器。安装方法也很简单，破解可以看<a href="/%E5%B9%B2%E8%B4%A7/Jetbrains-crack/">这篇文章</a>。</p>
<p>这个IDE需要用到mingw编译器，配置方法可以看<a href="/C%E8%AF%AD%E8%A8%80/C-language-learn-2/">这篇文章</a>，找到安装GCC编译器的方法。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>第一次运行的时候注意配置好Toolchains，当然也可以在进入编辑界面之后配置，由于我已经配置好，所以上一张已经配置好的图片吧。</p>
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/peizhi1.png" class="" title="途中的Environment设置成mingw的路径就行了">
<p>配置好之后我们新建一个工程：</p>
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/newproj.png" class="">
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/newproj1.png" class="">
<p>然后软件会自动生成一个输出helloworld语句，这时候我们给它打上短点然后点击右上方三角符号旁边的小甲虫开始调试：</p>
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/debug1.png" class="">
<p>就能看到已经开始调试了，而且程序停在了断点的位置：</p>
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/debug2.png" class="">
<p>可能你看到的框框和我的位置不太一样，你可以拖住框框拉到你想要的位置。上面的console就是用来输入输出的地方，frame就算函数的堆栈，variables可以看到这个函数里的变量的值。<br>在左下方的Debuger旁边，有几个按钮，比如蓝色箭头向下，红色箭头向下，蓝色箭头向上等等，你把鼠标放过去之后就能看到这几个按钮的名字，这里你只需要用到其中三个，分别是：</p>
<ol>
<li>step into：逐步调试，遇到函数进入函数内部逐步调试</li>
<li>step over：也是逐步调试，但是遇到函数会直接执行完一个函数，直接得到结果</li>
<li>step out：当你进入一个函数时，按下这个按钮，会执行完这个函数的所有语句然后回到上一个函数。</li>
</ol>
<p>这时候我们稍微改一下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);             <span class="comment">// 使用fflush(stdout)是因为在debug情况下不清缓冲区是不会立刻输出上一句的内容</span></span><br><span class="line">    func1();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a function!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在第6行打上断点，进行调试，这时候就能发现代码已经来到<code>printf(&quot;Hello, World!\n&quot;);</code>这一行，但是这行还没执行，这时候我们使用step into进行逐步调试看看效果吧！</p>
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/debug3.png" class="">
<p>可以看到代码按照我们预计的步骤运行着，在Frames能看到堆栈的信息，Variables能看到堆栈（函数）内的变量信息。</p>
<blockquote>
<p>除了<code>fflush(stdout);</code>可以让控制台及时输出之外，开可以在程序开头使用：<code>setbuf(stdout, 0);</code>，关掉缓冲区，这样每个字符都会及时打印出来</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    func1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a function!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>此时如果我们想知道变量val的地址怎么办，没关系我们有watch，点击Variables下方的加号，添加上一个表达式：<code>&amp;val</code>，按下回车就能得到我们的地址值了，反过来同理，当我们只有一个指针p，想知道指针指向的变量的值怎么办？那不就是加上取值符号星号：<code>*p</code>。</p>
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/debug4.png" class="">
<img src="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/debug5.png" class="">

<p>那么clion基本的调试方法就是这样啦，可以试试拿之前写好的代码来试试，有问题的时候就能快速定位到底是什么情况啦。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Html5学习笔记（1）</title>
    <url>/%E5%89%8D%E7%AB%AF/Html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>一些html5的学习笔记</p>
<span id="more"></span>

<h1 id="主要的标签和属性"><a href="#主要的标签和属性" class="headerlink" title="主要的标签和属性"></a>主要的标签和属性</h1><h2 id="新的多媒体元素"><a href="#新的多媒体元素" class="headerlink" title="新的多媒体元素"></a>新的多媒体元素</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;audio&gt;</code></td>
<td>定义音频内容</td>
</tr>
<tr>
<td><code>&lt;video&gt;</code></td>
<td>定义视频内容</td>
</tr>
<tr>
<td><code>&lt;source&gt;</code></td>
<td>定义多媒体资源，配合video或audio使用</td>
</tr>
<tr>
<td><code>&lt;embed&gt;</code></td>
<td>定义嵌入内容，个人感觉不常用</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;321&quot;</span> <span class="attr">height</span>= <span class="string">&quot;123&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">您的浏览器不支持Video标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果浏览器不支持就会显示：您的浏览器不支持Video标签。</p>
<p>video支持是属性：<a href="#" title="如果出现该属性，则视频在就绪后马上播放。">autoplay</a> 、 <a href=# title="如果出现该属性，则向用户显示控件，比如播放按钮。">controls</a> 、<a href=# title="播放器大小">height和width</a> 、<a href=# title="如果出现该属性，则当媒介文件完成播放后再次开始播放。">loop</a> 、<a href=# title="规定视频的音频输出应该被静音。">muted</a>、<a href=# title="规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。">poster</a>、<a href=# title="如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用autoplay，则忽略该属性。">preload</a>、<a href=# title="要播放的视频的 URL。">src</a> 。</p>
<p>audio有：autoplay、controls、loop、muted、preload、src属性。</p>
<h2 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;datalist&gt;</code></td>
<td>定义选项列表，与 input 元素配合使用，用来定义 input 可能的值。</td>
</tr>
<tr>
<td><code>&lt;keygen&gt;</code></td>
<td>规定用于表单的密钥对生成器字段。</td>
</tr>
<tr>
<td><code>&lt;output&gt;</code></td>
<td>定义不同类型的输出，比如脚本的输出。</td>
</tr>
</tbody></table>
<h2 id="新的语意标签"><a href="#新的语意标签" class="headerlink" title="新的语意标签"></a>新的语意标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;article&gt;</code></td>
<td>定义内容区域</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>定义侧边栏</td>
</tr>
<tr>
<td><code>&lt;command&gt;</code></td>
<td>定义命令按钮</td>
</tr>
<tr>
<td><code>&lt;details&gt;</code></td>
<td>定义细节</td>
</tr>
<tr>
<td><code>&lt;dialog&gt;</code></td>
<td>定义对话框</td>
</tr>
<tr>
<td><code>&lt;summary&gt;</code></td>
<td>标签包含 details 元素的标题</td>
</tr>
<tr>
<td><code>&lt;figure&gt;</code></td>
<td>规定独立的流内容（图像、图表、照片、代码等等）。</td>
</tr>
<tr>
<td><code>&lt;figcaption&gt;</code></td>
<td>定义<code> &lt;figure&gt;</code> 元素的标题</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>定义 section 或 document 的页脚。</td>
</tr>
<tr>
<td><code>&lt;header&gt;</code></td>
<td>定义了头部区域</td>
</tr>
<tr>
<td><code>&lt;mark&gt;</code></td>
<td>定义带有记号的文本。</td>
</tr>
<tr>
<td><code>&lt;meter&gt;</code></td>
<td>定义度量衡。仅用于已知最大和最小值的度量。</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>定义导航链接的部分。</td>
</tr>
<tr>
<td><code>&lt;progress&gt;</code></td>
<td>定义任何类型的任务的进度。</td>
</tr>
<tr>
<td><code>&lt;rt&gt;</code></td>
<td>定义字符（中文注音或字符）的解释或发音。</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>定义文档中的节（section、区段）。</td>
</tr>
<tr>
<td><code>&lt;time&gt;</code></td>
<td>定义日期或时间。</td>
</tr>
<tr>
<td><code>&lt;wbr&gt;</code></td>
<td>规定在文本中的何处适合添加换行符。</td>
</tr>
</tbody></table>
<h2 id="在HTML5中删除的HTML4-01标签"><a href="#在HTML5中删除的HTML4-01标签" class="headerlink" title="在HTML5中删除的HTML4.01标签"></a>在HTML5中删除的HTML4.01标签</h2><ul>
<li><code>&lt;acronym&gt;</code></li>
<li><code>&lt;applet&gt;</code></li>
<li><code>&lt;basefont&gt;</code></li>
<li><code>&lt;big&gt;</code></li>
<li><code>&lt;center&gt;</code></li>
<li><code>&lt;dir&gt;</code></li>
<li><code>&lt;font&gt;</code></li>
<li><code>&lt;frame&gt;</code></li>
<li><code>&lt;frameset&gt;</code></li>
<li><code>&lt;noframes&gt;</code></li>
<li><code>&lt;strike&gt;</code></li>
<li><code>&lt;tt&gt;</code></li>
</ul>
<h2 id="表单的属性"><a href="#表单的属性" class="headerlink" title="表单的属性"></a>表单的属性</h2><h3 id="form标签的属性"><a href="#form标签的属性" class="headerlink" title="form标签的属性"></a>form标签的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>accept-charset</td>
<td>charset_list</td>
<td>规定服务器可处理的表单数据字符集。</td>
</tr>
<tr>
<td>action</td>
<td>URL</td>
<td>规定当提交表单时向何处发送表单数据。</td>
</tr>
<tr>
<td>autocomplete</td>
<td>on &#x2F; off</td>
<td>规定是否启用表单的自动完成功能。</td>
</tr>
<tr>
<td>enctype</td>
<td></td>
<td>规定在发送表单数据之前如何对其进行编码。</td>
</tr>
<tr>
<td>method</td>
<td>get&#x2F;post</td>
<td>规定用于发送 form-data 的 HTTP 方法。</td>
</tr>
<tr>
<td>name</td>
<td>form_name</td>
<td>规定表单的名称。</td>
</tr>
<tr>
<td>novalidate</td>
<td>novalidate</td>
<td>如果使用该属性，则提交表单时不进行验证。</td>
</tr>
<tr>
<td>target</td>
<td></td>
<td>规定在何处打开 action URL。</td>
</tr>
</tbody></table>
<p>enctype 属性可能的值：</p>
<ul>
<li>application&#x2F;x-www-form-urlencoded</li>
<li>multipart&#x2F;form-data</li>
<li>text&#x2F;plain</li>
</ul>
<p>target 属性可能的值：</p>
<ul>
<li>_blank</li>
<li>_self</li>
<li>_parent</li>
<li>_top</li>
<li>framename</li>
</ul>
<h1 id="Web-储存"><a href="#Web-储存" class="headerlink" title="Web 储存"></a>Web 储存</h1><h2 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h2><p>客户端存储数据的两个对象：</p>
<ul>
<li>localStorage - 没有时间限制</li>
<li>sessionStorage - 针对session的数据储存</li>
</ul>
<p>使用前应检查是否支持</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_">typeof</span>(<span class="title class_">Storage</span>)!==<span class="string">&quot;undefined&quot;</span>) &#123;        </span><br><span class="line">    <span class="comment">// 是的! 支持 localStorage  sessionStorage 对象!         </span></span><br><span class="line">    <span class="comment">// 一些代码.....         </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">    <span class="comment">// 抱歉! 不支持 web 存储。         </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="localStorage对象"><a href="#localStorage对象" class="headerlink" title="localStorage对象"></a>localStorage对象</h2><p>实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="property">sitename</span> = <span class="string">&quot;Wyatex博客&quot;</span>;</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">localStorage</span>.<span class="property">sitename</span>;</span><br></pre></td></tr></table></figure>

<p>localStorage其他可用API：</p>
<ul>
<li>保存数据：<code>localStorage.setItem(key,value);</code></li>
<li>读取数据：<code>localStorage.getItem(key);</code></li>
<li>删除单个数据：<code>localStorage.removeItem(key);</code></li>
<li>删除所有数据：<code>localStorage.clear();</code></li>
<li>得到某个索引的key：<code>localStorage.key(index);</code></li>
</ul>
<h2 id="sessionStorage对象"><a href="#sessionStorage对象" class="headerlink" title="sessionStorage对象"></a>sessionStorage对象</h2><p>用户关闭浏览器窗口后数据会删除，实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sessionStorage.<span class="property">clickcount</span>) &#123;</span><br><span class="line">  sessionStorage.<span class="property">clickcount</span> = (sessionStorage.<span class="property">clickcount</span>)+<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sessionStorage.<span class="property">clickcount</span>=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;counter&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;在这个会话中你已经点击了该按钮 &quot;</span> + sessionStorage.<span class="property">clickcount</span> + <span class="string">&quot; 次 &quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="HTML5-应用程序缓存"><a href="#HTML5-应用程序缓存" class="headerlink" title="HTML5 应用程序缓存"></a>HTML5 应用程序缓存</h1><p>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。<br>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;demo.appcache&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">The content of the document......</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h2><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p>
<p>manifest 文件可分为三个部分：</p>
<ul>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>
</ul>
<h3 id="CACHE-MANIFEST"><a href="#CACHE-MANIFEST" class="headerlink" title="CACHE MANIFEST"></a>CACHE MANIFEST</h3><p>第一行，CACHE MANIFEST，是必需的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST        </span><br><span class="line">/theme.css        </span><br><span class="line">/logo.gif        </span><br><span class="line">/main.js</span><br></pre></td></tr></table></figure>

<h3 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h3><p>下面的 NETWORK 小节规定文件 “login.php” 永远不会被缓存，且离线时是不可用的： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETWORK:        </span><br><span class="line">login.php</span><br></pre></td></tr></table></figure>
<p>可以使用星号来指示所有其他其他资源&#x2F;文件都需要因特网连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETWORK:        </span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h3 id="FALLBACK"><a href="#FALLBACK" class="headerlink" title="FALLBACK"></a>FALLBACK</h3><p>下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 &#x2F;html&#x2F; 目录中的所有文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FALLBACK:       </span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure>
<p>第一个 URI 是资源，第二个是替补。</p>
<p>实例：完整的 Manifest 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST        </span><br><span class="line"># 2012-02-21 v1.0.0       </span><br><span class="line">/theme.css        </span><br><span class="line">/logo.gif        </span><br><span class="line">/main.js        </span><br><span class="line">        </span><br><span class="line">NETWORK:        </span><br><span class="line">login.php        </span><br><span class="line">        </span><br><span class="line">FALLBACK:       </span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong> : 以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。</p>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<p>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p>
<p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。</p>
<p>以下 API 用于创建 WebSocket 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Socket</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url, [protocal] );</span><br></pre></td></tr></table></figure>
<p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p>
<h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
    <tbody>
        <tr class="firstRow">
            <td width="401" valign="top" style="word-break: break-all;">
                属性
            </td>
            <td width="401" valign="top" style="word-break: break-all;">
                描述
            </td>
        </tr>
        <tr>
            <td width="401" valign="top" style="word-break: break-all;">
                Socket.readyState
            </td>
            <td width="401" valign="top" style="word-break: break-all;">
                <p>
                    只读属性&nbsp;readyState&nbsp;表示连接状态，可以是以下值：
                </p>
                <ul class="list list-paddingleft-2">
                    <li>
                        <p>
                            0 - 表示连接尚未建立。
                        </p>
                    </li>
                    <li>
                        <p>
                            1 - 表示连接已建立，可以进行通信。
                        </p>
                    </li>
                    <li>
                        <p>
                            2 - 表示连接正在进行关闭。
                        </p>
                    </li>
                    <li>
                        <p>
                            3 - 表示连接已经关闭或者连接不能打开。
                        </p>
                    </li>
                </ul>
            </td>
        </tr>
        <tr>
            <td width="401" valign="top" style="word-break: break-all;">
                Socket.bufferedAmount
            </td>
            <td width="401" valign="top" style="word-break: break-all;">
                只读属性&nbsp;bufferedAmount&nbsp;已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。
            </td>
        </tr>
    </tbody>
</table>

<h2 id="WebSocket-事件"><a href="#WebSocket-事件" class="headerlink" title="WebSocket 事件"></a>WebSocket 事件</h2><table class="reference" width="979" style="width: 828px;">
    <tbody style="margin: 0px; padding: 0px;">
        <tr style="margin: 0px; padding: 0px; background-color: rgb(239, 239, 239);" class="firstRow">
            <th width="10%" style="margin: 0px; padding: 3px; background-color: rgb(189, 189, 189); border-top-color: rgb(189, 189, 189); border-right-color: rgb(189, 189, 189); border-bottom: none; border-left-color: rgb(189, 189, 189); color: rgb(255, 255, 255); vertical-align: top; text-align: left;">
                事件
            </th>
            <th width="25%" style="margin: 0px; padding: 3px; background-color: rgb(189, 189, 189); border-top-color: rgb(189, 189, 189); border-right-color: rgb(189, 189, 189); border-bottom: none; border-left-color: rgb(189, 189, 189); color: rgb(255, 255, 255); vertical-align: top; text-align: left;">
                事件处理程序
            </th>
            <th style="margin: 0px; padding: 3px; background-color: rgb(189, 189, 189); border-top-color: rgb(189, 189, 189); border-right-color: rgb(189, 189, 189); border-bottom: none; border-left-color: rgb(189, 189, 189); color: rgb(255, 255, 255); vertical-align: top; text-align: left;">
                描述
            </th>
        </tr>
        <tr style="margin: 0px; padding: 0px;">
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                open
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                Socket.onopen
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                连接建立时触发
            </td>
        </tr>
        <tr style="margin: 0px; padding: 0px; background-color: rgb(239, 239, 239);">
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                message
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                Socket.onmessage
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                客户端接收服务端数据时触发
            </td>
        </tr>
        <tr style="margin: 0px; padding: 0px;">
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                error
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                Socket.onerror
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                通信发生错误时触发
            </td>
        </tr>
        <tr style="margin: 0px; padding: 0px; background-color: rgb(239, 239, 239);">
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                close
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                Socket.onclose
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                连接关闭时触发
            </td>
        </tr>
    </tbody>
</table>

<h2 id="WebSocket-方法"><a href="#WebSocket-方法" class="headerlink" title="WebSocket 方法"></a>WebSocket 方法</h2><p style="white-space: normal; margin-top: 0px; padding: 0px; overflow-wrap: break-word; color: rgb(51, 51, 51); line-height: 1.7; font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);">
    以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：
</p>
<table class="reference" width="979" style="width: 828px;">
    <tbody style="margin: 0px; padding: 0px;">
        <tr style="margin: 0px; padding: 0px; background-color: rgb(239, 239, 239);" class="firstRow">
            <th style="margin: 0px; padding: 3px; background-color: rgb(189, 189, 189); border-top-color: rgb(189, 189, 189); border-right-color: rgb(189, 189, 189); border-bottom: none; border-left-color: rgb(189, 189, 189); color: rgb(255, 255, 255); vertical-align: top; text-align: left;">
                方法
            </th>
            <th style="margin: 0px; padding: 3px; background-color: rgb(189, 189, 189); border-top-color: rgb(189, 189, 189); border-right-color: rgb(189, 189, 189); border-bottom: none; border-left-color: rgb(189, 189, 189); color: rgb(255, 255, 255); vertical-align: top; text-align: left;">
                描述
            </th>
        </tr>
        <tr style="margin: 0px; padding: 0px;">
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                Socket.send()
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                <p style="margin-bottom: 5px; overflow-wrap: break-word; line-height: 1.7;">
                    使用连接发送数据
                </p>
            </td>
        </tr>
        <tr style="margin: 0px; padding: 0px; background-color: rgb(239, 239, 239);">
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                Socket.close()
            </td>
            <td style="margin: 0px; padding: 7px 5px; min-width: 40px; vertical-align: top; box-sizing: border-box;">
                <p style="margin-bottom: 5px; overflow-wrap: break-word; line-height: 1.7;">
                    关闭连接
                </p>
            </td>
        </tr>
    </tbody>
</table>

<h2 id="WebScoket实例"><a href="#WebScoket实例" class="headerlink" title="WebScoket实例"></a>WebScoket实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> <span class="variable constant_">HTML</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>W3Cschool教程(w3cschool.cn)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">function</span> <span class="title function_">WebSocketTest</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span> (<span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="variable language_">window</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="title function_">alert</span>(<span class="string">&quot;您的浏览器支持 WebSocket!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">// 打开一个 web socket</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:9998/echo&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  ws.<span class="title function_">send</span>(<span class="string">&quot;发送数据&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="title function_">alert</span>(<span class="string">&quot;数据发送中...&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">evt</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">var</span> received_msg = evt.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="title function_">alert</span>(<span class="string">&quot;数据已接收...&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">				</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="comment">// 关闭 websocket</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="title function_">alert</span>(<span class="string">&quot;连接已关闭...&quot;</span>); </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">else</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">// 浏览器不支持 WebSocket</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="title function_">alert</span>(<span class="string">&quot;您的浏览器不支持 WebSocket!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sse&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:WebSocketTest()&quot;</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains系列产品2020.1最新激活方法[持续更新]</title>
    <url>/%E5%B9%B2%E8%B4%A7/Jetbrains-crack/</url>
    <content><![CDATA[<blockquote>
<p>如果不知道什么是JetBrains，那就问问神奇的魔法搜索引擎吧！</p>
</blockquote>
<p>这次要分享的是Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。</p>
<span id="more"></span>

<hr>
<p><strong>在以下IDE版本测试可成功激活:</strong></p>
<ul>
<li>IntelliJ IDEA <code>2020.1及以下</code></li>
<li>AppCode <code>2019.3.7及以下</code></li>
<li>CLion <code>2019.3.5及以下</code></li>
<li>DataGrip <code>2020.1及以下</code></li>
<li>GoLand <code>2020.1及以下</code></li>
<li>PhpStorm <code>2019.3.4及以下</code></li>
<li>PyCharm <code>2020.1及以下</code></li>
<li>Rider <code>2019.3.4及以下</code></li>
<li>RubyMine <code>2019.3.4及以下</code></li>
<li>WebStorm <code>2020.1及以下</code></li>
</ul>
<hr>
<p>首先下载破解补丁<br><a href="https://pan.baidu.com/s/1d_DQUsO-vJB7llClskJOfA">百度网盘</a> 提取码：<code>fmy1</code>。<br><a href="https://share.weiyun.com/5SbdK6z">微云</a></p>
<ul>
<li><p>启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE</p>
</li>
<li><p>下载压缩包直接拖到IDE里，点 “Restart” 按钮重启IDE。</p>
<img src="/%E5%B9%B2%E8%B4%A7/Jetbrains-crack/1.png" class="" title="把压缩包拖到IDE里">
</li>
<li><p>在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。</p>
<img src="/%E5%B9%B2%E8%B4%A7/Jetbrains-crack/2.png" class="" title="点击安装">
</li>
<li><p>重启IDE，搞定。</p>
<img src="/%E5%B9%B2%E8%B4%A7/Jetbrains-crack/3.png" class="" title="激活成功"></li>
</ul>
<p> 有什么问题可以在下面评论提出</p>
]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>Jetbrains</tag>
        <tag>干货</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js与开发实战（1）</title>
    <url>/NodeJS/Node-js%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-1/</url>
    <content><![CDATA[<p>字节前端青训营课程内容笔记</p>
<span id="more"></span>

<h1 id="编写-HTTP-Server"><a href="#编写-HTTP-Server" class="headerlink" title="编写 HTTP Server"></a>编写 HTTP Server</h1><h2 id="基本的-http-server："><a href="#基本的-http-server：" class="headerlink" title="基本的 http server："></a>基本的 http server：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入http包</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 自定义的端口号，可用数值为0-62235，0-1023是系统端口，最好不要使用</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="comment">// 创建http服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//告诉服务器响应已完成，并向请求的一方发送数据，内容为字符串&#x27;hello world&#x27;</span></span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 服务器监听端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on :&#x27;</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="发送-json-数据的-http-server"><a href="#发送-json-数据的-http-server" class="headerlink" title="发送 json 数据的 http server"></a>发送 json 数据的 http server</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建数据缓冲区</span></span><br><span class="line">  <span class="keyword">const</span> bufs = []</span><br><span class="line">  <span class="comment">// 监听数据，有数据变换，将其添加到缓冲区中</span></span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">buf</span>) =&gt;</span> &#123;</span><br><span class="line">    bufs.<span class="title function_">push</span>(buf)</span><br><span class="line">  &#125;)</span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将所有接受到的数据进行拼接和整合，转为utf8格式的字符串</span></span><br><span class="line">    <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(bufs).<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="comment">// 默认数据</span></span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 解析数据</span></span><br><span class="line">      <span class="keyword">const</span> ret = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(buf)</span><br><span class="line">      msg = ret.<span class="property">msg</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// res.end(&#x27;invalid json&#x27;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义响应数据</span></span><br><span class="line">    <span class="keyword">const</span> responseJson = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">`receive: <span class="subst">$&#123;msg&#125;</span>`</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置响应头</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(responseJson))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已经向客户端发送数据&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on:&#x27;</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在此，需要一个客户端发送响应，才能看到结果，所以，我们接下来创建一个发送数据的客户端。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="comment">// 定义发送的json数据</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;我是来自客户端的数据&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建请求</span></span><br><span class="line"><span class="keyword">const</span> request = http.<span class="title function_">request</span>(</span><br><span class="line">  <span class="string">&#x27;http://127.0.0.1:3000&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Tpye&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置得到响应后的回调函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bufs = []</span><br><span class="line">    response.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">buf</span>) =&gt;</span> &#123;</span><br><span class="line">      bufs.<span class="title function_">push</span>(buf)</span><br><span class="line">    &#125;)</span><br><span class="line">    response.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(bufs).<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(buf)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;json.msg&#x27;</span>, json)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">request.<span class="title function_">end</span>(body)</span><br></pre></td></tr></table></figure>

<h2 id="结合-promise-创建一个返回-json-的-http-server"><a href="#结合-promise-创建一个返回-json-的-http-server" class="headerlink" title="结合 promise 创建一个返回 json 的 http server"></a>结合 promise 创建一个返回 json 的 http server</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> msg = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bufs = []</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">buf</span>) =&gt;</span> &#123; bufs.<span class="title function_">push</span>(buf) &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="title function_">reject</span>(err) <span class="comment">// 失败的回调&#125;)</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> msg = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">      <span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(bufs).<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ret = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(buf)</span><br><span class="line">        msg = ret.<span class="property">msg</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err) <span class="comment">// 失败的回调</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 成功的回调</span></span><br><span class="line">      <span class="title function_">resolve</span>(msg)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> responseJson = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">`receive msg: <span class="subst">$&#123;msg&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(responseJson))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on: &#x27;</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="发送静态文件的-htpp-server"><a href="#发送静态文件的-htpp-server" class="headerlink" title="发送静态文件的 htpp server"></a>发送静态文件的 htpp server</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"><span class="comment">// 找到文件所在目录</span></span><br><span class="line"><span class="keyword">const</span> folderPath = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./static&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> info = url.<span class="title function_">parse</span>(req.<span class="property">url</span>)</span><br><span class="line">  <span class="comment">// 设置文件所在的绝对路径</span></span><br><span class="line">  <span class="keyword">const</span> filePath = path.<span class="title function_">resolve</span>(folderPath, <span class="string">&#x27;./&#x27;</span> + info.<span class="property">path</span>)</span><br><span class="line">  <span class="keyword">const</span> fileStream = fs.<span class="title function_">createReadStream</span>(filePath)</span><br><span class="line">  fileStream.<span class="title function_">pipe</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on: &#x27;</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>path.resolve([…paths])里的每个参数都类似在当前目录执行一个 cd 操作，从左到右执行，返回的是最后的当前目录。所以 const filePath &#x3D; path.resolve(folderPath, info.path)并不会正确地找到文件所在的路径。</li>
<li>使用 pipe 会节省内存</li>
</ul>
<h1 id="编写-http-server-React-SSR"><a href="#编写-http-server-React-SSR" class="headerlink" title="编写 http server-React SSR"></a>编写 http server-React SSR</h1><p>SSR (server side rendering)有什么特点?</p>
<ul>
<li>相比传统 HTML 模版引擎：避免重复编写代码</li>
<li>相比 SPA (single page application)：首屏渲染更快，SEO 友好</li>
<li>缺点：通常 qps 较低，前端代码编写时需要考虑服务端渲染情况</li>
</ul>
<p>SSR 难点：</p>
<ul>
<li>需要处理打包代码</li>
<li>需要思考前端代码在服务端运行时的逻辑</li>
<li>移除对服务端无意义的副作用，或重置环境</li>
</ul>
<p>SSR(Server Side Rendering)相比于传统的 HTML 模板引擎，能够比避免重复编写代码，相比于 SPA，首屏渲染更快、SEO 友好；其缺点是 QPS 较低，需要考虑服务器的渲染性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">React</span> = <span class="built_in">require</span>(<span class="string">&#x27;react&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactDOMServer</span> = <span class="built_in">require</span>(<span class="string">&#x27;react-dom/server&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, props.<span class="property">children</span> || <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">end</span>(</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;ReactDOMServer.renderToString(App(&#123;&#125;))&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on:&#x27;</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>SSR 需要处理打包代码，如使用 webpack</li>
<li>需要思考在服务器端运行时的逻辑，如在 componentDidMount 的时候发送网络请求</li>
<li>移除对服务器无意义的副作用配置和环境</li>
</ul>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>JsonSchema学习笔记</title>
    <url>/uncategorized/JsonSchema%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>to be continued</p>
]]></content>
      <tags>
        <tag>JsonSchema</tag>
      </tags>
  </entry>
  <entry>
    <title>React17学习笔记-1</title>
    <url>/React/React17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>字节前端青训营课程内容笔记</p>
<span id="more"></span>

<h1 id="组件化的准则"><a href="#组件化的准则" class="headerlink" title="组件化的准则"></a>组件化的准则</h1><ul>
<li>组件是组件的组合&#x2F;原子组件</li>
<li>组件内拥有状态，外部不可见</li>
<li>父组件可将状态传入组件内部</li>
</ul>
<p>组件设计：</p>
<ul>
<li>组件声明了状态和 UI 映射</li>
<li>组件有 Props&#x2F;State 两种状态</li>
<li>组件可以组合</li>
</ul>
<h1 id="JSX-语法和组件"><a href="#JSX-语法和组件" class="headerlink" title="JSX 语法和组件"></a>JSX 语法和组件</h1><p>React 组件声明共有两种形式：函数组件与 class 组件<br>函数组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsx 的语法就是在函数的 return 返回一段类似 HTML 的代码，但依然是 js 代码，只不过会通过构建工具转译成<code>React.createElement(&#39;h1&#39;, ...)</code>的格式，和 vue3 的 jsx 一模一样，可以查看：<a href="/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9Ajsx/">Vue3 学习笔记：jsx</a> 进行对比理解。</p>
<h1 id="React（hooks）的写法"><a href="#React（hooks）的写法" class="headerlink" title="React（hooks）的写法"></a>React（hooks）的写法</h1><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>传入一个初始值，返回一个状态，和 set 该状态的函数，用户可以通过调用该函数，来实现状态的修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>传入一个函数，和一个数组(可选)，数组是状态的数组，称作依赖项，该函数在 mount 时，和依赖项被 set 的时候会执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用一个副作用，传入的[count]数组使得此副作用只有当count变量改变时才会被调用</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 副作用：Update the document title using the browser API</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不写第二个参数的话，传入的参数引用了外面的状态，则这些状态其中一个发生变化都会触发这个副作用函数。</p>
<h1 id="生态介绍"><a href="#生态介绍" class="headerlink" title="生态介绍"></a>生态介绍</h1><h2 id="状态管理库"><a href="#状态管理库" class="headerlink" title="状态管理库"></a>状态管理库</h2><p>Redux、xState、mobx、recoil 等</p>
<h2 id="应用级框架"><a href="#应用级框架" class="headerlink" title="应用级框架"></a>应用级框架</h2><ol>
<li>NEXT.js：硅谷明星创业公司 Vercel 的 React 开发框架，稳定，开发体验好，支持 Unbundled Dev、SWC 等，其同样有 Serverless 一键部署平台帮助开发者快速完成部署。口号是”Let’s Make Web Faster”</li>
<li>MODERN.js：字节跳动 Web Infra 团队研发的全栈开发框架，内置了很多开箱即用的能力与最佳实践，可以减少很多调研选择工具的时间。</li>
<li>Blitz：无 API 思想的全栈开发框架，开发过程中无需写 API 调用与 CRUD 逻辑，适合前后端紧密结合的小团队项目</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>U盘推荐</title>
    <url>/%E6%95%B0%E7%A0%81%E4%BA%A7%E5%93%81%E6%8E%A8%E8%8D%90/U%E7%9B%98%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<blockquote>
<p>更新：2020-4-16</p>
</blockquote>
<span id="more"></span>

<p>U盘没啥新品，主要就多了一个L7C。</p>
<table>
<thead>
<tr>
<th>型号</th>
<th>价格</th>
<th>容量</th>
<th>读取速度</th>
<th>写入速度</th>
<th>评价</th>
</tr>
</thead>
<tbody><tr>
<td>闪迪CZ48</td>
<td>40</td>
<td>32</td>
<td>100</td>
<td>40</td>
<td>非常抠的一个盘，除非你连加10块钱上CZ74都不舍得就选这个，新版48和酷豆听说是同款颗粒</td>
</tr>
<tr>
<td>闪迪CZ74</td>
<td>50</td>
<td>32</td>
<td>150</td>
<td>60~80</td>
<td>低价位来看这个应该是性价比最好的了</td>
</tr>
<tr>
<td>闪迪CZ74</td>
<td>69</td>
<td>64</td>
<td>同上</td>
<td>同上</td>
<td>加20就能多一倍的空间，比32G更香了</td>
</tr>
<tr>
<td>金士顿DT100G3</td>
<td>40</td>
<td>32</td>
<td>160</td>
<td>20</td>
<td>选这个除非你是对金士顿有什么奇怪的信仰而且就算被坑也没事，那你就买吧（滑稽）</td>
</tr>
<tr>
<td>三星BAR+</td>
<td>159</td>
<td>128</td>
<td>300</td>
<td>40</td>
<td>三星自家的NAND闪存，128G版以上能读取上300，不过写入是个硬伤，只有40左右，如果你真的需要一个高速U盘建议看下一个</td>
</tr>
<tr>
<td>联想L7C</td>
<td>239（有时候是199）</td>
<td>128</td>
<td>550</td>
<td>500</td>
<td>真正的高速U盘，读写都没缺点，L7C永远滴神！</td>
</tr>
<tr>
<td>闪迪CZ880</td>
<td>269</td>
<td>128</td>
<td>420</td>
<td>380</td>
<td>是什么使你放弃L7C？是觉得联想声誉不行还是什么？当然选择权在你手上。</td>
</tr>
</tbody></table>
<p>以上容量的单位为G，读写速度单位为MB&#x2F;S。</p>
]]></content>
      <categories>
        <category>数码产品推荐</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>推荐</tag>
        <tag>数码产品</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis5种数据结构及使用场景分析</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>文章来自：<a href="http://www.chengxy-nds.top/">http://www.chengxy-nds.top/</a>，技术资料共享，同进步</p>
<span id="more"></span>

<h1 id="Redis基础数据结构有哪些？"><a href="#Redis基础数据结构有哪些？" class="headerlink" title="Redis基础数据结构有哪些？"></a>Redis基础数据结构有哪些？</h1><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>在任何一种编程语言里，字符串<code>String</code>都是最基础的数据结构， 那你有想过<code>Redis</code>中存储一个字符串都进行了哪些操作嘛？</p>
<p>在Redis中<code>String</code>是可以修改的，称为动态字符串(<code>Simple Dynamic String</code> 简称 <code>SDS</code>)（快拿小本本记名词，要考的），说是字符串但它的内部结构更像是一个 <code>ArrayList</code>，内部维护着一个字节数组，并且在其内部预分配了一定的空间，以减少内存的频繁分配。</p>
<p>Redis的内存分配机制是这样：</p>
<p>当字符串的长度小于 1MB时，每次扩容都是加倍现有的空间。<br>如果字符串长度超过 1MB时，每次扩容时只会扩展 1MB 的空间。<br>这样既保证了内存空间够用，还不至于造成内存的浪费，字符串最大长度为 512MB。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/str.webp" class="">
<blockquote>
<p>以上图片源自网络，如有侵权联系删除<br>上图就是字符串的基本结构，其中 <code>content</code> 里面保存的是字符串内容，<code>0x\0</code>作为结束字符不会被计算len中。</p>
</blockquote>
<p>分析一下字符串的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct SDS&#123;</span><br><span class="line">  T capacity;       <span class="comment">//数组容量</span></span><br><span class="line">  T len;            <span class="comment">//实际长度</span></span><br><span class="line">  <span class="type">byte</span> flages;      <span class="comment">//标志位,低三位表示类型</span></span><br><span class="line">  <span class="type">byte</span>[] content;   <span class="comment">//数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>capacity</code> 和 <code>len</code> 两个属性都是泛型，为什么不直接用<code>int</code>类型？因为<code>Redis</code>内部有很多优化方案，为更合理的使用内存，不同长度的字符串采用不同的数据类型表示，且在创建字符串的时候 <code>len</code> 会和 <code>capacity</code> 一样大，不产生冗余的空间，所以<code>String</code>值可以是字符串、数字（整数、浮点数) 或者 二进制。</p>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>存储key-value键值对，这个比较简单不细说了.</p>
<h3 id="字符串（String）常用的命令："><a href="#字符串（String）常用的命令：" class="headerlink" title="字符串（String）常用的命令："></a>字符串（String）常用的命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set   [key]  [value]    给指定key设置值（set 可覆盖老的值）</span><br><span class="line">get  [key]              获取指定key 的值</span><br><span class="line">del  [key]              删除指定key</span><br><span class="line">exists  [key]           判断是否存在指定key</span><br><span class="line">mset  [key1]  [value1]  [key2]  [value2] ...... 批量存键值对</span><br><span class="line">mget  [key1]  [key2] ......                     批量取key</span><br><span class="line">expire [key]  [time]                  给指定key 设置过期时间  单位秒</span><br><span class="line">setex    [key]  [time]  [value]       等价于 set + expire 命令组合</span><br><span class="line">setnx  [key]  [value]   如果key不存在则set 创建，否则返回0</span><br><span class="line">incr   [key]            如果value为整数 可用 incr命令每次自增1</span><br><span class="line">incrby  [key] [number]  使用incrby命令对整数值 进行增加 number</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h2><p>Redis中的list和Java中的<code>LinkedList</code>很像，底层都是一种链表结构， list的插入和删除操作非常快，时间复杂度为 0(1)，不像数组结构插入、删除操作需要移动数据。</p>
<p>像归像，但是redis中的list底层可不是一个双向链表那么简单。</p>
<p>当数据量较少的时候它的底层存储结构为一块连续内存，称之为<code>ziplist</code>(压缩列表)，它将所有的元素紧挨着一起存储，分配的是一块连续的内存；当数据量较多的时候将会变成quicklist(快速链表)结构。</p>
<p>可单纯的链表也是有缺陷的，链表的前后指针 <code>prev</code> 和 <code>next</code> 会占用较多的内存，会比较浪费空间，而且会加重内存的碎片化。在redis 3.2之后就都改用<code>ziplist</code>+链表的混合结构，称之为 <code>quicklist</code>(快速链表)。</p>
<p>下面具体介绍下两种链表</p>
<h3 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist(压缩列表)"></a>ziplist(压缩列表)</h3><p>先看一下ziplist的数据结构，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct ziplist&lt;T&gt;&#123;</span><br><span class="line">    int32 zlbytes;              <span class="comment">//压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset;        <span class="comment">//最后一个元素距离起始位置的偏移量,用于快速定位到最后一个节点</span></span><br><span class="line">    int16 zllength;             <span class="comment">//元素个数</span></span><br><span class="line">    T[] entries;                <span class="comment">//元素内容</span></span><br><span class="line">    int8 zlend;                 <span class="comment">//结束位 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>int32 zlbytes</code>： 压缩列表占用字节数<br><code>int32 zltail_offset</code>： 最后一个元素距离起始位置的偏移量,用于快速定位到最后一个节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`int16 zllength`</span>：元素个数</span><br><span class="line"><span class="string">`T[] entries`</span>：元素内容</span><br><span class="line"><span class="string">`int8 zlend`</span>：结束位 <span class="number">0xFF</span></span><br></pre></td></tr></table></figure>
<p>压缩列表为了支持双向遍历，所以才会有 <code>ztail_offset</code> 这个字段，用来快速定位到最后一个元素，然后倒着遍历</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/list.webp" class="">
<p><code>entry</code>的数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct entry&#123;</span><br><span class="line">    <span class="type">int</span>&lt;<span class="keyword">var</span>&gt; prevlen;             <span class="comment">//前一个 entry 的长度</span></span><br><span class="line">    <span class="type">int</span>&lt;<span class="keyword">var</span>&gt; encoding;            <span class="comment">//元素类型编码</span></span><br><span class="line">    optional <span class="type">byte</span>[] content;      <span class="comment">//元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>entry</code>它的 <code>prevlen</code> 字段表示前一个 <code>entry</code> 的字节长度，当压缩列表倒着遍历时，需要通过这<br>个字段来快速定位到下一个元素的位置。</p>
<h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><p>由于list它是一个按照插入顺序排序的列表，所以应用场景相对还较多的，例如：</p>
<ul>
<li>消息队列：lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能</li>
<li>朋友圈的点赞列表、评论列表、排行榜：lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表。</li>
</ul>
<h3 id="list操作的常用命名："><a href="#list操作的常用命名：" class="headerlink" title="list操作的常用命名："></a>list操作的常用命名：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpush  [key] [value1] [value2] ......    链表右侧插入</span><br><span class="line"></span><br><span class="line">rpop    [key]   移除右侧列表头元素，并返回该元素</span><br><span class="line"></span><br><span class="line">lpop   [key]    移除左侧列表头元素，并返回该元素</span><br><span class="line"></span><br><span class="line">llen  [key]     返回该列表的元素个数</span><br><span class="line"></span><br><span class="line">lrem [key] [count] [value]  删除列表中与value相等的元素，count是删除的个数。 count&gt;0 表示从左侧开始查找，删除count个元素，count&lt;0 表示从右侧开始查找，删除count个相同元素，count=0 表示删除全部相同的元素</span><br><span class="line"></span><br><span class="line">(PS:   index 代表元素下标，index 可以为负数， index= 表示倒数第一个元素，同理 index=-2 表示倒数第二 个元素。)</span><br><span class="line"></span><br><span class="line">lindex [key] [index]                      获取list指定下标的元素 （需要遍历，时间复杂度为O(n)）</span><br><span class="line"></span><br><span class="line">lrange [key]  [start_index] [end_index]   获取list 区间内的所有元素 （时间复杂度为 O（n））</span><br><span class="line"></span><br><span class="line">ltrim  [key]  [start_index] [end_index]   保留区间内的元素，其他元素删除（时间复杂度为 O（n））</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h2><p><code>Redis</code>的<code>Hash</code>和<code>Java</code>的<code>HashMap</code>相识，都是数组+链表的结构（感觉和Golang也像），值得注意的是在 <code>Redis</code> 的 <code>Hash</code> 中 <code>value</code> 只能是字符串。用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hset books java &quot;Effective java&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books golang &quot;concurrency in go&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hget books java </span><br><span class="line">&quot;Effective java&quot;</span><br><span class="line">&gt; hset user age 17 </span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hincrby user age 1 #单个 key 可以进行计数 和 incr 命令基本一致 </span><br><span class="line">(integer) 18</span><br></pre></td></tr></table></figure>
<p><code>Hash</code> 和<code>String</code>都可以用来存储用户信息 ，但不同的是<code>Hash</code>可以对用户信息的每个字段单独存储；<code>String</code>存的是用户全部信息经过序列化后的字符串，如果想要修改某个用户字段必须将用户信息字符串全部查询出来，解析成相应的用户信息对象，修改完后在序列化成字符串存入。而 <code>hash</code> 可以只对某个字段修改，从而节约网络流量，不过<code>hash</code>内存占用要大于 <code>String</code> ，这是 <code>hash</code> 的缺点。</p>
<h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>购物车：<code>hset [key] [field] [value]</code> 命令， 可以实现以<code>用户Id</code>，商品Id为<code>field</code>，商品数量为<code>value</code>，恰好构成了购物车的3个要素。</li>
<li>存储对象：hash类型的<code>(key, field, value)</code>的结构与对象的<code>(对象id, 属性, 值)</code>的结构相似，也可以用来存储对象。</li>
</ul>
<h3 id="hash常用的操作命令："><a href="#hash常用的操作命令：" class="headerlink" title="hash常用的操作命令："></a>hash常用的操作命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset  [key]  [field] [value]      新建字段信息</span><br><span class="line"></span><br><span class="line">hget  [key]  [field]              获取字段信息</span><br><span class="line"></span><br><span class="line">hdel [key] [field]                删除字段</span><br><span class="line"></span><br><span class="line">hlen  [key]                       保存的字段个数</span><br><span class="line"></span><br><span class="line">hgetall  [key]        获取指定key 字典里的所有字段和值 （字段信息过多,会导致慢查询 慎用：亲身经历 曾经用过这个这个指令导致线上服务故障）</span><br><span class="line"></span><br><span class="line">hmset  [key] [field1] [value1] [field2] [value2] ......   批量创建</span><br><span class="line"></span><br><span class="line">hincr  [key] [field]              对字段值自增</span><br><span class="line"></span><br><span class="line">hincrby [key] [field] [number]    对字段值增加number</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h2><p><code>Redis</code> 中的 <code>set</code> 和<code>Java</code>中的 <code>HashSet</code> 有些类似，它内部的键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值 NULL。当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。</p>
<h3 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>好友、关注、粉丝、感兴趣的人集合：<ol>
<li>sinter命令可以获得A和B两个用户的共同好友；</li>
<li>sismember命令可以判断A是否是B的好友；</li>
<li>scard命令可以获取好友数量；</li>
<li>关注时，smove命令可以将B从A的粉丝集合转移到A的好友集合</li>
</ol>
</li>
<li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而srandmember命令则可以从中随机获取几个。</li>
<li>存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。</li>
</ul>
<h3 id="set的常用命令："><a href="#set的常用命令：" class="headerlink" title="set的常用命令："></a>set的常用命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd  [key]  [value]      向指定key的set中添加元素</span><br><span class="line"></span><br><span class="line">smembers [key]            获取指定key 集合中的所有元素</span><br><span class="line"></span><br><span class="line">sismember [key] [value]   判断集合中是否存在某个value</span><br><span class="line"></span><br><span class="line">scard [key]               获取集合的长度</span><br><span class="line"></span><br><span class="line">spop  [key]               弹出一个元素</span><br><span class="line"></span><br><span class="line">srem [key] [value]        删除指定元素</span><br></pre></td></tr></table></figure>

<h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h2><p><code>zset</code>也叫<code>SortedSet</code>一方面它是个 <code>set</code> ，保证了内部 <code>value</code> 的唯一性，另方面它可以给每个 <code>value</code> 赋予一个<code>score</code>，代表这个<code>value</code>的排序权重。它的内部实现用的是一种叫作“跳跃列表”的数据结构。</p>
<h3 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li><code>zset</code> 可以用做排行榜，但是和<code>list</code>不同的是<code>zset</code>它能够实现动态的排序，例如： 可以用来存储粉丝列表，<code>value</code> 值是粉丝的用户 ID，<code>score</code> 是关注时间，我们可以对粉丝列表按关注时间进行排序。</li>
<li><code>zset</code> 还可以用来存储学生的成绩， <code>value</code> 值是学生的 ID, <code>score</code> 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。</li>
</ul>
<h3 id="zset有序集合的常用操作命令："><a href="#zset有序集合的常用操作命令：" class="headerlink" title="zset有序集合的常用操作命令："></a>zset有序集合的常用操作命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd [key] [score] [value]              向指定key的集合中增加元素</span><br><span class="line"></span><br><span class="line">zrange [key] [start_index] [end_index]  获取下标范围内的元素列表，按score 排序输出</span><br><span class="line"></span><br><span class="line">zrevrange [key] [start_index] [end_index]  获取范围内的元素列表 ，按score排序 逆序输出</span><br><span class="line"></span><br><span class="line">zcard [key]                             获取集合列表的元素个数</span><br><span class="line"></span><br><span class="line">zrank [key] [value]  获                 取元素再集合中的排名</span><br><span class="line"></span><br><span class="line">zrangebyscore [key] [score1] [score2]   输出score范围内的元素列表</span><br><span class="line"></span><br><span class="line">zrem [key] [value]                      删除元素</span><br><span class="line"></span><br><span class="line">zscore [key] [value]                    获取元素的score</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完结</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-2天学会sql直播课学习笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-2%E5%A4%A9%E5%AD%A6%E4%BC%9Asql%E7%9B%B4%E6%92%AD%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记（1）：组件</title>
    <url>/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>vue3 已经发布到 3.2 版本了，快来一起学习一下吧！<br>不过因为 Vue3 已经通过 ts 进行重写了，所以在学习 vue3 之前最好还是先学习一下 ts 的基本使用哦！</p>
<span id="more"></span>

<h1 id="组件定义"><a href="#组件定义" class="headerlink" title="组件定义"></a>组件定义</h1><p>在 vue3 中，定义组件主要是通过：<code>defineComponent</code>来定义，而不能向 vue2 一样直接<code>export</code>导出。</p>
<p>基本用法是先从 vue 依赖导入<code>defineComponent</code>函数，然后再<code>export default defineComponent</code>导出该组件，看起来就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="title class_">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="defineComponent-讲解"><a href="#defineComponent-讲解" class="headerlink" title="defineComponent 讲解"></a>defineComponent 讲解</h2><!-- 在 vscode 或者其他 ide 按住 ctrl 点击`defineComponent`函数跳转到依赖可以查看`defineComponent`的定义。
可以看到`defineComponent`一共有四种定义，它可以接收不同的参数类型，对应这四种不同的定义。 -->

<p>下载 vue 官方的 vue-next 仓库，查看相关的源码，先看一下 DefineComponent 类型：</p>
<figure class="highlight ts"><figcaption><span>package/runtime-core/src/apiDefineComponent.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">DefineComponent</span>&lt;</span><br><span class="line">  <span class="title class_">PropsOrPropOptions</span> = &#123;&#125;, <span class="comment">// 定义props</span></span><br><span class="line">  <span class="title class_">RawBindings</span> = &#123;&#125;, <span class="comment">// 如果组件setup函数里返回的是对象，那么该对象的属性将会记录在这路</span></span><br><span class="line">  D = &#123;&#125;, <span class="comment">// 组件的data定义</span></span><br><span class="line">  C <span class="keyword">extends</span> <span class="title class_">ComputedOptions</span> = <span class="title class_">ComputedOptions</span>, <span class="comment">// 组件的computed定义</span></span><br><span class="line">  M <span class="keyword">extends</span> <span class="title class_">MethodOptions</span> = <span class="title class_">MethodOptions</span>, <span class="comment">// 组件的methods定义</span></span><br><span class="line">  <span class="title class_">Mixin</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>, <span class="comment">// 组件的mixin定义</span></span><br><span class="line">  <span class="title class_">Extends</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>, <span class="comment">// 组件的extends定义</span></span><br><span class="line">  E <span class="keyword">extends</span> <span class="title class_">EmitsOptions</span> = &#123;&#125;, <span class="comment">// 如果组件需要emit一些事件的话，记录在这里</span></span><br><span class="line">  <span class="variable constant_">EE</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span>,</span><br><span class="line">  <span class="variable constant_">PP</span> = <span class="title class_">PublicProps</span>,</span><br><span class="line">  <span class="title class_">Props</span> = <span class="title class_">Readonly</span>&lt;</span><br><span class="line">    <span class="title class_">PropsOrPropOptions</span> <span class="keyword">extends</span> <span class="title class_">ComponentPropsOptions</span></span><br><span class="line">      ? <span class="title class_">ExtractPropTypes</span>&lt;<span class="title class_">PropsOrPropOptions</span>&gt;</span><br><span class="line">      : <span class="title class_">PropsOrPropOptions</span></span><br><span class="line">  &gt; &amp;</span><br><span class="line">    (&#123;&#125; <span class="keyword">extends</span> E ? &#123;&#125; : <span class="title class_">EmitsToProps</span>&lt;E&gt;),</span><br><span class="line">  <span class="title class_">Defaults</span> = <span class="title class_">ExtractDefaultPropTypes</span>&lt;<span class="title class_">PropsOrPropOptions</span>&gt;</span><br><span class="line">&gt; = <span class="title class_">ComponentPublicInstanceConstructor</span>&lt;</span><br><span class="line">  <span class="comment">// 可以看到返回类型是一个ComponentPublicInstanceConstructor</span></span><br><span class="line">  <span class="title class_">CreateComponentPublicInstance</span>&lt;</span><br><span class="line">    <span class="title class_">Props</span>,</span><br><span class="line">    <span class="title class_">RawBindings</span>,</span><br><span class="line">    D,</span><br><span class="line">    C,</span><br><span class="line">    M,</span><br><span class="line">    <span class="title class_">Mixin</span>,</span><br><span class="line">    <span class="title class_">Extends</span>,</span><br><span class="line">    E,</span><br><span class="line">    <span class="variable constant_">PP</span> &amp; <span class="title class_">Props</span>,</span><br><span class="line">    <span class="title class_">Defaults</span>,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &gt; &amp;</span><br><span class="line">    <span class="title class_">Props</span></span><br><span class="line">&gt; &amp;</span><br><span class="line">  <span class="title class_">ComponentOptionsBase</span>&lt;</span><br><span class="line">    <span class="title class_">Props</span>,</span><br><span class="line">    <span class="title class_">RawBindings</span>,</span><br><span class="line">    D,</span><br><span class="line">    C,</span><br><span class="line">    M,</span><br><span class="line">    <span class="title class_">Mixin</span>,</span><br><span class="line">    <span class="title class_">Extends</span>,</span><br><span class="line">    E,</span><br><span class="line">    <span class="variable constant_">EE</span>,</span><br><span class="line">    <span class="title class_">Defaults</span></span><br><span class="line">  &gt; &amp;</span><br><span class="line">  <span class="variable constant_">PP</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>建议动手下载一下源码，并去查看一下上面提到的一些类型，比如：<code>ComputedOptions</code>、<code>ComponentPublicInstanceConstructor</code>等等，想想为什么要这么写，想不到其实也没关系，其实这就是为了符合 TypeScript 的类型声明的理念。</p>
<p>通过查看<code>ComponentPublicInstanceConstructor</code>层层类型定义的嵌套，可以找到最终的一个类型定义</p>
<figure class="highlight ts"><figcaption><span>package/runtime-core/src/componentPublicInstance.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// public properties exposed on the proxy, which is used as the render context</span></span><br><span class="line"><span class="comment">// in templates (as `this` in the render option)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ComponentPublicInstance</span>&lt;</span><br><span class="line">  P = &#123;&#125;, <span class="comment">// props type extracted from props option</span></span><br><span class="line">  B = &#123;&#125;, <span class="comment">// raw bindings returned from setup()</span></span><br><span class="line">  D = &#123;&#125;, <span class="comment">// return from data()</span></span><br><span class="line">  C <span class="keyword">extends</span> <span class="title class_">ComputedOptions</span> = &#123;&#125;,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="title class_">MethodOptions</span> = &#123;&#125;,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="title class_">EmitsOptions</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">PublicProps</span> = P,</span><br><span class="line">  <span class="title class_">Defaults</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">MakeDefaultsOptional</span> <span class="keyword">extends</span> <span class="built_in">boolean</span> = <span class="literal">false</span>,</span><br><span class="line">  <span class="title class_">Options</span> = <span class="title class_">ComponentOptionsBase</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>, <span class="built_in">any</span>&gt;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  <span class="attr">$</span>: <span class="title class_">ComponentInternalInstance</span></span><br><span class="line">  <span class="attr">$data</span>: D</span><br><span class="line">  <span class="attr">$props</span>: <span class="title class_">MakeDefaultsOptional</span> <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="title class_">Partial</span>&lt;<span class="title class_">Defaults</span>&gt; &amp; <span class="title class_">Omit</span>&lt;P &amp; <span class="title class_">PublicProps</span>, keyof <span class="title class_">Defaults</span>&gt;</span><br><span class="line">    : P &amp; <span class="title class_">PublicProps</span></span><br><span class="line">  <span class="attr">$attrs</span>: <span class="title class_">Data</span></span><br><span class="line">  <span class="attr">$refs</span>: <span class="title class_">Data</span></span><br><span class="line">  <span class="attr">$slots</span>: <span class="title class_">Slots</span></span><br><span class="line">  <span class="attr">$root</span>: <span class="title class_">ComponentPublicInstance</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">$parent</span>: <span class="title class_">ComponentPublicInstance</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">$emit</span>: <span class="title class_">EmitFn</span>&lt;E&gt;</span><br><span class="line">  <span class="attr">$el</span>: <span class="built_in">any</span></span><br><span class="line">  <span class="attr">$options</span>: <span class="title class_">Options</span> &amp; <span class="title class_">MergedComponentOptionsOverride</span></span><br><span class="line">  <span class="attr">$forceUpdate</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">$nextTick</span>: <span class="keyword">typeof</span> nextTick</span><br><span class="line">  $watch(</span><br><span class="line">    <span class="attr">source</span>: <span class="built_in">string</span> | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: <span class="title class_">WatchOptions</span></span><br><span class="line">  ): <span class="title class_">WatchStopHandle</span></span><br><span class="line">&#125; &amp; P &amp;</span><br><span class="line">  <span class="title class_">ShallowUnwrapRef</span>&lt;B&gt; &amp;</span><br><span class="line">  <span class="title class_">UnwrapNestedRefs</span>&lt;D&gt; &amp;</span><br><span class="line">  <span class="title class_">ExtractComputedReturns</span>&lt;C&gt; &amp;</span><br><span class="line">  M &amp;</span><br><span class="line">  <span class="title class_">ComponentCustomProperties</span></span><br></pre></td></tr></table></figure>

<p>可以看到上面熟悉的：<code>$data</code>、<code>$refs</code>、<code>$parent</code>等等，这就是最终生成的组件的定义。</p>
<p>继续看主要内容：<code>defineComponent</code>，下面是四种不同的<code>defineComponent</code>函数的重载</p>
<figure class="highlight ts"><figcaption><span>package/runtime-core/src/apiDefineComponent.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// defineComponent is a utility that is primarily used for type inference</span></span><br><span class="line"><span class="comment">// when declaring components. Type inference is provided in the component</span></span><br><span class="line"><span class="comment">// options (provided as the argument). The returned value has artificial types</span></span><br><span class="line"><span class="comment">// for TSX / manual render function / IDE support.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload 1: direct setup function</span></span><br><span class="line"><span class="comment">// (uses user defined props interface)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineComponent&lt;<span class="title class_">Props</span>, <span class="title class_">RawBindings</span> = <span class="built_in">object</span>&gt;(</span><br><span class="line">  <span class="attr">setup</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    props: Readonly&lt;Props&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx: SetupContext</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="title class_">RawBindings</span> | <span class="title class_">RenderFunction</span></span><br><span class="line">): <span class="title class_">DefineComponent</span>&lt;<span class="title class_">Props</span>, <span class="title class_">RawBindings</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种是接收一个setup函数，其中props和ctx作为参数的入参。但是如果用过vue2的props就知道了，props需要通过一个对象去声明，而不能只用ts去声明，所以这种方法去使用的话会有问题，不推荐这样使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload 2: object format with no props</span></span><br><span class="line"><span class="comment">// (uses user defined props interface)</span></span><br><span class="line"><span class="comment">// return type is for Vetur and TSX support</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineComponent&lt;</span><br><span class="line">  <span class="title class_">Props</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">RawBindings</span> = &#123;&#125;,</span><br><span class="line">  D = &#123;&#125;,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="title class_">ComputedOptions</span> = &#123;&#125;,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="title class_">MethodOptions</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">Mixin</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  <span class="title class_">Extends</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="title class_">EmitsOptions</span> = <span class="title class_">EmitsOptions</span>,</span><br><span class="line">  <span class="variable constant_">EE</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">ComponentOptionsWithoutProps</span>&lt;</span><br><span class="line">    <span class="title class_">Props</span>,</span><br><span class="line">    <span class="title class_">RawBindings</span>,</span><br><span class="line">    D,</span><br><span class="line">    C,</span><br><span class="line">    M,</span><br><span class="line">    <span class="title class_">Mixin</span>,</span><br><span class="line">    <span class="title class_">Extends</span>,</span><br><span class="line">    E,</span><br><span class="line">    <span class="variable constant_">EE</span></span><br><span class="line">  &gt;</span><br><span class="line">): <span class="title class_">DefineComponent</span>&lt;<span class="title class_">Props</span>, <span class="title class_">RawBindings</span>, D, C, M, <span class="title class_">Mixin</span>, <span class="title class_">Extends</span>, E, <span class="variable constant_">EE</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：通过传入一个对象去定义，不传入props，只在对象里进行定义props的接口。但实际上也不推荐。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload 3: object format with array props declaration</span></span><br><span class="line"><span class="comment">// props inferred as &#123; [key in PropNames]?: any &#125;</span></span><br><span class="line"><span class="comment">// return type is for Vetur and TSX support</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineComponent&lt;</span><br><span class="line">  <span class="title class_">PropNames</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">RawBindings</span>,</span><br><span class="line">  D,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="title class_">ComputedOptions</span> = &#123;&#125;,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="title class_">MethodOptions</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">Mixin</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  <span class="title class_">Extends</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="title class_">EmitsOptions</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  <span class="variable constant_">EE</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">ComponentOptionsWithArrayProps</span>&lt;</span><br><span class="line">    <span class="title class_">PropNames</span>,</span><br><span class="line">    <span class="title class_">RawBindings</span>,</span><br><span class="line">    D,</span><br><span class="line">    C,</span><br><span class="line">    M,</span><br><span class="line">    <span class="title class_">Mixin</span>,</span><br><span class="line">    <span class="title class_">Extends</span>,</span><br><span class="line">    E,</span><br><span class="line">    <span class="variable constant_">EE</span></span><br><span class="line">  &gt;</span><br><span class="line">): <span class="title class_">DefineComponent</span>&lt;</span><br><span class="line">  <span class="title class_">Readonly</span>&lt;&#123; [key <span class="keyword">in</span> <span class="title class_">PropNames</span>]?: <span class="built_in">any</span> &#125;&gt;,</span><br><span class="line">  <span class="title class_">RawBindings</span>,</span><br><span class="line">  D,</span><br><span class="line">  C,</span><br><span class="line">  M,</span><br><span class="line">  <span class="title class_">Mixin</span>,</span><br><span class="line">  <span class="title class_">Extends</span>,</span><br><span class="line">  E,</span><br><span class="line">  <span class="variable constant_">EE</span></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种：和第二种类似，但是对象里的props是一个列表，也就是: props: [&#x27;name&#x27;, &#x27;age&#x27;...] 这种写法，但是可以看到官方解释，这种方式得到的prop都是any类型，因为不推荐在ts里使用any类型，所以这种方式也不推荐使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload 4: object format with object props declaration</span></span><br><span class="line"><span class="comment">// see `ExtractPropTypes` in ./componentProps.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineComponent&lt;</span><br><span class="line">  <span class="comment">// the Readonly constraint allows TS to treat the type of &#123; required: true &#125;</span></span><br><span class="line">  <span class="comment">// as constant instead of boolean.</span></span><br><span class="line">  <span class="title class_">PropsOptions</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="title class_">ComponentPropsOptions</span>&gt;,</span><br><span class="line">  <span class="title class_">RawBindings</span>,</span><br><span class="line">  D,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="title class_">ComputedOptions</span> = &#123;&#125;,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="title class_">MethodOptions</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">Mixin</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  <span class="title class_">Extends</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="title class_">EmitsOptions</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  <span class="variable constant_">EE</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">ComponentOptionsWithObjectProps</span>&lt;</span><br><span class="line">    <span class="title class_">PropsOptions</span>,</span><br><span class="line">    <span class="title class_">RawBindings</span>,</span><br><span class="line">    D,</span><br><span class="line">    C,</span><br><span class="line">    M,</span><br><span class="line">    <span class="title class_">Mixin</span>,</span><br><span class="line">    <span class="title class_">Extends</span>,</span><br><span class="line">    E,</span><br><span class="line">    <span class="variable constant_">EE</span></span><br><span class="line">  &gt;</span><br><span class="line">): <span class="title class_">DefineComponent</span>&lt;<span class="title class_">PropsOptions</span>, <span class="title class_">RawBindings</span>, D, C, M, <span class="title class_">Mixin</span>, <span class="title class_">Extends</span>, E, <span class="variable constant_">EE</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用ts去编写项目，最推荐使用这种方法，在options里定义props的定义。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implementation, close to no-op</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineComponent</span>(<span class="params">options: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isFunction</span>(options) ? &#123; <span class="attr">setup</span>: options, <span class="attr">name</span>: options.<span class="property">name</span> &#125; : options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一行才是真正去实现defineComponent函数，如果传入一个函数，那么返回一个包装过的对象，如果是传入一个对象则直接返回该对象。</span></span><br></pre></td></tr></table></figure>

<p>可以看到真正定义 <code>defineComponent</code> 函数的代码只有三行，其他的都是类型定义。</p>
<h2 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h2><p>既然上面了解了<code>defineComponent</code>，那么现在尝试去使用一下这个函数，这是一个非常基础的组件的定义：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, <span class="title class_">PropType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="built_in">number</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的<code>String</code>，<code>Number</code>这些其实只是一个类，如果要符合 ts，最正统的应该加上<code>as</code>将该值视为 xxx 类型。如果有些场景不加 as 的话：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">config</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 vscode 编辑器下，把鼠标放到：<code>this.config</code>上，可以看到 vscode 提示：<code>(property) config?: Record&lt;string, any&gt; | undefined</code></p>
<p>说明如果不定义类型的话那么 config 的值将会是 any 类型。对于 ts 来说这样可以用，但是 any 对于我们来说始终是不好的东西。我们应该这样去做：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="title class_">Config</span>&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">config</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样我们去看 config 的类型：<code>(property) config?: Config | undefined</code>。<br>可以看到该类型还有可能是<code>undefined</code>，如果不能让他为<code>undefined</code>只需要加上<code>required</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span> <span class="keyword">as</span> <span class="title class_">PropType</span>&lt;<span class="title class_">Config</span>&gt;,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终我们看到 config 类型是：<code>(property) config: Config</code>，因为声明了该 prop 是必传的，所以他肯定是有值的，那就必不可能是<code>undefined</code>。<br>如果上面不设置，直接调用<code>this.config.name</code>那么 TS 编译器则会报错：<code>Object is possibly &#39;undefined&#39;</code>。如果没有 required 去设置的话，你可能还要使用<code>if (this.config)</code>去调用<code>this.config.name</code>，那么如果有 required 的话将不再担心这些，可以直接去调用，这就是 ts 的好处。这样就能提高我们写代码的自信，因为 ts 没给我们报错，那么我们的代码出错的几率就会降低。</p>
<p>上面就是组件相关的一些内容，下一节开始将深入讲解 props。</p>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记（3）：h和createVNode函数</title>
    <url>/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9Ah%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>这一节来讲解 h 函数的使用</p>
<span id="more"></span>

<h1 id="先补充一点组件相关的知识"><a href="#先补充一点组件相关的知识" class="headerlink" title="先补充一点组件相关的知识"></a>先补充一点组件相关的知识</h1><p>首先<code>.vue</code>不是前端可以使用的一种格式，需要打包工具将这些文件编译打包成 js 文件。<br>而且比如像：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Vue logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;Welcome to Your Vue.js + TypeScript App&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码，最后也不会是一个 html 格式的代码，而是一种以 h 函数描述的代码。</p>
<h1 id="h-函数的使用"><a href="#h-函数的使用" class="headerlink" title="h 函数的使用"></a>h 函数的使用</h1><p>首先 h 函数是用来定义 DOM 节点的函数。上面的 html 标签可以表示成这样：</p>
<figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, h, defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// import App from &#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">      <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: <span class="string">&#x27;./assets/logo.png&#x27;</span> &#125;),</span><br><span class="line">      <span class="title function_">h</span>(<span class="title class_">HelloWorld</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Welcome to Your Vue.js + TypeScript App&#x27;</span> &#125;),</span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到页面成功渲染出来，但是图片并没有正常显示。这是因为写<code>.vue</code>文件时，写在 template 里的 src 会通过打包工具（比如 vue-loader）去找到正确的目录。可以改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="built_in">require</span>(<span class="string">&#x27;./assets/logo.png&#x27;</span>) <span class="comment">// eslint-disable-line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">      <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: img &#125;),</span><br><span class="line">      <span class="title function_">h</span>(<span class="title class_">HelloWorld</span>, &#123; <span class="attr">msg</span>: <span class="string">&#x27;Welcome to Your Vue.js + TypeScript App&#x27;</span> &#125;),</span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>就能看到图片正常显示了，加<code>// eslint-disable-line</code>的原因是 eslint 默认禁止使用 required，这里为了演示先关掉这一行的 eslint 检查。<br>至于样式问题，可以写一个 css 文件并引入即可，因为上面的写法是为了让你更好的了解 vue 的 sfc 也就是 vue 文件是如何编译打包的。<br>如果以后写 vue 文件时，看到某个 dom 结构你能快速的想出他是如果跟 h 函数这种结构对应的，那将对对你排查问题又非常大的好处。</p>
<h1 id="去看一下-h-函数的源码"><a href="#去看一下-h-函数的源码" class="headerlink" title="去看一下 h 函数的源码"></a>去看一下 h 函数的源码</h1><p>我们直接去 vue-next 源码看 h 函数的实现（implementation）：</p>
<figure class="highlight ts"><figcaption><span>package/runtime-core/src/h.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Actual implementation</span></span><br><span class="line"><span class="comment">// 可以看到h函数先接收一个type，第二个参数是props或者children，第三个是children。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">any</span>, propsOrChildren?: <span class="built_in">any</span>, children?: <span class="built_in">any</span></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = <span class="variable language_">arguments</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (l === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 当长度为2的时候，说明第二个是参数或者是children</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(propsOrChildren) &amp;&amp; !<span class="title function_">isArray</span>(propsOrChildren)) &#123;</span><br><span class="line">      <span class="comment">// single vnode without props</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isVNode</span>(propsOrChildren)) &#123;</span><br><span class="line">        <span class="comment">// 传入的是VNode，说明是children</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createVNode</span>(<span class="keyword">type</span>, <span class="literal">null</span>, [propsOrChildren])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不是children，那就是props</span></span><br><span class="line">      <span class="comment">// props without children</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createVNode</span>(<span class="keyword">type</span>, propsOrChildren)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 是数组，说明是children</span></span><br><span class="line">      <span class="comment">// omit props</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createVNode</span>(<span class="keyword">type</span>, <span class="literal">null</span>, propsOrChildren)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">// 长度大于3的话，取出props之后的children参数</span></span><br><span class="line">      children = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">2</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l === <span class="number">3</span> &amp;&amp; <span class="title function_">isVNode</span>(children)) &#123;</span><br><span class="line">      children = [children]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createVNode</span>(<span class="keyword">type</span>, propsOrChildren, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 h 函数实际上就是用来返回一个 VNode 的工具，就是通过各种规则的判断，将你写的不那么规范的代码变得更加规范一点。</p>
<h1 id="createVNode"><a href="#createVNode" class="headerlink" title="createVNode"></a>createVNode</h1><p>上面的代码我们可以直接改成<code>createVNode</code>的形式去写 dom 结构:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createVNode</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">      <span class="title function_">createVNode</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: img &#125;),</span><br><span class="line">      <span class="title function_">createVNode</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;Welcome to Your Vue.js + TypeScript App&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样就更符合 template 解析后的结构了。</p>
<h2 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h2><p>直接去看 vnode 相关的源码：</p>
<figure class="highlight ts"><figcaption><span>package/runtime-core/src/vnode.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createVNode = (</span><br><span class="line">  __DEV__ ? createVNodeWithArgsTransform : _createVNode</span><br><span class="line">) <span class="keyword">as</span> <span class="keyword">typeof</span> _createVNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到createVNode是_createVNode的一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_createVNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: VNodeTypes | ClassComponent | <span class="keyword">typeof</span> NULL_DYNAMIC_COMPONENT,</span></span><br><span class="line"><span class="params">  props: (Data &amp; VNodeProps) | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  children: <span class="built_in">unknown</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  patchFlag: <span class="built_in">number</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  dynamicProps: <span class="built_in">string</span>[] | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isBlockNode = <span class="literal">false</span></span></span><br><span class="line"><span class="params">  <span class="comment">// patchFlag、dynamicProps、isBlockNode是优化相关的参数</span></span></span><br><span class="line"><span class="params">  <span class="comment">// 在使用.vue文件时，打包工具将会为我们加上这些内容</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">type</span> || <span class="keyword">type</span> === <span class="variable constant_">NULL_DYNAMIC_COMPONENT</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Invalid vnode type when creating vnode: <span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> = <span class="title class_">Comment</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createBaseVNode</span>(</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    isBlockNode,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后的最后，虽然可以直接用 createVNode，但是官方既然提供了 h 函数，那么这个函数肯定是对我们有很多好处的，所以尽量还是用 h 函数而不是 createVNode 函数。</p>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 语法速成手册</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>本文针对关系型数据库的一般语法。限于篇幅，本文侧重说明用法，不会展开讲解特性、原理。</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h2><p><strong>数据库（database）</strong> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</p>
<p><strong>数据表（table）</strong> - 某种特定类型数据的结构化清单。</p>
<p><strong>模式（schema）</strong> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</p>
<p><strong>列（column）</strong> - 表中的一个字段。所有表都是由一个或多个列组成的。</p>
<p><strong>行（row）</strong> - 表中的一个记录。</p>
<p><strong>主键（primary key）</strong> - 一列（或一组列），其值能够唯一标识表中每一行。</p>
<h2 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h2><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL&#x2F;SQL、Transact-SQL 等。</p>
<h3 id="SQL-语法结构"><a href="#SQL-语法结构" class="headerlink" title="SQL 语法结构"></a>SQL 语法结构</h3><p>SQL 语法结构包括：</p>
<ul>
<li><strong>子句</strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>
<li><strong>表达式</strong> - 可以产生任何标量值，或由列和行的数据库表</li>
<li><strong>谓词</strong> - 给需要评估的 SQL 三值逻辑（3VL）（true&#x2F;false&#x2F;unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>
<li><strong>查询</strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>
<li><strong>语句</strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>
</ul>
<h3 id="SQL-语法要点"><a href="#SQL-语法要点" class="headerlink" title="SQL 语法要点"></a>SQL 语法要点</h3><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。</p>
<p>例如：SELECT 与 select 、Select 是相同的。</p>
<p>多条 SQL 语句必须以分号（;）分隔。</p>
<p>处理 SQL 语句时，所有空格都被忽略。SQL 语句可以写成一行，也可以分写为多行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一行 SQL 语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多行 SQL 语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>SQL 支持三种注释</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 注释<span class="number">1</span></span><br><span class="line"><span class="comment">-- 注释2</span></span><br><span class="line"><span class="comment">/* 注释3 */</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL语言的分类"><a href="#SQL语言的分类" class="headerlink" title="SQL语言的分类"></a>SQL语言的分类</h3><h4 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h4><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>
<p>DDL 的主要功能是定义数据库对象。</p>
<p>DDL 的核心指令是 CREATE、ALTER、DROP。</p>
<h4 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h4><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>
<p>DML 的主要功能是 访问数据，因此其语法都是以读写数据库为主。</p>
<p>DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p>
<h4 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h4><p>事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>
<p>TCL 的核心指令是 COMMIT、ROLLBACK。</p>
<h4 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h4><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>
<p>DCL 的核心指令是 GRANT、REVOKE。</p>
<p>DCL 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。</p>
<blockquote>
<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>
</blockquote>
<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>INSERT INTO 语句用于向表中插入新记录。</p>
<p>插入完整的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>插入行的一部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username, password, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>插入查询出来的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username)</span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure>

<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>UPDATE 语句用于更新表中的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>DELETE 语句用于删除表中的记录。</li>
<li>TRUNCATE TABLE 可以清空表，也就是删除所有行。</li>
</ul>
<p>删除表中的指定数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>清空表中的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><ul>
<li>SELECT 语句用于从数据库中查询数据。</li>
<li>DISTINCT 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>
<li>LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。<ul>
<li>ASC ：升序（默认）</li>
<li>DESC ：降序</li>
</ul>
</li>
</ul>
<p>查询单列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p>查询多列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p>查询所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ELECT <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p>查询不同的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">vend_id <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p>限制查询结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询是嵌套在较大查询中的 SQL 查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。</p>
<ul>
<li>子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中。</li>
<li>子查询通常会在另一个 SELECT 语句的 WHERE 子句中添加。</li>
<li>您可以使用比较运算符，如 &gt;，&lt;，或 &#x3D;。比较运算符也可以是多行运算符，如 IN，ANY 或 ALL。</li>
<li>子查询必须被圆括号 () 括起来。</li>
<li>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/1.webp" class=""></li>
</ul>
<p>子查询的子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                    <span class="keyword">FROM</span> orders</span><br><span class="line">                    <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                        <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                        <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><ul>
<li>WHERE 子句用于过滤记录，即缩小访问数据的范围。</li>
<li>WHERE 后跟一个返回 true 或 false 的条件。</li>
<li>WHERE 可以与 SELECT，UPDATE 和 DELETE 一起使用。</li>
<li>可以在 WHERE 子句中使用的操作符<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/2.webp" class=""></li>
</ul>
<p>SELECT 语句中的 WHERE 子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>UPDATE 语句中的 WHERE 子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Jack Jones&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>DELETE 语句中的 WHERE 子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="IN-和-BETWEEN"><a href="#IN-和-BETWEEN" class="headerlink" title="IN 和 BETWEEN"></a>IN 和 BETWEEN</h2><ul>
<li>IN 操作符在 WHERE 子句中使用，作用是在指定的几个特定值中任选一个值。</li>
<li>BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于某个范围内的值。</li>
</ul>
<p>IN 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>BETWEEN 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="AND、OR、NOT"><a href="#AND、OR、NOT" class="headerlink" title="AND、OR、NOT"></a>AND、OR、NOT</h2><ul>
<li>AND、OR、NOT 是用于对过滤条件的逻辑处理指令。</li>
<li>AND 优先级高于 OR，为了明确处理顺序，可以使用 ()。</li>
<li>AND 操作符表示左右条件都要满足。</li>
<li>OR 操作符表示左右条件满足任意一个即可。</li>
<li>NOT 操作符用于否定一个条件。</li>
</ul>
<p>AND 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>OR 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>NOT 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h2><ul>
<li>LIKE 操作符在 WHERE 子句中使用，作用是确定字符串是否匹配模式。</li>
<li>只有字段是文本值时才使用 LIKE。</li>
<li>LIKE 支持两个通配符匹配选项：% 和 _。</li>
<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>
<li>% 表示任何字符出现任意次数。</li>
<li>_ 表示任何字符出现一次。</li>
</ul>
<p>% 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>_ 示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="CASE-WHEN语句"><a href="#CASE-WHEN语句" class="headerlink" title="CASE WHEN语句"></a>CASE WHEN语句</h2><p>case的第一个作用是判断的同时改变其值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username,</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;管理员&#x27;</span></span><br><span class="line">     <span class="keyword">when</span> <span class="string">&#x27;user&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;普通用户&#x27;</span></span><br><span class="line">     <span class="keyword">else</span> <span class="string">&#x27;其他用户&#x27;</span> <span class="keyword">end</span> role</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  id, </span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">             <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">END</span> sex,</span><br><span class="line">        username</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p>当然还可以使用大于小于等的判断符，</p>
<h1 id="连接和组合"><a href="#连接和组合" class="headerlink" title="连接和组合"></a>连接和组合</h1><h2 id="连接（JOIN）"><a href="#连接（JOIN）" class="headerlink" title="连接（JOIN）"></a>连接（JOIN）</h2><ul>
<li>如果一个 JOIN 至少有一个公共字段并且它们之间存在关系，则该 JOIN 可以在两个或多个表上工作。</li>
<li>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</li>
<li>JOIN 保持基表（结构和数据）不变。</li>
<li>JOIN 有两种连接类型：内连接和外连接。</li>
<li>内连接又称等值连接，使用 INNER JOIN 关键字。在没有条件语句的情况下返回笛卡尔积。<ul>
<li>自连接可以看成内连接的一种，只是连接的表是自身而已。</li>
</ul>
</li>
<li>自然连接是把同名列通过 &#x3D; 测试连接起来的，同名列可以有多个。</li>
<li>内连接 vs 自然连接<ul>
<li>内连接提供连接的列，而自然连接自动连接所有同名列。</li>
</ul>
</li>
<li>外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。<ul>
<li>左外连接就是保留左表没有关联的行。</li>
<li>右外连接就是保留右表没有关联的行。</li>
</ul>
</li>
<li>连接 vs 子查询<ul>
<li>连接可以替换子查询，并且比子查询的效率一般会更快。</li>
</ul>
</li>
</ul>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/3.webp" class="">

<p>内连接（INNER JOIN）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure>
<p>自连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers c1, customers c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name <span class="operator">=</span> c2.cust_name</span><br><span class="line"><span class="keyword">AND</span> c2.cust_contact <span class="operator">=</span> <span class="string">&#x27;Jim Jones&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>自然连接（NATURAL JOIN）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Customers;</span><br></pre></td></tr></table></figure>
<p>左连接（LEFT JOIN）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>右连接（RIGHT JOIN）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<h2 id="组合（UNION）"><a href="#组合（UNION）" class="headerlink" title="组合（UNION）"></a>组合（UNION）</h2><ul>
<li>UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行。</li>
<li>UNION 基本规则<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
</ul>
</li>
<li>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</li>
<li>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</li>
<li>应用场景<ul>
<li>在一个查询中从不同的表返回结构数据。</li>
<li>对一个表执行多个查询，按一个查询返回数据。</li>
</ul>
</li>
</ul>
<p>组合查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;MI&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="JOIN-vs-UNION"><a href="#JOIN-vs-UNION" class="headerlink" title="JOIN vs UNION"></a>JOIN vs UNION</h2><ul>
<li>JOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同。</li>
<li>UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>🔔 <strong>注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 Mysql 的函数为例。</strong></p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/4.webp" class="">

<p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:MM:SS<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/5.webp" class="">
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> NOW();</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span><span class="number">-11</span><span class="number">-20</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/6.webp" class="">

<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SQL-%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90%E6%89%8B%E5%86%8C/7.webp" class="">

<p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure>

<h1 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h1><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><ul>
<li>ORDER BY 用于对结果集进行排序。<ul>
<li>ASC ：升序（默认）</li>
<li>DESC ：降序</li>
</ul>
</li>
<li>可以按多个列进行排序，并且为每个列指定不同的排序方式</li>
</ul>
<p>指定多个列的排序方向</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><ul>
<li>GROUP BY 子句将记录分组到汇总行中。</li>
<li>GROUP BY 为每个组返回一个记录。</li>
<li>GROUP BY 通常还涉及聚合：COUNT，MAX，SUM，AVG 等。</li>
<li>GROUP BY 可以按一列或多列进行分组。</li>
<li>GROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序。</li>
</ul>
<p>分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>
<p>分组后排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><ul>
<li>HAVING 用于对汇总的 GROUP BY 结果进行过滤。</li>
<li>HAVING 要求存在一个 GROUP BY 子句。</li>
<li>WHERE 和 HAVING 可以在相同的查询中。</li>
<li>HAVING vs WHERE<br>WHERE 和 HAVING 都是用于过滤。<br>HAVING 适用于汇总的组记录；而 WHERE 适用于单个记录。</li>
</ul>
<p>使用 WHERE 和 HAVING 过滤数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h1><p>下面为DDL语句用法</p>
<blockquote>
<p>DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）。</p>
</blockquote>
<h2 id="数据库（DATABASE）"><a href="#数据库（DATABASE）" class="headerlink" title="数据库（DATABASE）"></a>数据库（DATABASE）</h2><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE test;</span><br></pre></td></tr></table></figure>

<p>选择数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE test;</span><br></pre></td></tr></table></figure>

<h2 id="数据表（TABLE）"><a href="#数据表（TABLE）" class="headerlink" title="数据表（TABLE）"></a>数据表（TABLE）</h2><p>创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br></pre></td></tr></table></figure>
<p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE test;</span><br></pre></td></tr></table></figure>
<p>选择数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE test;</span><br></pre></td></tr></table></figure>

<h2 id="数据表（TABLE）-1"><a href="#数据表（TABLE）-1" class="headerlink" title="数据表（TABLE）"></a>数据表（TABLE）</h2><p>普通的创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  email <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>根据已有的表创建新表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vip_user <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>删除数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>修改数据表:<br>添加列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> age <span class="type">int</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>删除列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> age;</span><br></pre></td></tr></table></figure>
<p>修改列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> age tinyint;</span><br></pre></td></tr></table></figure>
<p>添加主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (id);</span><br></pre></td></tr></table></figure>
<p>删除主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<h2 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="视图（VIEW）"></a>视图（VIEW）</h2><ul>
<li>定义<ul>
<li>视图是基于 SQL 语句的结果集的可视化的表。</li>
<li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>
</ul>
</li>
<li>作用<ul>
<li>简化复杂的 SQL 操作，比如复杂的联结；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
</li>
</ul>
<p>创建视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> top_10_user_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>删除视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>

<h2 id="索引（INDEX）"><a href="#索引（INDEX）" class="headerlink" title="索引（INDEX）"></a>索引（INDEX）</h2><ul>
<li>作用<ul>
<li>通过索引可以更加快速高效地查询数据。</li>
<li>用户无法看到索引，它们只能被用来加速查询。</li>
</ul>
</li>
<li>注意<ul>
<li>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</li>
</ul>
</li>
<li>唯一索引<ul>
<li>唯一索引表明此索引的每一个索引值只对应唯一的数据记录。</li>
</ul>
</li>
</ul>
<p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br></pre></td></tr></table></figure>
<p>创建唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX user_index</span><br><span class="line">ON user (id);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><blockquote>
<p>SQL 约束用于规定表中的数据规则。</p>
</blockquote>
<ul>
<li>如果存在违反约束的数据行为，行为会被约束终止。</li>
<li>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</li>
<li>约束类型<ul>
<li>NOT NULL - 指示某列不能存储 NULL 值。</li>
<li>UNIQUE - 保证某列的每行必须有唯一的值。</li>
<li>PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li>FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li>CHECK - 保证列中的值符合指定的条件。</li>
<li>DEFAULT - 规定没有给列赋值时的默认值。</li>
</ul>
</li>
</ul>
<p>创建表时使用约束条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">  Id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增Id&#x27;</span>,</span><br><span class="line">  Username <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  Password <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  Email <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱地址&#x27;</span>,</span><br><span class="line">  Enabled TINYINT(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否有效&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (Id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h1><p>下面属于DCL语句</p>
<ul>
<li>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</li>
<li>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</li>
<li>通过 set autocommit&#x3D;0 可以取消自动提交，直到 set autocommit&#x3D;1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。</li>
<li>指令<ul>
<li>START TRANSACTION - 指令用于标记事务的起始点。</li>
<li>SAVEPOINT - 指令用于创建保留点。</li>
<li>ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。</li>
<li>COMMIT - 提交事务。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><ul>
<li>GRANT 和 REVOKE 可在几个层次上控制访问权限：<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
</li>
<li>新创建的账户没有任何权限。</li>
<li>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</li>
<li>MySQL 的账户信息保存在 mysql 这个数据库中。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可以这样查看</span></span><br><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>创建账户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>修改账户名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;newuser&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>删除账户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure>
<p>查看权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure>
<p>授予权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure>
<p>删除权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>
<p>更改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> myuser <span class="operator">=</span> <span class="string">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><ul>
<li>存储过程可以看成是对一系列 SQL 操作的批处理；</li>
<li>使用存储过程的好处<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
</li>
<li>创建存储过程<ul>
<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>
<li>包含 in、out 和 inout 三种参数。</li>
<li>给变量赋值都需要用 select into 语句。</li>
<li>每次只能给一个变量赋值，不支持集合的操作。</li>
</ul>
</li>
</ul>
<p>创建存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> `proc_adder`;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `proc_adder`(<span class="keyword">IN</span> a <span class="type">int</span>, <span class="keyword">IN</span> b <span class="type">int</span>, <span class="keyword">OUT</span> sum <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> c <span class="type">int</span>;</span><br><span class="line">    if a <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    if b <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> sum  <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>使用存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@b</span><span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">call</span> proc_adder(<span class="number">2</span>,<span class="variable">@b</span>,<span class="variable">@s</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@s</span> <span class="keyword">as</span> sum;</span><br></pre></td></tr></table></figure>

<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><ul>
<li>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。</li>
<li>在存储过程中使用游标可以对一个结果集进行移动遍历。</li>
<li>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</li>
<li>使用游标的四个步骤：<ul>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> getTotal()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建接收游标数据的变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sid <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> sname <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">-- 创建总数变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sage <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建结束标志变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">-- 创建游标</span></span><br><span class="line">    <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id,name,age <span class="keyword">from</span> cursor_table <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">30</span>;</span><br><span class="line">    <span class="comment">-- 指定游标循环结束时的返回值</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">SET</span> total <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> cur;</span><br><span class="line">    <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    WHILE(<span class="keyword">NOT</span> done)</span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">SET</span> total <span class="operator">=</span> total <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CLOSE</span> cur;</span><br><span class="line">    <span class="keyword">SELECT</span> total;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> getTotal();</span><br></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><blockquote>
<p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p>
</blockquote>
<p>可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p>
<h2 id="BEGIN-和-END"><a href="#BEGIN-和-END" class="headerlink" title="BEGIN 和 END"></a>BEGIN 和 END</h2><p>当触发器的触发条件满足时，将会执行 BEGIN 和 END 之间的触发器执行动作。</p>
<blockquote>
<p>🔔 注意：在 MySQL 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。<br> 这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiter。new_delemiter 可以设为 1 个或多个长度的符号，默认的是分号 ;，我们可以把它修改为其他符号，如 $ - DELIMITER $ 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 $，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>
</blockquote>
<h2 id="NEW-和-OLD"><a href="#NEW-和-OLD" class="headerlink" title="NEW 和 OLD"></a>NEW 和 OLD</h2><ul>
<li>MySQL 中定义了 NEW 和 OLD 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>
<li>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li>
<li>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；</li>
<li>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；</li>
<li>使用方法： NEW.columnName （columnName 为相应数据表某一列名）</li>
</ul>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><blockquote>
<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>
</blockquote>
<p>CREATE TRIGGER 指令用于创建触发器。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>trigger_name：触发器名</li>
<li>trigger_time: 触发器的触发时机。取值为 BEFORE 或 AFTER。</li>
<li>trigger_event: 触发器的监听事件。取值为 INSERT、UPDATE 或 DELETE。</li>
<li>table_name: 触发器的监听目标。指定在哪张表上建立触发器。</li>
<li>FOR EACH ROW: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>
<li>trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 ; 来结尾。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好了这些基本上就是SQL语言的基本知识了，掌握之后就能应对简单的CRUD业务开发了。但是MYSQL还有很多知识点，比如索引的类别、锁、查询优化器、读写分离、主备一致、数据库引擎等等需要你去学习哦！</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记（4）：setup函数</title>
    <url>/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9Asetup/</url>
    <content><![CDATA[<p>在看这个文章之前，建议先浏览一遍下面内容：<br><a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">官方文档：组合式 API 介绍</a><br><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">官方文档：组合式 API setup</a><br><a href="https://www.jianshu.com/p/cfe25e757d0e">全面解析 Vue3 Reactive 家族和 Ref 家族 API</a></p>
<p>这篇文章会说到一些官方文档可能没写到的内容，但是可能对你后面学习 jsx&#x2F;tsx 会很有用。</p>
<span id="more"></span>

<h1 id="setup-函数的运用"><a href="#setup-函数的运用" class="headerlink" title="setup 函数的运用"></a>setup 函数的运用</h1><p>首先演示一下大致的用法：</p>
<figure class="highlight js"><figcaption><span>HelloWorld.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">msg</span>: <span class="title class_">String</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params">props, &#123; slots, attrs, emit &#125;</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// setup传入两个参数，props和ctx，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// ctx包括：slots, attrs, emit这些属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> name = <span class="string">&#x27;jack&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><p>根据官方的文档，data 里的东西可以放到 setup，但是如果我们想改变 name 的值呢，比如这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  name += <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现界面上的 jack 并没有发生改变，这是因为 setup 在组件创建到挂在的过程中只会执行一次，而 return 这个对象的时候只是相当于把上面 name 的值也就是<code>&#39;jack&#39;</code>这个值放到了对象里面，相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那你改变 name 的值自然是没有效果的。这时候就需要用到 reactive api，将上面代码改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; name.value &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> name = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">value</span>: <span class="string">&#x27;jack&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">1000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后发现很神奇的是界面可以随着时间发生改变了，也就是动态绑定成功了，这就是 vue3 响应式的最基础用法。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>但是如果我们不想让这个 name 包一层对象那得怎么办呢，这时候就要用到 ref api 了，可以改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">1000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到其实也是有效果的。ref 实际上的原理很简单，也是和 reactive 类似，由 api 去帮你包一层对象，并返回一个代理。其中传进去的值包裹在：<code>&#123; value: &#39;jack&#39; &#125;</code>，所以可以看到在 setInterval 里面对 name 操作的话就需要使用<code>.value</code>来访问。而为什么模板又不用呢，那是因为 vue 编译器判断这是一个 ref 对象所以自动帮我们使用了<code>.value</code>。</p>
<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>其实这个 computed api 和 vue2 的很类似，直接上代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent, ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> computedName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> name.<span class="property">value</span> + <span class="string">&#x27;2&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">1000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">name</span>: computedName,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，每当 name 发生改变的时候，computed 会帮我们重新计算值，这也是 computed 函数的一个用法。</p>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><p>首先演示一下这个 api 怎么用，有啥效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; defineComponent, ref, computed, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> computedName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> name.<span class="property">value</span> + <span class="string">&#x27;2&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      name.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">1000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">name</span>: computedName,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>打开页面，打开控制台，在 setInterval 执行对 name.value 进行修改的时候，控制台会将 name.value 进行输出。<br>所以这个函数的作用是某个 ref 或者 reactive 变量的值发生改变的时候，会调用该函数。<br>值得注意的一点是 watchEffect 只会监听你写进去的变量，比如上面的 name。如果你创建了一个另一个 ref 对象，比如叫 age，然后同样对 age 进行操作但是 watchEffect 并没有将 age 写到该函数里面，会发现 watchEffect 函数并没有执行。<br>所以这个函数非常强大而且好用，相对于 vue2 的 watch 来说不再需要注意监听的东西是否是数组或者对象，是否深度监听对象里的属性或者数组里的值发生（deep），还有其他一堆的东西。你只需要把想要执行的代码写在里面即可，不再需要关系其他东西。</p>
<h2 id="setup-的一些补充"><a href="#setup-的一些补充" class="headerlink" title="setup 的一些补充"></a>setup 的一些补充</h2><p>有一点要注意的是，setup 返回的是东西有点像 data 函数返回的对象。比如这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略上面的一些代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你会发现控制台打印了一个<code>&#39;jack&#39;</code>出来，说明 setup 外部能拿到返回的值，是不是和 data 差不多，但是值得注意的是他打印出来的并不是一个 proxy 对象，也就是直接把 ref 对象里的值拿出来了，这算一个小坑。因为我们 setup 函数返回的是一个 ref，所以当我们拿出 ref 值的时候可能值会发生改变（比如在 mounted 生命周期前对 ref 进行操作）。</p>
<h1 id="在-setup-里使用-render"><a href="#在-setup-里使用-render" class="headerlink" title="在 setup 里使用 render"></a>在 setup 里使用 render</h1><p>比如之前写到 render 和 h 函数演示的代码，我们进行一点修改，使用上 setup：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 上面的return ()=&gt;&#123;&#125;是指直接返回一个render函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: img &#125;),</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, name.<span class="property">value</span>),</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开页面，可以发现效果和上面写的 sfc 组件是类似的，其实写 sfc 的时候编译器也会将模板代码、script 部分代码这些编译成类似的带 render 的 js 代码。</p>
<h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><p>假如我们改一下需求，代码写成这个样子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.<span class="property">value</span> += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      num.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: img &#125;),</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, name.<span class="property">value</span> + num.<span class="property">value</span>),</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>页面很正常，num 也能随着时间增长，但是有些同学为了方便，可能写成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.<span class="property">value</span> += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      num.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">const</span> numVal = num.<span class="property">value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: img &#125;),</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, name.<span class="property">value</span> + numVal),</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你会发现，怎么 numVal 一直为 1，这是因为组件从创建到挂载，只会执行一次 setup 函数，我们可以改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.<span class="property">value</span> += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      num.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> numVal = num.<span class="property">value</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, [</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;img&#x27;</span>, &#123; <span class="attr">alt</span>: <span class="string">&#x27;Vue logo&#x27;</span>, <span class="attr">src</span>: img &#125;),</span><br><span class="line">        <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, name.<span class="property">value</span> + numVal),</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在页面展示的 numVal 能随着值发生改变了。所以说如果把 numVal 写在 setup 函数里面的话，那么他永远只会是组件初始化时拿到的 1。<br>而当我们对 ref 对象进行修改的话，会导致组件重新执行 render 函数，这就是导致两种写法会有不一样效果的原因。<br>但其实这样写的代码是不太适合阅读的，现在这么写是为了后面学习使用 jsx 做好铺垫。</p>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记（2）：Props</title>
    <url>/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9AProps/</url>
    <content><![CDATA[<p>这节课讲解一下 Props 相关的内容，如果没看过第一篇建议先去看完第一篇： <a href="/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6/">Vue3 学习笔记（1）：组件</a></p>
<span id="more"></span>

<h1 id="Props-的一些坑"><a href="#Props-的一些坑" class="headerlink" title="Props 的一些坑"></a>Props 的一些坑</h1><p>当我们不想每个组件都写一些 Props，想把相同的 Props 定义提取出来，我们可能会这么做，这里用上一篇的例子继续演示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, <span class="title class_">PropType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PropsType</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: <span class="title class_">PropsType</span>,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这时候看一下 age 的类型，是不是发现不对劲，age 的类型是：<code>number | undefined</code>。<br>不对啊我们都定义了 required 为 true 了，为什么还会是<code>undefined</code>呢？首先说一下解决办法，其实很简单，只需要加上<code>as const</code>即可：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PropsType</span> = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span></span><br></pre></td></tr></table></figure>

<p>你会发现神奇的事情发生了，age 不再有可能是<code>undefined</code>了。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>其实原因写在了<code>defineComponent</code>函数声明的地方（不是定义），<br>看到 vue-next 源码的 <code>package/runtime-core/src/apiDefineComponent.ts</code> ，看到 overload4 的部分:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// overload 4: object format with object props declaration</span></span><br><span class="line"><span class="comment">// see `ExtractPropTypes` in ./componentProps.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> defineComponent&lt;</span><br><span class="line">  <span class="comment">// the Readonly constraint allows TS to treat the type of &#123; required: true &#125;</span></span><br><span class="line">  <span class="comment">// as constant instead of boolean.</span></span><br><span class="line">  <span class="title class_">PropsOptions</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="title class_">ComponentPropsOptions</span>&gt;,</span><br><span class="line">  <span class="title class_">RawBindings</span>,</span><br><span class="line">  D,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="title class_">ComputedOptions</span> = &#123;&#125;,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="title class_">MethodOptions</span> = &#123;&#125;,</span><br><span class="line">  <span class="title class_">Mixin</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  <span class="title class_">Extends</span> <span class="keyword">extends</span> <span class="title class_">ComponentOptionsMixin</span> = <span class="title class_">ComponentOptionsMixin</span>,</span><br><span class="line">  E <span class="keyword">extends</span> <span class="title class_">EmitsOptions</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  <span class="variable constant_">EE</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">string</span></span><br><span class="line">&gt;(</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">ComponentOptionsWithObjectProps</span>&lt;</span><br><span class="line">    <span class="title class_">PropsOptions</span>,</span><br><span class="line">    <span class="title class_">RawBindings</span>,</span><br><span class="line">    D,</span><br><span class="line">    C,</span><br><span class="line">    M,</span><br><span class="line">    <span class="title class_">Mixin</span>,</span><br><span class="line">    <span class="title class_">Extends</span>,</span><br><span class="line">    E,</span><br><span class="line">    <span class="variable constant_">EE</span></span><br><span class="line">  &gt;</span><br><span class="line">): <span class="title class_">DefineComponent</span>&lt;<span class="title class_">PropsOptions</span>, <span class="title class_">RawBindings</span>, D, C, M, <span class="title class_">Mixin</span>, <span class="title class_">Extends</span>, E, <span class="variable constant_">EE</span>&gt;</span><br></pre></td></tr></table></figure>

<p>最重要的一句是：</p>
<blockquote>
<p>&#x2F;&#x2F; the Readonly constraint allows TS to treat the type of { required: true }<br>&#x2F;&#x2F; as constant instead of boolean.</p>
</blockquote>
<p>翻译出来就是：<code>Readonly</code>约束可以让 TS 将<code>&#123; required: true &#125;</code>视为该对象是必须的。</p>
<p>但是如果我们使用这样子的方式去定义的话：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PropsType</span> = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没上下文可以告诉 TS 这个 PropsType 是<code>Readonly</code>类型，就会导致 required 的约束失效。怎么将这个对象设为<code>Readonly</code>类型呢？很简单，ts 提供了一个<code>as const</code>的语法，可以将对象的所有属性设为 readonly，也就是这个对象是一个<code>Readonly</code>类型的对象，那么约束就可以生效了。</p>
<p>这个坑如果不是用 ts 去开发的话根本不会遇到，但是这个坑可能网上都找不到太多的相关知识。</p>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记（6）：单元测试</title>
    <url>/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>这节讲一下如何用 jest 进行单元测试</p>
<span id="more"></span>

<h1 id="使用-vue-cli-的预设"><a href="#使用-vue-cli-的预设" class="headerlink" title="使用 vue-cli 的预设"></a>使用 vue-cli 的预设</h1><p>在执行：<code>vue create xxx</code>时，选上：<code>Unit Test</code>，框架选择<code>Jest</code>框架。<br>初始化完成后可以看到<code>/tests/unit</code>目录下有一个：<code>example.spec.ts</code>文件：</p>
<figure class="highlight ts"><figcaption><span>example.spec.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="jest-的配置"><a href="#jest-的配置" class="headerlink" title="jest 的配置"></a>jest 的配置</h1><p>跑 jest 的单元测试主要通过根目录下的：<code>jest.config.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">preset</span>: <span class="string">&#x27;@vue/cli-plugin-unit-jest/presets/typescript-and-babel&#x27;</span>,</span><br><span class="line">  <span class="attr">transform</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^.+\\.vue$&#x27;</span>: <span class="string">&#x27;vue-jest&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们去到 preset 的目录<code>/node_modules/@vue/cli-plugin-unit-jest/presets/typescript-and-babel</code>看到，有一个 jest-preset.js:</p>
<figure class="highlight js"><figcaption><span>jest-preset.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepmerge = <span class="built_in">require</span>(<span class="string">&#x27;deepmerge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> defaultTsPreset = <span class="built_in">require</span>(<span class="string">&#x27;../typescript/jest-preset&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">deepmerge</span>(defaultTsPreset, &#123;</span><br><span class="line">  <span class="attr">globals</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;ts-jest&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">babelConfig</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到这个预设主要是在基础预设上加上了<code>ts-jest</code>的配置。继续看：<code>/typescript/jest-preset</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepmerge = <span class="built_in">require</span>(<span class="string">&#x27;deepmerge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> defaultPreset = <span class="built_in">require</span>(<span class="string">&#x27;../default/jest-preset&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">deepmerge</span>(defaultPreset, &#123;</span><br><span class="line">  <span class="attr">moduleFileExtensions</span>: [<span class="string">&#x27;ts&#x27;</span>, <span class="string">&#x27;tsx&#x27;</span>],</span><br><span class="line">  <span class="attr">transform</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^.+\\.tsx?$&#x27;</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;ts-jest&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到这个<code>moduleFileExtensions</code>指定了去寻找 ts 文件和 tsx 文件。<br><code>transform</code> 用来指定编译代码，这里指定了 <code>tsx</code> 交给<code>ts-jest</code>这个依赖来编译。</p>
<p>继续往<code>/default/jest-preset</code>看，可以看到：</p>
<figure class="highlight js"><figcaption><span>jest-preset</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 在我们写代码的时候，其实可以不写后缀名，这里的 moduleFileExtensions 会自动帮我们补后缀名。</span></span><br><span class="line">  <span class="attr">moduleFileExtensions</span>: [</span><br><span class="line">    <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;jsx&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="comment">// tell Jest to handle *.vue files</span></span><br><span class="line">    <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 然后 transform 还是指定需要编译的文件，比如这个 .vue 文件使用 vue-jest 编译。</span></span><br><span class="line">  <span class="attr">transform</span>: &#123;</span><br><span class="line">    <span class="comment">// process *.vue files with vue-jest</span></span><br><span class="line">    <span class="string">&#x27;^.+\\.vue$&#x27;</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;vue-jest&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$&#x27;</span>:</span><br><span class="line">      <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;jest-transform-stub&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;^.+\\.jsx?$&#x27;</span>: <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;babel-jest&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定哪些不需要编译的</span></span><br><span class="line">  <span class="attr">transformIgnorePatterns</span>: [<span class="string">&#x27;/node_modules/&#x27;</span>],</span><br><span class="line">  <span class="comment">// 把@映射到/src目录</span></span><br><span class="line">  <span class="comment">// support the same @ -&gt; src alias mapping in source code</span></span><br><span class="line">  <span class="attr">moduleNameMapper</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^@/(.*)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/src/$1&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在什么环境下进行测试，比如jsdom这个</span></span><br><span class="line">  <span class="attr">testEnvironment</span>: <span class="string">&#x27;jest-environment-jsdom-fifteen&#x27;</span>,</span><br><span class="line">  <span class="comment">// 快照测试:把测试结果序列化到一个文件，以后跑单测时比较输出的字符串时候和之前的一样，保证稳定性。</span></span><br><span class="line">  <span class="comment">// serializer for snapshots</span></span><br><span class="line">  <span class="attr">snapshotSerializers</span>: [<span class="string">&#x27;jest-serializer-vue&#x27;</span>],</span><br><span class="line">  <span class="comment">// jest找哪里哪些文件去跑测试</span></span><br><span class="line">  <span class="attr">testMatch</span>: [<span class="string">&#x27;**/tests/unit/**/*.spec.[jt]s?(x)&#x27;</span>, <span class="string">&#x27;**/__tests__/*.[jt]s?(x)&#x27;</span>],</span><br><span class="line">  <span class="comment">// 类似模拟浏览器的环境，通过浏览器加载一些js文件</span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/jest/issues/6766</span></span><br><span class="line">  <span class="attr">testURL</span>: <span class="string">&#x27;http://localhost/&#x27;</span>,</span><br><span class="line">  <span class="comment">// 启动了watch后，每次保存都会自动跑一次测试</span></span><br><span class="line">  <span class="attr">watchPlugins</span>: [</span><br><span class="line">    <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;jest-watch-typeahead/filename&#x27;</span>),</span><br><span class="line">    <span class="built_in">require</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;jest-watch-typeahead/testname&#x27;</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这些配置非常像 webpack。</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="测试声明"><a href="#测试声明" class="headerlink" title="测试声明"></a>测试声明</h2><p>jest 有三种 api，分别是：<code>describe、it、test</code>。</p>
<p>describe 指一整个套件，it 包含在 describe 里面，特指单个测试。test 是单独的一个测试。</p>
<p>大部分情况都是使用 describe 和 it 去测试，test 可能只会用在一些小项目里，测一下简单的东西。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言指判断结果是否和我们预期的一样，比如：</p>
<figure class="highlight ts"><figcaption><span>example.spec.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>比如这个：<code>expect(wrapper.text()).toMatch(msg)</code>，指的是期待：<code>wrapper.text()</code>的结果要 msg 匹配。</p>
<p>除了 toMatch 还有 toBe、toEqual 等 api。可以看<a href="https://jestjs.io/zh-Hans/docs/expect">官方文档</a>的介绍。</p>
<p>如果需要反转一下匹配结果，比如需要结果不等于什么，只需要在 toxxx 前面加上 not，比如：<code>expect(wrapper.text()).not.toMatch(msg)</code></p>
<h2 id="预设和清理"><a href="#预设和清理" class="headerlink" title="预设和清理"></a>预设和清理</h2><p>包括几个 api：<code>beforeEach/afterEach、beforeAll/afterAll</code><br>beforeEach 指每个单元测试执行前都会执行，同理 afterEach 是测试后执行。beforeAll 所有测试开始前只执行一次，afterAll 是所有测试执行完后执行一次。<br>要注意这些都有作用域，通常写到 describe 里面，比如：</p>
<figure class="highlight ts"><figcaption><span>example.spec.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">beforeAll</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;测试还没开始&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;某个it测试还没开始&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title class_">AfterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;某个it测试已经结束&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">afterAll</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有测试已完成&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h1><p>默认情况下测试都是同步测试，如果写上异步的代码可能会出现一些问题，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">123</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>理论上这个测试是不应该通过的，但是跑起来发现还是可以通过，原因是 jest 认为我们再跑同步测试，所以 setTimeout 里面的代码并没有去执行，解决方法如下。</p>
<h2 id="done"><a href="#done" class="headerlink" title="done"></a>done</h2><p>可以传入一个参数 done，然后测试结束后执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">      <span class="title function_">done</span>()</span><br><span class="line">    &#125;, <span class="number">123</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>可以在函数的返回值使用 Promise 去解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>测试可以看到也是不通过，说明 Promise 的方法还是有用的。</p>
<h2 id="async、await-语法糖"><a href="#async、await-语法糖" class="headerlink" title="async、await 语法糖"></a>async、await 语法糖</h2><p>可以使用上这些新的语法糖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;HelloWorld.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg when passed&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;new message&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">HelloWorld</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> wrapper.<span class="title function_">setProps</span>(&#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为 vue 修改 dom 不是同步的，如果改了值再想拿到 dom 的值需要 nextTick 这个 api，这也是一个异步操作，所以我们用 await 来等待 dom 修改完成。<br>测试是不通过的，然后将 toMatch 的值设为<code>&#39;123&#39;</code>再跑就能通过了。</p>
<h1 id="vue-test-utils-测试-vue3-组件"><a href="#vue-test-utils-测试-vue3-组件" class="headerlink" title="vue-test-utils 测试 vue3 组件"></a>vue-test-utils 测试 vue3 组件</h1>]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记（5）：jsx</title>
    <url>/Vue3/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9Ajsx/</url>
    <content><![CDATA[<p>这集来讲解 jsx 的基本使用，为了让你更好理解建议先把该系列的前置课程学会。</p>
<span id="more"></span>

<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>这里建议使用官方推荐的：<code>@vue/babel-plugin-jsx</code>。<br>安装：<code>yarn add @vue/babel-plugin-jsx -D</code><br>然后在 babel 配置文件使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>],</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@vue/babel-plugin-jsx&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>我们先对 App.vue 进行改造，先创建一个 App.tsx 文件：</p>
<figure class="highlight ts"><figcaption><span>App.tsx</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">require</span>(<span class="string">&#x27;./assets/logo.png&#x27;</span>) <span class="comment">// eslint-disable-line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到这个结构是不是和用 h 函数写非常的像，如果你能理解 h 函数的写法应该也很好理解这种写法。<br>其中 jsx 如果需要引用值的话只需要使用<code>&#123;&#125;</code>即可。</p>
<h2 id="属性检查"><a href="#属性检查" class="headerlink" title="属性检查"></a>属性检查</h2><p>jsx 有个好处就是能检查你使用组件时是否按照要求传入属性，如果检查不通过则会直接编译时报错：</p>
<figure class="highlight js"><figcaption><span>HelloWorld.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这时候如果我们的 jsx 这样写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">require</span>(<span class="string">&#x27;./assets/logo.png&#x27;</span>) <span class="comment">// eslint-disable-line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">HelloWorld</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行会发现直接报错不通过编译，或者直接传入一个 number 试试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也是一样会报错：<code>TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></p>
<p>然后我们正常的传入一个 string：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&#123;</span>&#x27;<span class="attr">123</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到正常的跑起来的，这就是 ts 和 jsx 给我们带来的好处。</p>
<p>而我们如果使用.vue 的话，不传入属性：</p>
<figure class="highlight js"><figcaption><span>App.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;./assets/logo.png&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">HelloWorld</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>只有在运行时才会在控制台弹出警告：<code>Missing required prop: &quot;msg&quot;</code>，而且只是警告，但是这个 app.vue 还是能正常运行，这就不太符合 ts 的思想了。</p>
<h2 id="加上函数"><a href="#加上函数" class="headerlink" title="加上函数"></a>加上函数</h2><p>如果我们有一些复杂的逻辑，会导致需要渲染的片段不一样，那可能就需要这样去做了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderHelloWorld</span>(<span class="params">msg: string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&#123;msg&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;renderHelloWorld(&#x27;hello&#x27;)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过一些函数来生成不一样的代码，不像 template 一样直接写死。</p>
<h2 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h2><p>比如使用双向绑定<code>v-model</code>指令，就和写 sfc 一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">v-model</span>=<span class="string">&#123;name.value&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们进行输入，上面的 p 也会跟着改变。</p>
<blockquote>
<p>以下内容基于 vue3.2.x 补充</p>
</blockquote>
<h1 id="模板的语法"><a href="#模板的语法" class="headerlink" title="模板的语法"></a>模板的语法</h1><p>上面说模板的方式编写组件没办法对 props 进行类型检测，其实在 vue3.2 加上 volar 插件的情况下是可以进行类型检测的。（volar 用于代码编写时进行类型检查）</p>
<p>组件只需要使用 defineProps 编译器宏也是能够实现类型检测的：</p>
<figure class="highlight ts"><figcaption><span>HelloWorld.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;script lang=<span class="string">&#x27;ts&#x27;</span> setup&gt;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IMyProps</span> &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">const</span> props = defineProps&lt;<span class="title class_">IMyProps</span>&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当然如果在 setup 里面不需要调用 props 的话可以去掉前面的声明赋值，只写 defineProps 就行了。</p>
<p>然后其他组件调用：</p>
<figure class="highlight ts"><figcaption><span>App.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#x27;Vue logo&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;./assets/logo.png&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">HelloWorld</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>这时候会提示缺少了某个属性，当然传入不正确的类型也会报错。如果需要属性可选，不传的话使用默认值则需要使用 <code>withDefaults</code> 编译器宏:</p>
<figure class="highlight ts"><figcaption><span>官网例子</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  msg?: <span class="built_in">string</span></span><br><span class="line">  labels?: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(), &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">labels</span>: <span class="function">() =&gt;</span> [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同样 emit 也能进行类型校验了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = defineEmits&lt;&#123;</span><br><span class="line">  (<span class="attr">e</span>: <span class="string">&#x27;change&#x27;</span>, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">  (<span class="attr">e</span>: <span class="string">&#x27;update&#x27;</span>, <span class="attr">value</span>: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;&gt;()</span><br><span class="line"><span class="comment">// 下面需要emit的话：</span></span><br><span class="line"><span class="title function_">emit</span>(<span class="string">&#x27;change&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="title function_">emit</span>(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果 emit 的事件和参数写错也是会报类型错误。</p>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记额外篇（1）：Vue 组件通信的 8 种方式</title>
    <url>/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%A2%9D%E5%A4%96%E7%AF%87%EF%BC%881%EF%BC%89%EF%BC%9AVue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84-8-%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>简单介绍</p>
<img src="/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%A2%9D%E5%A4%96%E7%AF%87%EF%BC%881%EF%BC%89%EF%BC%9AVue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84-8-%E7%A7%8D%E6%96%B9%E5%BC%8F/1.png" class="">

<span id="more"></span>

<h1 id="父组件-向-子组件-传递值"><a href="#父组件-向-子组件-传递值" class="headerlink" title="父组件 向 子组件 传递值"></a>父组件 向 子组件 传递值</h1><p>步骤：</p>
<ul>
<li>在父组件中引入子组件</li>
<li>注册子组件</li>
<li>在页面中使用，子组件标签上 动态绑定传入动态值 &#x2F; 静态值</li>
<li>在子组件中，使用 props 来接受 父组件 传递过了的值</li>
</ul>
<p>子组件接收的父组件的值分为引用类型和普通类型两种：</p>
<ul>
<li>普通类型：字符串（String）、数字（Number）、布尔值（Boolean）、空（Null）</li>
<li>引用类型：数组（Array）、对象（Object）</li>
</ul>
<figure class="highlight js"><figcaption><span>father.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 传递值 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Test</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">:obj</span>=<span class="string">&quot;obj&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">info</span>=<span class="string">&quot;测试&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 引入子组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&#x27;./children.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;about&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 注册子组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Test</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">obj</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">code</span>: <span class="number">200</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">title</span>: <span class="string">&quot;一起自学Vue吧！&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><figcaption><span>children.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;obj.code&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;obj.title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&#x27;test&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">props</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">obj</span>:<span class="title class_">Object</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">info</span>: [<span class="title class_">String</span>,<span class="title class_">Number</span>]  <span class="comment">//info值为其中一种类型即可，其他类型报警告</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 Vue 是 单向数据流， 子组件 是不能直接 修改 父组件 的 值。</p>
</blockquote>
<h1 id="子组件-向-父组件-传递值"><a href="#子组件-向-父组件-传递值" class="headerlink" title="子组件 向 父组件 传递值"></a>子组件 向 父组件 传递值</h1><p>子组件通过绑定事件，通过 this.$emit(‘函数名’，传递参数)</p>
<figure class="highlight js"><figcaption><span>father.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Test</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">:obj</span>=<span class="string">&quot;obj&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">info</span>=<span class="string">&quot;测试&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        @<span class="attr">modify</span>=<span class="string">&quot;modifyFatherValue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 引入子组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&quot;./children.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;about&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 注册子组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Test</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>:<span class="string">&#x27;我是父组件&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 接受子组件传递来的值，赋值给data中的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">modifyFatherValue</span>(<span class="params">e</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>children.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;obj.code&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;obj.title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&#x27;test&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">props</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">obj</span>:<span class="title class_">Object</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">info</span>: [<span class="title class_">String</span>,<span class="title class_">Number</span>]  <span class="comment">//info值为其中一种类型即可，其他类型报警告</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="父组件-通过-refs-x2F-children-来获取子组件值"><a href="#父组件-通过-refs-x2F-children-来获取子组件值" class="headerlink" title="父组件 通过 $refs &#x2F; $children 来获取子组件值"></a>父组件 通过 $refs &#x2F; $children 来获取子组件值</h1><p>$refs :</p>
<ul>
<li>获取DOM 元素 和 组件实例来获取组件的属性和方法。</li>
<li>通过在 子组件 上绑定 ref ，使用 this.$refs.refName.子组件属性 &#x2F; 子组件方法</li>
</ul>
<p>$children :</p>
<ul>
<li>当前实例的子组件，它返回的是一个子组件的集合。如果想获取哪个组件属性和方法，可以通过 this.$children[index].子组件属性&#x2F;f方法</li>
</ul>
<figure class="highlight js"><figcaption><span>text1.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">datas</span>:<span class="string">&quot;我是子组件值&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">props</span>:&#123;</span><br><span class="line">            <span class="attr">obj</span>:<span class="title class_">Object</span>,</span><br><span class="line">            <span class="attr">info</span>: [<span class="title class_">String</span>,<span class="title class_">Number</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是Test1&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>text2.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是Test2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&#x27;test&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">datas</span>:<span class="string">&quot;我是Test2&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">obj</span> ) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">getQuery</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">getTest2</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">datas</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   // 给子组件上绑定 ref  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Test1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">ref</span>=<span class="string">&quot;son&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">Test2</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 省略注册等代码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 使用$refs示例</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">son</span>.<span class="property">datas</span>)  <span class="comment">// 输出：我是子组件值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">son</span>.<span class="title function_">getValue</span>()           <span class="comment">// 输出：我是Test1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 使用$children示例</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">0</span>].<span class="title function_">getValue</span>(); <span class="comment">// 我是 Test1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">1</span>].<span class="title function_">getTest2</span>();  <span class="comment">//我是 Test2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.$children[<span class="number">1</span>].datas&#125;</span>`</span>); <span class="comment">//我是Test2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="子组件-通过-parent-来获取父组件实例的属性和方法"><a href="#子组件-通过-parent-来获取父组件实例的属性和方法" class="headerlink" title="子组件 通过 $parent 来获取父组件实例的属性和方法"></a>子组件 通过 $parent 来获取父组件实例的属性和方法</h1><figure class="highlight js"><figcaption><span>children.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">        <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">obj</span> ) </span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">getQuery</span>()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="attrs-和-listeners-获取父组件实例属性和方法-组件嵌套情况下使用"><a href="#attrs-和-listeners-获取父组件实例属性和方法-组件嵌套情况下使用" class="headerlink" title="$attrs 和 $listeners 获取父组件实例属性和方法(组件嵌套情况下使用)"></a>$attrs 和 $listeners 获取父组件实例属性和方法(组件嵌套情况下使用)</h1><p><strong>$attrs</strong>：包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)，并且可以通过 v-bind&#x3D;” $attrs” 传入内部组件。当一个组件没有声明任何 props 时，它包含所有父作用域的绑定 (class 和 style 除外)。</p>
<p><strong>$listeners</strong>：包含了父作用域中的 (不含 .native 修饰符) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件。它是一个对象，里面包含了作用在这个组件上的所有事件监听器，相当于子组件继承了父组件的事件。</p>
<p>使用场景： 多层嵌套组件的情况下使用，可以避免使用Vuex来做数据处理， 使用 v-bind&#x3D;”$attrs” v-on&#x3D;”$listeners” 很方便达到业务数据传递。</p>
<figure class="highlight js"><figcaption><span>father.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Test1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">:status</span>=<span class="string">&quot;status&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        @<span class="attr">getData</span>=<span class="string">&quot;getData&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Children1</span> <span class="keyword">from</span> <span class="string">&quot;./children1.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;person&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">title</span>:<span class="string">&#x27;personal 组件&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">status</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title class_">Children1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>children1.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>children1 组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    // 通过 $attrs（属性，除了【props中定义的属性】）  和 $listeners（方法）  来给嵌套子组件传递父组件的属性和方法</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Children2</span>   <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 引入子子组件   </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Children2</span> <span class="keyword">from</span> <span class="string">&quot;./children2.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;Children1&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&quot;title&quot;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Children2</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$attrs</span>);  <span class="comment">//&#123;status: false&#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$listeners</span>); <span class="comment">// &#123;getData: ƒ&#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>children2.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>children2 组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;Children2&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----children2------&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$attrs</span>) <span class="comment">//&#123;status: false&#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$listeners</span>) <span class="comment">// &#123;getData: ƒ&#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="跨组件之间传值（eventBus）"><a href="#跨组件之间传值（eventBus）" class="headerlink" title="跨组件之间传值（eventBus）"></a>跨组件之间传值（eventBus）</h1><p>通过新建一个 <code>js</code> 文件，导入 <code>vue</code> , 导出 <code>vue</code> 实例； 然后通过 给导出的实例 上绑定事件 <code>$emit</code> 事件 , 然后再通过 <code>$on</code> 监听触发的事件，这样就可以达到全局组件数据共享。</p>
<p>使用场景：它可以满足任意场景传递数据， 父子组件传值 , 子父传值 , 兄弟组件之间传值 , 跨级组件之间传值。</p>
<p>通信数据比较简单时，可以采用这种方案，eventBus也有不方便之处, 当项目较大，就容易造成难以维护的灾难，这时候可以采用 <code>Vuex</code> 。</p>
<figure class="highlight js"><figcaption><span>myVue.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>组件A</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeValue&quot;</span>&gt;</span>改变<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> myVue <span class="keyword">from</span> <span class="string">&#x27;./myVue.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;person&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">title</span>:<span class="string">&#x27;personal 组件&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">status</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">changeValue</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 通过给 vue实例绑定事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            myVue.$emit(<span class="string">&#x27;getTitle&#x27;</span>, <span class="variable language_">this</span>.<span class="property">title</span>)   </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>组件B</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Test4 组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> myVue <span class="keyword">from</span> <span class="string">&quot;./myVue.js&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&quot;test4&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">title</span>: <span class="string">&quot;test4&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 通过 vue 实例.$on  监听事件名，来接收跨级组件传递过来的值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myVue.$on(<span class="string">&#x27;getTitle&#x27;</span>, <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">title</span> = item</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="provide-和-inject-实现父组件向子孙孙组件传值。-层级不限"><a href="#provide-和-inject-实现父组件向子孙孙组件传值。-层级不限" class="headerlink" title="provide 和 inject 实现父组件向子孙孙组件传值。(层级不限)"></a>provide 和 inject 实现父组件向子孙孙组件传值。(层级不限)</h1><p>provide 和 inject 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
<p>provide:是一个对象或返回一个对象的函数，该对象包含可注入其子孙的属性。</p>
<p>inject:是一个字符串数组 或者是一个对象，用来在子组件或者子孙组件中注入 provide 提供的父组件属性。</p>
<p>使用场景：provide&#x2F;inject可以轻松实现跨级访问父组件的数据</p>
<figure class="highlight js"><figcaption><span>father.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./SonOne&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">provide</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">title</span>: <span class="string">&#x27;父组件的值&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title class_">Son</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>SonOne.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SonTwo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">SonTwo</span> <span class="keyword">from</span> <span class="string">&#x27;./SonTwo&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title class_">SonTwo</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">inject</span>:[<span class="string">&#x27;title&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span>)     <span class="comment">// 输出：父组件的值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>SonTwo.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是子孙组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title class_">SonTwo</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">inject</span>:[<span class="string">&#x27;title&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span>)     <span class="comment">// 输出：父组件的值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="Vuex、localStorage-x2F-sessionStorage"><a href="#Vuex、localStorage-x2F-sessionStorage" class="headerlink" title="Vuex、localStorage &#x2F; sessionStorage"></a>Vuex、localStorage &#x2F; sessionStorage</h1><p>Vuex请看：<a href="/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9AVuex%E5%9F%BA%E7%A1%80/">Vue学习笔记（4）：Vuex基础</a><br>localStorage请看：<a href="/%E5%89%8D%E7%AB%AF/Html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/#Web-%E5%82%A8%E5%AD%98">Html5学习笔记</a>，这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记（1）：基本指令</title>
    <url>/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>vue 指令的说明和用法</p>
<span id="more"></span>

<h1 id="数据-amp-方法"><a href="#数据-amp-方法" class="headerlink" title="数据&amp;方法"></a>数据&amp;方法</h1><p>实例化 Vue 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Wyatex&#x27;</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&#x27;程序员&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">world</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The World!&#x27;</span>),</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y,</span><br><span class="line">    <span class="attr">myJob</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">job</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>el: element 需要获取的元素，一定是 html 中的根容器元素<br>data: 用于数据的存储<br>methods: 用于存放方法</p>
<p>在 html 中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My name is &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;&#123;world()&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;add(1,2)&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>my job is &#123;&#123;myJob()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;xx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h1><p>和上面的<code>&#123;&#123;xxx&#125;&#125;</code>用法差不多</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和下面的一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="属性绑定-v-bind"><a href="#属性绑定-v-bind" class="headerlink" title="属性绑定 v-bind"></a>属性绑定 v-bind</h1><p>在 vue 实例化里的 data 里添加：<code>url: &quot;http://baidu.com&quot;</code><br>在 html 的 app 容器里添加<code>&lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt;</code><br>这样就可以把 data 里的数据绑定到 html 里</p>
<h1 id="html-标签绑定"><a href="#html-标签绑定" class="headerlink" title="html 标签绑定"></a>html 标签绑定</h1><p>在 data 里存放标签：<code>tag: &quot;&lt;a href=&quot;http://baidu.com&quot;&gt;百度&lt;/a&gt;&quot;</code><br>然后在 html 里用另一个标签然后使用 v-html 绑定：<code>&lt;div v-html=&quot;tag&quot;&gt;&lt;/div&gt;</code></p>
<blockquote>
<p>官方提示：在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。</p>
</blockquote>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>重新开始初始化 vue 实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;21&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">sub</span>: <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> -= a</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">addTen</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> -= <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My age is &#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;age++&quot;</span>&gt;</span>涨一岁<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;ageTen&quot;</span>&gt;</span>涨十岁<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;sub(1)&quot;</span>&gt;</span>减一岁<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:dblclick</span>=<span class="string">&quot;sub(10)&quot;</span>&gt;</span>双击减十岁<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 v-on 中调用的方法可以不用加括号，但是在数据绑定就必须要使用括号才能正确调用方法</p>
<p>还有一些其他的事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;block&quot;</span> <span class="attr">v-on:mousemove</span>=<span class="string">&quot;getXY&quot;</span>&gt;</span>&#123;&#123;x&#125;&#125;,&#123;&#123;y&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">getXY</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> = e.<span class="property">offsetX</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> = e.<span class="property">offsetY</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>v-on 可以简写成@，比如<code>@click</code>、<code>@mousemove</code></p>
</blockquote>
<h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><p>停止事件的一种方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;block&quot;</span> <span class="attr">v-on:mousemove</span>=<span class="string">&quot;getXY&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;x&#125;&#125;,&#123;&#123;y&#125;&#125; - <span class="tag">&lt;<span class="name">span</span> @<span class="attr">mousemove</span>=<span class="string">&quot;stopUpdate&quot;</span>&gt;</span>Stop Updata<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">getXY</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> = e.<span class="property">offsetX</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> = e.<span class="property">offsetY</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">stopUpdate</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是可以用更方便的 stop 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;block&quot;</span> <span class="attr">v-on:mousemove</span>=<span class="string">&quot;getXY&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;x&#125;&#125;,&#123;&#123;y&#125;&#125; - <span class="tag">&lt;<span class="name">span</span> @<span class="attr">mousemove.stop</span>=<span class="string">&quot;&quot;</span>&gt;</span>Stop Updata<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有比如 once 修饰符，也就是调用的方法只能调用一次，第二次以后的方法都不会再调用方法</p>
<p>官方介绍：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>prevent 可以阻止默认事件，比如可以在 a 标签中使用<code>v-on:click.prevent=&quot;&quot;</code>可以阻止跳转</p>
<blockquote>
<p>2.3.0 新增：<br>Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 .passive 修饰符尤其能够提升移动端的性能。</p>
<h1 id="键盘事件和修饰符"><a href="#键盘事件和修饰符" class="headerlink" title="键盘事件和修饰符"></a>键盘事件和修饰符</h1><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>keyup：在松开键盘时会调用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup</span>=<span class="string">&quot;inputting&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样每次输入一个字符或者按下其他键时会调用 inputting 方法</p>
<p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然还有 keydown，就是按下键盘时触发<br>keypress 就是按住时不断触发</p>
<h2 id="键盘修饰符"><a href="#键盘修饰符" class="headerlink" title="键盘修饰符"></a>键盘修饰符</h2><p>vue 支持的一些修饰符：</p>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“删除”和“退格”键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<p>还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1` Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.1.0 新增</p>
</blockquote>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。</p>
</blockquote>
<h1 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h1><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>通过 ref 属性可以将标签绑定到 vm.$refs 里</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-on:keyup</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My name is &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">name</span>.<span class="property">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>也可以去掉 v-on 使用 v-model 来进行绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My name is &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="动态绑定-css-样式-v-bind"><a href="#动态绑定-css-样式-v-bind" class="headerlink" title="动态绑定 css 样式 v-bind"></a>动态绑定 css 样式 v-bind</h1><p>绑定 css 的方法是<code>v-bind:class=&quot;xxx:true/false&quot;</code><br>比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;red:true, blue:false&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么这样整个 div 就会绑定到 red 类<br>如果需要动态的话就可以绑定一些方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;red:changeColor&#125;&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;changeColor = !changeColor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假如 div 默认蓝色，也就是 changeColor 默认是 false，点击后 div 后 div 就能加上 red 的类。</p>
<h1 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h1><p>官方介绍：根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 &#x2F; 组件被销毁并重建。如果元素是 <template>，将提出它的内容作为条件块。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>xxx为true<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样当 data 里的 xxx 为真时，整个 div 就会显示</p>
<h1 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h1><p>和 v-if 不一样的是，v-show 是设置 display 进行隐藏和显示，而 v-if 是整个组件销毁或者重建。</p>
<h1 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h1><p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 <code>item in items</code> 或者 <code>(item, index) in items</code> 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-1&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [&#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example-2&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">parentMessage</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">    <span class="attr">items</span>: [&#123; <span class="attr">message</span>: <span class="string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">&#x27;Bar&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以用 <code>value in object</code>、<code>(value, name) in object</code>、<code>(value, name, index) in object</code> 来遍历对象的 property，会按 <code>Object.keys()</code> 的结果遍历对象。</p>
<p>在 2.2.0 之后的版本，v-for 必须使用 key：<a href="https://www.jianshu.com/p/4bd5e745ce95">VUE 中演示 v-for 为什么要加 key</a></p>
<p>也可以使用值范围，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>v-text：用于绑定一个字符串，在页面中显示为字符串，和<code>&#123;&#123;&#125;&#125;</code>效果一样</li>
<li>v-html: 用于将一个字符串格式的 html 显示在页面并渲染出来</li>
<li>v-on: 用于绑定事件，用法是 v-on:事件名称&#x3D;”调用的方法”，可以缩写成<code>@</code>，比如@click</li>
<li>v-if: 绑定 vue 实例里的一个变量，变量为真就渲染出来，为假就之前销毁</li>
<li>v-show: 和 v-if 看上去效果差不多，但是不同之处在于 show 只会设置 display 属性，不会销毁</li>
<li>v-for: 遍历一个数组，并在 html 中一个一个渲染出来</li>
<li>b-bind: 用于绑定属性，也可以绑定类，不过绑定类一般传入一个对象，对象里一般是<code>成员: 布尔值</code>，为真就为便签加上整个类，可缩写成 <code>:</code></li>
<li>v-once: 第一次渲染之后便不会改变</li>
<li>v-model: v-model 指可以在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。</li>
<li>v-solt：2.6 之后插槽指令，可缩写成 <code>#</code></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记（2）：组件基础</title>
    <url>/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>组件的简单使用，包括prop和插槽<br>(本文在vue2环境下)</p>
<span id="more"></span>

<h1 id="基础实例"><a href="#基础实例" class="headerlink" title="基础实例"></a>基础实例</h1><h2 id="定义一个组件"><a href="#定义一个组件" class="headerlink" title="定义一个组件"></a>定义一个组件</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>在vue2的option里，组件拥有 <code>data、computed、watch、methods</code> 以及生命周期钩子等属性。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>
<p>组件的data选择必须是一个函数，通过return返回一份对象的拷贝。</p>
<p>使用 <code>Vue.component</code> 都是全局注册。</p>
<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><h2 id="通过Prop传递数据"><a href="#通过Prop传递数据" class="headerlink" title="通过Prop传递数据"></a>通过Prop传递数据</h2><p>在option中添加prop，然后父组件就可以通过定义的prop列表传递数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后调用这个组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>渲染出来的结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-post-demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>My journey with Vue<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Blogging with Vue<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Why Vue is so fun<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了这样多次调用以外，还可以用v-for指令来生成多个组件。</p>
<p>如果需要传递多个属性的话建议传入对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="prop单向数据流"><a href="#prop单向数据流" class="headerlink" title="prop单向数据流"></a>prop单向数据流</h2><p>父级prop的更新会流动到子组件，子组件可以响应式变化，但是反过来则不行。如果试图将prop作为一个本地的prop数据来用，不跟随父组件传入的数据改变，可以使用data：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">initialCounter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedSize</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：对象和数组是通过引用传入的，如果子组件对一个引用对象、数组进行修改，是会影响到父组件的状态的！</p>
</blockquote>
<h2 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h2><p>将原来的数组改成一个带有验证需求的对象，可以验证传入的数据是否满足需求，如果不满足将会在控制台中警告。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    <span class="attr">propA</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    <span class="attr">propB</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="attr">default</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    <span class="attr">propF</span>: &#123;</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>type除了原生的属性以外，还可以是自定义的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (firstName, lastName) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">author</span>: <span class="title class_">Person</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h1><p>展示一个子组件与父组件通过事件进行信息传递的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;post&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;blog-post&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;</span></span><br><span class="line"><span class="string">        Enlarge text</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#blog-posts-events-demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">posts</span>: [<span class="comment">/* ... */</span>],</span><br><span class="line">    <span class="attr">postFontSize</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blog-posts-events-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; fontSize: postFontSize + &#x27;em&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样点击子组件的按钮时，会通知父组件，实现子组件到父组件的数据流。</p>
<h2 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h2><p>有的时候用一个事件来抛出一个特定的值是非常有用的。例如我们可能想让 <blog-post> 组件决定它的文本要放大多少。这时可以使用 $emit 的第二个参数来提供这个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后当在父级组件监听这个事件的时候，我们可以通过 $event 访问到被抛出的这个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者，如果这个事件处理函数是一个方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">onEnlargeText</span>: <span class="keyword">function</span> (<span class="params">enlargeAmount</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">postFontSize</span> += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h2><p>在 <code>&lt;input&gt;</code> 里用v-model相当于同时使用 <code>:value=&quot;xx&quot;</code> <code>@input=&quot;xxx = $event.target.value&quot;</code><br>所以v-model当用在自己的组件上会变成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;searchText = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>
<ul>
<li>将其 value attribute 绑定到一个名叫 value 的 prop 上</li>
<li>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</li>
</ul>
<p>在代码里面是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样子v-model应该就能正常工作了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="插槽-x2F-slot"><a href="#插槽-x2F-slot" class="headerlink" title="插槽 &#x2F; slot"></a>插槽 &#x2F; slot</h1><p>插槽的基本内容很简单，直接上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当我们需要向一个组件传递内容怎么办？ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">  Something bad happened.</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实现这个 <code>alert-box</code> 的方法很简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;alert-box&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>&lt;slot&gt;</code>的作用也很简单，如果没有这个标签那么传进来的内容都会被丢弃（起始标签和结束标签之间的任何内容）。</p>
<h2 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h2><p>有时候我们需要在不传内容进来时，插槽需要提供默认的内容，实现这个功能也很简单，只需要将内容填入<code>&lt;slot&gt;&lt;/slot&gt;</code>之间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>比如上面的<code>&lt;submit-button&gt;</code>子组件，插槽提供了默认的内容，那么调用时不提供插槽内容时：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span><span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将会渲染成</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是如果提供内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span>save<span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则会渲染成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Save</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="具名插槽-x2F-命名插槽"><a href="#具名插槽-x2F-命名插槽" class="headerlink" title="具名插槽 &#x2F; 命名插槽"></a>具名插槽 &#x2F; 命名插槽</h2><p>当我们需要多个插槽时，就需要使用命名插槽，直接上例子，比如我们需要一个带如下模板的<code>&lt;base-layout&gt;</code>组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这时候就需要使用slot的一个attribute：<code>name</code>，将上面代码改成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>中间没有命名的slot其实有个默认的名称：default<br>然后在向插槽提供内容是，在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指定名称即可，请注意语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者更明确一点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上面的<code>v-slot:xxx</code>语法是2.6.0之后的语法，在此之前的<code>slot=&quot;&quot;</code> 语法以及被废弃，同样 <code>slot-scope=&quot;&quot;</code> 的语法也变成 <code>v-slot=&quot;&quot;</code>，两个合起来用就是 <code>v-slot:xxx=&quot;xxx&quot;</code>。</p>
</blockquote>
<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><p>有时候我们需要在不同的组件之间进行动态切换。只需要设置一个特殊的 <code>is</code> attribute即可，直接上代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamic-component&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;currentComponent = &#x27;first-component&#x27;&quot;</span>&gt;</span>第一个组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;currentComponent = &#x27;second-component&#x27;&quot;</span>&gt;</span>第二个组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;first-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div id=&#x27;blog-post&#x27;&gt;</span></span><br><span class="line"><span class="string">  我是第一个组件</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;second-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div id=&#x27;blog-post&#x27;&gt;</span></span><br><span class="line"><span class="string">  我是第二个组件</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#dynamic-component&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">currentComponent</span>: <span class="string">&#x27;first-component&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>以上就是组件的基本内容，但是还有很多内容需要去了哦！下一小节补充组件注册和动态组件&amp;异步组件</p>
</blockquote>
<p>参考资料：<br><a href="https://cn.vuejs.org/v2/guide/components.html">VUE官方文档：组件基础</a><br><a href="https://cn.vuejs.org/v2/guide/components-props.html">VUE官方文档：Prop</a><br><a href="https://cn.vuejs.org/v2/guide/components-slots.html">VUE官方文档：插槽</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记（5）：VueRouter</title>
    <url>/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9AVue-router/</url>
    <content><![CDATA[<p>(下面基于vue2来讲解)</p>
<p>官方介绍：</p>
<blockquote>
<p>用 Vue.js + Vue Router 创建单页应用，感觉很自然：使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。</p>
</blockquote>
<span id="more"></span>

<h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/foo&quot;</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/bar&quot;</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 (路由) 组件。</span></span><br><span class="line"><span class="comment">// 可以从其他文件 import 进来</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;foo&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Bar</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;bar&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义路由</span></span><br><span class="line"><span class="comment">// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span></span><br><span class="line"><span class="comment">// 通过 Vue.extend() 创建的组件构造器，</span></span><br><span class="line"><span class="comment">// 或者，只是一个组件配置对象。</span></span><br><span class="line"><span class="comment">// 我们晚点再讨论嵌套路由。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Foo</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/bar&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Bar</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></span><br><span class="line"><span class="comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes <span class="comment">// (缩写) 相当于 routes: routes</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建和挂载根实例。</span></span><br><span class="line"><span class="comment">// 记得要通过 router 配置参数注入路由，</span></span><br><span class="line"><span class="comment">// 从而让整个应用都有路由功能</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，应用已经启动了！</span></span><br></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/yyx990803/xgrjzsup/">在线演示</a></p>
<h1 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h1><p>简单来说就是通过路由传递参数，比如路由url设置：’&#x2F;user&#x2F;:name’，当访问：’&#x2F;user&#x2F;foo’的时候将会映射到这个路由，然后在被调用的组件里通过$router.params.name获取到’foo’。</p>
<p>演示代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/yyx990803/4xfa2f19/">在线演示</a></p>
<p>除此之外还可与设置多端的参数，比如模式：’&#x2F;user&#x2F;:username&#x2F;post&#x2F;:post_id’，通过：’&#x2F;user&#x2F;evan&#x2F;post&#x2F;123’可以匹配到：<code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></p>
<h2 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h2><p>当匹配的模式不改变，只改变参数时，已经渲染的组件不会再次渲染，也就是各种钩子函数也不会生效，可以使用watch监听参数的变化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="title function_">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don&#x27;t forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获所有路由或-404-Not-found-路由"><a href="#捕获所有路由或-404-Not-found-路由" class="headerlink" title="捕获所有路由或 404 Not found 路由"></a>捕获所有路由或 404 Not found 路由</h2><blockquote>
<p>常规参数只会匹配被 &#x2F; 分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (<em>).<br>当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: ‘</em>‘ } 通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。</p>
</blockquote>
<p>也就是说，如果我们需要做一个404 Not Found 页面的话，可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NotFoundPage</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;404 Not Found!&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">component</span>: <span class="title class_">NotFoundPage</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样当跳转到路由没定义的url就会匹配上这一条规则。</p>
<h2 id="高级匹配模式"><a href="#高级匹配模式" class="headerlink" title="高级匹配模式"></a>高级匹配模式</h2><blockquote>
<p>vue-router 使用 path-to-regexp (opens new window)作为路径匹配引擎，所以支持很多高级的匹配模式，例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。</p>
</blockquote>
<p>下面是官方推荐的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="comment">// The matching uses path-to-regexp, which is the matching engine used</span></span><br><span class="line"><span class="comment">// by express as well, so the same matching rules apply.</span></span><br><span class="line"><span class="comment">// For detailed rules, see https://github.com/pillarjs/path-to-regexp</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: __dirname,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">// params are denoted with a colon &quot;:&quot;</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/params/:foo/:bar&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">// a param can be made optional by adding &quot;?&quot;</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/optional-params/:foo?&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">// a param can be followed by a regex pattern in parens</span></span><br><span class="line">    <span class="comment">// this route will only be matched if :id is all numbers</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/params-with-regex/:id(\\d+)&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">// asterisk can match anything</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/asterisk/*&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">// make part of the path optional by wrapping with parens and add &quot;?&quot;</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/optional-group/(foo/)?bar&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Route Matching&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;/&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/params/foo/bar&quot;&gt;/params/foo/bar&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/optional-params&quot;&gt;/optional-params&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/optional-params/foo&quot;&gt;/optional-params/foo&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/params-with-regex/123&quot;&gt;/params-with-regex/123&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/params-with-regex/abc&quot;&gt;/params-with-regex/abc&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/asterisk/foo&quot;&gt;/asterisk/foo&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/asterisk/foo/bar&quot;&gt;/asterisk/foo/bar&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/optional-group/bar&quot;&gt;/optional-group/bar&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/optional-group/foo/bar&quot;&gt;/optional-group/foo/bar&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;Route context&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;pre&gt;&#123;&#123; JSON.stringify($route, null, 2) &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h2><p>路由定义的优先级：<strong>路由定义得越早，优先级就越高</strong>。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack5学习笔记</title>
    <url>/uncategorized/Webpack5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue学习笔记（4）：Vuex基础</title>
    <url>/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9AVuex%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>vuex的学习笔记</p>
<span id="more"></span>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>最简单的使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样可以通过调用这个store使用vuex功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用了increment函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">state</span>.<span class="property">count</span>) </span><br><span class="line"><span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><blockquote>
<p>Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT (opens new window))”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
</blockquote>
<p>官网如是说道</p>
<h2 id="在组件中获取Vuex状态"><a href="#在组件中获取Vuex状态" class="headerlink" title="在组件中获取Vuex状态"></a>在组件中获取Vuex状态</h2><p>首先需要创建vue实例时将store绑定，这样就可以在所有的子组件通过 <code>this.$store</code> 调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.<span class="property">state</span>.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Counter</span> &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h2><p>演示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: <span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> + <span class="variable language_">this</span>.<span class="property">localCount</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: <span class="title function_">mapState</span>([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="使用对象展开运算符混合自定义计算属性"><a href="#使用对象展开运算符混合自定义计算属性" class="headerlink" title="使用对象展开运算符混合自定义计算属性"></a>使用对象展开运算符混合自定义计算属性</h2><p>演示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// 需要用到的状态</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h1><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数，而且可能多个组件都需要用到，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>
<p>那么就在store中定义getter吧（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br>演示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">todos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">done</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后就可以以属性的形式访问这些值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="property">doneTodos</span> </span><br><span class="line"><span class="comment">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></span><br></pre></td></tr></table></figure>
<p>Getter 也可以接受其他 getter 作为第二个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">doneTodosCount</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.<span class="property">doneTodos</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一样的方法调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="property">doneTodosCount</span> </span><br><span class="line"><span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>
</blockquote>
<h2 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h2><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">getTodoById</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">todos</span>.<span class="title function_">find</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">id</span> === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="title function_">getTodoById</span>(<span class="number">2</span>) </span><br><span class="line"><span class="comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>
</blockquote>
<h2 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h2><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapGetters</span>(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  <span class="attr">doneCount</span>: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h1><p>Mutation 作用是用于改变store里的值，只能同步提交。</p>
<blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用这个方式的途径是以相应的 type 调用 store.commit 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h2><p>可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.<span class="property">count</span> += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.<span class="property">count</span> += payload.<span class="property">amount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h2><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.<span class="property">count</span> += payload.<span class="property">amount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h2><ol>
<li>最好提前在你的 store 中初始化好所有所需属性。</li>
<li>当需要在对象上添加新属性时，你应该</li>
</ol>
<ul>
<li>使用 Vue.set(obj, ‘newProp’, 123), 或者</li>
<li>以新对象替换老对象。(可以使用展开运算符，将新属性合并成一个新对象)</li>
</ul>
<h2 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h2><p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>
<h2 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h2><p>Action 的分发通过 <code>store.dispatch</code> 方法触发： <code>store.dispatch(&#39;increment&#39;)</code></p>
<p>因为Action可以执行异步代码，比如这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;incrementAsync&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.<span class="property">cart</span>.<span class="property">added</span>]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    <span class="title function_">commit</span>(types.<span class="property">CHECKOUT_REQUEST</span>)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.<span class="title function_">buyProducts</span>(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">commit</span>(types.<span class="property">CHECKOUT_SUCCESS</span>),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">commit</span>(types.<span class="property">CHECKOUT_FAILURE</span>, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h2><p>在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapActions</span>([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h2><p>因为action可以异步执行，所以可以组合多个action。而且dispatch可以返回一个Promise，所以可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在另外一个 action 中也可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;someOtherMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用优雅的async await来改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getData</span>())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;gotOtherData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getOtherData</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记（3）：组件基础拓展</title>
    <url>/Vue/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<p>这节补充一下组件注册和动态组件&amp;异步组件</p>
<span id="more"></span>

<h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><p>在上一章展示了使用 <code>Vue.component(&#39;my-component-name&#39;, &#123;...&#125;)</code> 进行全局注册。全局注册之后可以用在任何新创建的 Vue 根实例 <code>new Vue()</code> 的模板中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-a&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-b&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-c&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-b</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component-c</span>&gt;</span><span class="tag">&lt;/<span class="name">component-c</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-c</span>&gt;</span><span class="tag">&lt;/<span class="name">component-c</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。</p>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>局部注册的缺点就是使用像webpack这样的构建系统时，就算不需要使用一个组件但是它仍然在构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。<br>而使用局部注册的方法就是使用 <code>components</code> 属性进行注册：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: <span class="title class_">ComponentA</span>,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: <span class="title class_">ComponentB</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果通过babel和webpack使用es6的话，可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">ComponentA</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h1><h2 id="使用-keep-alive"><a href="#使用-keep-alive" class="headerlink" title="使用 keep-alive"></a>使用 keep-alive</h2><p>在上一篇的实例：<code>&lt;component v-bind:is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</code> 中，每当切换组件时都会导致组件重新渲染，导致不必要的性能浪费。<br>使用 <code>&lt;keep-alive&gt;</code> 可以将组件在第一次被创建时缓存下来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamic-component&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;currentComponent = &#x27;first-component&#x27;&quot;</span>&gt;</span>第一个组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;currentComponent = &#x27;second-component&#x27;&quot;</span>&gt;</span>第二个组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部&#x2F;全局注册。</p>
</blockquote>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。<br>一个推荐的做法就是将异步组件和 webpack 的 code-splitting 功能一起配合使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;async-webpack-example&#x27;</span>, <span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，可以这样使用动态导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当使用局部注册的时候，也可以直接提供一个返回 Promise 的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;my-component&#x27;</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="处理加载状态"><a href="#处理加载状态" class="headerlink" title="处理加载状态"></a>处理加载状态</h2><p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">AsyncComponent</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  <span class="attr">component</span>: <span class="title function_">import</span>(<span class="string">&#x27;./MyComponent.vue&#x27;</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  <span class="attr">loading</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  <span class="attr">error</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员学习路线</title>
    <url>/%E5%B9%B2%E8%B4%A7/developer-roadmap/</url>
    <content><![CDATA[<p>程序员学习路线，让你少走弯路</p>
<span id="more"></span>
<h1 id="后端学习路线"><a href="#后端学习路线" class="headerlink" title="后端学习路线"></a>后端学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/backend-map.png" class="" title="后端学习路线">
<h1 id="前端学习路线"><a href="#前端学习路线" class="headerlink" title="前端学习路线"></a>前端学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/frontend-map.png" class="" title="前端学习路线">
<h1 id="Golang学习路线"><a href="#Golang学习路线" class="headerlink" title="Golang学习路线"></a>Golang学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/go.png" class="" title="前端学习路线">
<h1 id="DevOps学习路线"><a href="#DevOps学习路线" class="headerlink" title="DevOps学习路线"></a>DevOps学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/devops-map.png" class="" title="DevOps学习路线">
<h1 id="游戏客户端学习路线"><a href="#游戏客户端学习路线" class="headerlink" title="游戏客户端学习路线"></a>游戏客户端学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/client.png" class="" title="游戏客户端学习路线">
<h1 id="游戏服务端学习路线"><a href="#游戏服务端学习路线" class="headerlink" title="游戏服务端学习路线"></a>游戏服务端学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/server.png" class="" title="游戏服务端学习路线">
<h1 id="GameTester学习路线"><a href="#GameTester学习路线" class="headerlink" title="GameTester学习路线"></a>GameTester学习路线</h1><img src="/%E5%B9%B2%E8%B4%A7/developer-roadmap/qa.png" class="" title="GameTester学习路线">]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>const 和 Object.freeze() 的区别</title>
    <url>/JavaScript/const-%E5%92%8C-Object-freeze-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>这篇文章介绍了使用const和Object.freeze()在 JS中定义常量和配置值一些做法，以及它们之间的区别。</p>
<span id="more"></span>

<p>当我们在 JS 应用程序中定义常量和配置值时。它们应具有以下特点:</p>
<ul>
<li>跨应用程序可访问</li>
<li>量的值是不可变的</li>
<li>变量的引用应该是不可变的</li>
</ul>
<p>接下来一个一个看上面三个特征。</p>
<h1 id="使用-let"><a href="#使用-let" class="headerlink" title="使用 let"></a>使用 let</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">CONFIG</span> = <span class="string">&#x27;ip: 127.0.0.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getConfigCentent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable constant_">CONFIG</span> = <span class="string">&#x27;发生修改&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">CONFIG</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getConfigCentent</span>()  <span class="comment">//&#x27;发生修改&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面的值被修改了，那怎么防止值被修改呢</p>
<h1 id="使用-const"><a href="#使用-const" class="headerlink" title="使用 const"></a>使用 const</h1><p>当我们使用 <code>const</code> 来定义时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CONFIG</span> = <span class="string">&#x27;ip: 127.0.0.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getConfigCentent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable constant_">CONFIG</span> = <span class="string">&#x27;发生修改&#x27;</span>         <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">CONFIG</span>               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当修改时抛出错误，但是真的能防止值被修改吗？看下面操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruites = [<span class="string">&#x27;葡萄&#x27;</span>, <span class="string">&#x27;哈密瓜&#x27;</span>]</span><br><span class="line">fruites.<span class="title function_">push</span>(<span class="string">&#x27;香蕉&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruites )       <span class="comment">//[&quot;葡萄&quot;, &quot;哈密瓜&quot;, &quot;香蕉&quot;]</span></span><br></pre></td></tr></table></figure>
<p>或者使用对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constants = &#123;</span><br><span class="line">  <span class="attr">APP_NAME</span>: <span class="string">&quot;Foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">constants.<span class="property">APP_NAME</span> = <span class="string">&quot;已修改&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(constants.<span class="property">APP_NAME</span>) <span class="comment">//已修改</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>const</code> 的意思只是引用的地址值不能改变，但是能修改地址对应的对象的值</p>
<p>那怎么防止引用数据的值不被修改呢？</p>
<h1 id="使用-Object-freeze"><a href="#使用-Object-freeze" class="headerlink" title="使用 Object.freeze()"></a>使用 Object.freeze()</h1><p> <code>Object.freeze()</code> 的作用是忽略对象或者数组的值的改变<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> constants = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;</span><br><span class="line">  <span class="attr">APP_NAME</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">constants.<span class="property">APP_NAME</span> = <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(constants.<span class="property">APP_NAME</span>) <span class="comment">// foo</span></span><br></pre></td></tr></table></figure><br>可以从示例中看到，如果更改值，它不会抛出任何错误，也不会影响对象状态。但是他并不能阻止引用的修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> constants = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;</span><br><span class="line">  <span class="attr">APP_NAME</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">constants = &#123;</span><br><span class="line">   <span class="variable constant_">APP_NAME</span> : <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(constants.<span class="property">APP_NAME</span>); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure>

<p>看到这里，我猜善于思考的你在大脑中有答案了</p>
<h1 id="一起使用-const-和-Object-freeze"><a href="#一起使用-const-和-Object-freeze" class="headerlink" title="一起使用 const 和 Object.freeze()"></a>一起使用 const 和 Object.freeze()</h1><p>直接看效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Config</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;</span><br><span class="line">  <span class="variable constant_">APP_NAME</span> : <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Config</span>.<span class="property">APP_NAME</span> = <span class="string">&quot;bar&quot;</span>      <span class="comment">//依然是foo</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Config</span> = &#123;</span><br><span class="line">    <span class="variable constant_">APP_NAME</span> : <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;                            <span class="comment">//抛出上面一样的TypeError</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记（2）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>这是今天学习git的笔记（第二部分）</p>
<span id="more"></span>

<h1 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h1><p>当使用 <code>git checkout [commit]</code> 时，会出现分离头指针，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">6b21cfc (HEAD -&gt; master) 233</span><br><span class="line">59c56a8 123</span><br><span class="line"></span><br><span class="line">$ git checkout 59c56a8</span><br><span class="line">Note: switching to &#x27;59c56a8&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by switching back to a branch.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -c with the switch command. Example:</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation with:</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">Turn off this advice by setting config variable advice.detachedHead to false</span><br><span class="line"></span><br><span class="line">HEAD is now at 59c56a8 123</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从git的说明可以看出正在一个‘分离头指针’的状态，在这个状态下能继续产生commit或者丢弃任何产生的commit，而且不会影响其他的分支。</p>
<p>也就是说现在处于一个没有任何分支的情况下，当切换回其他分支，那么前面提交的commit很有可能被git当成垃圾并处理掉。</p>
<p>所以我们应该让他跟某个分支挂钩，在分支的基础上做修改就能保证安全性。</p>
<p>当然分离头指针也有好处，就是当我们觉得不需要某个commit的时候，能随时扔掉。</p>
<p>PS： 使用 <code>git commit -am &#39;something&#39;</code> 可以不存入暂存区，直接commit </p>
<p>这时候我们看看有多少个分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -av</span><br><span class="line">* (HEAD detached from 59c56a8) a14dd72 detached head</span><br><span class="line">  master                       6b21cfc 233</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们切换回master分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Warning: you are leaving 1 commit behind, not connected to</span><br><span class="line">any of your branches:</span><br><span class="line"></span><br><span class="line">  a14dd72 detached head</span><br><span class="line"></span><br><span class="line">If you want to keep it by creating a new branch, this may be a good time</span><br><span class="line">to do so with:</span><br><span class="line"></span><br><span class="line"> git branch &lt;new-branch-name&gt; a14dd72</span><br><span class="line"></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看出git在提醒我们有一个commit没有加到任何分支，而且现在是创建新分支的一个好时间（不然git可能会清理掉这个commit）</p>
<p>现在如果我们需要这个commit，那么最好先新建一个分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch fix_readme a14dd72</span><br><span class="line"></span><br><span class="line">$ git branch -av</span><br><span class="line">  fix_readme a14dd72 detached head</span><br><span class="line">* master     6b21cfc 233</span><br></pre></td></tr></table></figure>
<p>这样就可以新建一个分支出来</p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>可以使用 <code>git diff [commit] [commit]</code> 来比较两个commit的差异，其中commit可以用HEAD代替，或者使用HEAD^或者HEAD<del>来表示HEAD的父亲，HEAD^^是HEAD的父亲的父亲，也可以用HEAD</del>n来表示第n个父亲。</p>
<p>用 <code>git diff --cached</code> 可以查看暂存区和最新commit的差别。</p>
<p>而 <code>git diff</code> 比较的是工作区和暂存区的差别</p>
<p>如果只想对某个文件感兴趣，可以在末尾加上<code> -- [文件名]</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff -- readme.md</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$ git diff --cached -- readme.md</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h1 id="修改一个commit的message"><a href="#修改一个commit的message" class="headerlink" title="修改一个commit的message"></a>修改一个commit的message</h1><p>使用 <code>git commit --amend</code> 来修改最新的commit的message。</p>
<p>使用 <code>git rebase -i [想修改的commit的父亲]</code>。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline -n5</span><br><span class="line">08dfd6f (HEAD -&gt; master) test1</span><br><span class="line">e4a7951 补全信息</span><br><span class="line">c415064 (origin/master, origin/HEAD) 更新git学习笔记</span><br><span class="line">1f18a2b 修改git学习笔记</span><br><span class="line">bf7beab 更新git学习笔记</span><br><span class="line"></span><br><span class="line">$ git rebase -i c415064</span><br></pre></td></tr></table></figure>
<p>使用这个命令后会弹出一个文件让我们做交互操作，下面我们开始修改message为“补全信息”的那个message。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick e4a7951 补全信息</span><br><span class="line">pick 08dfd6f test1</span><br><span class="line"></span><br><span class="line"># Rebase c415064..08dfd6f onto c415064 (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#x27;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由下面提示的命令可以知道，我们需要reword命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r e4a7951 补全信息</span><br><span class="line">pick 08dfd6f test1</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>然后就弹出一个新的交互文件，我们就可以看到那个commit的message，只需要修改保存，git就能自动处理我们的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline -n5</span><br><span class="line">0878b1b (HEAD -&gt; master) test1</span><br><span class="line">f6090dd 补全其他文章的信息</span><br><span class="line">c415064 (origin/master, origin/HEAD) 更新git学习笔记</span><br><span class="line">1f18a2b 修改git学习笔记</span><br><span class="line">bf7beab 更新git学习笔记</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和开始的那个commit相比他的哈希值已经发生了改变，从git的操作过程来看，git也使用了一个分离头指针操作，并且把commit的内容copy到新的commit。</p>
<blockquote>
<p>注意：变基操作只能在自己负责的分支进行，如果已经合并到了主分支尽量不要对主分支进行变基操作，否者会对别人造成影响。</p>
</blockquote>
<h1 id="把多个连续的commit合并成一个"><a href="#把多个连续的commit合并成一个" class="headerlink" title="把多个连续的commit合并成一个"></a>把多个连续的commit合并成一个</h1><p>同上，我们需要用到rebase变基操作，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline -n6</span><br><span class="line">0878b1b (HEAD -&gt; master) test1</span><br><span class="line">f6090dd 补全其他文章的信息</span><br><span class="line">c415064 (origin/master, origin/HEAD) 更新git学习笔记</span><br><span class="line">1f18a2b 修改git学习笔记</span><br><span class="line">bf7beab 更新git学习笔记</span><br><span class="line">d8eea00 新增html5学习笔记</span><br></pre></td></tr></table></figure>
<p>我们中间有三个commit完全可以合并成一个commit，在上面的rebase操作中我们可以看到一行：<code># s, squash &lt;commit&gt; = use commit, but meld into previous commit</code>，意思是把保留使用commit并且合并到一个commit。使用我们使用他们的一个父亲commit：d8eea00</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase -i d8eea00</span><br></pre></td></tr></table></figure>
<p>这时候生成的文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick bf7beab 更新git学习笔记</span><br><span class="line">pick 1f18a2b 修改git学习笔记</span><br><span class="line">pick c415064 更新git学习笔记</span><br><span class="line">pick f6090dd 补全其他文章的信息</span><br><span class="line">pick 0878b1b test1</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>修改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick bf7beab 更新git学习笔记</span><br><span class="line">s 1f18a2b 修改git学习笔记</span><br><span class="line">s c415064 更新git学习笔记</span><br><span class="line">pick f6090dd 补全其他文章的信息</span><br><span class="line">pick 0878b1b test1</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这时候生成一个新的交互文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">更新git学习笔记</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">修改git学习笔记</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>我们在第一行注释下面写上新的commit的message：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line">更新git学习笔记</span><br><span class="line"># This is the 1st commit message:</span><br><span class="line"></span><br><span class="line">更新git学习笔记</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这时候来看看是否发生改变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline -n4</span><br><span class="line">353aa27 (HEAD -&gt; master) test1</span><br><span class="line">ac6799e 补全其他文章的信息</span><br><span class="line">aee07b0 更新git学习笔记</span><br><span class="line">d8eea00 新增html5学习笔记</span><br></pre></td></tr></table></figure>
<p>成功把三个commit合并到一个commit</p>
<h1 id="把多个不连续的commit合并成一个"><a href="#把多个不连续的commit合并成一个" class="headerlink" title="把多个不连续的commit合并成一个"></a>把多个不连续的commit合并成一个</h1><p>操作和联系的基本一样，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick a xxx</span><br><span class="line">pick b xxx</span><br><span class="line">pick c xxx</span><br></pre></td></tr></table></figure>
<p>我们如果想把a和c合并只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick a xxx</span><br><span class="line">squash c xxx</span><br><span class="line">pick b xxx</span><br></pre></td></tr></table></figure>
<p>不过有可能发生一些事情，可以用<code>git status</code>查看信息，并用<code>git rebase --continue</code>，然后就回到连续commit合并时相同的界面，和上面操作一样写上message保存关闭文件即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记（3）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>开始学习协作</p>
<span id="more"></span>

<h1 id="让暂存区恢复成HEAD一样的状态"><a href="#让暂存区恢复成HEAD一样的状态" class="headerlink" title="让暂存区恢复成HEAD一样的状态"></a>让暂存区恢复成HEAD一样的状态</h1><p>使用 <code>git reset HEAD -- &lt;file&gt;...</code> 可以把暂存区的某个文件恢复成HEAD指向的commit，如果直接使用 <code>git reset HEAD</code> 将会把整个暂存区还原成HEAD的状态。</p>
<h1 id="让工作区恢复成暂存区一样"><a href="#让工作区恢复成暂存区一样" class="headerlink" title="让工作区恢复成暂存区一样"></a>让工作区恢复成暂存区一样</h1><p>使用 <code>git checkout -- &lt;file&gt;</code> 可以把工作区的文件恢复成暂存区的状态。 </p>
<h1 id="删除最近的几个分支"><a href="#删除最近的几个分支" class="headerlink" title="删除最近的几个分支"></a>删除最近的几个分支</h1><p>使用 <code>git reset --hard [commit]</code> 可以把当前分支的HEAD还原成以前的某个commit状态</p>
<blockquote>
<p>注意：使用该命令会把工作区和暂存区一起还原，比较危险。</p>
</blockquote>
<h1 id="比较两个分支或者commit的差别"><a href="#比较两个分支或者commit的差别" class="headerlink" title="比较两个分支或者commit的差别"></a>比较两个分支或者commit的差别</h1><p>使用 <code>git diff [branch1] [branch2] -- &lt;file&gt;</code> ，查看两个分支的差别，如果不使用– file的话会把所有的差异全部列出来。</p>
<p>当然也可以用commit的id代替分支名也可以查看两个commit的差异。</p>
<h1 id="删除文件的操作"><a href="#删除文件的操作" class="headerlink" title="删除文件的操作"></a>删除文件的操作</h1><p>可以直接使用 <code>git rm [file]</code> 命令，而不需要rm再git rm，一步到位。</p>
<h1 id="临时存放工作区的状态"><a href="#临时存放工作区的状态" class="headerlink" title="临时存放工作区的状态"></a>临时存放工作区的状态</h1><p>使用 <code>git stash</code> 可以把现在工作区里的状态存入一个堆栈里，当需要紧急完成某些其他的任务时可能需要用到。 <code>git shash list</code> 可以查看堆栈里存放的信息，可以使用 <code>git shtash apply/pop</code> 可以把顶部储存的状态还原到工作区，区别在于apply不会清除堆栈的信息，pop会直接弹出（删除）堆栈里的信息。</p>
<h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><p>使用 <code>git clone --bare [url]</code> 可以把远端不带工作区的仓库克隆过来。</p>
<h1 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h1><p>使用 <code>git remote add [name] [url]</code> 可以把远端的仓库地址加到这个仓库，<code>git remote -v</code> 可以查看远端地址。</p>
<h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><p>命令： <code>git push [远程主机名] [本地分支名] &lt;远程分支名&gt;</code>，加 <code>-u</code> 比如：<code>git push -u origin master</code>，可以指定一个默认主机，这样后面就可以直接使用 <code>git push</code> 。</p>
<p>如果本地版本库比远程服务器上低，可以使用 <code>--force</code> 强制推送。</p>
<blockquote>
<p><code>-u</code> 是 <code>--set-upstream</code> 的省略形式。</p>
</blockquote>
<h1 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h1><p>如果两个用户修改了不同文件可以先使用fetch把一个用户的修改拉下来，然后使用 <code>git merge [要合并的分支]</code> ，就能进行合并，工作区的文件也会被修改，然后就可以顺利的push。</p>
<p>当两个用户修改了同文件的不同区域，也可以顺利地进行merge操作。</p>
<p>使用merge操作后新的commit拥有两个parent。</p>
<h1 id="不同的人修改了同一文件同一区域"><a href="#不同的人修改了同一文件同一区域" class="headerlink" title="不同的人修改了同一文件同一区域"></a>不同的人修改了同一文件同一区域</h1><p>先进行 <code>git pull</code> 更新本地的版本库，然后会可能会出现自动merge失败，然后打开冲突的文件，进行修改，保存，然后进行 <code>git add</code> 和 <code>git commit</code> 操作即可完成合并。 但是如果不想merge就可以 <code>git merge --abort</code> 即可退出merge操作。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记（1）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>可能是比较详细的git笔记</p>
<span id="more"></span>

<h1 id="第一步：安装和配置"><a href="#第一步：安装和配置" class="headerlink" title="第一步：安装和配置"></a>第一步：安装和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Debian系上安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</span><br><span class="line">$ apt-get install git</span><br><span class="line">$ git --version</span><br><span class="line">git version xxxxx</span><br></pre></td></tr></table></figure>

<p>在红帽系上安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br><span class="line"></span><br><span class="line">$ yum -y install git-core</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version xxxxx</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;name&quot;</span><br><span class="line">$ git config --global user.email abc@abc.com</span><br></pre></td></tr></table></figure>

<p>除了global还有local（针对某仓库）和system。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="仓库初始化和简单使用"><a href="#仓库初始化和简单使用" class="headerlink" title="仓库初始化和简单使用"></a>仓库初始化和简单使用</h2><p>使用 <code>git init</code> 初始化一个仓库，init后可以加一个目录可以自定在某个目录初始化。<br>使用 <code>git add</code> 对文件进行跟踪。<br>使用 <code>git commit</code> 进行提交。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;第一次提交&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>如果想修改一个文件的名称，不需要 <code>git add</code> 和 <code>git rm</code> ，使用一个<code>git mv name rename</code> 就可以了，然后commit一次就完成更名操作。</p>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p><code>git clone [url]</code>可以克隆某个网上的仓库<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/someone/somelib</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就会在当前目录下创建一个somelib目录，并在该目录下初始化一个.git文件夹,从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。</p>
<p>当已经存在同名目录，可以在url后加一个不太的名字，就可以自定义本地仓库名字。</p>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p><code>git log</code> 能查看每一次提交的用户、邮箱地址、提交时间、提交说明。</p>
<p><code>git log --oneline</code> 能查看简洁的列表</p>
<p><code>git log -n 数字</code> 能查看最近的几个</p>
<p>–online 和 -n 可以合并使用</p>
<p><code>git log --all</code> 可以查看所有分支的log，不使用–all只输出当前head指向的分支的log。</p>
<p>如果使用–all加-n就会在–all基础上限制只输出几个。</p>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>使用<code>git branch</code>可以查看本地所有分支，<code>git branch -av</code> 还可以查看分支最新的commit和提交说明</p>
<p>使用 <code>git branch -d/D [分支名]</code> 可以删除某个分支，当用-d无法删除时要用-D删除。</p>
<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p><code>git checkout [分支名]</code> 可以切换到某个分支 </p>
<p><code>git checkout -b [分支名] [基于某个分支]</code>可以先基于某个分支创建一个新的分支并且切换到那个分支。</p>
<h1 id="git目录内容"><a href="#git目录内容" class="headerlink" title=".git目录内容"></a>.git目录内容</h1><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>文件里的内容是：<code>ref: refs/heads/xxx</code><br>说明现在的head指向的是哪一个分支</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>里面储存的是当前仓库的一些设置，如果通过上面的 <code>git config --local</code> 修改了这个仓库的的user.name和email，那么这个文件下会有<code>[user]</code>字段，当在这里修改了name或者email的值时，使用<code>git config --local --list</code>可以看出修改后的值。</p>
<p>反之亦然，使用 <code>git config --global user.name &quot;xxx&quot;</code> 后可以发现config里面的内容也修改了。</p>
<blockquote>
<p>ps. 使用 <code>git config --local user.name</code> 可以查看当前仓库的用户 </p>
</blockquote>
<h2 id="refs目录"><a href="#refs目录" class="headerlink" title="refs目录"></a>refs目录</h2><p>refs目录包括了heads和tags目录</p>
<h3 id="heads目录"><a href="#heads目录" class="headerlink" title="heads目录"></a>heads目录</h3><p>这个目录存放的是仓库的分支，比如仓库初始化后默认只有一个master分支，那么这个heads目录下就有一个名为master文件。</p>
<p>而master里面是一个40位的哈希值（也是一个对象），我们可以使用<code>git cat-file -t xxx</code>查看他的类型：<br>比如我的某个仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd .git/refs/heads</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">master</span><br><span class="line"></span><br><span class="line">$ cat master</span><br><span class="line">59c56a87fcf4debcdcb794acad72b0613d838611</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 59c56</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>

<p>通过这个操作可以看出这个master里的一串哈希值是一个commit，而且是当前分支最新的一个commit</p>
<h3 id="tags目录"><a href="#tags目录" class="headerlink" title="tags目录"></a>tags目录</h3><p>存放的是所有</p>
<h2 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h2><p>放的是各种对象，使用 <code>find .git/objects -type f</code> 可以查看各个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/4d/18ac21026a0e9fa0681ea72c3c1ac4a597bbea</span><br><span class="line">.git/objects/59/c56a87fcf4debcdcb794acad72b0613d838611</span><br><span class="line">.git/objects/6b/21cfcbab815ab0495b8a2d427ab97528ef56da</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的cat-file命令进行查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t 4d18ac21026</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 4d18ac21026</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme.md</span><br><span class="line">100644 blob f2ba8f84ab5c1bce84a7b441cb1959cfc7093b7f    test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="commit对象的结构"><a href="#commit对象的结构" class="headerlink" title="commit对象的结构"></a>commit对象的结构</h1><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/commit.png" class="" title="commit结构图">

<p>可以使用 <code>git cat-file -p</code> 可以查看各个对象的内容</p>
<p>比如上面objects里的那个test.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p f2ba8f84</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<p>可以直接查看文件（blob）的内容</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的一些详情</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<h1 id="博客由于个人操作问题导致的数据丢失"><a href="#博客由于个人操作问题导致的数据丢失" class="headerlink" title="博客由于个人操作问题导致的数据丢失"></a>博客由于个人操作问题导致的数据丢失</h1><blockquote>
<p>由于操作失误，导致大部分数据丢失，但是恢复数据比较麻烦，现在已经恢复所有数据，新的一年将会继续分享一波各种干货哦，比如各种黑科技软件，电脑及配件的推荐，补完C入门指北等等，</p>
</blockquote>
<h1 id="重大更新！"><a href="#重大更新！" class="headerlink" title="重大更新！"></a>重大更新！</h1><p><strong>博客已加入Pjax刷新，查看文章再也不会刷新全页面，妈妈再也不怕我听歌时点击其他文章时被打断啦！</strong></p>
<h1 id="一些小改进"><a href="#一些小改进" class="headerlink" title="一些小改进"></a>一些小改进</h1><ul>
<li>之前因为混用crlf和lf经常导致代码提交失败，这次统一所有代码，采用lf换行。</li>
<li>加入阅读次数，让我康康到底有多少人看（滑稽）</li>
</ul>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 每次点击其他页面会刷新整个页面，导致音乐播放器重新价值然后重新播放歌曲，非常影响使用体验，需要采用Pjax解决</li>
<li><input disabled="" type="checkbox"> 貌似有时候会出现回不到主页的问题，控制台报跨域错误，看看能不能修复一下</li>
<li><input disabled="" type="checkbox"> 无法显示无序标签和有序标签，可能是渲染引擎的锅，算了这个不怎么影响观看就不理了</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>java课后题总结</title>
    <url>/uncategorized/java%E8%AF%BE%E5%90%8E%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>自己写的垃圾代码(下面只给出主体代码)</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="输出全部大写字母"><a href="#输出全部大写字母" class="headerlink" title="输出全部大写字母"></a>输出全部大写字母</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、快速打印：</span></span><br><span class="line">System.out.println(<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>);</span><br><span class="line"><span class="comment">//2、循环打印</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">char</span> <span class="variable">upperCharStart</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>, upperCharEnd = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> <span class="variable">i</span> <span class="operator">=</span> upperCharStart; i &lt;= upperCharEnd; i++) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;猜一个1到100之间的整数&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">realNum</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.print(<span class="string">&quot;请输入您的猜测：&quot;</span>);</span><br><span class="line">guess = reader.nextInt();</span><br><span class="line"><span class="keyword">while</span> (guess != realNum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (guess &gt; realNum) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猜大了，请再输入&quot;</span>);</span><br><span class="line">        guess = reader.nextInt();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猜小了，请再输入&quot;</span>);</span><br><span class="line">        guess = reader.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;猜对了&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="求1000以内的完数"><a href="#求1000以内的完数" class="headerlink" title="求1000以内的完数"></a>求1000以内的完数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;一千以内的完数是：&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= range; i++) &#123;</span><br><span class="line">    <span class="comment">// sum用于记录真因子的和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为完数，是则输出</span></span><br><span class="line">    <span class="keyword">if</span> (sum == i) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求最大整数"><a href="#求最大整数" class="headerlink" title="求最大整数"></a>求最大整数</h2><p>求满足1!+2!+3!+…+n!≤9876的最大整数n </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;; i++) &#123;</span><br><span class="line">    <span class="comment">// sum记录阶乘的和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="comment">// factorial记录阶乘的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">factorial</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= j; k++) &#123;</span><br><span class="line">            factorial *= k;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += factorial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当达到要求后</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">9876</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为已经超出要求值，所以最大值为当前循环量减一</span></span><br><span class="line">        result = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;最大整数n为：&quot;</span> + result);</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            arr[j] = arr[j] ^ arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j] ^ arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j] = arr[j] ^ arr[j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hundred</span> <span class="operator">=</span> i / <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> (i - hundred * <span class="number">100</span>) / <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> i % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (one*one*one+ten*ten*ten+Math.pow(hundred, <span class="number">3</span>) == i) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="获取字符串中第一个和最后一个字符"><a href="#获取字符串中第一个和最后一个字符" class="headerlink" title="获取字符串中第一个和最后一个字符"></a>获取字符串中第一个和最后一个字符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有字符串str</span></span><br><span class="line"><span class="type">char</span> <span class="variable">start</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line"><span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> str.charAt(str.length() - <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;首个字符是：&quot;</span>+start+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;最后一个字符是：&quot;</span>+end);</span><br></pre></td></tr></table></figure>

<h2 id="剔除字符串中全部非数字字符"><a href="#剔除字符串中全部非数字字符" class="headerlink" title="剔除字符串中全部非数字字符"></a>剔除字符串中全部非数字字符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ab123cd45&quot;</span>;</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\D+&quot;</span>).matcher(s);</span><br><span class="line">System.out.println(m.replaceAll(<span class="string">&quot;&quot;</span>));   <span class="comment">//输出：12345</span></span><br></pre></td></tr></table></figure>

<h2 id="解析字符串中的数字"><a href="#解析字符串中的数字" class="headerlink" title="解析字符串中的数字"></a>解析字符串中的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="string">&quot;数学87分，物理76分，英语96分&quot;</span>)).useDelimiter(<span class="string">&quot;\\D+&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sum += s.nextInt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;总成绩为：&quot;</span> + sum + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;平均分为：&quot;</span> + sum/<span class="number">3.0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="了解打印流"><a href="#了解打印流" class="headerlink" title="了解打印流"></a>了解打印流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;p.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out);</span><br><span class="line">    ps.print(<span class="number">12345.6789</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;how are you&quot;</span>);</span><br><span class="line">    ps.println(<span class="literal">true</span>);</span><br><span class="line">    ps.close();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException ignored) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析文件中的数字"><a href="#解析文件中的数字" class="headerlink" title="解析文件中的数字"></a>解析文件中的数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;cost.txt&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(file);</span><br><span class="line">    sc.useDelimiter(<span class="string">&quot;[^0-9.]+&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            sum += price;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InputMismatchException ignored) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;平均价格为：&quot;</span> + sum/count);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="线程sleep打断"><a href="#线程sleep打断" class="headerlink" title="线程sleep打断"></a>线程sleep打断</h2><p>有三个线程student1、student2、teacher，student1准备睡10分钟再上课，student2准备睡一个小时后上课，teacher输出三句“上课”后吵醒student1，student1被吵醒后负责吵醒student2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassRoom</span> <span class="variable">classRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassRoom</span>();</span><br><span class="line">        classRoom.map.get(<span class="string">&quot;student1&quot;</span>).start();</span><br><span class="line">        classRoom.map.get(<span class="string">&quot;student2&quot;</span>).start();</span><br><span class="line">        classRoom.map.get(<span class="string">&quot;teacher&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassRoom</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    Thread attachThread;</span><br><span class="line">    Map&lt;String, Thread&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Thread&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ClassRoom() &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">        teacher.setName(<span class="string">&quot;teacher&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">        student1.setName(<span class="string">&quot;student1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">        student2.setName(<span class="string">&quot;student2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;teacher&quot;</span>, teacher);</span><br><span class="line">        map.put(<span class="string">&quot;student1&quot;</span>, student1);</span><br><span class="line">        map.put(<span class="string">&quot;student2&quot;</span>, student2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//字符串放前面避免空指报空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;student1&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;student1先睡10分钟再上课&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;student1被叫醒了\nstudent1正在叫醒student2&quot;</span>);</span><br><span class="line">                map.get(<span class="string">&quot;student2&quot;</span>).interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;student2&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;student2先睡一个小时再上课&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;student2被叫醒了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;上课&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(<span class="string">&quot;student1&quot;</span>).interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程联合"><a href="#线程联合" class="headerlink" title="线程联合"></a>线程联合</h2><p>创建三个线程：运货司机、装运工、仓库管理员。要求运货司机占有CPU后立刻联合装运工（也就是等到装运工完成后开车），装运工占有CPU后立刻联合仓库管理员（等到仓库管理员打开仓库后开始装运）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadJoin</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadJoin</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(a);</span><br><span class="line">        driver.setName(<span class="string">&quot;运货司机&quot;</span>);</span><br><span class="line">        driver.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadJoin</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    Map&lt;String, Thread&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Thread&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ThreadJoin() &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">porter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">        porter.setName(<span class="string">&quot;搬运工&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">storekeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">        storekeeper.setName(<span class="string">&quot;仓库管理员&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;搬运工&quot;</span>, porter);</span><br><span class="line">        map.put(<span class="string">&quot;仓库管理员&quot;</span>,storekeeper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;运货司机&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;运货司机：等待搬运工&quot;</span>);</span><br><span class="line">                map.get(<span class="string">&quot;搬运工&quot;</span>).start();</span><br><span class="line">                map.get(<span class="string">&quot;搬运工&quot;</span>).join();</span><br><span class="line">                System.out.println(<span class="string">&quot;运货司机：开始发车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;搬运工&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;搬运工：等待仓库管理员打开仓库&quot;</span>);</span><br><span class="line">                map.get(<span class="string">&quot;仓库管理员&quot;</span>).start();</span><br><span class="line">                map.get(<span class="string">&quot;仓库管理员&quot;</span>).join();</span><br><span class="line">                System.out.println(<span class="string">&quot;搬运工:开始搬运....\n搬运工:搬运完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;仓库管理员&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;仓库管理员：正在打开仓库...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>使用套接字编写网络程序，客户输入三角形的三边并发送给服务器，服务器把计算得到的结果返回。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8082</span>;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器启动成功，绑定端口：&quot;</span> + port);</span><br><span class="line">            <span class="comment">// 创建线程池</span></span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//获得socket并生成对于的handle</span></span><br><span class="line">                <span class="type">Handle</span> <span class="variable">handle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handle</span>(serverSocket.accept());</span><br><span class="line">                <span class="comment">//提交任务给线程池，让线程池自行管理线程，通过线程复用提高性能</span></span><br><span class="line">                es.execute(handle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handle</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Handle(Socket socket) &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">firstSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">secondSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">thirdSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得输入输出流接口</span></span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">                <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">                <span class="comment">// 输入边长</span></span><br><span class="line">                out.writeUTF(<span class="string">&quot;请输入第一条边长:&quot;</span>);</span><br><span class="line">                firstSide = Double.parseDouble(in.readUTF());</span><br><span class="line">                out.writeUTF(<span class="string">&quot;请输入第二条边长:&quot;</span>);</span><br><span class="line">                secondSide = Double.parseDouble(in.readUTF());</span><br><span class="line">                out.writeUTF(<span class="string">&quot;请输入第三条边长:&quot;</span>);</span><br><span class="line">                thirdSide = Double.parseDouble(in.readUTF());</span><br><span class="line">                <span class="comment">//计算面积并让用户决定是否继续</span></span><br><span class="line">                <span class="keyword">if</span> (firstSide + secondSide &gt; thirdSide &amp;&amp;</span><br><span class="line">                    firstSide + thirdSide &gt; secondSide &amp;&amp;</span><br><span class="line">                    secondSide + thirdSide &gt; firstSide) &#123;</span><br><span class="line">                    <span class="comment">//半周长</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">l</span> <span class="operator">=</span> (firstSide + secondSide + thirdSide) / <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//面积</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> Math.sqrt(l * (l - firstSide) * (l - secondSide) * (l - thirdSide));</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;可以构成三角形，&quot;</span> + <span class="string">&quot;三角形面积为：&quot;</span> + area + <span class="string">&quot;\n是否退出？（Y：退出，N：继续，默认：退出）&quot;</span>;</span><br><span class="line">                    out.writeUTF(str);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.writeUTF(<span class="string">&quot;不能构成三角形!&quot;</span> + <span class="string">&quot;\n是否退出？（Y：退出，N：继续，默认：退出）&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断是否退出</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">check</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;N&quot;</span>.equals(in.readUTF())) &#123;</span><br><span class="line">                    check = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (check == <span class="number">1</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 抛出异常后应该立刻退出，不然会因为while而无限循环无法退出而且不能将资源让给其他用户</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 下面的ip请改成你的服务端ip，如果在本地运行则使用127.0.1.1</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;123.123.123.123&quot;</span>, <span class="number">8082</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器连接成功&quot;</span>);</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(clientSocket.getInputStream());</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(clientSocket.getOutputStream());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.print(in.readUTF());</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                out.writeUTF(scanner.nextLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已关闭连接&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;&#x3D;&#x3D; to be continued</p>
]]></content>
  </entry>
  <entry>
    <title>js元编程笔记：代理</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E5%85%83%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>从ECMAScript 2015 开始，JavaScript 获得了 Proxy 和 Reflect 对象的支持，允许你拦截并定义基本语言操作的自定义行为（例如，属性查找，赋值，枚举，函数调用等）。借助这两个对象，你可以在 JavaScript 元级别进行编程。    —— MDN</p>
</blockquote>
<span id="more"></span>

<p>在 ECMAScript 6 中引入的 <code>Proxy</code> 对象可以拦截某些操作并实现自定义行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler)</span><br><span class="line">p.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">a</span>, p.<span class="property">b</span>)       <span class="comment">//1 -1</span></span><br></pre></td></tr></table></figure>

<p>这里Proxy对象定义了一个目标（空对象）和一个实现了 <code>get</code> 陷阱的handle对象，这时候对代理的对象未定义的属性进行 <code>get</code> 操作时不会返回 <code>undefined</code> 而是-1。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p><strong>handler</strong>: 包含陷阱的占位符对象。<br><strong>traps</strong>: 提供属性访问的方法。这类似于操作系统中陷阱的概念。<br><strong>target</strong>: 代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。<br><strong>invariants</strong>: 实现自定义操作时保持不变的语义称为不变量。如果你违反处理程序的不变量，则会抛出一个 <code>TypeError</code>。</p>
<h1 id="句柄和陷阱"><a href="#句柄和陷阱" class="headerlink" title="句柄和陷阱"></a>句柄和陷阱</h1><h2 id="handler-get"><a href="#handler-get" class="headerlink" title="handler.get()"></a>handler.get()</h2><table>
<thead>
<tr>
<th>Handler &#x2F; trap</th>
<th>Interceptions</th>
<th>Invariants</th>
</tr>
</thead>
<tbody><tr>
<td>handler.get()</td>
<td>Property access: proxy[foo]and proxy.bar<br>Inherited property access: Object.create(proxy)[foo]<br>Reflect.get()</td>
<td>* The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property. <br> * The value reported for a property must be undefined if the corresponding target object property is non-configurable accessor property that has undefined as its [[Get]] attribute.</td>
</tr>
</tbody></table>
<p>可以看出，这个陷阱能拦截一个对象的读取属性操作，甚至对通过 <code>Object.create</code> 创建的对象使用这个陷阱。(还有<code>Reflect.get()</code>也可以)</p>
<p>但是在 <code>Invariants</code> 中可以看到，第一个约束是：如果属性特征的 <code>configurable</code> 或者 <code>writable</code> 设置为false而且get不返回原来的值就会导致报错。</p>
<p>（第二个还搞不清楚）</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>&#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">return</span> target[property]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">`property name &quot;<span class="subst">$&#123;property&#125;</span>&quot; does not exist`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)   <span class="comment">//foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>)    <span class="comment">//Uncaught ReferenceError: property name &quot;age&quot; does not exist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defindProperty</span>(obj1, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj1, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;返回其他值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br><span class="line"><span class="comment">//Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;name&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;foo1&#x27; but got &#x27;返回其他值&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当writable或者configurable为false时，如果不是返回属性的值的话，会自动抛出一个TypeError。</p>
<h2 id="handler-set"><a href="#handler-set" class="headerlink" title="handler.set()"></a>handler.set()</h2><table>
<thead>
<tr>
<th>Handler &#x2F; trap</th>
<th>Interceptions</th>
<th>Invariants</th>
</tr>
</thead>
<tbody><tr>
<td>handler.get()</td>
<td>Property assignment: proxy[foo] &#x3D; bar and proxy.foo &#x3D; bar<br>Inherited property assignment: Object.create(proxy)[foo] &#x3D; bar<br>Reflect.set()</td>
<td>Cannot change the value of a property to be different from the value of the corresponding target object property if the corresponding target object property is a non-writable, non-configurable data property.<br> Cannot set the value of a property if the corresponding target object property is a non-configurable accessor property that has undefined as its [[Set]] attribute.<br>In strict mode, a false return value from the set handler will throw a TypeError exception.</td>
</tr>
</tbody></table>
<p>这个方法是设置属性值操作的捕获器，当使用方括号或者点为属性赋值时能捕获，当指定继承者的属性值也可以捕获（Object.create(proxy)[foo] &#x3D; bar），当然<code>Reflect.set()</code>也可以。</p>
<p>当违背下面约束时会抛出TypeError异常：</p>
<ul>
<li>若目标属性是一个不可写及不可配置的数据属性，则不能改变它的值。</li>
<li>如果目标属性没有配置存储方法，即 [[Set]] 属性的是 undefined，则不能设置它的值。</li>
<li>在严格模式下，如果 set() 方法返回 false，那么也会抛出一个 TypeError 异常。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, prop, value, receiver</span>) &#123;</span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;property set: &#x27;</span> + prop + <span class="string">&#x27; = &#x27;</span> + value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">a</span> = <span class="number">10</span>;               <span class="comment">// &quot;property set: a = 10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">a</span>);       <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="handler-apply"><a href="#handler-apply" class="headerlink" title="handler.apply()"></a>handler.apply()</h2><p><code>handler.apply()</code> 方法用于拦截函数的调用。</p>
<p>不多说直接上例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calculate sum: <span class="subst">$&#123;argumentsList&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// expected output: &quot;Calculate sum: 1,2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">target</span>(argumentsList[<span class="number">0</span>], argumentsList[<span class="number">1</span>]) * <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy1</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: 30</span></span><br></pre></td></tr></table></figure>
<p>其中target是目标对象（函数），thisArg为被调用时的上下文对象(也就是this指向)，argumentsList为被调用时的参数数组。</p>
<p>该方法会拦截目标对象的以下操作:</p>
<ul>
<li>proxy(…args)</li>
</ul>
<blockquote>
<p>还有一些其他的handle，感觉不太需要，所以先放下，学习其他的内容</p>
</blockquote>
<hr>
<h1 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">View</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="comment">//设置代理拦截</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span></span><br><span class="line"><span class="language-javascript">    &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">get</span>(<span class="params">obj, property</span>) &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">set</span>(<span class="params">obj, property, value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        obj[property] = value;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span></span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">querySelectorAll</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="string">`[v-model=&quot;<span class="subst">$&#123;property&#125;</span>&quot;],[v-bind=&quot;<span class="subst">$&#123;property&#125;</span>&quot;]`</span></span></span><br><span class="line"><span class="language-javascript">          )</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">forEach</span>(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            el.<span class="property">innerHTML</span> = value;</span></span><br><span class="line"><span class="language-javascript">            el.<span class="property">value</span> = value;</span></span><br><span class="line"><span class="language-javascript">          &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  );</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//初始化绑定元素事件</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">this</span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> els = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;[v-model]&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    els.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      item.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        proxy[<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;v-model&quot;</span>)] = <span class="variable language_">this</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">View</span>().<span class="title function_">run</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>未完待续</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js核心知识进阶笔记（1）：this指向</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9Athis%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>所有知识来自：前端开发知识进阶：从夯实基础到突破瓶颈。</p>
<span id="more"></span>

<h1 id="this-到底指向谁"><a href="#this-到底指向谁" class="headerlink" title="this 到底指向谁"></a>this 到底指向谁</h1><p>最广为流传的说法是：“谁调用它，this 就指向谁”。这其实并不准确。准确来说是执行上下文。</p>
<p>在讲细节之前可以先“死记硬背”几条规则：</p>
<ul>
<li>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 this 会被绑定到 undefined 上，在非严格模式下则会被绑定到全局对象 window&#x2F;global 上。</li>
<li>一般使用 new 方法调用构造函数时，构造函数内的 this 会被绑定到新创建的对象上。</li>
<li>一般通过 call&#x2F;apply&#x2F;bind 方法显式调用函数时，函数体内的 this 会被绑定到指定参数的对象上。</li>
<li>一般通过 上下文对象调用函数时，函数体内的 this 会被绑定到该对象上。</li>
<li>在箭头函数中，this 的指向是由外层(函数或全局)作用域来决定的。</li>
</ul>
<p>但是实际上还是得实际情况具体分析</p>
<p>下面的代码没有特别说明都是在浏览器环境中运行。</p>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="例题-1：全局环境的-this"><a href="#例题-1：全局环境的-this" class="headerlink" title="例题 1：全局环境的 this"></a>例题 1：全局环境的 this</h2><p>先看例题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>() <span class="comment">// window</span></span><br><span class="line"><span class="title function_">f2</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>很简单，并符合你的预期，但是也会有变种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = foo.<span class="property">fn</span></span><br><span class="line"><span class="title function_">fn1</span>()</span><br></pre></td></tr></table></figure>

<p>这里 fn1 执行时 this 依然是 window，因为这是在全局环境中执行的。</p>
<p>稍微改一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>

<p>这次输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">bar</span>: <span class="number">10</span>, <span class="attr">fn</span>: ƒ&#125;</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>因为上下文是 foo 对象，所以毫无疑问 this 指向 foo 对象。</p>
<h2 id="例题-2：上下文对象调用-this"><a href="#例题-2：上下文对象调用-this" class="headerlink" title="例题 2：上下文对象调用 this"></a>例题 2：上下文对象调用 this</h2><p>根据上一个例子，我们加点嵌套：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">brother</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;mike&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">brother</span>.<span class="title function_">fn</span>())</span><br></pre></td></tr></table></figure>

<p>这里输出的是 mike，因为 this 会指向最后调用它的对象。再来看难一点的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;o1&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">text</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;o2&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> o1.<span class="title function_">fn</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;o3&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = o1.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="title function_">fn</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="title function_">fn</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="title function_">fn</span>())</span><br></pre></td></tr></table></figure>

<p>答案是：o1、o1、undefined</p>
<ul>
<li>第一个输出 o1 应该是毫无疑问的。</li>
<li>第二个因为 o2.fn()最终还是调用了 o1.fn()，所以结果还是 o1</li>
<li>最后一个通过 var fn &#x3D; o1.fn 的赋值再进行”裸奔“调用了，所以 this 指向是 window，所以结果是 undefined</li>
</ul>
<p>面试官可能会问如何让<code>console.log(o2.fn())</code>输出 o2，一般面试者都会想到使用 bind、call、apply，面试官可能会问除此之外还有别的方法吗，其实是有的，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;o1&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">text</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;o2&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: o1.<span class="property">fn</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="title function_">fn</span>())</span><br></pre></td></tr></table></figure>

<p>只需要讲 o1 的 fn 挂载到 o2 上即可。</p>
<h2 id="例题-3：通过-bind、call、apply-改变-this-指向"><a href="#例题-3：通过-bind、call、apply-改变-this-指向" class="headerlink" title="例题 3：通过 bind、call、apply 改变 this 指向"></a>例题 3：通过 bind、call、apply 改变 this 指向</h2><p>这三个函数都是用来改变相关函数 this 指向的，详细用法直接百度就有，这里不展开讲。<br>上例题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;mike&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">fn</span>.<span class="title function_">call</span>(bar))</span><br></pre></td></tr></table></figure>

<p>这里打印 mike，并不难理解</p>
<h2 id="例题-4：构造函数和-this"><a href="#例题-4：构造函数和-this" class="headerlink" title="例题 4：构造函数和 this"></a>例题 4：构造函数和 this</h2><p>直接上例题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">bar</span>)</span><br></pre></td></tr></table></figure>

<p>如果你看过构造函数的话就知道这里输出的是 jack，没什么问题。</p>
<p>课外知识：这里的 new 操作符调用构造函数具体做了什么？这里是简略的步骤</p>
<ul>
<li>创建一个新的对象</li>
<li>将构造函数 this 指向这个新对象</li>
<li>为对象添加属性、方法</li>
<li>返回这个新对象</li>
</ul>
<p>简略步骤按照代码大概是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">__proto__</span> = foo.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure>

<p>当然这只是最简单的版本。</p>
<p>但是当构造函数中显示使用 return 的话，又分为两种情况：</p>
<p>场景 1：下面输出 undefined，instance 得到的是返回的空对象 o</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">bar</span>)</span><br></pre></td></tr></table></figure>

<p>场景 2： 下面输出 jack，instance 得到的是目标对象实例 this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">bar</span>)</span><br></pre></td></tr></table></figure>

<p>所以，如果构造函数中显式返回一个值，且返回的是一个对象(返回复杂类型)，那么 this 就指向这个返回的对象;如果返回的不是一个对象(返回基本类型)，那么 this 仍然指向实例。</p>
<h2 id="例题-5：箭头函数中的-this"><a href="#例题-5：箭头函数中的-this" class="headerlink" title="例题 5：箭头函数中的 this"></a>例题 5：箭头函数中的 this</h2><p>在此之前，先重温一遍箭头函数：在箭头函数中，this 的指向是由外层(函数或全局)作用域来决定的。</p>
<p>就比如这个，this 出现在 setTimeout 函数中，因此 this 指向 windows 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">fn</span>())</span><br></pre></td></tr></table></figure>

<p>想要让这个 this 指向 foo 可以巧用箭头函数来解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">fn</span>())</span><br></pre></td></tr></table></figure>

<p>单纯的箭头函数中 this 指向问题非常简单，但是如果综合所有情况，并结合 this 优先级的话，this 就不那么容易确定了。</p>
<h2 id="例题-6：this-优先级"><a href="#例题-6：this-优先级" class="headerlink" title="例题 6：this 优先级"></a>例题 6：this 优先级</h2><p>我们常常把 call、apply、bind、new 对 this 进行绑定的情况成为显示绑定，而把根据调用关系确定 this 指向的情况称为隐式绑定。<br>那显示绑定和隐式绑定谁的优先级更高呢？来看看下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2)</span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>(obj1)</span><br></pre></td></tr></table></figure>

<p>输出分别是 2、1，也就是说 call、apply 这些显示绑定一般要比隐式绑定高。再来看另一段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj1)</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>)</span><br></pre></td></tr></table></figure>

<p>输出的是：2，也就是说执行 bar(2)后 obj1 对象是:<code>&#123;a:2&#125;</code></p>
<p>如果再将 bar 作为构造函数的话，下面代码会输出 3：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">a</span>)</span><br></pre></td></tr></table></figure>

<p>当 bar 再次通过 new 调用时，返回的实例就已经和 obj1 解绑了，new 修改了 bind 绑定的 this 指向，也就是说 new 绑定的优先级要比显示 bind 绑定更高。</p>
<p>下面我们看看箭头函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">call</span>(obj1)</span><br><span class="line">bar.<span class="title function_">call</span>(obj2)</span><br></pre></td></tr></table></figure>

<p>输出结果是 1。由于 foo 中的 this 绑定到了 obj1 上，所以 bar（引用箭头函数）中的 this 也绑定到 obj1 上，而且箭头函数的绑定是无法被修改的。</p>
<p>如果将 foo 完全写成箭头函数，下面代码会输出 123：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">call</span>(obj1)</span><br><span class="line">bar.<span class="title function_">call</span>(obj2)</span><br></pre></td></tr></table></figure>

<p>因为调用 foo 是箭头函数根据上下文已经绑定到了全局对象 window 上，下面的 call 就没办法修改 this 了。再抖个机灵，改一下变量 a 的声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">call</span>(obj1)</span><br><span class="line">bar.<span class="title function_">call</span>(obj2)</span><br></pre></td></tr></table></figure>

<p>这是输出的是 undefined，因为 const 和 let 的声明的变量都不会挂载到 window 全局对象上。不过 const 和 let 等声明变量方式不在本篇讨论范围内，后续再讲解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本篇内容的学习，我们看到 this 的用法纷繁多象，确实不容易彻底掌握。本篇尽可能系统地对 this 的用法进行讲解、说明，例题尽可能地覆盖更多场景，但还需要读者在阅读之外继续消化与吸收。只有“记死”，才能“用活”。<br>如果读者还有困惑，也不要灰心。事实上，资深工程师也不敢保证针对所有场景都能给出很好的解决方案，也存在理解不到位的情况。也许区别资深工程师和菜鸟工程师的点，不完全在于他们回答应试题目的准确率，更在于他们怎么思考问题、解决问题。如果不懂 this 指向，那就动手实践一下；如果不了解原理，那就翻出规范来看一下，没有什么大不了的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：ES6新增语法</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9AES6%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>记录下ES6新增的语法</p>
<span id="more"></span>

<h1 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h1><p>let有以下几个特性：</p>
<ul>
<li>let声明的变量只在所在的块级有效（也就是在{}中）</li>
<li>不存在变量提升（要先声明后使用）</li>
<li>具有暂时性死区</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂时性死区情况</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于在块里面存在let关键字，所以使用num时不会在外部寻找num，而且因为先定义后使用的原因，在let上面调用num会报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>var关键字不具备上述特点</p>
</blockquote>
<p>经典面试题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();   <span class="comment">//2</span></span><br><span class="line">arr[<span class="number">1</span>]();   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();   <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]();   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><p>作用：声明常量，即内存地址不能改变的值</p>
<p>特点：</p>
<ul>
<li>使用const关键字声明的常量也具有块级作用域。</li>
<li>声明时必须赋值</li>
<li>赋值后不能修改</li>
</ul>
<h1 id="var、let、const比较"><a href="#var、let、const比较" class="headerlink" title="var、let、const比较"></a>var、let、const比较</h1><table>
<thead>
<tr>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>函数级作用域</td>
<td>块级作用域</td>
<td>块级作用域</td>
</tr>
<tr>
<td>变量提升</td>
<td>不存在变量提升</td>
<td>不存在变量提升</td>
</tr>
<tr>
<td>值可更改</td>
<td>值可更改</td>
<td>地址值不可更改</td>
</tr>
</tbody></table>
<blockquote>
<p>还有一些其他的移步到：<a href="/JavaScript/%E5%8D%81%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84ES6%E7%89%B9%E6%80%A7/">十个实用的ES6特性</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js正则表达式</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>记录一下正则表达式的使用</p>
<span id="more"></span>

<h1 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h1><p>使用RegExp对象来创建正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/123/</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用字面量来创建正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/123/</span></span><br></pre></td></tr></table></figure>

<h1 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h1><p>使用方法是 <code>regexObj.test(str)</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/123/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg.<span class="title function_">test</span>(<span class="number">123</span>));  <span class="comment">//ture</span></span><br></pre></td></tr></table></figure>

<h1 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h1><h2 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h2><table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>表示匹配行首的文本（以谁开始）</td>
</tr>
<tr>
<td>$</td>
<td>匹配以谁结束</td>
</tr>
</tbody></table>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/abc/</span>;     <span class="comment">//表示含有abc</span></span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/^abc/</span>    <span class="comment">//表示开头是abc</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/abc$/</span>    <span class="comment">//表示是以abc结束</span></span><br><span class="line"><span class="keyword">var</span> rg3 = <span class="regexp">/^abc$/</span>   <span class="comment">//精准匹配abc</span></span><br></pre></td></tr></table></figure>

<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>使用 <code>[]</code> 表示一系列字符可供选择，比如: <code>/[abc]/</code> 表示只要有a或者有b或者有c都能匹配。比如： <code>/^[abc]$/</code> 只能匹配a或者b或者c。</p>
<p>在方括号里使用 <code>[-]</code> 表示范围，比如 <code>/[a-z]/</code> 表示只要有26个字母都能匹配</p>
<p>还可以进行字符组合：<code>/^[a-z0-9A-Z_-]$/</code> 这样只要是a到z或者0到9或者A到Z或者_或者-开头和结尾都能匹配。</p>
<p>在方括号里面加 <code>^</code> 表示取反的意思，比如：<code>/[^0-9a-z]/</code> 表示的是不能取0-9和a-z。</p>
<h2 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h2><ol>
<li><code>*</code> 重复0次或者很多次</li>
<li><code>+</code> 重复1次或者很多次</li>
<li><code>?</code> 出现0次或者1次</li>
<li><code>&#123;3&#125;</code> 重复三次</li>
<li><code>&#123;3,&#125;</code> 大于等于三次</li>
<li><code>&#123;3,16&#125;</code> 大于等于3并且小于等于16次<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/^a*$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg1.<span class="title function_">test</span>(<span class="string">&#x27;&#x27;</span>));      <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg1.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>));     <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg1.<span class="title function_">test</span>(<span class="string">&#x27;aaa&#x27;</span>));   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^a+$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg2.<span class="title function_">test</span>(<span class="string">&#x27;&#x27;</span>));      <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg2.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>));     <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg3 = <span class="regexp">/^a?$/</span>;   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg3.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>));    <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg4 = <span class="regexp">/^a&#123;3&#125;$/</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg4.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>));    <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg4.<span class="title function_">test</span>(<span class="string">&#x27;aaa&#x27;</span>));   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg5 = <span class="regexp">/^a&#123;2,&#125;$/</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg5.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>));    <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg5.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>));     <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg6 = <span class="regexp">/^a&#123;2,3&#125;$/</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg6.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>));     <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg6.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>));    <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rg6.<span class="title function_">test</span>(<span class="string">&#x27;aaaa&#x27;</span>));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a>括号总结</h1><ol>
<li>中括号 字符组合：匹配括号中的任意字符</li>
<li>大括号 量词符：表示重复次数</li>
<li>小括号 表示优先级<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^abc&#123;3&#125;$/</span>    <span class="comment">//表示c重复三次 匹配 abccc</span></span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">/^(abc)&#123;3&#125;$/</span>      <span class="comment">//表示abc重复三次 匹配 abcabcabc</span></span><br><span class="line"></span><br><span class="line">reg = <span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h1><p>预定义类指某些常见模式的简写方式</p>
<table>
<thead>
<tr>
<th>预定义类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配0-9之间的任意数字，相当于[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配0-9以为的字符，相当于[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任意字母、数字和下划线，相当于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任意字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格（包括换行符、制表符），相当于[\t\r\n\v\f]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空格的字符，相当于[^\t\r\n\v\f]</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;123&#x27;</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//座机号码验证 比如 010-12345678或者0530-1234567</span></span><br><span class="line">reg = <span class="regexp">/^\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;$/</span>;</span><br><span class="line"><span class="comment">// 其中的 | 表示或者的意思</span></span><br></pre></td></tr></table></figure>

<h1 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h1><p>使用 <code>replace</code> 方法可以替换字符串，替换方法可以使用正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;angel和alex&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> newStr1 = str.<span class="title function_">replace</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;rin&#x27;</span>);    <span class="comment">//rin和jack</span></span><br><span class="line"><span class="keyword">var</span> newStr2 = str.<span class="title function_">replace</span>(<span class="regexp">/a/</span>, <span class="string">&#x27;*&#x27;</span>);    <span class="comment">//*ngel和alex</span></span><br></pre></td></tr></table></figure>
<p>可以看到只替换了第一个a，没有替换掉后面的，这时候就需要使用到匹配模式了。</p>
<blockquote>
<p>&#x2F;regexp&#x2F;[switch]</p>
</blockquote>
<p>switch(修饰符)可以选择按照什么模式来匹配，有三个值：</p>
<ul>
<li>g: 全局模式</li>
<li>i: 忽略大小写</li>
<li>gi: 全局加忽略大小写</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;angel和alex&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">new</span> = str.<span class="title function_">replace</span>(<span class="regexp">/a|l/g</span>, <span class="string">&#x27;*&#x27;</span>);  <span class="comment">//*nge*和**ex</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：Promise</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9APromise/</url>
    <content><![CDATA[<p>ES6中Promise的学习笔记</p>
<span id="more"></span>

<h1 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h1><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<p><code>Promise</code> 对象有以下两个特点：</p>
<ol>
<li>对象状态不受外界影响。Promise对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。</li>
<li>一旦状态改变就不能再变。状态变化只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。一旦其中一种状态发生了，状态就凝固了，会一直保持这个结果，称为：resolved（已定型）</li>
</ol>
<p>优点：有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>缺点：首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code> 函数将状态从未完成变为成功（即<code>pending</code>变为<code>fulfilled</code>），并将异步操作的结果，作为参数传递出去，<code>reject</code>就是转变成失败，同时将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。</p>
<p>其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>一个简单的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>)         <span class="comment">//&#x27;done&#x27;是传给resolve的参数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>过了100毫秒后状态转变成resolve，然后就会触发then方法绑定的的回调函数</p>
<p><strong>Promise执行顺序</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>异步加载图片的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是实现Ajax操作的一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler</span><br><span class="line">    client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span></span><br><span class="line">    client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    client.<span class="title function_">send</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：JSON</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9AJSON/</url>
    <content><![CDATA[<ul>
<li>json 是一种轻量级的数据交换格式，易于人阅读和编写。</li>
<li>使用json 数据格式是替换 xml 的最佳方式，主流语言都很好的支持json 格式。所以 json 也是前后台传输数据的主要格式。</li>
<li>json 标准中要求使用双引号包裹属性，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误语言错误的发生。</li>
</ul>
<span id="more"></span>

<h1 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h1><p>基本结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;father&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lessons = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;JavaScript入门到实战&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tag&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">            <span class="string">&quot;JS&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Vue入门到实战&quot;</span>,</span><br><span class="line">        <span class="string">&quot;click&quot;</span>: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>序列化是将 <code>json</code> 转换为字符串，一般用来向其他语言传输使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里用上面的两个变量来序列化</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(foo))</span><br><span class="line"><span class="comment">//&#123;&quot;name&quot;:&quot;foo&quot;,&quot;age&quot;:18,&quot;father&quot;:&#123;&quot;name&quot;:&quot;bar&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(lessons))</span><br><span class="line"><span class="comment">//[&#123;&quot;title&quot;:&quot;JavaScript入门到实战&quot;,&quot;tag&quot;:[&quot;前端&quot;,&quot;JS&quot;]&#125;,&#123;&quot;title&quot;:&quot;Vue入门到实战&quot;,&quot;click&quot;:12&#125;]</span></span><br></pre></td></tr></table></figure>

<p>然后可以通过在参数列表的第二个参数控制需要序列号输出的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(lessons, [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;tag&quot;</span>]))</span><br><span class="line"><span class="comment">//[&#123;&quot;title&quot;:&quot;JavaScript入门到实战&quot;,&quot;tag&quot;:[&quot;前端&quot;,&quot;JS&quot;]&#125;,&#123;&quot;title&quot;:&quot;Vue入门到实战&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<p>第三个是参数用来控制TAB对应空格的数量，如果字符串则为前导字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(lessons, <span class="literal">null</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         &quot;title&quot;: &quot;JavaScript入门到实战&quot;,</span></span><br><span class="line"><span class="comment">//         &quot;tag&quot;: [</span></span><br><span class="line"><span class="comment">//             &quot;前端&quot;,</span></span><br><span class="line"><span class="comment">//             &quot;JS&quot;</span></span><br><span class="line"><span class="comment">//         ]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         &quot;title&quot;: &quot;Vue入门到实战&quot;,</span></span><br><span class="line"><span class="comment">//         &quot;click&quot;: 12</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>为数据添加 toJSON 方法来自定义返回格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;father&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">	<span class="string">&quot;toJSON&quot;</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span>: <span class="variable language_">this</span>.<span class="property">name</span>,</span><br><span class="line">			<span class="string">&quot;father&quot;</span>: <span class="variable language_">this</span>.<span class="property">father</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(foo))</span><br><span class="line"><span class="comment">// &#123;&quot;name&quot;:&quot;foo&quot;,&quot;father&quot;:&#123;&quot;name&quot;:&quot;bar&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>使用 <code>JSON.parse</code> 将字符串 <code>json</code> 解析成对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依旧使用上面的foo对象</span></span><br><span class="line"><span class="keyword">let</span> jsonStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(foo)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr))</span><br></pre></td></tr></table></figure>

<p>使用第二个参数可以对返回的数据进行二次处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonStr1 = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(lessons);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr1, <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&quot;tag&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value+<span class="string">&quot;,实战&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：原型与继承</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>每个对象都有一个原型 <code>prototype</code> 对象，通过函数创建的对象也将拥有这个原型对象。原型是一个指向对象的指针。</p>
<ul>
<li>可以将原型理解为对象的父亲，对象从原型对象继承来属性</li>
<li>原型就是对象除了是某个对象的父母外没有什么特别之处</li>
<li>所有函数的原型默认是 <code>Object</code> 的实例，所以可以使用 <code>toString/toValues/isPrototypeOf</code> 等方法的原因</li>
<li>使用原型对象为多个对象共享属性或方法</li>
<li>如果对象本身不存在属性或方法将到原型上查找</li>
<li>使用原型可以解决，通过构建函数创建对象时复制多个函数造成的内存占用问题</li>
<li>原型包含 <code>constructor</code> 属性，指向构造函数</li>
<li>对象包含 <code>__proto__</code> 指向他的原型对象</li>
</ul>
<span id="more"></span>

<p>当然也可以创建一个没有原型的极简对象（原型为null）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>))   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>))   <span class="comment">//Uncaught TypeError: bar.hasOwnProperty is not a function</span></span><br></pre></td></tr></table></figure>

<p>函数拥有多个原型， <code>prototype</code> 用于实例对象使用，<code>__proto__</code> 用于函数对象使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">User</span>.<span class="property">__proto__</span>.<span class="property">view</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;User function view method&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">User</span>.<span class="title function_">view</span>();    <span class="comment">//User function view method</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">foo.<span class="title function_">show</span>();     <span class="comment">//Hello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span> == foo.<span class="property">__proto__</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/1.png" class="">

<p>使用 <code>setPrototypeOf</code> 、 <code>getPrototypeOf</code> 可以设置和获取原型，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> parent = &#123; <span class="attr">name</span>: <span class="string">&quot;parent&quot;</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(foo, parent);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(foo));</span><br></pre></td></tr></table></figure>
<p><code>getPrototypeOf</code> 相当于将某个对象的 <code>__proto__</code> 设置成另一个对象</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/2.png" class="">

<h2 id="原型检测"><a href="#原型检测" class="headerlink" title="原型检测"></a>原型检测</h2><p><code>instanceof</code> 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = c;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = b;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(a <span class="keyword">instanceof</span> A); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(a <span class="keyword">instanceof</span> B); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(a <span class="keyword">instanceof</span> C); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(b <span class="keyword">instanceof</span> C); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(c <span class="keyword">instanceof</span> B); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>isPrototypeOf</code> 检测一个对象是否是另一个对象的原型链中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(b, c);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">isPrototypeOf</span>(a)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">isPrototypeOf</span>(a)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">isPrototypeOf</span>(b)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="属性检测"><a href="#属性检测" class="headerlink" title="属性检测"></a>属性检测</h2><p>使用in 检测原型链上是否存在属性，使用 hasOwnProperty 只检测当前对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>: <span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">url</span>: <span class="string">&quot;baidu.com&quot;</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> a);               <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;url&quot;</span> <span class="keyword">in</span> a);                <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;url&quot;</span>));   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//url</span></span><br></pre></td></tr></table></figure>
<p>不过看方法名就可以知道hasOwnProperty是检测对象自己的属性,而不会查找原型。</p>
<h2 id="借用原型"><a href="#借用原型" class="headerlink" title="借用原型"></a>借用原型</h2><p>使用 <code>call</code> 或 <code>apply</code> 可以借用其他原型方法完成功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(foo, &#123;</span><br><span class="line">  <span class="attr">max</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">max</span>(foo.<span class="property">data</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">lessons</span>: &#123;</span><br><span class="line">    <span class="attr">js</span>:<span class="number">96</span>, <span class="attr">php</span>: <span class="number">89</span>, <span class="attr">node</span>: <span class="number">90</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">lessons</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">__proto__</span>.<span class="property">max</span>.<span class="title function_">call</span>(bar);</span><br></pre></td></tr></table></figure>

<p>关于改变this指向详情看：<a href="/JavaScript/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-2/#%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91">js面向对象笔记-2#改变this指向</a></p>
<h1 id="原型总结"><a href="#原型总结" class="headerlink" title="原型总结"></a>原型总结</h1><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>可以看到：<a href="/JavaScript/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-1/#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-prototype">js面向对象笔记-1#构造函数原型 prototype</a></p>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><p>可以创建一个新的对象，并且设置这个对象的原型和属性，第一个参数设置新对象的原型，第二个参数和 <code>Object.defineProperty</code> 的第二第三个参数类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="title class_">Object</span>.<span class="title function_">create</span>(user, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;小明&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaoming.<span class="title function_">getName</span>())   <span class="comment">//小明</span></span><br></pre></td></tr></table></figure>

<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>实例化对象的<code>__proto__</code>记录了对象的原型，但<code>__proto__</code>不是对象属性，可以理解为<code>prototype</code>的<code>getter/setter</code>实现，所以只允许值为对象或者null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">foo.<span class="property">__proto__</span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo)        <span class="comment">//foo.__proto__依然是一个Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">bar.<span class="property">__proto__</span> = <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar)        <span class="comment">//&#123;__proto__: &quot;bar&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>一般通过设置<code>__proto__</code>或者使用<code>Object.setPrototypeOf()</code>修改对象的原型，或者使用<code>Object.create</code>创建一个新的对象并返回，他们效果基本一样，都是作用于<code>__proto__</code></p>
<h1 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h1><p>不要在构造函数里面声明方法，不然会浪费内存，以及函数不能共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建议</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了函数也可以通过原型共享属性，相当于Java的类static变量</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>可以转到：<a href="/JavaScript/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-1/#%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">js面向对象笔记-1</a></p>
<p>不过除了上面那篇这样，也可以这样实现继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son&#x27;</span>)</span><br><span class="line">son.<span class="title function_">getName</span>()   <span class="comment">//son</span></span><br></pre></td></tr></table></figure>

<h1 id="原型工厂"><a href="#原型工厂" class="headerlink" title="原型工厂"></a>原型工厂</h1><p>原型工厂是将继承的过程封装，使用继承业务简单化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">sub, sup</span>) &#123;</span><br><span class="line">  sub.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(sup.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  sub.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Access</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Admin</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Member</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">User</span>, <span class="title class_">Access</span>); <span class="comment">//User继承Access</span></span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Admin</span>, <span class="title class_">User</span>); <span class="comment">//Admin继承User</span></span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Member</span>, <span class="title class_">Access</span>); <span class="comment">//Member继承Access</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Access</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">rules</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Admin</span>()); <span class="comment">// 继承关系: Admin&gt;User&gt;Access&gt;Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Member</span>()); <span class="comment">//继承关系：Member&gt;Access&gt;Object</span></span><br></pre></td></tr></table></figure>

<h1 id="对象工厂"><a href="#对象工厂" class="headerlink" title="对象工厂"></a>对象工厂</h1><p>在原型继承基础上，将对象的生成使用函数完成，并在函数内部为对象添加属性或方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Admin</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="title class_">User</span>.<span class="title function_">call</span>(instance, name, age);</span><br><span class="line">  instance.<span class="property">role</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;admin.role&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="title class_">Admin</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">19</span>);</span><br><span class="line">foo.<span class="title function_">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">member</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="title class_">User</span>.<span class="title function_">call</span>(instance, name, age);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="title function_">member</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">28</span>);</span><br><span class="line">bar.<span class="title function_">show</span>();</span><br></pre></td></tr></table></figure>

<h1 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h1><p>因为JS不能实现多继承，所以有时候想要继承多个父类时可能会把无关的类连接起来，但是这样做并不优雅也不直观，这时候可以用<code>Mixin</code>模式来组合多个父类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">sub, sup</span>) &#123;</span><br><span class="line">  sub.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(sup.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  sub.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = sub;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Request</span> = &#123;</span><br><span class="line">  <span class="title function_">ajax</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求后台&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Credit</span> = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: <span class="title class_">Request</span>,</span><br><span class="line">  <span class="title function_">total</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">ajax</span>() + <span class="string">&quot;,统计积分&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Admin</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Admin</span>, <span class="title class_">User</span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Admin</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="title class_">Request</span>, <span class="title class_">Credit</span>);</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Admin</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">19</span>);</span><br><span class="line">foo.<span class="title function_">show</span>();</span><br><span class="line">foo.<span class="title function_">total</span>(); <span class="comment">//统计积分</span></span><br><span class="line">foo.<span class="title function_">ajax</span>(); <span class="comment">//请求后台</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：symbol、set和map</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9Asymbol%E5%92%8Cset/</url>
    <content><![CDATA[<p>记录一下symbol和set的一些知识点</p>
<span id="more"></span>

<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Symbol是一个新增的数据类型，下面先描述一下symbol的一个使用场景，比如在一个游戏中，用户需要选择角色的种族：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> race = &#123;</span><br><span class="line">    <span class="attr">protoss</span>: <span class="string">&#x27;protoss&#x27;</span>,   <span class="comment">// 神族</span></span><br><span class="line">    <span class="attr">terran</span>: <span class="string">&#x27;terran&#x27;</span>,     <span class="comment">// 人族</span></span><br><span class="line">    <span class="attr">zerg</span>: <span class="string">&#x27;zerg&#x27;</span>          <span class="comment">// 虫族</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRole</span>(<span class="params">type</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(type === race.<span class="property">protoss</span>)&#123;</span><br><span class="line">        <span class="comment">//创建神族角色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type === race.<span class="property">terran</span>)&#123;</span><br><span class="line">        <span class="comment">//创建人族角色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type === race.<span class="property">zerg</span>)&#123;</span><br><span class="line">        <span class="comment">//创建虫族角色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么用户选择种族后，就需要调用 createRole 来创建角色：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入字符串</span></span><br><span class="line"><span class="title function_">createRole</span>(<span class="string">&#x27;zerg&#x27;</span>) </span><br><span class="line"><span class="comment">// 或者传入变量</span></span><br><span class="line"><span class="title function_">createRole</span>(race.<span class="property">zerg</span>)</span><br></pre></td></tr></table></figure>
<p>一般传入字符串被认为是不好的做法，所以使用 createRole(race.zerg) 的更多。</p>
<p>如果使用 createRole(race.zerg)，那么就会存在一个问题：race.protoss、race.terran、race.zerg 的值为多少并不重要。</p>
<p>改为如下写法，对 createRole(race.zerg) 毫无影响：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> race = &#123;</span><br><span class="line">    <span class="attr">protoss</span>: <span class="string">&#x27;askdjaslkfjas;lfkjas;flkj&#x27;</span>, <span class="comment">// 神族</span></span><br><span class="line">    <span class="attr">terran</span>: <span class="string">&#x27;;lkfalksjfl;askjfsfal;skfj&#x27;</span>, <span class="comment">// 人族</span></span><br><span class="line">    <span class="attr">zerg</span>: <span class="string">&#x27;qwieqwoirqwoiruoiwqoisrqwroiu&#x27;</span> <span class="comment">// 虫族</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，只要 <code>race.zerg</code> 的值和另外两个不一样就行了，而Symbol的用处就出来了，Symbol可以创建一个独一无二的值，下面可以改写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> race = &#123;</span><br><span class="line">  <span class="attr">protoss</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">  <span class="attr">terran</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">  <span class="attr">zerg</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以给他起个名字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> race = &#123;</span><br><span class="line">  <span class="attr">protoss</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;protoss&#x27;</span>),</span><br><span class="line">  <span class="attr">terran</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;terran&#x27;</span>),</span><br><span class="line">  <span class="attr">zerg</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;zerg&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不给这个值只是一个描述，和Symbol没有任何关系。</p>
<h2 id="Symbol的for和keyFor方法"><a href="#Symbol的for和keyFor方法" class="headerlink" title="Symbol的for和keyFor方法"></a>Symbol的for和keyFor方法</h2><p>可以使用 <code>Symbol.for()</code> 来创建一个全局的变量，也就是说又可以能不唯一了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b)     <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> d = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a !== b)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>keyFor</code> 可以读取使用 <code>Symbol.for()</code> 创建的变量:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(a))  <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(b))  <span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<h2 id="解决字符串耦合问题"><a href="#解决字符串耦合问题" class="headerlink" title="解决字符串耦合问题"></a>解决字符串耦合问题</h2><p>比如有一个记录成绩的变量，但是可能在一个班里面存在两个同名的人：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">let</span> user2 = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">let</span> grade = &#123;</span><br><span class="line">    [user1]: &#123;<span class="attr">c</span>:<span class="number">95</span>, <span class="attr">sql</span>:<span class="number">89</span>&#125;,</span><br><span class="line">    [user2]: &#123;<span class="attr">c</span>:<span class="number">86</span>,<span class="attr">sql</span>:<span class="number">78</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grade)  <span class="comment">//&#123;张三:&#123;c:86,sql:78&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>[user1]</code>和<code>[user2]</code>最终都会解析成字符串，所以相当于第二次把第一次覆盖了。可以改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> grade = &#123;</span><br><span class="line">    [user1.<span class="property">key</span>]: &#123;<span class="attr">c</span>:<span class="number">95</span>, <span class="attr">sql</span>:<span class="number">89</span>&#125;,</span><br><span class="line">    [user2.<span class="property">key</span>]: &#123;<span class="attr">c</span>:<span class="number">86</span>,<span class="attr">sql</span>:<span class="number">78</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grade[user1.<span class="property">key</span>])   <span class="comment">//&#123;c: 95, sql: 89&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grade[user2.<span class="property">key</span>])   <span class="comment">//&#123;c: 86, sql: 78&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="在缓存容器中的使用"><a href="#在缓存容器中的使用" class="headerlink" title="在缓存容器中的使用"></a>在缓存容器中的使用</h2><p>比如在一个系统中，有很多模块，和一个为所有模块提供一个储存空间的容器，如果没有Symbol可能是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> data = &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">set</span>(<span class="params">name, value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">data</span>[name] = value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[name]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&quot;用户资料&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cart = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&quot;购物车&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了把这两个变量存进Cache里面，可能要这样：</span></span><br><span class="line"><span class="title class_">Cache</span>.<span class="title function_">set</span>(<span class="string">&quot;user-apple&quot;</span>, user)</span><br><span class="line"><span class="title class_">Cache</span>.<span class="title function_">set</span>(<span class="string">&quot;cart-apple&quot;</span>, cart)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cache</span>.<span class="title function_">get</span>(<span class="string">&quot;cart-apple&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>当我们有symbol后可以改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略类定义</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&quot;用户资料&quot;</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cart = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&quot;购物车&quot;</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cache</span>.<span class="title function_">set</span>(user.<span class="property">key</span>, user)</span><br><span class="line"><span class="title class_">Cache</span>.<span class="title function_">set</span>(cart.<span class="property">key</span>, cart)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cache</span>.<span class="title function_">get</span>(cart.<span class="property">key</span>));   <span class="comment">//&#123;name: &quot;apple&quot;, desc: &quot;购物车&quot;...&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="属性保护"><a href="#属性保护" class="headerlink" title="属性保护"></a>属性保护</h2><p>Symbol有个特性就是无法用 <code>for in</code> 得到对象中的Symbol属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;my name&quot;</span>,</span><br><span class="line">    [s]: <span class="string">&quot;Symbol&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;   <span class="comment">//只输出name</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>Object.getOwnPropertySymbols</code> 方法获得：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略声明定义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj))&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;   <span class="comment">// Symbol()</span></span><br></pre></td></tr></table></figure>
<p>但是这种情况又获取不到非隐藏的属性，可以通过反射拿到所有属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>。<span class="title function_">ownKeys</span>(obj))&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//Symbol()</span></span><br></pre></td></tr></table></figure>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">x</span> =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"><span class="comment">// Set结构不会添加重复的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 初始化</span></span><br><span class="line"><span class="comment">// 例一 可以接受一个数组作为参数</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...将一个数组转为用逗号分隔的参数序列</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三 可以接受具有iterable接口的其他数据结构作为参数</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set2.<span class="property">size</span>);         <span class="comment">//一个div为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">document</span></span><br><span class="line">    .<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> set.<span class="title function_">add</span>(div));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set中NaN等于自身，其余比较相当于 ===</span></span><br><span class="line"><span class="keyword">let</span> set3 = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line">set3.<span class="title function_">add</span>(a);</span><br><span class="line">set3.<span class="title function_">add</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set3)   <span class="comment">//set(1) &#123;Nan=N&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个对象总是不相等的</span></span><br><span class="line"><span class="keyword">let</span> set4 = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set4.<span class="title function_">add</span>(&#123;&#125;);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set4.<span class="property">size</span>); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">set4.<span class="title function_">add</span>(&#123;&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set4.<span class="property">size</span>); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> set5 = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set5.<span class="property">size</span>)  <span class="comment">//3</span></span><br><span class="line"><span class="comment">//相当于 Set([...&quot;abc&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除,取值，清空</span></span><br><span class="line"><span class="keyword">let</span> set6 = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">set6.<span class="title function_">delete</span>(<span class="string">&quot;b&quot;</span>)            <span class="comment">//成功删除返回true，元素不存在返回false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set6)           <span class="comment">//Set(2) &#123;&quot;a&quot;, &quot;c&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set6.<span class="title function_">values</span>())  <span class="comment">//SetIterator &#123;&quot;a&quot;, &quot;c&quot;&#125;</span></span><br><span class="line">set6.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set6)           <span class="comment">//Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>转换成数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set])</span><br></pre></td></tr></table></figure>
<p>去除数组中重复的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">arr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)            <span class="comment">//(4) [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;12345&quot;</span>)</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, set</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value,key,set)  <span class="comment">//其中value和key相同</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用for of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)  <span class="comment">//输出1到5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并集-x2F-交集-x2F-差集算法"><a href="#并集-x2F-交集-x2F-差集算法" class="headerlink" title="并集&#x2F;交集&#x2F;差集算法"></a>并集&#x2F;交集&#x2F;差集算法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;12345&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;2478&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]))</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b.<span class="title function_">has</span>(item)</span><br><span class="line">    &#125;))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !b.<span class="title function_">has</span>(item)</span><br><span class="line">    &#125;))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>因为WeakSet的弱引用特性，不能使用keys、values等方法，for of也是不能用。WeakSet与Set相比，WeakSet只能是<strong>对象的集合</strong>，不能是任意类型的任意值。如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着WeakSet中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。</p>
<h1 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h1><p>Map是ES6之后的哈希结构，算是对object类型的修补。在以往的Object类型中只是把字符串作为键名，而Map可以任意类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;我是1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;我还是1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)    <span class="comment">//&#123;1: &quot;我还是1&quot;&#125;</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&quot;a&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line">])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map)    <span class="comment">//Map(2) &#123;1 =&gt; &quot;a&quot;, &quot;1&quot; =&gt; &quot;b&quot;&#125;</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, <span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&quot;我是一个对象&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map)</span><br><span class="line"><span class="comment">//Map(4) &#123;1 =&gt; &quot;a&quot;, &quot;1&quot; =&gt; &quot;b&quot;, ƒ =&gt; &quot;我是一个函数&quot;, &#123;…&#125; =&gt; &quot;我是一个对象&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>set方法也支持链式操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>).<span class="title function_">set</span>(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="map类型的增删改查和遍历"><a href="#map类型的增删改查和遍历" class="headerlink" title="map类型的增删改查和遍历"></a>map类型的增删改查和遍历</h2><p>增删改查等操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//增&amp;改</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">map.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">map.<span class="title function_">delete</span>(key)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">delete</span> map[key]</span><br><span class="line"><span class="comment">//清除</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line"><span class="comment">//查看有没有某个元素</span></span><br><span class="line">map.<span class="title function_">has</span>(key)</span><br></pre></td></tr></table></figure>
<p>遍历操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//for of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> map.<span class="title function_">key</span>()) &#123;</span><br><span class="line">    <span class="comment">//可以拿到map的键</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> map.<span class="title function_">value</span>()) &#123;</span><br><span class="line">    <span class="comment">//可以拿到map的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="comment">//可以拿到map的键值对</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//forEach</span></span><br><span class="line">hd.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//一样可以拿到键值对</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="map的类型转换"><a href="#map的类型转换" class="headerlink" title="map的类型转换"></a>map的类型转换</h2><p>数组转换，可以使用展开语法或者 <code>Array.form</code> 方法转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;houdunren&quot;</span>, <span class="string">&quot;后盾人&quot;</span>], [<span class="string">&quot;hdcms&quot;</span>, <span class="string">&quot;开源系统&quot;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...hd); <span class="comment">//(2) [&quot;houdunren&quot;, &quot;后盾人&quot;] (2) [&quot;hdcms&quot;, &quot;开源系统&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...hd.<span class="title function_">entries</span>()); <span class="comment">//(2) [&quot;houdunren&quot;, &quot;后盾人&quot;] (2) [&quot;hdcms&quot;, &quot;开源系统&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...hd.<span class="title function_">values</span>()); <span class="comment">//后盾人 开源系统</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...hd.<span class="title function_">keys</span>()); <span class="comment">//houdunren hdcms</span></span><br></pre></td></tr></table></figure>

<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>和WeakSet相似，WeakMap对键名是弱引用，键值是正常引用。</p>
<ul>
<li>键名必须是对象</li>
<li>垃圾回收不考虑WeaMap的键名，不会改变引用计数器，键在其他地方不被引用时即删除</li>
<li>因为WeakMap 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行<code>forEach( )</code>遍历等操作</li>
<li>也是因为弱引用，WeaMap 结构没有keys( )，values( )，entries( )等方法和 size 属性</li>
<li>当键的外部引用删除时，希望自动删除数据时使用 <code>WeakMap</code></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象笔记-2</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>defineProperty、call、apply、bind、闭包笔记</p>
<span id="more"></span>

<h1 id="Object-keys获取对象属性名"><a href="#Object-keys获取对象属性名" class="headerlink" title="Object.keys获取对象属性名"></a>Object.keys获取对象属性名</h1><p>Object.keys()可以用于获取对象自身的所有属性，类似与for…in，返回一个由属性名组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));  <span class="comment">// [&quot;id&quot;, &quot;name&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="Object-defineProperty方法"><a href="#Object-defineProperty方法" class="headerlink" title="Object.defineProperty方法"></a>Object.defineProperty方法</h1><p>函数原型： <code>Object.defineProperty(obj, prop, descriptor)</code> </p>
<ul>
<li>obj：目标对象</li>
<li>prop：需要定义或者修改的名字</li>
<li>descriptor：目标属性所拥有的特性</li>
</ul>
<p>其中 <code>descriptor</code> 是一个对象，里面可以包含：</p>
<ul>
<li>value：设置属性的值，默认undefined</li>
<li>writable：值是否可重写，默认false</li>
<li>enumerable：目标属性是否可被枚举，默认false</li>
<li>configurable：目标是否服用被删除或者是否可以再次修改特性，默认false</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;num&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">//这里设置成true后通过keys方法遍历可以看到num属性</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>  <span class="comment">//这里使用true下面可以再次使用defineProperty操作num属性</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;num&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1000</span>,</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">num</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));  <span class="comment">//[&quot;id&quot;, &quot;name&quot;, &quot;num&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">num</span>);           <span class="comment">//1000,由于上面writable默认是false，所以无法直接修改，仍然是重定义后的1000</span></span><br></pre></td></tr></table></figure>
<p>所以如果想让某个方法的属性不能被遍历出来可以将 <code>enumerable</code> 设置成 <code>false</code> 或者默认。如果让某个属性不能被修改可以设置 <code>writable</code> 或者默认。同样不想让某个属性被删除可以设置 <code>configurable</code> </p>
<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><table>
<thead>
<tr>
<th>调用方式</th>
<th>this指向</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数</td>
<td>windows</td>
</tr>
<tr>
<td>构造函数</td>
<td>实例对象，包括原型对象的方法也是</td>
</tr>
<tr>
<td>对象方法调用</td>
<td>该方法所属对象</td>
</tr>
<tr>
<td>事件绑定方法</td>
<td>绑定该方法的对象</td>
</tr>
<tr>
<td>定时器函数</td>
<td>windows</td>
</tr>
<tr>
<td>立刻执行函数</td>
<td>windows</td>
</tr>
</tbody></table>
<h1 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>call()方法调用一个函数或者方法，可以通过传入值修改函数或者方法里this的指向。<br>函数使用: <code>fun.call(thisArg, arg1, arg2, ...)</code><br>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">call</span>(o); <span class="comment">//this指向了o</span></span><br></pre></td></tr></table></figure>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>和call区别只有一个，就是不能传入后面的几个参数，只能传入一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.<span class="title function_">apply</span>(thisArg, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>也可以改变this指向，不过他不会立刻执行，而是返回一个修改this指向后的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">bind</span>(o)() <span class="comment">//输出的是对象o</span></span><br></pre></td></tr></table></figure>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数值这个函数能接收或者返回一个函数的函数（有套娃内味了）<br>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">op, x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">op</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">calculate</span>(add, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>js不愧是动态语言，使用起来比c、go方便多了，go使用高级函数还得先为一些函数定义好函数原型才能用。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指某个函数有权访问另一个函数作用域中变量的函数。  ——JavaScript高级程序设计</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    (<span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num);   <span class="comment">//能访问外部的num，实现了闭包</span></span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func1</span>();    <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>c语言不能实现闭包的原因是因为在一个函数里不能访问另一个函数内的局部变量。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：对象-1</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<p>这个系列详细的记录对象相关的知识点</p>
<span id="more"></span>

<h1 id="函数编程和面向对象对比"><a href="#函数编程和面向对象对比" class="headerlink" title="函数编程和面向对象对比"></a>函数编程和面向对象对比</h1><p>函数编程可能编写出来的方法可能不简练</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">user, name</span>) &#123;</span><br><span class="line">    user.<span class="title function_">push</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">edit</span>(<span class="params">user, index, rename</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; user.<span class="property">length</span>) &#123;</span><br><span class="line">        user[index] = rename</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>面向对象就可省略很多的代码，比如下面的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">genUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = []</span><br><span class="line">&#125;</span><br><span class="line">genUser.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>.<span class="title function_">push</span>(name)</span><br><span class="line">&#125;</span><br><span class="line">genUser.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">edit</span> = <span class="keyword">function</span>(<span class="params">index, rename</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>[index] = rename</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> userA = <span class="keyword">new</span> <span class="title function_">genUser</span>()</span><br></pre></td></tr></table></figure>
<p>或者直接写成es6的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">genUser</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">edit</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样感觉更优雅了</p>
<h1 id="引用传址"><a href="#引用传址" class="headerlink" title="引用传址"></a>引用传址</h1><p>因为对象是引用类型，直接赋值只会复制地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> otherUser = user</span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherUser.<span class="property">name</span>)     <span class="comment">//张三</span></span><br></pre></td></tr></table></figure>

<h1 id="展开语法实现参数合并"><a href="#展开语法实现参数合并" class="headerlink" title="展开语法实现参数合并"></a>展开语法实现参数合并</h1><p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">upload</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> config = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;*.jpeg,*.png&quot;</span>,</span><br><span class="line">        <span class="attr">size</span>: <span class="number">100000</span></span><br><span class="line">    &#125;</span><br><span class="line">    config = &#123;...config, ...params&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(config)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">upload</span>(&#123;<span class="attr">size</span>: <span class="number">9999</span>&#125;))   </span><br><span class="line"><span class="comment">//&#123;type: &quot;*.jpeg,*.png&quot;, size: 9999&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">upload</span>(&#123;<span class="attr">size</span>: <span class="number">9999</span>, <span class="attr">type</span>: <span class="string">&quot;*.gif&quot;</span>&#125;))    </span><br><span class="line"><span class="comment">//&#123;type: &quot;*.gif&quot;, size: 9999&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="解析赋值"><a href="#解析赋值" class="headerlink" title="解析赋值"></a>解析赋值</h1><p>跳转到<a href="/JavaScript/%E5%8D%81%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84ES6%E7%89%B9%E6%80%A7/#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">十个实用的ES6特性:解构赋值</a></p>
<h1 id="函数参数解构"><a href="#函数参数解构" class="headerlink" title="函数参数解构"></a>函数参数解构</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">[name, age]</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">foo</span>([<span class="string">&quot;Handsome Jack&quot;</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, &#123;sex, age&#125;</span>)      <span class="comment">//只解析部分</span></span><br><span class="line"><span class="title function_">bar</span>(<span class="string">&quot;Handsome Jack&quot;</span>, &#123;<span class="attr">sex</span>: <span class="string">&quot;male&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="对象属性的增删查改"><a href="#对象属性的增删查改" class="headerlink" title="对象属性的增删查改"></a>对象属性的增删查改</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>使用 <code>hasOwnProperty()</code> 方法可以查看是否存在某个属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">foo.<span class="property">name</span> = <span class="string">&quot;Handsome Jack&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>))     <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;age&quot;</span>))      <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>如果想要检查原型 <code>__proto__</code> 中是否拥有某个属性就需要用到 <code>in</code> 关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = []</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;length&quot;</span>))   <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;push&quot;</span>))     <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;push&quot;</span> <span class="keyword">in</span> foo)                  <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>可以用点语法或者中括号都能访问到对象里面的某个成员。（特殊的成员只能用中括号）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;my age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);				<span class="comment">//张三</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[<span class="string">&quot;name&quot;</span>]);			<span class="comment">//张三</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">my</span> age);			<span class="comment">//Uncaught SyntaxError: missing ) after argument list</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[<span class="string">&quot;my age&quot;</span>]);		<span class="comment">//18</span></span><br></pre></td></tr></table></figure>
<p>不过一般都不会用上面那么奇怪的写法，而且点会更加常用</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以用 <code>for in</code> 遍历,这种情况下就只能用中括号了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;my age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新增或者删除属性"><a href="#新增或者删除属性" class="headerlink" title="新增或者删除属性"></a>新增或者删除属性</h2><p>也是直接用点语法或者中括号就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line">user[<span class="string">&quot;name&quot;</span>] = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">user.<span class="property">age</span> = <span class="number">19</span>;</span><br><span class="line">user.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>的年龄是<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="title function_">get</span>())     <span class="comment">//张三的年龄是19</span></span><br><span class="line"><span class="keyword">delete</span> user.<span class="property">age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="title function_">get</span>())     <span class="comment">//张三的年龄是undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="对象浅拷贝"><a href="#对象浅拷贝" class="headerlink" title="对象浅拷贝"></a>对象浅拷贝</h1><p>浅拷贝的意思是：不能深层次的拷贝，只能拷贝第一层的基本属性（不包括对象）</p>
<h2 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;foo.com&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    bar[key] = hd[key]</span><br><span class="line">&#125;</span><br><span class="line">bar[name] = <span class="string">&quot;bar&quot;</span>           <span class="comment">//foo中的name不会发生改变</span></span><br></pre></td></tr></table></figure>

<h2 id="使用assign方法"><a href="#使用assign方法" class="headerlink" title="使用assign方法"></a>使用assign方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;foo.com&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, foo)</span><br><span class="line">bar[name] = <span class="string">&quot;bar&quot;</span>           <span class="comment">//foo中的name不会发生改变</span></span><br></pre></td></tr></table></figure>

<h2 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;foo.com&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;...foo&#125;</span><br><span class="line">bar[name] = <span class="string">&quot;bar&quot;</span>           <span class="comment">//foo中的name不会发生改变</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DeepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        res[key] = <span class="keyword">typeof</span> obj[key] == <span class="string">&quot;object&quot;</span> ? <span class="title class_">DeepCopy</span>(obj[key]) : obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这个只是考虑到对象并没有考虑到数组，继续优化一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DeepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">        res[key] = <span class="keyword">typeof</span> value == <span class="string">&quot;object&quot;</span> ? <span class="title class_">DeepCopy</span>(value) : value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：对象-2</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1-2/</url>
    <content><![CDATA[<p>继续记录对象的一些特性</p>
<span id="more"></span>


<h1 id="属性特征"><a href="#属性特征" class="headerlink" title="属性特征"></a>属性特征</h1><p>JS中可以对属性的访问特性进行控制</p>
<h2 id="查看对象的属性特征"><a href="#查看对象的属性特征" class="headerlink" title="查看对象的属性特征"></a>查看对象的属性特征</h2><p>使用 <code>Object.getOwnPropertyDescriptor</code> 或者 <code>Object.getOwnPropertyDescriptor</code> 查看属性的一些特征</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(foo, <span class="string">&quot;name&quot;</span>), <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;value&quot;: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">//   &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">//   &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">//   &quot;configurable&quot;: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(foo), <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;name&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;value&quot;: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;configurable&quot;: true</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   &quot;age&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;value&quot;: 18,</span></span><br><span class="line"><span class="comment">//     &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;configurable&quot;: true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的四个特征"><a href="#属性的四个特征" class="headerlink" title="属性的四个特征"></a>属性的四个特征</h2><table>
<thead>
<tr>
<th>属性</th>
<th>意义</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>当前属性的值</td>
<td>undefined</td>
</tr>
<tr>
<td>writable</td>
<td>是否可被修改</td>
<td>false</td>
</tr>
<tr>
<td>enumerable</td>
<td>是否可被for in 遍历</td>
<td>false</td>
</tr>
<tr>
<td>configurable</td>
<td>是否可被删除</td>
<td>false</td>
</tr>
</tbody></table>
<blockquote>
<p>上面三个特征默认值为 <code>false</code> 是对于 <code>defineProperty</code> 来说的，如果只是使用点来定义的话，全部都是true。</p>
</blockquote>
<h2 id="设置特征"><a href="#设置特征" class="headerlink" title="设置特征"></a>设置特征</h2><p>在<a href="/JavaScript/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-2/#Object-defineProperty%E6%96%B9%E6%B3%95">js面向对象笔记-2</a>中有说明</p>
<h2 id="禁止添加"><a href="#禁止添加" class="headerlink" title="禁止添加"></a>禁止添加</h2><p><code>Object.preventExtensions</code> 禁止向对象添加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(foo);</span><br><span class="line">foo.<span class="property">age</span> = <span class="number">18</span>; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p><code>Object.isExtensible</code> 判断是否能向对象中添加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(foo)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="封闭对象"><a href="#封闭对象" class="headerlink" title="封闭对象"></a>封闭对象</h2><p><code>Object.seal()</code> 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为 <code>configurable: false</code> ，<code>Object.isSealed</code> 方法判断是否封闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(foo), <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;name&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;value&quot;: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;configurable&quot;: false</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   &quot;age&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;value&quot;: 18,</span></span><br><span class="line"><span class="comment">//     &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">//     &quot;configurable&quot;: false</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(foo));  <span class="comment">// ture</span></span><br><span class="line"><span class="keyword">delete</span> foo.<span class="property">name</span>; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h1 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h1><p><code>Object.freeze</code> 冻结对象后不允许添加、删除、修改属性，<code>writable</code>、<code>configurable</code>都标记为<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(foo);</span><br><span class="line">foo.<span class="property">age</span> = <span class="number">18</span>; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h1 id="属性访问器"><a href="#属性访问器" class="headerlink" title="属性访问器"></a>属性访问器</h1><p>getter方法用于获得属性值，setter方法用于设置属性，这是JS提供的存取器特性即使用函数来管理属性。</p>
<ul>
<li>用于避免错误的赋值</li>
<li>需要动态监测值的改变</li>
<li>属性只能在访问器和普通属性任选其一，不能共同存在</li>
</ul>
<h2 id="getter-x2F-setter"><a href="#getter-x2F-setter" class="headerlink" title="getter&#x2F;setter"></a>getter&#x2F;setter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;<span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">age</span>: <span class="literal">null</span>&#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value != <span class="string">&quot;number&quot;</span> || value &gt; <span class="number">100</span> || value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;年龄格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">age</span> = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`年龄是：<span class="subst">$&#123;<span class="variable language_">this</span>.data.age&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">age</span>)   <span class="comment">//年龄是：18</span></span><br></pre></td></tr></table></figure>
<p>下面使用getter设置只读的课程总价</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Lesson</span> = &#123;</span><br><span class="line">  <span class="attr">lists</span>: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;js&quot;</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;mysql&quot;</span>, <span class="attr">price</span>: <span class="number">212</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;vue.js&quot;</span>, <span class="attr">price</span>: <span class="number">98</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">total</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lists</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">t, b</span>) =&gt;</span> t + b.<span class="property">price</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lesson</span>.<span class="property">total</span>); <span class="comment">//410</span></span><br><span class="line"><span class="title class_">Lesson</span>.<span class="property">total</span> = <span class="number">30</span>; <span class="comment">//无效</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lesson</span>.<span class="property">total</span>); <span class="comment">//410</span></span><br></pre></td></tr></table></figure>
<p>批量设置属性的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> web = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;百度&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;baidu.com&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">site</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.url&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">site</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">url</span>] = value.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">web.<span class="property">site</span> = <span class="string">&quot;好123,hao123.com&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(web.<span class="property">site</span>);</span><br></pre></td></tr></table></figure>
<p>下面是设置token储取的示例，将业务逻辑使用 <code>getter/setter</code> 处理更方便，也方便其他业务的复用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Request</span> = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">token</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> con = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!con) &#123;</span><br><span class="line">    	<span class="title function_">alert</span>(<span class="string">&#x27;请登录后获取token&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">token</span>(<span class="params">con</span>) &#123;</span><br><span class="line">  	<span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, con);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Request</span>.<span class="property">token</span> = <span class="string">&#x27;Bearer xxxxx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="property">token</span>);   <span class="comment">//Bearer xxxxx</span></span><br></pre></td></tr></table></figure>
<p>定义内部私有属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span> &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;用户名不能小于三位&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;    </span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;foo&quot;</span>;          <span class="comment">//Uncaught Error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);</span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;foo and bar&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<h2 id="访问器描述符"><a href="#访问器描述符" class="headerlink" title="访问器描述符"></a>访问器描述符</h2><p>使用 <code>defineProperty</code> 可以模拟定义私有属性，从而使用面向对象的抽象特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = &#123; name, age &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="property">name</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="title function_">trim</span>() == <span class="string">&quot;&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;无效用户名&quot;</span>)</span><br><span class="line">        data.<span class="property">name</span> = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="property">name</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="title function_">trim</span>() == <span class="string">&quot;&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;无效的用户名&quot;</span>);</span><br><span class="line">        data.<span class="property">name</span> = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>)   <span class="comment">//foo</span></span><br><span class="line">foo.<span class="property">name</span> = <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>)   <span class="comment">//bar</span></span><br></pre></td></tr></table></figure>
<p>也可以使用es6之后的class语法糖定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DATA</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable constant_">DATA</span>] = &#123; name, age &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable constant_">DATA</span>].<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>() == <span class="string">&quot;&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;无效的用户名&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable constant_">DATA</span>].<span class="property">name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable constant_">DATA</span>].<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>() == <span class="string">&quot;&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;无效的用户名&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable constant_">DATA</span>].<span class="property">name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包访问器"><a href="#闭包访问器" class="headerlink" title="闭包访问器"></a>闭包访问器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(data)) &#123;</span><br><span class="line">  <span class="title function_">observer</span>(data, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observer</span>(<span class="params">data, key, v</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> v</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      v = newValue</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">data.<span class="property">name</span> = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(data.<span class="property">name</span>) <span class="comment">//bar</span></span><br></pre></td></tr></table></figure>

<h1 id="代理拦截"><a href="#代理拦截" class="headerlink" title="代理拦截"></a>代理拦截</h1><p>代理（拦截器）是对象的访问控制，<code>setter/getter</code> 是对单个对象属性的控制，而代理是对整个对象的控制。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>转到：<a href="/JavaScript/js%E5%85%83%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%A3%E7%90%86/?highlight=%E4%BB%A3%E7%90%86">js元编程：代理</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(foo, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">obj, property</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[property]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">obj, property, value</span>) &#123;</span><br><span class="line">    obj[property] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>                 <span class="comment">//严格模式下 set 必须返回布尔值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo)</span><br></pre></td></tr></table></figure>

<h2 id="代理函数"><a href="#代理函数" class="headerlink" title="代理函数"></a>代理函数</h2><p>如果代理以函数方式执行时，会执行代理中定义 <code>apply</code> 方法。</p>
<p>参数说明：函数，上下文对象，参数</p>
<p>下面使用 apply 计算函数执行时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num == <span class="number">1</span> ? <span class="number">1</span> : num * <span class="title function_">factorial</span>(num - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(factorial, &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">func, obj, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    func.<span class="title function_">apply</span>(obj,args)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;rum&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：手写Promise</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<p>这篇文章讲解如何手写一个简单的 promise</p>
<span id="more"></span>

<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>首先我们用另一个名称代表 promise，然后写一个类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commitment</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;待定&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;成功&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;失败&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">initFunc</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先创建的promise是pending</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">PENDING</span></span><br><span class="line">    <span class="comment">// result属性用来存放结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">initFunc</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行resolve之后转成fulfilled，并赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commitment = <span class="keyword">new</span> <span class="title class_">Commitment</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在代码看起来好像没啥问题了，但是运行一下会发现：<code>TypeError: Cannot read properties of undefined (reading &#39;status&#39;)</code></p>
<p>原因是什么呢，明显是在 resolve 里调用 this 并没有指向新实例。</p>
<h2 id="细节：this"><a href="#细节：this" class="headerlink" title="细节：this"></a>细节：this</h2><p>因为上面的：<code>resolve(&#39;123&#39;)</code>明显是在外部调用的，所以需要绑定 this：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commitment</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;待定&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;成功&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;失败&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">initFunc</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 1、这里的bind是给下面的resolve绑定this的</span></span><br><span class="line">    <span class="title function_">initFunc</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commitment = <span class="keyword">new</span> <span class="title class_">Commitment</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2、给这个resolve绑定this</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="then"><a href="#then" class="headerlink" title="then"></a>then</h1><p>为了代码的美观和强壮性，我们将 then 写在 class 里吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commitment</span> &#123;</span><br><span class="line">  <span class="comment">// 省略上面写好的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFULFILLED, onREJECTED</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="title function_">onFULFILLED</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">REJECTED</span>) &#123;</span><br><span class="line">      <span class="title function_">onREJECTED</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们试一下正不正常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commitment = <span class="keyword">new</span> <span class="title class_">Commitment</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">commitment.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>控制台看起来很正常，并没有报错什么的，也能正常打印，但是还有一个细节没解决。</p>
<h2 id="执行异常"><a href="#执行异常" class="headerlink" title="执行异常"></a>执行异常</h2><p>首先我演示一下原生 promise 如果在执行期间抛出异常的话：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">message</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>控制台能成功打印出：<code>123</code>，那么我们也来实现一下，只需要在构建函数上加上 try-catch：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">initFunc</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Commitment</span>.<span class="property">PENDING</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">initFunc</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后抛出异常就能用了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commitment = <span class="keyword">new</span> <span class="title class_">Commitment</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">commitment.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">message</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="一点细节"><a href="#一点细节" class="headerlink" title="一点细节"></a>一点细节</h1><p>原生的 promise 如果不传入 resolve 或者 reject 函数的话，运行是不会报错的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="literal">undefined</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">message</span>))</span><br></pre></td></tr></table></figure>

<p>而我们写的如果不传入的话会出现：<code>TypeError: onFULFILLED is not a function</code></p>
<p>解决方法很简单，只需要在 then 改一下即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFULFILLED, onREJECTED</span>) &#123;</span><br><span class="line">    onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="title function_">onFULFILLED</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Commitment</span>.<span class="property">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onREJECTED</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记：类</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>es5的基础基本上学完了，继续学习es6中的类</p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因为在js中生成实例对象的方法是直接通过构造函数，和c++和java有较大出入，所以es6提供了更接近传统语言的写法，通过<code>class</code>关键字，可以直接定义类</p>
<p>不过这个<code>class</code>只是一个语法糖，例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Foo</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可以知道其实类就是一个函数，类本身指向构造函数，而且定义在“类”上的方法其实也都是定义在构造函数的<code>prototype</code>属性上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toValue() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    constructor() &#123;&#125;,</span><br><span class="line">    toString() &#123;&#125;,</span><br><span class="line">    toValue() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>想往类添加其他的方法除了在使用class定义时也可以像<a href="/JavaScript/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/#Mixin%E6%A8%A1%E5%BC%8F">原型与继承</a>中Mixin模式那样直接使用<code>Object.assign</code>进行添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.assign(Foo.prototype, &#123;</span><br><span class="line">    toString() &#123;&#125;,</span><br><span class="line">    toValue() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：和ES5不同的地方是类内部定义的方法是不可枚举的，而es5是可枚举的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Bar() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype.toString = function() &#123;&#125;</span><br><span class="line">console.log(Object.keys(Foo.prototype));            //[]</span><br><span class="line">console.log(Object.keys(Bar.prototype));            //[&quot;toString&quot;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Foo.prototype)); //[&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Bar.prototype)); //[&quot;constructor&quot;,&quot;toString&quot;]</span><br></pre></td></tr></table></figure>

<p>还有个不同点是<code>class</code>必须使用<code>new</code>调用，否则会报错，这也是和普通构造函数不同的地方</p>
<h2 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h2><p>用法在 <a href="/JavaScript/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-1/#%E7%B1%BB-constructor-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">js面向对象笔记</a> 里写有。</p>
<p><code>constructor</code> 方法如果没有显式定义，则会默认添加一个空的 <code>constructor</code> </p>
<p><code>constructor</code> 默认返回实例对象，也就是 <code>this</code> ，也可以指定返回另一个对象，不过会导致实例对象不是该类。</p>
<p>类和普通的构造函数不一样的就是类必须要用 <code>new</code> 来调用否则报错。</p>
<h2 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h2><p>生成类的实例的写法，与ES5一样，需要用 <code>new</code> ，和上面说的一样如果不加 <code>new</code> 调用 <code>class</code> 会产生报错</p>
<p>和ES5差不多如果实例的属性除非是显式定义在其本身（即定义在 <code>this</code> 对象上），否则都是定义在原型上（即定义在 <code>class</code> 上）。</p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。</p>
</blockquote>
<p>但是一旦修改 <code>__proto__</code> 后可能会影响后面实例化的所有实例</p>
<h2 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h2><p>在前面的es5里面有为单个实例对象添加getter和setter的方法：<a href="/JavaScript/js%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1-2/#getter-setter">js笔记：对象</a></p>
<p>ES6和ES5差不多，可以在类内部使用 <code>get</code> 和 <code>set</code> 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomHTMLElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">html</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">html</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(</span><br><span class="line">  <span class="title class_">CustomHTMLElement</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;html&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;set&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h2><p>类的属性名，可以采用表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;getName&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [foo]() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>类也可以像函数一样通过表达式赋值给变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyClass</span> = <span class="keyword">class</span> <span class="title class_">Me</span> &#123;</span><br><span class="line">  <span class="title function_">getClassName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Me</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。</p>
<p>采用 Class 表达式，可以写出立即执行的 Class。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
<h3 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h3><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Foo(); // ReferenceError</span><br><span class="line">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Point</span>.<span class="property">name</span> <span class="comment">// &quot;Point&quot;</span></span><br></pre></td></tr></table></figure>
<p>name属性总是返回紧跟在class关键字后面的类名。</p>
<h3 id="Generator-方法"><a href="#Generator-方法" class="headerlink" title="Generator 方法"></a>Generator 方法</h3><p>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">args</span> = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">args</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象笔记-1</title>
    <url>/%E5%89%8D%E7%AB%AF/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>面向对象篇开始</p>
<span id="more"></span>

<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在es6中可以使用 <code>class</code> 关键字声明一个类，后面可以使用这个类进行实例化。<br>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameOfClass</span> &#123;</span><br><span class="line">    <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类-constructor-构造函数"><a href="#类-constructor-构造函数" class="headerlink" title="类 constructor 构造函数"></a>类 constructor 构造函数</h2><p>用于传递参数然后返回实例对象，使用 <code>new</code> 关键字时自动使用这个构建函数。比如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, type, price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">type</span> = type;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> residentEvil = <span class="keyword">new</span> <span class="title class_">Game</span>(<span class="string">&#x27;Resident Evil 3&#x27;</span>, <span class="string">&#x27;AVG&#x27;</span>, <span class="string">&#x27;414￥&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类中公用方法"><a href="#类中公用方法" class="headerlink" title="类中公用方法"></a>类中公用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="comment">// constructor和上面一样</span></span><br><span class="line">    <span class="title function_">describe</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游戏名：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游戏类型：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">type</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游戏售价：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">price</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> residentEvil = <span class="keyword">new</span> <span class="title class_">Game</span>(<span class="string">&#x27;Resident Evil 3&#x27;</span>, <span class="string">&#x27;AVG&#x27;</span>, <span class="string">&#x27;414￥&#x27;</span>);</span><br><span class="line">residentEvil.<span class="title function_">describe</span>();</span><br></pre></td></tr></table></figure>

<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>子类可以继承父类的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">price</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游戏价格：100￥&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVGGame</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">AVGGame</span>();</span><br><span class="line">son.<span class="title function_">price</span>();</span><br></pre></td></tr></table></figure>

<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code> 关键字用于访问父类和调用父类上的函数（构造函数和普通函数）。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getPrice</span>(<span class="params"></span>) &#123;   </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游戏售价：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">price</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">retName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVGGame</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, price</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">retName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> residentEvil = <span class="keyword">new</span> <span class="title class_">AVGGame</span>(<span class="string">&#x27;Resident Evil 3&#x27;</span>,<span class="string">&#x27;414￥&#x27;</span>);</span><br><span class="line">residentEvil.<span class="title function_">getPrice</span>();</span><br><span class="line">residentEvil.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：super必须要在this之前</p>
</blockquote>
<h2 id="三个注意点"><a href="#三个注意点" class="headerlink" title="三个注意点"></a>三个注意点</h2><ol>
<li>在ES6中类没有变量提升，需要先定义后使用。</li>
<li>类里面共有的属性和方法要加this进行使用，比如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fn</span> = <span class="variable language_">this</span>.<span class="property">getPrice</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getPrice</span>(<span class="params"></span>) &#123;   </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游戏售价：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">price</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类里的this指向问题：谁调用某个方法，那么那个方法里面的this指向的是调用者，而构建函数指向的是实例化的对象。</li>
</ol>
<h1 id="es5"><a href="#es5" class="headerlink" title="es5"></a>es5</h1><h2 id="创建对象方法"><a href="#创建对象方法" class="headerlink" title="创建对象方法"></a>创建对象方法</h2><p>创建对象有三种方法：</p>
<ol>
<li>对象字面量</li>
<li>new Object();</li>
<li>自定义构造函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 3. </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Game</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gta = <span class="keyword">new</span> <span class="title class_">Game</span>(<span class="string">&#x27;Grand Theft Auto&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="实例成员和静态成员"><a href="#实例成员和静态成员" class="headerlink" title="实例成员和静态成员"></a>实例成员和静态成员</h2>实例成员只能通过实例化对象来访问，比如上面 <code>Game</code> 中的name，不可以直接通过 <code>Game.name</code> 访问。而静态成员是在构造函数本身上添加的成员，可以同构造函数访问但是不能通过实例对象进行访问，比如在上面的代码基础上：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Game</span>.<span class="property">name</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="title class_">Game</span>.<span class="property">type</span> = <span class="string">&#x27;AVG&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Game</span>.<span class="property">type</span>); <span class="comment">//AVG</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gta.<span class="property">type</span>);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数原型-prototype"><a href="#构造函数原型-prototype" class="headerlink" title="构造函数原型 prototype"></a>构造函数原型 prototype</h2>如果在构造函数中把函数赋值给实例对象，会因为每次实例化对象时都会分配空间给相同的对象，所以会造成空间浪费，这时候就需要用到原型了。</li>
</ol>
<p>构造函数通过原型分配的函数是所有对象共享的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样是上面的代码</span></span><br><span class="line"><span class="title class_">Game</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gta = <span class="keyword">new</span> <span class="title class_">Game</span>(<span class="string">&#x27;Grand Theft Auto&#x27;</span>);</span><br><span class="line">gta.<span class="title function_">getName</span>();  <span class="comment">//Grand Theft Auto</span></span><br></pre></td></tr></table></figure>
<p>这样上面的 <code>getName</code> 就不用每次实例化对象时都分配一段空间给这个函数。</p>
<h2 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 proto"></a>对象原型 <strong>proto</strong></h2><p>上面实例化对象可以使用 <code>getName</code> 是因为对象中有一个 <code>__proto__</code> 对象，他等价于构造函数的 <code>prototype</code> ，所以只有构造函数的原型中有这个方法就可以在实例对象中使用</p>
<h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h2><p>对象原型 <code>__proto__</code> 和 构造函数原型 <code>prototype</code> 里面都有一个constructor属性，同时指回构造函数本身。</p>
<h2 id="继承父类的属性"><a href="#继承父类的属性" class="headerlink" title="继承父类的属性"></a>继承父类的属性</h2><p>这里需要用到 <code>call</code> 调用父类的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="继承父类的方法"><a href="#继承父类的方法" class="headerlink" title="继承父类的方法"></a>继承父类的方法</h2><p>根据原型链的原理，只需要实例化一个父类的对象赋值给子类对象的 <code>prototype</code> 就可以通过原型链访问到父类的方法了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line">son.<span class="title function_">getName</span>();  <span class="comment">// son</span></span><br></pre></td></tr></table></figure>


<h1 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h1><p>在es6之前可以通过构造函数+原型实现面向对象编程，es6之后可以通过类进行面向对象编程。类其实可以看做是构造函数和原型结合的语法糖。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>固态硬盘推荐</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>固态硬盘简称SSD，相对于传统机械硬盘有更快的传输速度，更长的使用寿命，而如今1TB以上的机械硬盘大多数采用<a href="https://laoyaoba.com/html/news/newsdetail?source=pc&news_id=724004">SMR工艺</a>，所以速度非常慢,这就是为什么大部分人旧的电脑升级到win10后会很卡。</p>
<p>所以建议起码人手一个SSD做系统盘，下面我来推荐一些不容易掉进坑的SSD</p>
<span id="more"></span>

<h1 id="第一步-先确认接口"><a href="#第一步-先确认接口" class="headerlink" title="第一步 先确认接口"></a>第一步 先确认接口</h1><img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/1.png" class="">

<p>这些接口看起来眼花缭乱但实则非常好分辨，SSD一般分SATA接口和M.2接口，从目前市场上看SATA固态基本只有SATA3接口。</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/2.png" class="">
<p style="text-align: center;">
    <span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 12px; color: rgb(127, 127, 127);">主板上的SATA接口</span>
</p>

<p>m.2接口又分为Socket 2（B key）和Socket 3（M key），基本上只要看缺口就能分辨了</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/3.png" class="">
<p style="text-align: center;">
    <span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 12px; color: rgb(127, 127, 127);">左上为B key 右上为M key 下面的为B &amp; M key</span>
</p>

<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/4.png" class="">
<p style="text-align: center;">
    <span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 12px; color: rgb(127, 127, 127);">上图970pro为m key接口，860evo为b key接口。</span>
</p>

<p>如今几乎全部的固态都跳过B key而采用B &amp; K key，能够同时兼任两种插槽。</p>
<p>而大部分拥有Socket 3这一高速接口的主板，都会进行一些醒目的标注，毕竟是很大的卖点。常见的标注有“M.2 Socket 3”、“PCI-E ×4”、“M.2 ×4”等，华擎则将其命名为“Ultra M.2”，也有一些主板会直接标注速度，如“32Gbps”（PCI-E 3.0×4）等；</p>
<blockquote>
<p><em>PS：对于台式机，英特尔平台一般六代酷睿以前都不存在m.2接口，AMD平台锐龙之前也不存在m.2接口，此时应选择SATA接口的SSD。若为六代酷睿以上的英特尔平台以及AMD锐龙平台一般带有1~2个m.2接口（过于低端的主板不带m.2的也有）,可以查阅主板说明书或者根据型号上网查找关于m.2接口的信息</em></p>
</blockquote>
<blockquote>
<p><em>对于笔记本，可以在网上找相关资料（拆机图文或视频，评测视频、贴吧提问等等）得知自己笔记本上有没有多余的硬盘位（光驱位也行），但是对于比较旧的笔记本基本都没有多余的硬盘位</em></p>
</blockquote>
<hr>
<h1 id="第二步-选购"><a href="#第二步-选购" class="headerlink" title="第二步 选购"></a>第二步 选购</h1><h2 id="SATA硬盘"><a href="#SATA硬盘" class="headerlink" title="SATA硬盘"></a>SATA硬盘</h2><h3 id="三星860evo"><a href="#三星860evo" class="headerlink" title="三星860evo"></a>三星860evo</h3><p>颗粒：V-NAND（三星自家的3D NAND技术） TLC颗粒</p>
<ul>
<li>主控：mjx主控</li>
<li>缓存：LPDDR4</li>
<li>价格（容量&#x2F;价格）：<br><code>256g/319元 512g/499 1t/999</code></li>
</ul>
<p>评价：基本上是最优先选择的硬盘，各方面水平非常平衡而且质量非常不错，拥有五年质保。</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/5.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/6.png" class="">

<h3 id="西数蓝盘"><a href="#西数蓝盘" class="headerlink" title="西数蓝盘"></a>西数蓝盘</h3><ul>
<li>颗粒：西数64层3D TLC正片</li>
<li>主控：马牌88SS1074</li>
<li>缓存：lpddr3</li>
<li>价格（容量&#x2F;价格）：<br><code>250g/309元  512g/459  1t/999元</code></li>
</ul>
<p>评价：性能可靠，但此ssd主控诞生于2014年，到如今以持续战斗五年，已无特别突出的地方，质保五年，价格合适，同上属于同类佼佼者，目前价格低于1元&#x2F;g</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/7.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/8.png" class="">

<h3 id="英睿达mx500"><a href="#英睿达mx500" class="headerlink" title="英睿达mx500"></a>英睿达mx500</h3><ul>
<li>颗粒： IMFT第二代64层的3D TLC</li>
<li>主控：慧荣SM2258</li>
<li>缓存：LPDDR3</li>
<li>价格（容量&#x2F;价格）：<br><code>250g/329元  512g/399  1t/899元</code></li>
</ul>
<p>评价：英睿达mx500采用慧荣主控，性能方面随着SLC Cache大容量化，性能也是赶上了860evo，同五年保，目前来说，mx500只有京东购买才享有保修，其余都为店保</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/9.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/10.png" class="">

<blockquote>
<p>总结：以上三个型号SSD属于SATA盘里首选盘，而随着m.2接口的普及以及SSD市场价格的持续走低，如今已可以称之为“白菜价”，这三款之间也无较大性能差距，可靠性也相近，建议按需要找到适合自己的容量，然后选择其中便宜的入手即可。</p>
</blockquote>
<h2 id="M-2接口固态"><a href="#M-2接口固态" class="headerlink" title="M.2接口固态"></a>M.2接口固态</h2><h3 id="西数蓝盘sn500"><a href="#西数蓝盘sn500" class="headerlink" title="西数蓝盘sn500"></a>西数蓝盘sn500</h3><ul>
<li>颗粒：闪迪 64层 3d堆叠</li>
<li>主控：闪迪hg48r</li>
<li>缓存：未知</li>
<li>通道数：pci 3.0 x2</li>
</ul>
<p>评价：西数家推出全新m.2系列产品，定位为入门级，虽然主控是没有数据的闪迪自家主控，在这个价位上不错的速度表现使之成为入门级别很不错的选择，而b口硬盘也没有太多可选择的余地（入门无脑选这个）</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/11.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/12.png" class="">

<h3 id="西数黑盘sn750"><a href="#西数黑盘sn750" class="headerlink" title="西数黑盘sn750"></a>西数黑盘sn750</h3><ul>
<li>颗粒：闪迪 64层 3d堆叠</li>
<li>主控：SanDisk 20-82-007011</li>
<li>缓存：18G的SLC缓存+海力士1GB DDR4-2400</li>
<li>通道数：pci 3.0 x4</li>
</ul>
<p>评价：西数家推出全新m.2系列产品，定位发烧级，主控虽然依旧是闪迪自家研发（闪迪已被西数收购），但自带18G的SLC缓存与海力士的ddr4高速缓存让它速度惊人，从跑分上也看到这点，当然相对的发热也不小，如果不差钱可以上这款</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/13.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/14.png" class="">

<h3 id="浦科特m9peg"><a href="#浦科特m9peg" class="headerlink" title="浦科特m9peg"></a>浦科特m9peg</h3><ul>
<li>颗粒：东芝64层的3D TLC</li>
<li>主控：Marvell 88SS1093</li>
<li>缓存：512MB的LPDDR3缓存</li>
<li>通道数：pci 3.0 x4</li>
</ul>
<p>评价：浦科特今年的主流产品，在这价位速度表现不错，主控和颗粒都没问题，与高性能对应的是较高的发热。（性能区于西数黑盘和蓝屏之间，价格也略贵与蓝盘）</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/15.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/16.png" class="">

<h3 id="三星970-pro（发烧级固态）"><a href="#三星970-pro（发烧级固态）" class="headerlink" title="三星970 pro（发烧级固态）"></a>三星970 pro（发烧级固态）</h3><p>颗粒：64层堆叠的MLC<br>主控：Phoenix主控<br>缓存：1GB的LPDDR4缓存<br>通道数：pci 3.0 x4</p>
<p>评价：市场上为数不多的还存留的mlc（tlc模拟）颗粒，颗粒理论寿命长于tlc，加上1gb的ddr4缓存，掉速问题是不存在的，三星自家定位为发烧级产品，如果是日常使用和游戏使用其实选西数黑盘就够了。如果你想追求最极致的享受，那这个盘必选了。</p>
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/17.png" class="">
<img src="/%E7%A1%AC%E4%BB%B6%E6%8E%A8%E8%8D%90/ssd%E6%8E%A8%E8%8D%90/18.png" class="">
]]></content>
      <categories>
        <category>硬件推荐</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>硬件推荐</tag>
        <tag>固态</tag>
      </tags>
  </entry>
  <entry>
    <title>ts笔记（2）：函数、类、接口类型和类型别名</title>
    <url>/TypeScript/ts%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p>这章讲解函数类型、类类型、接口类型、类型别名、</p>
<span id="more"></span>

<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>在 TypeScript 里我们可以显式指定函数参数和返回值的类型，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h2><p>在 JavaScript 中，我们知道一个函数可以没有显式 return，此时函数的返回值应该是 undefined，而<strong>函数的返回类型是 void 类型</strong>。</p>
<blockquote>
<p>需要注意的是，在 TypeScript 中，如果我们显式声明函数的返回值类型为 undfined，将会得到如下所示的错误提醒。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ts(2355) A function whose declared type is neither &#x27;void&#x27; nor &#x27;any&#x27; must return a value</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上一章，如果函数不需要返回值应该使用 void 来表示返回值类型，这应该算是 void 类型的唯一用处了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line"><span class="title function_">fn1</span>().<span class="title function_">doSomething</span>() <span class="comment">// ts(2339) Property &#x27;doSomething&#x27; does not exist on type &#x27;void&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用类似定义箭头函数的语法来表示函数类型的参数和返回值类型，此时&#x3D;&gt; 类型仅仅用来定义一个函数类型而不用实现这个函数。<strong>需要注意的是，这里的&#x3D;&gt;与 ES6 中箭头函数的&#x3D;&gt;有所不同。TypeScript 函数类型中的&#x3D;&gt;用来表示函数的定义，其左侧是函数的参数类型，右侧是函数的返回值类型；而 ES6 中的&#x3D;&gt;是函数的实现</strong>。如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Adder</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> <span class="comment">// TypeScript 函数类型定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">Adder</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b <span class="comment">// ES6 箭头函数</span></span><br></pre></td></tr></table></figure>

<p>在对象中，除了使用这种声明语法，我们还可以使用类似对象属性的简写语法来声明函数类型的属性，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">del</span>(<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">entity</span>: <span class="title class_">Entity</span> = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b,</span><br><span class="line">  <span class="title function_">del</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可缺省和可推断的返回值类型"><a href="#可缺省和可推断的返回值类型" class="headerlink" title="可缺省和可推断的返回值类型"></a>可缺省和可推断的返回值类型</h2><p>幸运的是，函数返回值的类型可以在 TypeScript 中被推断出来，即可缺省。</p>
<p>函数内是一个相对独立的上下文环境，我们可以根据入参对值加工计算，并返回新的值。从类型层面看，我们也可以通过类型推断（回想一下 04 讲中的类型推断、上下文类型推断）加工计算入参的类型，并返回新的类型，示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computeTypes</span>(<span class="params">one: <span class="built_in">string</span>, two: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [two]</span><br><span class="line">  <span class="keyword">const</span> strs = [one]</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    nums,</span><br><span class="line">    strs,</span><br><span class="line">  &#125; <span class="comment">// 返回 &#123; nums: number[]; strs: string[] &#125; 的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，TypeScript 中的函数返回值类型是可以缺省和推断出来的，但是有些特例需要我们显式声明返回值类型，比如 Generator 函数的返回值。</p>
<h2 id="Generator-函数的返回值"><a href="#Generator-函数的返回值" class="headerlink" title="Generator 函数的返回值"></a>Generator 函数的返回值</h2><p>Generator 函数返回的是一个 Iterator 迭代器对象，我们可以使用 Generator 的同名接口泛型或者 Iterator 的同名接口泛型表示返回值的类型，示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AnyType</span> = <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnyReturnType</span> = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnyNextType</span> = <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Generator</span>&lt;<span class="title class_">AnyType</span>, <span class="title class_">AnyReturnType</span>, <span class="title class_">AnyNextType</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="keyword">yield</span> <span class="literal">true</span> <span class="comment">// nextValue 类型是 number，yield 后必须是 boolean 类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;nextValue&#125;</span>`</span> <span class="comment">// 必须返回 string 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h2><p>在实际情况中可能会遇到函数参数可以可传或不传的情况，在 ts 中也一样可以表达</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// function log(x?: string | undefined): string | undefined</span></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>() <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// =&gt; hello world</span></span><br></pre></td></tr></table></figure>

<p>如果在类型标注的<code>:</code>前加上<code>?</code>表示 log 函数的参数 x 就是可缺省的，也就是说 x 的类型可能是<code>undefined</code></p>
<p>但是并不意味着可缺省和类型是 <code>undefined</code> 等价的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log1</span>(<span class="params">x: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>()</span><br><span class="line"><span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="title function_">log1</span>() <span class="comment">// ts(2554) Expected 1 arguments, but got 0</span></span><br><span class="line"><span class="title function_">log1</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>显然这里的<code>?:</code>表示参数可以缺省、可以不传，也就是说调用函数时，我们可以不显式传入参数。但是，如果我们声明了参数类型为 xxx | undefined，就表示函数参数是不可缺省且类型必须是 xxx 或者 undfined。</p>
<p>在 ES6 中支持函数默认参数的功能，而 TypeScript 会根据函数的默认参数的类型来推断函数参数的类型，示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x = <span class="string">&#x27;hello&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>() <span class="comment">// =&gt; &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// =&gt; &#x27;hi&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// ts(2345) Argument of type &#x27;1&#x27; is not assignable to parameter of type &#x27;string | undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据函数的默认参数 ‘hello’ ，TypeScript 推断出了 x 的类型为 string | undefined。</p>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>在 ES6 中，JavaScript 支持函数参数的剩余参数，它可以把多个参数收集到一个变量中。同样，在 TypeScript 中也支持这样的参数类型定义，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// =&gt; 6</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>) <span class="comment">// ts(2345) Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们将函数参数 nums 聚合的类型定义为 (number | string)[]，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: (<span class="built_in">number</span> | <span class="built_in">string</span>)[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="property">reduce</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + <span class="title class_">Number</span>(b), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>那么，函数的每一个参数的类型就是联合类型 number | string，因此 sum(1, ‘2’, 3) 的类型检查也就通过了。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>使用了 TypeScript 后，通过指定 this 的类型（严格模式下，必须显式指定 this 的类型），当我们错误使用了 this，TypeScript 就会提示我们，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">// ts(2683) &#x27;this&#x27; implicitly has type &#x27;any&#x27; because it does not have a type annotation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">say</span>()</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果我们直接调用 say 函数，this 可能指向全局 window 或 global（Node 中）或 undefined（浏览器 js 脚本开启 strict）。但是，在 strict 模式下的 TypeScript 中，它会提示 this 的类型是 any，此时就需要我们手动显式指定类型了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"><span class="variable language_">this</span>: Window, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">say</span> = say</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">say</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  say,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">say</span>(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// ts(2684) The &#x27;this&#x27; context of type &#x27;&#123; say: (this: Window, name: string) =&gt; void; &#125;&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;Window&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">say</span>(<span class="string">&#x27;captain&#x27;</span>) <span class="comment">// ts(2684) The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;Window&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果我们直接调用 say()，this 实际上应该指向全局变量 window，但是因为 TypeScript 无法确定 say 函数被谁调用，所以将 this 的指向默认为 void，也就提示了一个 ts(2684) 错误。</p>
</blockquote>
<p>同样，定义对象的函数属性时，只要实际调用中 this 的指向与指定的 this 指向不同，TypeScript 就能发现 this 指向的错误，示例代码如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">say</span>(<span class="attr">this</span>: <span class="title class_">Person</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;captain&#x27;</span>,</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = person.<span class="property">say</span></span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// ts(2684) The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;Person&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：显式注解函数中的 this 类型，它表面上占据了第一个形参的位置，但并不意味着函数真的多了一个参数，因为 TypeScript 转译为 JavaScript 后，“伪形参” this 会被抹掉。</p>
</blockquote>
<p>同样，我们也可以显式限定类函数属性中的 this 类型，TypeScript 也能检查出错误的使用方式，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">onClick</span>(<span class="params"><span class="variable language_">this</span>: Component</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> component = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">interface</span> UI &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="attr">onClick</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">ui</span>: <span class="variable constant_">UI</span> = &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">ui.<span class="title function_">addClickListener</span>(<span class="keyword">new</span> <span class="title class_">Component</span>().<span class="property">onClick</span>) <span class="comment">// ts(2345)</span></span><br></pre></td></tr></table></figure>

<p>此外，在链式调用风格的库中，使用 this 也可以很方便地表达出其类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">val</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">map</span>(<span class="attr">cb</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">log</span>(): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Container</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">log</span>() <span class="comment">// =&gt; 2</span></span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">3</span>)</span><br><span class="line">  .<span class="title function_">log</span>() <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>

<p>因为 Container 类中 map、log 等函数属性（方法）未显式指定 this 类型，默认类型是 Container，所以以上方法在被调用时返回的类型也是 Container，this 指向一直是类的实例，它可以一直无限地被链式调用。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>下面代码通过 convert 函数将 string 类型的值转换为 number 类型，number 类型转换为 string 类型，而将 null 类型转换为数字 -1。此时， x1、x2、x3 的返回值类型都会被推断成 string | number</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> | -<span class="number">1</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = <span class="title function_">convert</span>(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// =&gt; string | number</span></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="title function_">convert</span>(<span class="number">1</span>) <span class="comment">// =&gt; string | number</span></span><br><span class="line"><span class="keyword">const</span> x3 = <span class="title function_">convert</span>(<span class="literal">null</span>) <span class="comment">// =&gt; string | number</span></span><br></pre></td></tr></table></figure>

<p>如果想要精确的描述参数和返回值关系的话，就需要用到函数重载。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: <span class="literal">null</span></span>): -<span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = <span class="title function_">convert</span>(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="title function_">convert</span>(<span class="number">1</span>) <span class="comment">// =&gt; string</span></span><br><span class="line"><span class="keyword">const</span> x3 = <span class="title function_">convert</span>(<span class="literal">null</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>示例中 1~3 行定义了三种各不相同的函数类型列表，并描述了不同的参数类型对应不同的返回值类型，而从第 4 行开始才是函数的实现。</p>
<blockquote>
<p>注意：函数重载列表的各个成员（即示例中的 1 ~ 3 行）必须是函数实现（即示例中的第 4 行）的子集，例如 “function convert(x: string): number”是“function convert(x: string | number | null): any”的子集。</p>
</blockquote>
<p>在 convert 函数被调用时，TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义。因此，我们需要把最精确的函数重载放到前面。比如下面实例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> P1 &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> P2 <span class="keyword">extends</span> P1 &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: P1</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: P2</span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: P1 | P2</span>): <span class="built_in">any</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = <span class="title function_">convert</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span> &#125; <span class="keyword">as</span> <span class="variable constant_">P1</span>) <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="title function_">convert</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125; <span class="keyword">as</span> <span class="variable constant_">P2</span>) <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>因为 P2 继承自 P1，所以类型为 P2 的参数会和类型为 P1 的参数一样匹配到第一个函数重载，此时 x1、x2 的返回值都是 number。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: P2</span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: P1</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x: P1 | P2</span>): <span class="built_in">any</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = <span class="title function_">convert</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span> &#125; <span class="keyword">as</span> <span class="variable constant_">P1</span>) <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="title function_">convert</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125; <span class="keyword">as</span> <span class="variable constant_">P2</span>) <span class="comment">// =&gt; string</span></span><br></pre></td></tr></table></figure>

<p>而我们只需要将函数重载列表的顺序调换一下，类型为 P2 和 P1 的参数就可以分别匹配到正确的函数重载了</p>
<h2 id="类型谓词（is）"><a href="#类型谓词（is）" class="headerlink" title="类型谓词（is）"></a>类型谓词（is）</h2><p>示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">s</span>): s is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 类型谓词</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> s === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> n === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">operator</span>(<span class="params">x: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(x)) &#123;</span><br><span class="line">    <span class="comment">// ok x 类型缩小为 string</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isNumber</span>(x)) &#123;</span><br><span class="line">    <span class="comment">// ts(2345) unknown 不能赋值给 number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在实际业务中，任何实体都可以被抽象为一个使用类表达的类似对象的数据结构，且这个数据结构既包含属性，又包含方法，比如我们在下方抽象了一个狗的类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">dog.<span class="title function_">bark</span>() <span class="comment">// =&gt; &#x27;Woof! Woof!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果使用传统的 ES5 或者 ES3 代码定义类，我们需要使用函数+原型链的形式进行模拟，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name <span class="comment">// ts(2683) &#x27;this&#x27; implicitly has type &#x27;any&#x27; because it does not have a type annotation.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Q&#x27;</span>) <span class="comment">// ts(7009) &#x27;new&#x27; expression, whose target lacks a construct signature, implicitly has an &#x27;any&#x27; type.</span></span><br><span class="line">dog.<span class="title function_">bark</span>() <span class="comment">// =&gt; &#x27;Woof! Woof!&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 中，使用 extends 关键字就能很方便地定义类继承的抽象模式，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">say</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line">dog.<span class="title function_">bark</span>() <span class="comment">// =&gt; &#x27;Woof! Woof!&#x27;</span></span><br><span class="line">dog.<span class="title function_">say</span>(<span class="string">&#x27;Q&#x27;</span>) <span class="comment">// =&gt; I&#x27;m Q!</span></span><br><span class="line">dog.<span class="property">type</span> <span class="comment">// =&gt; Animal</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：派生类通常被称作子类，基类也被称作超类（或者父类）。</p>
</blockquote>
<blockquote>
<p>这里的 Dog 基类与第一个例子中的类相比，少了一个构造函数。<strong>这是因为派生类如果包含一个构造函数，则必须在构造函数中调用 super() 方法，这是 TypeScript 强制执行的一条重要规则</strong>。</p>
</blockquote>
<p>如果不调用 super：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ts(2377) Constructors for derived classes must contain a &#x27;super&#x27; call.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公共、私有与受保护的修饰符"><a href="#公共、私有与受保护的修饰符" class="headerlink" title="公共、私有与受保护的修饰符"></a>公共、私有与受保护的修饰符</h2><p>属性和方法除了可以通过 extends 被继承之外，还可以通过修饰符控制可访问性。在 TypeScript 中就支持 3 种访问修饰符，分别是 public、private、protected。</p>
<ul>
<li>public 修饰的是在任何地方可见、公有的属性或方法；</li>
<li>private 修饰的是仅在同一类中可见、私有的属性或方法；</li>
<li>protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">lastName</span>: <span class="built_in">string</span> = <span class="string">&#x27;Stark&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;Tony&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">firstName</span>) <span class="comment">//  =&gt; &quot;Tony&quot;</span></span><br><span class="line">son.<span class="property">firstName</span> = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">firstName</span>) <span class="comment">//  =&gt; &quot;Jack&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">lastName</span>) <span class="comment">// ts(2341) Property &#x27;lastName&#x27; is private and only accessible within class &#x27;Son&#x27;.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：TypeScript 中定义类的私有属性仅仅代表静态类型检测层面的私有。如果我们强制忽略 TypeScript 类型的检查错误，转译且运行 JavaScript 时依旧可以获取到 lastName 属性，这是因为 JavaScript 并不支持真正意义上的私有属性。</p>
</blockquote>
<p>接下来我们再看一下受保护的属性和方法，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">lastName</span>: <span class="built_in">string</span> = <span class="string">&#x27;Stark&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Son</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(firstName)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getMyLastName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> grandSon = <span class="keyword">new</span> <span class="title class_">GrandSon</span>(<span class="string">&#x27;Tony&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grandSon.<span class="title function_">getMyLastName</span>()) <span class="comment">// =&gt; &quot;Stark&quot;</span></span><br><span class="line">grandSon.<span class="property">lastName</span> <span class="comment">// ts(2445) Property &#x27;lastName&#x27; is protected and only accessible within class &#x27;Son&#x27; and its subclasses.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然我们不能通过派生类的实例访问 protected 修饰的属性和方法，但是可以通过派生类的实例方法进行访问。比如示例中的第 21 行，通过实例的 getMyLastName 方法获取受保护的属性 lastName 是 ok 的，而第 22 行通过实例直接获取受保护的属性 lastName 则提示了一个 ts(2445) 的错误。</p>
</blockquote>
<h2 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h2><p>在前面的例子中，Son 类 public 修饰的属性既公开可见，又可以更改值，如果我们不希望类的属性被更改，则可以使用 readonly 只读修饰符声明类的属性，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;Tony&#x27;</span>)</span><br><span class="line">son.<span class="property">firstName</span> = <span class="string">&#x27;Jack&#x27;</span> <span class="comment">// ts(2540) Cannot assign to &#x27;firstName&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>除了上边提到的修饰符之外，在 TypeScript 中还可以通过 getter、setter 截取对类成员的读写访问。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">lastName</span>: <span class="built_in">string</span> = <span class="string">&#x27;Stark&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Son</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(firstName)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">myLastName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">myLastName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">firstName</span> === <span class="string">&#x27;Tony&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lastName</span> = name</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Unable to change myLastName&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> grandSon = <span class="keyword">new</span> <span class="title class_">GrandSon</span>(<span class="string">&#x27;Tony&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grandSon.<span class="property">myLastName</span>) <span class="comment">// =&gt; &quot;Stark&quot;</span></span><br><span class="line">grandSon.<span class="property">myLastName</span> = <span class="string">&#x27;Rogers&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grandSon.<span class="property">myLastName</span>) <span class="comment">// =&gt; &quot;Rogers&quot;</span></span><br><span class="line"><span class="keyword">const</span> grandSon1 = <span class="keyword">new</span> <span class="title class_">GrandSon</span>(<span class="string">&#x27;Tony1&#x27;</span>)</span><br><span class="line">grandSon1.<span class="property">myLastName</span> = <span class="string">&#x27;Rogers&#x27;</span> <span class="comment">// =&gt; 控制台err: &quot;Unable to change myLastName&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>因为这些属性存在于类这个特殊的对象上，而不是类的实例上，所以我们可以直接通过类访问静态属性，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">&#x27;MyArray&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isArray</span>(<span class="params">obj: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyArray</span>.<span class="property">displayName</span>) <span class="comment">// =&gt; &quot;MyArray&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyArray</span>.<span class="title function_">isArray</span>([])) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyArray</span>.<span class="title function_">isArray</span>(&#123;&#125;)) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>这里分别调用了类的静态属性和静态方法。</p>
<blockquote>
<p>注意：上边我们提到了不依赖实例 this 上下文的方法就可以定义成静态方法，这就意味着需要显式注解 this 类型才可以在静态方法中使用 this；非静态方法则不需要显式注解 this 类型，因为 this 的指向默认是类的实例。</p>
</blockquote>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是一种不能被实例化仅能被子类继承的特殊类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">add</span>(): <span class="built_in">number</span></span><br><span class="line">  displayName = <span class="string">&#x27;Adder&#x27;</span></span><br><span class="line">  <span class="title function_">addTwice</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>) * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumAdder</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Adder</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numAdder = <span class="keyword">new</span> <span class="title class_">NumAdder</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numAdder.<span class="property">displayName</span>) <span class="comment">// =&gt; &quot;Adder&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numAdder.<span class="title function_">add</span>()) <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numAdder.<span class="title function_">addTwice</span>()) <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>

<p>实际上，我们也可以定义一个描述对象结构的接口类型抽象类的结构，并通过 implements 关键字约束类的实现。使用接口与使用抽象类相比，区别在于接口只能定义类成员的类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdder</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">add</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumAdder</span> <span class="keyword">implements</span> <span class="title class_">IAdder</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addTwice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>) * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>interface 会在转移成 js 时抹除掉，而抽象类则会留下来。</p>
</blockquote>
<h2 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h2><p>类的最后一个特性——类的类型和函数类似，即在声明类的时候，其实也同时声明了一个特殊的类型（确切地讲是一个接口类型），这个类型的名字就是类名，表示类实例的类型；在定义类的时候，我们声明的除构造函数外所有属性、方法的类型就是这个特殊类型的成员。如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a1</span>: A = &#123;&#125; <span class="comment">// ts(2741) Property &#x27;name&#x27; is missing in type &#x27;&#123;&#125;&#x27; but required in type &#x27;A&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a2</span>: A = &#123; <span class="attr">name</span>: <span class="string">&#x27;a2&#x27;</span> &#125; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h1 id="接口类型与类型别名"><a href="#接口类型与类型别名" class="headerlink" title="接口类型与类型别名"></a>接口类型与类型别名</h1><h2 id="Interface-接口类型"><a href="#Interface-接口类型" class="headerlink" title="Interface 接口类型"></a>Interface 接口类型</h2><p>TypeScript 不仅能帮助前端改变思维方式，还能强化面向接口编程的思维和能力，而这正是得益于 Interface 接口类型。通过接口类型，我们可以清晰地定义模块内、跨模块、跨项目代码的通信规则。</p>
<p>TypeScript 对对象的类型检测遵循一种被称之为“鸭子类型”（duck typing）或者“结构化类型（structural subtyping）”的准则，即只要两个对象的结构一致，属性和方法的类型一致，则它们的类型就是一致的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Study</span>(<span class="params">language: &#123; name: <span class="built_in">string</span>; age: () =&gt; <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`ProgramLanguage <span class="subst">$&#123;language.name&#125;</span> created <span class="subst">$&#123;language.age()&#125;</span> years ago.`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Study</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Study</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ts(2322) number 不能赋值给 string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Study</span>(&#123;</span><br><span class="line">  <span class="comment">// ts(2345) 实参(Argument)与形参(Parameter)类型不兼容，缺少必需的属性 age</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Study</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>, <span class="comment">// ts(2345) 实参(Argument)与形参(Parameter)类型不兼容，不存在的属性 id</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有意思的是，在上边的示例中，如果我们先把这个对象字面量赋值给一个变量，然后再把变量传递给函数进行调用，那么 TypeScript 静态类型检测就会仅仅检测形参类型中定义过的属性类型，而包容地忽略任何多余的属性，此时也不会抛出一个 ts(2345) 类型错误。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ts = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Study</span>(ts) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>这并非一个疏忽或 bug，而是有意为之地将对象字面量和变量进行区别对待，我们把这种情况称之为对象字面量的 freshness。</p>
<p>内联形式的接口类型定义在语法层面与熟知的 JavaScript 解构颇为神似，所以要分清楚它们的区别：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 纯 JavaScript 解构语法 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StudyJavaScript</span>(<span class="params">&#123; name, age &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** TypeScript 里解构与内联类型混用 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StudyTypeScript</span>(<span class="params">&#123; name, age &#125;: &#123; name: <span class="built_in">string</span>; age: () =&gt; <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 纯 JavaScript 解构语法，定义别名 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StudyJavaScript</span>(<span class="params">&#123; name: aliasName &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义name的别名</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(aliasName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** TypeScript */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StudyTypeScript</span>(<span class="params">language: &#123; name: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(name); // 不能直接打印name</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(language.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，接口的语法和其他类型的语言并没有太大区别，我们通过如下所示代码一起看看接口是如何定义的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/ ** 关键字 接口名称 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProgramLanguage</span> &#123;</span><br><span class="line">  <span class="comment">/** 语言名称 */</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/** 使用年限 */</span></span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前边示例中，通过内联参数类型定义的 Study 函数就可以直接使用 ProgramLanguage 接口来定义参数 language 的类型了，或者定义变量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NewStudy</span>(<span class="params">language: ProgramLanguage</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`ProgramLanguage <span class="subst">$&#123;language.name&#125;</span> created <span class="subst">$&#123;language.age()&#125;</span> years ago.`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">TypeScript</span>: <span class="title class_">ProgramLanguage</span></span><br></pre></td></tr></table></figure>

<p>接着，我们把满足接口类型约定的一个对象字面量赋值给了这个变量:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">TypeScript</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">TypeScript</span> = &#123;&#125;</span><br><span class="line"><span class="comment">// 提示对象字面量类型 &#123;&#125; 缺少 name 和 age 属性的 ts(2739) 错误</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">TypeScript</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提示对象字面量类型 &#123; name: string; &#125; 缺少必需的 age 属性的 ts( 2741) 错误。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">TypeScript</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;Wrong Type&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts(2322) number 类型不能赋值给 string，第 3 行会提示错误：ts(2322)string 不能赋值给函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">TypeScript</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts(2322) 错误：对象字面量不能赋值给 ProgramLanguage 类型的变量 TypeScript，id在ProgramLanguage类型里不存在</span></span><br></pre></td></tr></table></figure>

<h2 id="可缺省属性"><a href="#可缺省属性" class="headerlink" title="可缺省属性"></a>可缺省属性</h2><p>如果某个属性需要时可缺省，那么可以使用<code>?</code>语法来标注：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 关键字 接口名称 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OptionalProgramLanguage</span> &#123;</span><br><span class="line">  <span class="comment">/** 语言名称 */</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/** 使用年限 */</span></span><br><span class="line">  age?: <span class="function">() =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">OptionalTypeScript</span>: <span class="title class_">OptionalProgramLanguage</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">&#125; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>当属性被标注为可缺省后，它的类型就变成了显式指定的类型与 undefined 类型组成的联合类型，比如示例中 OptionalTypeScript 的 age 属性类型就变成了<code>(() =&gt; number) | undefined</code></p>
<p>但是和前面的可缺省参数一样，可缺省属性并不等同于<code>xxx | undefined</code>。</p>
<p>既然值可能是 undefined ，如果我们需要对该对象的属性或方法进行操作，就可以使用类型守卫或 Optional Chain，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">OptionalTypeScript</span>.<span class="property">age</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="title class_">OptionalTypeScript</span>.<span class="title function_">age</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="title class_">OptionalTypeScript</span>.<span class="property">age</span>?.()</span><br></pre></td></tr></table></figure>

<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>我们可能还会碰到这样的场景，希望对对象的某个属性或方法锁定写操作，这时，我们可以在属性名前通过添加 readonly 修饰符的语法来标注其为只读属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyProgramLanguage</span> &#123;</span><br><span class="line">  <span class="comment">/** 语言名称 */</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/** 使用年限 */</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: (<span class="function">() =&gt;</span> <span class="built_in">number</span>) | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ReadOnlyTypeScript</span>: <span class="title class_">ReadOnlyProgramLanguage</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ts(2540)错误，name 只读 */</span></span><br><span class="line"><span class="title class_">ReadOnlyTypeScript</span>.<span class="property">name</span> = <span class="string">&#x27;JavaScript&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，这仅仅是静态类型检测层面的只读，实际上并不能阻止对对象的篡改。因为在转译为 JavaScript 之后，readonly 修饰符会被抹除。因此，任何时候与其直接修改一个对象，不如返回一个新的对象，这会是一种比较安全的实践。</p>
</blockquote>
<h2 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h2><p>除了对象还可以定义函数的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StudyLanguage</span> &#123;</span><br><span class="line">  (<span class="attr">language</span>: <span class="title class_">ProgramLanguage</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 单独的函数实践 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">StudyInterface</span>: <span class="title class_">StudyLanguage</span> = <span class="function">(<span class="params">language</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;language.name&#125;</span> <span class="subst">$&#123;language.age()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，我们很少使用接口类型来定义函数的类型，更多使用内联类型或类型别名配合箭头函数语法来定义函数类型，比如：<code>type StudyLanguageType = (language: ProgramLanguage) =&gt; void</code></p>
<h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2><p>在实际工作中我们经常会把对象当 Map 映射使用，比如下边代码示例中定义了索引是任意数字的对象 LanguageRankMap 和索引是任意字符串的对象 LanguageMap。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">LanguageRankMap</span> = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;TypeScript&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">LanguageMap</span> = &#123;</span><br><span class="line">  <span class="title class_">TypeScript</span>: <span class="number">2012</span>,</span><br><span class="line">  <span class="title class_">JavaScript</span>: <span class="number">1995</span>,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，我们需要使用索引签名来定义上边提到的对象映射结构，并通过 “[索引名: 类型]”的格式约束索引的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LanguageRankInterface</span> &#123;</span><br><span class="line">  [<span class="attr">rank</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LanguageYearInterface</span> &#123;</span><br><span class="line">  [<span class="attr">name</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">LanguageRankMap</span>: <span class="title class_">LanguageRankInterface</span> = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;TypeScript&#x27;</span>, <span class="comment">// ok</span></span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;JavaScript&#x27;</span>, <span class="comment">// ok</span></span><br><span class="line">    <span class="title class_">WrongINdex</span>: <span class="string">&#x27;2012&#x27;</span>, <span class="comment">// ts(2322) 不存在的属性名</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">LanguageMap</span>: <span class="title class_">LanguageYearInterface</span> = &#123;</span><br><span class="line">    <span class="title class_">TypeScript</span>: <span class="number">2012</span>, <span class="comment">// ok</span></span><br><span class="line">    <span class="title class_">JavaScript</span>: <span class="number">1995</span>, <span class="comment">// ok</span></span><br><span class="line">    <span class="number">1</span>: <span class="number">1970</span>, <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在上述示例中，数字作为对象索引时，它的类型既可以与数字兼容，也可以与字符串兼容，这与 JavaScript 的行为一致。因此，使用 0 或 ‘0’ 索引对象时，这两者等价。</p>
</blockquote>
<p>同样，我们可以使用 readonly 注解索引签名，此时将对应属性设置为只读就行，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LanguageRankInterface</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">rank</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LanguageYearInterface</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">name</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：虽然属性可以与索引签名进行混用，但是属性的类型必须是对应的数字索引或字符串索引的类型的子集，否则会出现错误提示。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringMap</span> &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span> <span class="comment">// ok</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">// ts(2411) name 属性的 string 类型不能赋值给字符串索引类型 number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberMap</span> &#123;</span><br><span class="line">  [<span class="attr">rank</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">  <span class="number">1</span>: <span class="built_in">string</span> <span class="comment">// ok</span></span><br><span class="line">  <span class="number">0</span>: <span class="built_in">number</span> <span class="comment">// ts(2412) 0 属性的 number 类型不能赋值给数字索引类型 string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，由于上边提到了数字类型索引的特殊性，所以我们不能约束数字索引属性与字符串索引属性拥有截然不同的类型，具体示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LanguageRankInterface</span> &#123;</span><br><span class="line">  [<span class="attr">rank</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> <span class="comment">// ts(2413) 数字索引类型 string 类型不能赋值给字符串索引类型 number</span></span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们确实需要使用 age 是 number 类型、其他属性类型是 string 的对象数据结构，应该如何定义它的类型且不提示错误呢？那么就需要使用到多个接口了，用法在下一章讲到。</p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 中，接口类型可以继承和被继承，比如我们可以使用如下所示的 extends 关键字实现接口的继承。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">DynamicLanguage</span> <span class="keyword">extends</span> <span class="title class_">ProgramLanguage</span> &#123;</span><br><span class="line">  <span class="attr">rank</span>: <span class="built_in">number</span> <span class="comment">// 定义新属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TypeSafeLanguage</span> <span class="keyword">extends</span> <span class="title class_">ProgramLanguage</span> &#123;</span><br><span class="line">  <span class="attr">typeChecker</span>: <span class="built_in">string</span> <span class="comment">// 定义新的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 继承多个 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TypeScriptLanguage</span> <span class="keyword">extends</span> <span class="title class_">DynamicLanguage</span>, <span class="title class_">TypeSafeLanguage</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TypeScript&#x27;</span> <span class="comment">// 用原属性类型的兼容的类型(比如子集)重新定义属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：我们仅能使用兼容的类型覆盖继承的属性</strong>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** ts(6196) 错误的继承，name 属性不兼容 */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WrongTypeLanguage</span> <span class="keyword">extends</span> <span class="title class_">ProgramLanguage</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，因为 ProgramLanguage 的 name 属性是 string 类型，WrongTypeLanguage 的 name 属性是 number，二者不兼容，所以不能继承，也会提示一个 ts(6196) 错误。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们还可与让类实现某个接口</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LanguageClass</span> <span class="keyword">implements</span> <span class="title class_">ProgramLanguage</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  age = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="number">2012</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Type-类型别名"><a href="#Type-类型别名" class="headerlink" title="Type 类型别名"></a>Type 类型别名</h1><p>接口类型的一个作用是将内联类型抽离出来，从而实现类型可复用。其实，我们也可以使用类型别名接收抽离出来的内联类型实现复用。此时，我们可以通过如下所示“type 别名名字 &#x3D; 类型定义”的格式来定义类型别名。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LanguageType</span> = &#123;</span><br><span class="line">  <span class="comment">/** 以下是接口属性 */</span></span><br><span class="line">  <span class="comment">/** 语言名称 */</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/** 使用年限 */</span></span><br><span class="line">  <span class="attr">age</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，针对接口类型无法覆盖的场景，比如组合类型、交叉类型（下一章讲到），我们只能使用类型别名来接收，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 联合 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MixedType</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="comment">/** 交叉 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType</span> = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 提取接口属性类型 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AgeType</span> = <span class="title class_">ProgramLanguage</span>[<span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：类型别名，诚如其名，即我们仅仅是给类型取了一个新的名字，并不是创建了一个新的类型。</p>
</blockquote>
<h2 id="Interface-与-Type-的区别"><a href="#Interface-与-Type-的区别" class="headerlink" title="Interface 与 Type 的区别"></a>Interface 与 Type 的区别</h2><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。比如，重复定义的接口类型，它的属性会叠加，这个特性使得我们可以极其方便地对全局变量、第三方库的类型做扩展，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Language</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Language</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">lang</span>: <span class="title class_">Language</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>, <span class="comment">// ok</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>, <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，先后定义的两个 Language 接口属性被叠加在了一起，此时我们可以赋值给 lang 变量一个同时包含 id 和 name 属性的对象。不过，如果我们重复定义类型别名，如下代码所示，则会提示一个 ts(2300) 错误。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** ts(2300) 重复的标志 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Language</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ts(2300) 重复的标志 */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Language</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">lang</span>: <span class="title class_">Language</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下一章讲解：联合类型、交叉类型、枚举类型、泛型</p>
</blockquote>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ts笔记（1）：搭建和一些基础类型</title>
    <url>/TypeScript/ts%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%90%AD%E5%BB%BA%E5%92%8C%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>新系列开坑</p>
<span id="more"></span>

<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><h2 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h2><p>不需要安装，可以直接运行，<a href="https://www.typescriptlang.org/zh/play">官方中文版</a>、<a href="https://www.typescriptlang.org/play">官方英文版</a></p>
<h2 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h2><p>使用 npm 或者 yarn 进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g typescript</span><br><span class="line">// 或者</span><br><span class="line">yarn add -g typescript</span><br></pre></td></tr></table></figure>

<p>安装完成后查看版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure>

<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>使用 <code>tsc --init</code> 命令在当前目录创建一个 <code>tsconfig.json</code> 文件。<br>为了学习，在配置文件里修改成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">/* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>,              <span class="comment">/* Enable strict null checks. */</span></span><br><span class="line">    <span class="string">&quot;strictFunctionTypes&quot;</span>: <span class="literal">true</span>,           <span class="comment">/* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="string">&quot;strictBindCallApply&quot;</span>: <span class="literal">true</span>,           <span class="comment">/* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="string">&quot;strictPropertyInitialization&quot;</span>: <span class="literal">true</span>,  <span class="comment">/* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="string">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>,                <span class="comment">/* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="string">&quot;alwaysStrict&quot;</span>: <span class="literal">false</span>,                  <span class="comment">/* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;esnext&quot;</span>,                          <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,                     <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个 HelloWorld.ts 文件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">word: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(word)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">say</span>(<span class="string">&#x27;Hello, World&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在该目录执行 tsc 命令，HelloWorld.ts 会编译出一个 HelloWorld.js 文件。</p>
<blockquote>
<p>注意：指定转译的目标文件后，tsc 将忽略当前应用路径下的 tsconfig.json 配置，因此我们需要通过显式设定如下所示的参数，让 tsc 以严格模式检测并转译 TypeScript 代码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc HelloWorld.ts --strict --alwaysStrict false</span><br></pre></td></tr></table></figure>

<p>同时，我们可以给 tsc 设定一个 watch 参数监听文件内容变更，实时进行类型检测和代码转译，如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc HelloWorld.ts --strict --alwaysStrict false --watch</span><br></pre></td></tr></table></figure>

<p>也可以直接使用 ts-node 运行 HelloWorld.ts：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g ts-node</span><br><span class="line">// or</span><br><span class="line">yarn add -g ts-node</span><br><span class="line"></span><br><span class="line">ts-node HelloWorld.ts // 输出：Hello, World</span><br></pre></td></tr></table></figure>

<p>在编辑器比如 vscode 将 <code>&#39;Hello, World&#39;</code> 改成 1 即可看到 vscode 立刻作出提示：<code>error TS2345: Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.</code>，这就是类型检查带来的好处。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>在语法层面，缺省类型注解的 TypeScript 与 JavaScript 完全一致。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例中的语法同时符合 JavaScript 语法和 TypeScript 语法。而在 ts 中可以加上类型标注：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>number</code> 表示数字类型，<code>:</code> 用来分割变量和类型的分隔符。</p>
</blockquote>
<p>同理，我们也可以把:后的 number 换成其他的类型（比如 JavaScript 原始类型：number、string、boolean、null、undefined、symbol 等）</p>
<h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>在 JavaScript 中，原始类型指的是非对象且没有方法的数据类型，它包括 string、number、bigint、boolean、undefined 和 symbol 这六种 （null 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在 JavaScript 中，我们可以使用 string 表示 JavaScript 中任意的字符串（包括模板字符串），ts 也是类似：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">firstname</span>: <span class="built_in">string</span> = <span class="string">&#x27;Captain&#x27;</span> <span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">familyname</span>: <span class="built_in">string</span> = <span class="title class_">String</span>(<span class="string">&#x27;S&#x27;</span>) <span class="comment">// 显式类型转换</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fullname</span>: <span class="built_in">string</span> = <span class="string">`my name is <span class="subst">$&#123;firstname&#125;</span>.<span class="subst">$&#123;familyname&#125;</span>`</span> <span class="comment">// 模板字符串</span></span><br></pre></td></tr></table></figure>

<p>所有 JavaScript 支持的定义字符串的方法，我们都可以直接在 TypeScript 中使用。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>同样，可以使用 number 类型表示 JavaScript 已经支持或者即将支持的十进制整数、浮点数，以及二进制数、八进制数、十六进制数，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 十进制整数 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">integer</span>: <span class="built_in">number</span> = <span class="number">6</span></span><br><span class="line"><span class="comment">/** 十进制整数 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">integer2</span>: <span class="built_in">number</span> = <span class="title class_">Number</span>(<span class="number">42</span>)</span><br><span class="line"><span class="comment">/** 十进制浮点数 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">decimal</span>: <span class="built_in">number</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">/** 二进制整数 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binary</span>: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="comment">/** 八进制整数 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octal</span>: <span class="built_in">number</span> = <span class="number">0o744</span></span><br><span class="line"><span class="comment">/** 十六进制整数 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hex</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br></pre></td></tr></table></figure>

<p>如果使用较少的大整数，那么我们可以使用 bigint 类型来表示，如下代码所示。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> = <span class="number">100n</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>还是和 js 差不多</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** TypeScript 真香 为 真 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">TypeScriptIsGreat</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">/** TypeScript 太糟糕了 为 否 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">TypeScriptIsBad</span>: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>自 ECMAScript 6 起，TypeScript 开始支持新的 Symbol 原始类型， 即我们可以通过 Symbol 构造函数，创建一个独一无二的标记</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sym1</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sym2</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;42&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TypeScript 还包含 Number、String、Boolean、Symbol 等类型（注意区分大小写），和小写格式对应的 number、string、boolean、symbol 并不一样。</p>
</blockquote>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>在变量声明的同时进行定义，ts 可以为我们进行类型推导：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="string">&#x27;Hello&#x27;</span> <span class="comment">// 报错：TS2322: Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<h1 id="复杂基础类型"><a href="#复杂基础类型" class="headerlink" title="复杂基础类型"></a>复杂基础类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>因为 TypeScript 的数组和元组转译为 JavaScript 后都是数组，所以这里我们把数组和元组这两个类型整合到一起介绍。</p>
<p>数组类型（Array）：在 TypeScript 中，我们也可以像 JavaScript 一样定义数组类型，并且指定数组元素的类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 子元素是数字类型的数组 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrayOfNumber</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">/** 子元素是字符串类型的数组 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrayOfString</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>同样，我们也可以使用 Array 泛型定义数组类型:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 子元素是数字类型的数组 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrayOfNumber</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">/** 子元素是字符串类型的数组 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arrayOfString</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里更推荐使用<code>[]</code>的方式</p>
</blockquote>
<p>元组类型（Tuple）：元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myTuple</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不使用类型标注的话，会变成另外一种类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myTuple1 = [<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// 等价于 let myTuple: (string | number)[]</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>在使用 any 之前要知道，<strong>Any is Hell（Any 是地狱）</strong>，它会使类型检查失效。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">anything</span>: <span class="built_in">any</span> = <span class="number">1</span></span><br><span class="line">anything.<span class="title function_">doAnything</span>() <span class="comment">//不会提示错误</span></span><br><span class="line">anything = <span class="string">&#x27;hello&#x27;</span> <span class="comment">//不会提示错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = anything <span class="comment">//不会提示错误</span></span><br></pre></td></tr></table></figure>

<p>从长远来看，使用 any 绝对是一个坏习惯。如果一个 TypeScript 应用中充满了 any，此时静态类型检测基本起不到任何作用，也就是说与直接使用 JavaScript 没有任何区别。</p>
<h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量，它可以接收多种返回值，但是它只能赋值给 unknown 和 any。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">unknown</span></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  result = <span class="title function_">x</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (y) &#123;</span><br><span class="line">  result = <span class="title function_">y</span>()</span><br><span class="line">&#125; <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">unknown</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = result <span class="comment">// 提示 ts(2322)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">anything</span>: <span class="built_in">any</span> = result <span class="comment">// 不会提示错误</span></span><br></pre></td></tr></table></figure>

<p>使用 unknown 后，TypeScript 会对它做类型检测。但是，如果不缩小类型（Type Narrowing），我们对 unknown 执行的任何操作都会出现如下所示错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">unknown</span></span><br><span class="line">result.<span class="title function_">toFixed</span>() <span class="comment">// 提示 ts(2571)</span></span><br></pre></td></tr></table></figure>

<p>而所有的类型缩小手段对 unknown 都有效</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="built_in">unknown</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  result.<span class="title function_">toFixed</span>() <span class="comment">// 此处 hover result 提示类型是 number，不会提示错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void、undefined、null"><a href="#void、undefined、null" class="headerlink" title="void、undefined、null"></a>void、undefined、null</h3><p><strong>void 类型</strong>：它仅适用于表示没有返回值的函数。即如果该函数没有返回值，那它的类型就是 void。</p>
<p>undefined 和 void 是 ts 中值于类型同名的例外。但是在 ts 中实际上并没有啥作用。undefined 的最大价值主要体现在接口类型上，它表示一个可缺省、未定义的属性。</p>
<blockquote>
<p>我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型。</p>
</blockquote>
<p>不建议随意使用非空断言来排除值可能为 null 或 undefined 的情况，因为这样很不安全：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">userInfo.<span class="property">id</span>!.<span class="title function_">toFixed</span>() <span class="comment">// ok，但不建议</span></span><br><span class="line">userInfo.<span class="property">name</span>!.<span class="title function_">toLowerCase</span>() <span class="comment">// ok，但不建议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐做法</span></span><br><span class="line">userInfo.<span class="property">id</span>?.<span class="title function_">toFixed</span>() <span class="comment">// Optional Chain</span></span><br><span class="line"><span class="keyword">const</span> myName = userInfo.<span class="property">name</span> ?? <span class="string">`my name is <span class="subst">$&#123;info.name&#125;</span>`</span> <span class="comment">// 空值合并</span></span><br></pre></td></tr></table></figure>

<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never 表示永远不会发生值的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ThrowError</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="title class_">Error</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InfiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>never 是所有类型的子类型，它可以给所有类型赋值:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Unreachable</span>: <span class="built_in">never</span> = <span class="number">1</span> <span class="comment">// ts(2322)</span></span><br><span class="line"><span class="title class_">Unreachable</span> = <span class="string">&#x27;string&#x27;</span> <span class="comment">// ts(2322)</span></span><br><span class="line"><span class="title class_">Unreachable</span> = <span class="literal">true</span> <span class="comment">// ts(2322)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="title class_">Unreachable</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="title class_">Unreachable</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="built_in">boolean</span> = <span class="title class_">Unreachable</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>object 类型表示非原始类型的类型，即非  number、string、boolean、bigint、symbol、null、undefined 的类型。然而这个类型并没有什么作用，用起来会有种 any 的感觉。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">any</span></span><br><span class="line"><span class="title function_">create</span>(&#123;&#125;) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">create</span>(<span class="function">() =&gt;</span> <span class="literal">null</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">create</span>(<span class="number">2</span>) <span class="comment">// ts(2345)</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// ts(2345)</span></span><br></pre></td></tr></table></figure>

<h1 id="类型断言（Type-Assertion）"><a href="#类型断言（Type-Assertion）" class="headerlink" title="类型断言（Type Assertion）"></a>类型断言（Type Assertion）</h1><p>TypeScript 类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比 TypeScript 更清楚实际类型的情况，比如下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arrayNumber</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">greaterThan2</span>: <span class="built_in">number</span> = arrayNumber.<span class="title function_">find</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num &gt; <span class="number">2</span>) <span class="comment">// 提示 ts(2322)</span></span><br></pre></td></tr></table></figure>

<p>单纯看代码可以看到是有大于 2 的数的，但静态类型对运行时的逻辑无能为力，因为 greaterThan2 有可能是 undefined。</p>
<p>不过，我们可以使用一种笃定的方式——类型断言（类似仅作用在类型层面的强制类型转换）告诉 TypeScript 按照我们的方式做类型检查。比如，我们可以使用 as 语法做类型断言：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arrayNumber</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">greaterThan2</span>: <span class="built_in">number</span> = arrayNumber.<span class="title function_">find</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num &gt; <span class="number">2</span>) <span class="keyword">as</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<p>又或者是使用尖括号 + 类型的格式做类型断言，如下:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arrayNumber</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">greaterThan2</span>: <span class="built_in">number</span> = &lt;<span class="built_in">number</span>&gt;arrayNumber.<span class="title function_">find</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>以上两种方式虽然没有任何区别，但是尖括号格式会与 JSX 产生语法冲突，因此更推荐使用 as 语法。</p>
<p>另外，any 和 unknown 这两个特殊类型属于万金油，因为它们既可以被断言成任何类型，反过来任何类型也都可以被断言成 any 或 unknown。因此，如果我们想强行“指鹿为马”，就可以先把“鹿”断言为 any 或 unknown，然后再把 any 和 unknown 断言为“马”，比如鹿 as any as 马。</p>
<blockquote>
<p>我们除了可以把特定类型断言成符合约束添加的其他类型之外，还可以使用“字面量值 + as const”语法结构进行常量断言，具体示例如下所示：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** str 类型是 &#x27;str&#x27; */</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;str&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">/** readOnlyArr 类型是 &#x27;readonly [0, 1]&#x27; */</span></span><br><span class="line"><span class="keyword">const</span> readOnlyArr = [<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br></pre></td></tr></table></figure>

<p>不过断言之后这个 str 就是<code>&#39;str&#39;</code>类型了。</p>
<p>此外还有一种特殊非空断言，即在值（变量、属性）的后边添加 ‘!’ 断言操作符，它可以用来排除值为 null、undefined 的情况，具体示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mayNullOrUndefinedOrString</span>: <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span></span><br><span class="line">mayNullOrUndefinedOrString!.<span class="title function_">toString</span>() <span class="comment">// ok</span></span><br><span class="line">mayNullOrUndefinedOrString.<span class="title function_">toString</span>() <span class="comment">// ts(2531)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于非空断言来说，我们同样应该把它视作和 any 一样危险的选择。在复杂应用场景中，如果我们使用非空断言，就无法保证之前一定非空的值，比如页面中一定存在 id 为 feedback 的元素，数组中一定有满足 &gt; 2 条件的数字，这些都不会被其他人改变。而一旦保证被改变，错误只会在运行环境中抛出，而静态类型检测是发现不了这些错误的。</p>
</blockquote>
<p>所以，建议使用类型守卫来代替非空断言，比如如下所示的条件判断：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mayNullOrUndefinedOrString</span>: <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> mayNullOrUndefinedOrString === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  mayNullOrUndefinedOrString.<span class="title function_">toString</span>() <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><p>在 TypeScript 中，类型标注声明是在变量之后（即类型后置），它不像 Java 语言一样，先声明变量的类型，再声明变量的名称。</p>
<p>使用类型标注后置的好处是编译器可以通过代码所在的上下文推导其对应的类型，无须再声明变量类型，具体示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x1 = <span class="number">42</span> <span class="comment">// 推断出 x1 的类型是 number</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">x2</span>: <span class="built_in">number</span> = x1 <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">let</span> x3 = x2 <span class="comment">// 推断出 x3 的类型是 number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上下文推断"><a href="#上下文推断" class="headerlink" title="上下文推断"></a>上下文推断</h2><p>在某些特定的情况下，我们也可以通过变量所在的上下文环境推断变量的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Adder</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">Adder</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x1 = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 推断出 x1 类型是 number</span></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="title function_">add</span>(<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>) <span class="comment">// ts(2345) Argument of type &#x27;&quot;1&quot;&#x27; is not assignable to parameter of type &#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h1><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。</p>
<p>目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">specifiedStr</span>: <span class="string">&#x27;this is string&#x27;</span> = <span class="string">&#x27;this is string&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">specifiedNum</span>: <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">specifiedBoolean</span>: <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字面量类型是集合类型的子类型，它是集合类型的一种更具体的表达。比如 ‘abc’类型是 string 类型的子类型。数字 1 是数字类型 number 的子类型。</p>
<h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>一般来说，我们可以使用一个字符串字面量类型作为变量的类型，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">hello</span>: <span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">hello = <span class="string">&#x27;hi&#x27;</span> <span class="comment">// ts(2322) Type &#x27;&quot;hi&quot;&#x27; is not assignable to type &#x27;&quot;hello&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实际上，定义单个的字面量类型并没有太大的用处，它真正的应用场景是可以把多个字面量类型组合成一个联合类型，用来描述拥有明确成员的实用的集合，比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;up&#x27;</span> | <span class="string">&#x27;down&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">dir: Direction</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">move</span>(<span class="string">&#x27;up&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">move</span>(<span class="string">&#x27;right&#x27;</span>) <span class="comment">// ts(2345) Argument of type &#x27;&quot;right&quot;&#x27; is not assignable to parameter of type &#x27;Direction&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Literal-Widening-x2F-字面量类型拓宽"><a href="#Literal-Widening-x2F-字面量类型拓宽" class="headerlink" title="Literal Widening &#x2F; 字面量类型拓宽"></a>Literal Widening &#x2F; 字面量类型拓宽</h2><p>所有通过 let 或 var 定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型，这就是字面量类型拓宽。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;this is string&#x27;</span> <span class="comment">// 类型是 string</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">strFun</span> = (<span class="params">str = <span class="string">&#x27;this is string&#x27;</span></span>) =&gt; str <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line">  <span class="keyword">const</span> specifiedStr = <span class="string">&#x27;this is string&#x27;</span> <span class="comment">// 类型是 &#x27;this is string&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> str2 = specifiedStr <span class="comment">// 类型是 &#x27;string&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">strFun2</span> = (<span class="params">str = specifiedStr</span>) =&gt; str <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于字面量类型拓宽的条件，我们可以通过如下所示代码添加显示类型注解控制类型拓宽行为。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">specifiedStr</span>: <span class="string">&#x27;this is string&#x27;</span> = <span class="string">&#x27;this is string&#x27;</span> <span class="comment">// 类型是 &#x27;&quot;this is string&quot;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> str2 = specifiedStr <span class="comment">// 即便使用 let 定义，类型是 &#x27;this is string&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Type-Widening-x2F-类型拓宽"><a href="#Type-Widening-x2F-类型拓宽" class="headerlink" title="Type Widening &#x2F; 类型拓宽"></a>Type Widening &#x2F; 类型拓宽</h2><p>比如对 null 和 undefined 的类型进行拓宽，通过 let、var 定义的变量如果满足未显式声明类型注解且被赋予了 null 或 undefined 值，则推断出这些变量的类型是 any：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="literal">null</span> <span class="comment">// 类型拓宽成 any</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="literal">undefined</span> <span class="comment">// 类型拓宽成 any</span></span><br><span class="line">  <span class="comment">/** -----分界线------- */</span></span><br><span class="line">  <span class="keyword">const</span> z = <span class="literal">null</span> <span class="comment">// 类型是 null</span></span><br><span class="line">  <span class="comment">/** -----分界线------- */</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">anyFun</span> = (<span class="params">param = <span class="literal">null</span></span>) =&gt; param <span class="comment">// 类型是 (param?: null) =&gt; null</span></span><br><span class="line">  <span class="keyword">let</span> z2 = z <span class="comment">// 类型是 null</span></span><br><span class="line">  <span class="keyword">let</span> x2 = x <span class="comment">// 类型是 null</span></span><br><span class="line">  <span class="keyword">let</span> y2 = y <span class="comment">// 类型是 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例第 7~10 行的类型推断行为因为开启了 strictNullChecks&#x3D;true</p>
</blockquote>
<h2 id="Type-Narrowing-x2F-类型缩小"><a href="#Type-Narrowing-x2F-类型缩小" class="headerlink" title="Type Narrowing &#x2F; 类型缩小"></a>Type Narrowing &#x2F; 类型缩小</h2><p>在 TypeScript 中，我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合，这就是 “Type Narrowing”。</p>
<p>比如，我们可以使用类型守卫将函数参数的类型从 any 缩小到明确的类型，具体示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">anything: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> anything === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> anything <span class="comment">// 类型是 string</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> anything === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> anything <span class="comment">// 类型是 number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以通过字面量类型等值判断（&#x3D;&#x3D;&#x3D;）或其他控制流语句（包括但不限于 if、三目运算符、switch 分支）将联合类型收敛为更具体的类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Goods</span> = <span class="string">&#x27;pen&#x27;</span> | <span class="string">&#x27;pencil&#x27;</span> | <span class="string">&#x27;ruler&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getPenCost</span> = (<span class="params">item: <span class="string">&#x27;pen&#x27;</span></span>) =&gt; <span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getPencilCost</span> = (<span class="params">item: <span class="string">&#x27;pencil&#x27;</span></span>) =&gt; <span class="number">4</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getRulerCost</span> = (<span class="params">item: <span class="string">&#x27;ruler&#x27;</span></span>) =&gt; <span class="number">6</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getCost</span> = (<span class="params">item: Goods</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="string">&#x27;pen&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getPenCost</span>(item) <span class="comment">// item =&gt; &#x27;pen&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="string">&#x27;pencil&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getPencilCost</span>(item) <span class="comment">// item =&gt; &#x27;pencil&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getRulerCost</span>(item) <span class="comment">// item =&gt; &#x27;ruler&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getCost</span> = (<span class="params">item: Goods</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="string">&#x27;pen&#x27;</span>) &#123;</span><br><span class="line">      item <span class="comment">// item =&gt; &#x27;pen&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item <span class="comment">// =&gt; &#x27;pencil&#x27; | &#x27;ruler&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ts笔记（4）：类型守卫、类型兼容、增强类型系统</title>
    <url>/TypeScript/ts%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB%E3%80%81%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E3%80%81%E5%A2%9E%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>下面是 TypeScript 进阶内容</p>
<span id="more"></span>

<h1 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h1><p>JavaScript 作为一种动态语言，意味着其中的参数、值可以是多态（多种类型）。因此，我们需要区别对待每一种状态，以此确保对参数、值的操作合法。举一个常见的场景为例，如下我们定义了一个可以接收字符串或者字符串数组的参数 toUpperCase，并将参数转成大写格式输出的函数 convertToUpperCase。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">convertToUpperCase</span> = (<span class="params">strOrArray</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> strOrArray === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> strOrArray.<span class="title function_">toUpperCase</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(strOrArray)) &#123;</span><br><span class="line">    <span class="keyword">return</span> strOrArray.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="title function_">toUpperCase</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，因为受静态类型检测约束，所以在编码阶段我们必须使用类似的手段确保当前的数据类型支持相应的操作。当然，前提条件是已经显式地注解了类型的多态。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">convertToUpperCase</span> = (<span class="params">strOrArray: <span class="built_in">string</span> | <span class="built_in">string</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> strOrArray === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> strOrArray.<span class="title function_">toUpperCase</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(strOrArray)) &#123;</span><br><span class="line">    <span class="keyword">return</span> strOrArray.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="title function_">toUpperCase</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从示例中，我们可以看到类型守卫的作用在于触发类型缩小。实际上，它还可以用来区分类型集合中的不同成员。</p>
<h2 id="如何区分联合类型？"><a href="#如何区分联合类型？" class="headerlink" title="如何区分联合类型？"></a>如何区分联合类型？</h2><p>首先，我们看一下如何使用类型守卫来区分联合类型的不同成员，常用的类型守卫包括 switch、字面量恒等、typeof、instanceof、in 和自定义类型守卫这几种。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">convert</span> = (<span class="params">c: <span class="string">&#x27;a&#x27;</span> | <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> c.<span class="title function_">toFixed</span>() <span class="comment">// c is 1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> c.<span class="title function_">toLowerCase</span>() <span class="comment">// c is &#x27;a&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">feat</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  c: &#123; animal: <span class="string">&#x27;panda&#x27;</span>; name: <span class="string">&#x27;China&#x27;</span> &#125; | &#123; feat: <span class="string">&#x27;video&#x27;</span>; name: <span class="string">&#x27;Japan&#x27;</span> &#125;</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (c.<span class="property">name</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;China&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> c.<span class="property">animal</span> <span class="comment">// c is &quot;&#123; animal: &#x27;panda&#x27;; name: &#x27;China&#x27; &#125;&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Japan&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> c.<span class="property">feat</span> <span class="comment">// c is &quot;&#123; feat: &#x27;video&#x27;; name: &#x27;Japan&#x27; &#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字面量恒等"><a href="#字面量恒等" class="headerlink" title="字面量恒等"></a>字面量恒等</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">convert</span> = (<span class="params">c: <span class="string">&#x27;a&#x27;</span> | <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (c === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="title function_">toFixed</span>() <span class="comment">// c is 1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="title function_">toLowerCase</span>() <span class="comment">// c is &#x27;a&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">convert</span> = (<span class="params">c: <span class="string">&#x27;a&#x27;</span> | <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> c === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="title function_">toFixed</span>() <span class="comment">// c is 1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> c === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="title function_">toLowerCase</span>() <span class="comment">// c is &#x27;a&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  wang = <span class="string">&#x27;wangwang&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">  miao = <span class="string">&#x27;miaomiao&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">animal: Dog | Cat</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> <span class="title class_">Dog</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> <span class="title class_">Cat</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">miao</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>当联合类型的成员包含接口类型（对象），并且接口之间的属性不同，如下示例中的接口类型 Dog、Cat，我们不能直接通过“ . ”操作符获取 param 的 wang、miao 属性，从而区分它是 Dog 还是 Cat。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">wang</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="attr">miao</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">animal: Dog | Cat</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> animal.<span class="property">wang</span> == <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ts(2339)</span></span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span> <span class="comment">// ts(2339)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal.<span class="property">miao</span>) &#123;</span><br><span class="line">    <span class="comment">// ts(2339)</span></span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">miao</span> <span class="comment">// ts(2339)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改成这样</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">animal: Dog | Cat</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;wang&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span> <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;miao&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">miao</span> <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类型守卫"><a href="#自定义类型守卫" class="headerlink" title="自定义类型守卫"></a>自定义类型守卫</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDog = <span class="keyword">function</span> (<span class="params">animal: Dog | Cat</span>): animal is <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;wang&#x27;</span> <span class="keyword">in</span> animal</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">animal: Dog | Cat</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDog</span>(animal)) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何区别枚举类型？"><a href="#如何区别枚举类型？" class="headerlink" title="如何区别枚举类型？"></a>如何区别枚举类型？</h2><p>最佳实践时，永远不要拿枚举和除了自身之外的任何枚举、类型进行比较。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> A &#123;</span><br><span class="line">  one,</span><br><span class="line">  two,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> B &#123;</span><br><span class="line">  one,</span><br><span class="line">  two,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cpWithNumber</span> = (<span class="params">param: A</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (param === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// bad</span></span><br><span class="line">    <span class="keyword">return</span> param</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cpWithOtherEnum</span> = (<span class="params">param: A</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (param === (B.<span class="property">two</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> A)) &#123;</span><br><span class="line">    <span class="comment">// ALERT bad</span></span><br><span class="line">    <span class="keyword">return</span> param</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cpWithSelf</span> = (<span class="params">param: A</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (param === A.<span class="property">two</span>) &#123;</span><br><span class="line">    <span class="comment">// good</span></span><br><span class="line">    <span class="keyword">return</span> param</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="失效的类型守卫"><a href="#失效的类型守卫" class="headerlink" title="失效的类型守卫"></a>失效的类型守卫</h2><p>失效的类型守卫指的是某些类型守卫应用在泛型函数中时不能缩小类型，即失效了。比如我们改造了一个可以接受泛型入参的 getName 函数，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.3.x前</span></span><br><span class="line"><span class="keyword">const</span> getName = &lt;T <span class="keyword">extends</span> <span class="title class_">Dog</span> | <span class="title class_">Cat</span>&gt;<span class="function">(<span class="params">animal: T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;wang&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span> <span class="comment">// ts(2339)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> animal.<span class="property">miao</span> <span class="comment">// ts(2339)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 4.3.x 之前的版本：上述示例中，虽然我们在第 2 行使用了 in 类型守卫，但是它并没有让 animal 的类型如预期那样缩小为 Dog 的子类型，所以第 3 行的 T 类型上没有 wang 属性，从而提示一个 ts(2339) 的错误。所以第 5 行的 animal 也不会缩小为 Cat 的子类型，从而也会提示一个 ts(2339) 的错误。</p>
<p>4.3.x 之后的版本：可以在泛型入参的函数中使用 in 类型守卫。</p>
<p>4.3.x 之前的版本：我们把 in 操作换成自定义类型守卫 isDog 或者使用 instanceOf，animal 的类型就会缩小成了 Dog 的子类型（T &amp; Dog），所以第 3 行不会提示 ts(2339) 的错误。由此可见，in 和 instanceOf、类型谓词在泛型类型缩小上是有区别的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getName = &lt;T <span class="keyword">extends</span> <span class="title class_">Dog</span> | <span class="title class_">Cat</span>&gt;<span class="function">(<span class="params">animal: T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDog</span>(animal)) &#123;</span><br><span class="line">    <span class="comment">// instanceOf 亦可</span></span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span> <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> animal.<span class="property">miao</span> <span class="comment">// 4.3.x之前的版本：ts(2339)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在缺省的 else 条件分支里，animal 的类型并没有缩小成 Cat 的子类型，所以第 5 行依旧会提示一个 ts(2339) 的错误，但是 4.3.x 之后的版本修复了这个问题，不会再报错。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.3.x之前可以这样：</span></span><br><span class="line"><span class="keyword">const</span> getName = &lt;T <span class="keyword">extends</span> <span class="title class_">Dog</span> | <span class="title class_">Cat</span>&gt;<span class="function">(<span class="params">animal: T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDog</span>(animal)) &#123;</span><br><span class="line">    <span class="comment">// instanceOf 亦可</span></span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">wang</span> <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (animal <span class="keyword">as</span> <span class="title class_">Cat</span>).<span class="property">miao</span> <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型兼容：如何判断一个类型是否可以赋值给其他类型？"><a href="#类型兼容：如何判断一个类型是否可以赋值给其他类型？" class="headerlink" title="类型兼容：如何判断一个类型是否可以赋值给其他类型？"></a>类型兼容：如何判断一个类型是否可以赋值给其他类型？</h1><h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><ol>
<li>any：any 类型可以赋值给除了 never 之外的任意其他类型，反过来其他类型也可以赋值给 any。也就是说 any 可以兼容除 never 之外所有的类型，同时也可以被所有的类型兼容（即 any 既是 bottom type，也是 top type）</li>
<li>never：never 的特性是可以赋值给任何其他类型，但反过来不能被其他任何类型（包括 any 在内）赋值（即 never 是 bottom type）。</li>
<li>unknown：unknown 的特性和 never 的特性几乎反过来，即我们不能把 unknown 赋值给除了 any 之外任何其他类型，反过来其他类型都可以赋值给 unknown（即 unknown 是 top type）。</li>
<li>void、null、undefined：void、null、undefined 这三大废材类型的兼容性也很特别，比如 void 类型仅可以赋值给 any 和 unknown 类型，反过来仅 any、never、undefined 可以赋值给 void</li>
<li>enum：最后一个特例是 enum 枚举类型，其中数字枚举和数字类型相互兼容。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> A &#123;</span><br><span class="line">  one,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = A.<span class="property">one</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fun</span> = (<span class="params">param: A</span>) =&gt; <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><h3 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h3><p>从子类型的角度来看，所有的子类型与它的父类型都兼容，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = one <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPar</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IChild</span> <span class="keyword">extends</span> <span class="title class_">IPar</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Par</span>: <span class="title class_">IPar</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Child</span>: <span class="title class_">IChild</span></span><br><span class="line"><span class="title class_">Par</span> = <span class="title class_">Child</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPar</span> &#123;</span><br><span class="line">  cname = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CPar</span> &#123;</span><br><span class="line">  cid = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ParInst</span>: <span class="title class_">CPar</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ChildInst</span>: <span class="title class_">CChild</span></span><br><span class="line"><span class="title class_">ParInst</span> = <span class="title class_">ChildInst</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">mixedNum</span>: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> = one <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ICPar</span>: <span class="title class_">IPar</span> | <span class="title class_">CPar</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ICChild</span>: <span class="title class_">IChild</span> | <span class="title class_">CChild</span></span><br><span class="line"><span class="title class_">ICPar</span> = <span class="title class_">ICChild</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>类型兼容性的另一准则是结构类型，即如果两个类型的结构一致，则它们是互相兼容的。比如拥有相同类型的属性、方法的接口类型或类，则可以互相赋值。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> I1 &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> I2 &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">InstC1</span>: <span class="variable constant_">C1</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">InstC2</span>: <span class="variable constant_">C2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">O1</span>: <span class="variable constant_">I1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">O2</span>: <span class="variable constant_">I2</span></span><br><span class="line"><span class="title class_">InstC1</span> = <span class="title class_">InstC2</span> <span class="comment">// ok</span></span><br><span class="line"><span class="variable constant_">O1</span> = <span class="variable constant_">O2</span> <span class="comment">// ok</span></span><br><span class="line"><span class="title class_">InstC1</span> = <span class="variable constant_">O1</span> <span class="comment">// ok</span></span><br><span class="line"><span class="variable constant_">O2</span> = <span class="title class_">InstC2</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>另外一个特殊的场景：两个接口类型或者类，如果其中一个类型不仅拥有另外一个类型全部的属性和方法，还包含其他的属性和方法（如同继承自另外一个类型的子类一样），那么前者是可以兼容后者的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> I1 &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> I2 &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">  id = <span class="number">1</span></span><br><span class="line">  name = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">O1</span>: <span class="variable constant_">I1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">O2</span>: <span class="variable constant_">I2</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">InstC2</span>: <span class="variable constant_">C2</span></span><br><span class="line"><span class="variable constant_">O1</span> = <span class="variable constant_">O2</span></span><br><span class="line"><span class="variable constant_">O1</span> = <span class="title class_">InstC2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里涉及一个需要特别注意的特性：虽然包含多余属性 id 的变量 O2 可以赋值给变量 O1，但是如果我们直接将一个与变量 O2 完全一样结构的对象字面量赋值给变量 O1，则会提示一个 ts(2322) 类型不兼容的错误，这就是对象字面的 freshness 特性。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">O1</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>, <span class="comment">// ts(2322)</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">O3</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable constant_">O1</span> = <span class="variable constant_">O3</span> <span class="comment">// ok</span></span><br><span class="line"><span class="variable constant_">O1</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="variable constant_">I2</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>另外，我们还需要注意类兼容性特性：实际上，在判断两个类是否兼容时，我们可以完全忽略其构造函数及静态属性和方法是否兼容，只需要比较类实例的属性和方法是否兼容即可。如果两个类包含私有、受保护的属性和方法，则仅当这些属性和方法源自同一个类，它们才兼容。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> age = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> age = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">InstC1</span>: <span class="variable constant_">C1</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">InstC2</span>: <span class="variable constant_">C2</span>;</span><br><span class="line">  <span class="title class_">InstC1</span> = <span class="title class_">InstC2</span>; <span class="comment">// ts(2322)</span></span><br><span class="line">  <span class="title class_">InstC2</span> = <span class="title class_">InstC1</span>; <span class="comment">// ts(2322)</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CPar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> age = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">C3</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CPar</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">inital: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    name = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> gender = <span class="string">&#x27;man&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">C4</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CPar</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">inital: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    name = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> gender = <span class="string">&#x27;woman&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">InstC3</span>: <span class="variable constant_">C3</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">InstC4</span>: <span class="variable constant_">C4</span>;</span><br><span class="line">  <span class="title class_">InstC3</span> = <span class="title class_">InstC4</span>; <span class="comment">// ok</span></span><br><span class="line">  <span class="title class_">InstC4</span> = <span class="title class_">InstC3</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>因为类 C1 和类 C2 各自包含私有和受保护的属性，且实例 InstC1 和 InstC2 不能相互赋值，所以提示了一个 ts(2322) 类型的错误。因为类 C3、类 C4 的私有、受保护属性都继承自同一个父类 CPar，所以检测类型兼容性时会忽略其类型不相同的构造函数和静态属性 gender，也因此实例 InstC3 和 实例 InstC4 之间可以相互赋值。</p>
<h3 id="可继承和可实现"><a href="#可继承和可实现" class="headerlink" title="可继承和可实现"></a>可继承和可实现</h3><p>类型兼容性还决定了接口类型和类是否可以通过 extends 继承另外一个接口类型或者类，以及类是否可以通过 implements 实现接口。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> I1 &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> I2 <span class="keyword">extends</span> I1 &#123;</span><br><span class="line">  <span class="comment">// ts(2430)</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  <span class="keyword">private</span> id = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">C1</span> &#123;</span><br><span class="line">  <span class="comment">// ts(2415)</span></span><br><span class="line">  name = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">  <span class="keyword">private</span> id = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span> <span class="keyword">implements</span> <span class="variable constant_">I1</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;&#x27;</span> <span class="comment">// ts(2416)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型类型、泛型类的兼容性实际指的是将它们实例化为一个确切的类型后的兼容性。可以通过指定类型入参实例化泛型，且入参只有作为实例化后的类型的一部分时才能影响类型兼容性:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> I1&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">O1</span>: <span class="variable constant_">I1</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">O2</span>: <span class="variable constant_">I1</span>&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="variable constant_">O1</span> = <span class="variable constant_">O2</span></span><br></pre></td></tr></table></figure>

<p>因为接口泛型 I1 的入参 T 是无用的，且实例化类型 <code>I1&lt;string&gt; 和 I1&lt;numer&gt;</code> 的结构一致，即类型兼容，所以对应的变量 O2 可以给变量 O1 赋值。</p>
<p>而对于未明确指定类型入参泛型的兼容性，例如函数泛型（实际上仅有函数泛型才可以在不需要实例化泛型的情况下赋值），TypeScript 会把 any 类型作为所有未明确指定的入参类型实例化泛型，然后再检测其兼容性，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun1 = &lt;T&gt;(<span class="attr">p1</span>: T): <span class="number">1</span> =&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> fun2 = &lt;T&gt;(<span class="attr">p2</span>: T): <span class="function"><span class="params">number</span> =&gt;</span> <span class="number">2</span></span><br><span class="line">fun2 = fun1 <span class="comment">// ok？</span></span><br></pre></td></tr></table></figure>

<p>这两个函数的类型兼容吗？答案：兼容。</p>
<p>为什么兼容呢？这就涉及接下来我们要介绍的函数类型兼容性。在此之前，我们先了解一下判定函数类型兼容性的基础理论知识：变型。</p>
<h2 id="变型"><a href="#变型" class="headerlink" title="变型"></a>变型</h2><p>TypeScript 中的变型指的是根据类型之间的子类型关系推断基于它们构造的更复杂类型之间的子类型关系。比如根据 Dog 类型是 Animal 类型子类型这样的关系，我们可以推断数组类型 Dog[] 和 Animal[] 、函数类型 () &#x3D;&gt; Dog 和 () &#x3D;&gt; Animal 之间的子类型关系。</p>
<h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> isChild&lt;<span class="title class_">Child</span>, <span class="title class_">Par</span>&gt; = <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Par</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">woof</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Covariance</span>&lt;T&gt; = T <span class="comment">// 复杂类型构造器，原封不动返回了类型入参 T</span></span><br><span class="line"><span class="keyword">type</span> isCovariant = isChild&lt;<span class="title class_">Covariance</span>&lt;<span class="title class_">Dog</span>&gt;, <span class="title class_">Covariance</span>&lt;<span class="title class_">Animal</span>&gt;&gt; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> isPropAssignmentCovariant = isChild&lt;&#123; <span class="attr">type</span>: <span class="title class_">Dog</span> &#125;, &#123; <span class="attr">type</span>: <span class="title class_">Animal</span> &#125;&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> isArrayElementCovariant = isChild&lt;<span class="title class_">Dog</span>[], <span class="title class_">Animal</span>[]&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> isReturnTypeCovariant = isChild&lt;<span class="function">() =&gt;</span> <span class="title class_">Dog</span>, <span class="function">() =&gt;</span> <span class="title class_">Animal</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为 Covariant<Dog> 是 Covariant<Animal> 的子类型，所以类型 isCovariant 是 true，这就是协变。实际上接口类型的属性、数组类型、函数返回值的类型都是协变的。</p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>实际场景中，在我们推崇的 TypeScript 严格模式下，函数参数类型是逆变的，具体示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Contravariance</span>&lt;T&gt; = <span class="function">(<span class="params">param: T</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> isNotContravariance = isChild&lt;<span class="title class_">Contravariance</span>&lt;<span class="title class_">Dog</span>&gt;, <span class="title class_">Contravariance</span>&lt;<span class="title class_">Animal</span>&gt;&gt; <span class="comment">// false;</span></span><br><span class="line"><span class="keyword">type</span> isContravariance = isChild&lt;<span class="title class_">Contravariance</span>&lt;<span class="title class_">Animal</span>&gt;, <span class="title class_">Contravariance</span>&lt;<span class="title class_">Dog</span>&gt;&gt; <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 严格模式的设定是函数参数类型是逆变的，所以 Contravariance<Animal> 会是 Contravariance<Dog> 的子类型。</p>
<p>为了更易于理解，我们可以从安全性的角度理解函数参数是逆变的设定。</p>
<blockquote>
<p>如果函数参数类型是协变而不是逆变，那么意味着函数类型 (param: Dog) &#x3D;&gt; void 和 (param: Animal) &#x3D;&gt; void 是兼容的，这与 Dog 和 Animal 的兼容一致，所以我们可以用 (param: Dog) &#x3D;&gt; void 代替 (param: Animal) &#x3D;&gt; void 遍历 Animal[] 类型数组。但是，这样是不安全的，因为它不能确保 Animal[] 数组中的成员都是 Dog（可能混入 Animal 类型的其他子类型，比如 Cat），这就会导致 (param: Dog) &#x3D;&gt; void 类型的函数可能接收到 Cat 类型的入参。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">visitDog</span> = (<span class="params">animal: Dog</span>) =&gt; &#123;</span><br><span class="line">  animal.<span class="title function_">woof</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">animals</span>: <span class="title class_">Animal</span>[] = [&#123; <span class="attr">name</span>: <span class="string">&#x27;Cat&#x27;</span>, <span class="attr">miao</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> <span class="number">0</span> &#125;]</span><br><span class="line">animals.<span class="title function_">forEach</span>(visitDog) <span class="comment">// ts(2345)</span></span><br></pre></td></tr></table></figure>

<p>在示例中，如果函数参数类型是协变的，那么第 5 行就可以通过静态类型检测，而不会提示一个 ts(2345) 类型的错误。这样第 1 行定义的 visitDog 函数在运行时就能接收到 Dog 类型之外的入参，并调用不存在的 woof 方法，从而在运行时抛出错误。</p>
<h3 id="双向协变"><a href="#双向协变" class="headerlink" title="双向协变"></a>双向协变</h3><p>对应到实际的场景，在 TypeScript 非严格模式下，函数参数类型就是双向协变的。如前边提到函数只有在参数是逆变的情况下才安全，且本课程一直在强调使用严格模式，所以双向协变并不是一个安全或者有用的特性，因此我们不大可能遇到这样的实际场景。<br>但在某些资料中有提到，如果函数参数类型是双向协变，那么它是有用的，并进行了举例论证 （以下示例缩减自网络）：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  <span class="attr">timestamp</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MouseEvent</span> <span class="keyword">extends</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addEventListener</span>(<span class="params">handler: (n: Event) =&gt; <span class="built_in">void</span></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">x</span> + <span class="string">&#x27;,&#x27;</span> + e.<span class="property">y</span>)) <span class="comment">// ts(2769)</span></span><br></pre></td></tr></table></figure>

<p>真正有用且安全的做法是使用泛型，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> addEventListener&lt;E <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;(<span class="attr">handler</span>: <span class="function">(<span class="params">n: E</span>) =&gt;</span> <span class="built_in">void</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">x</span> + <span class="string">&#x27;,&#x27;</span> + e.<span class="property">y</span>)) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="不变"><a href="#不变" class="headerlink" title="不变"></a>不变</h3><p>不变即只要是不完全一样的类型，它们一定是不兼容的。</p>
<p>对应到实际场景，出于类型安全层面的考虑，在特定情况下我们可能希望数组是不变的（实际上是协变），见示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">miao</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cat</span>: <span class="title class_">Cat</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Cat&#x27;</span>,</span><br><span class="line">  <span class="attr">miao</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Dog&#x27;</span>,</span><br><span class="line">  <span class="attr">woof</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">dogs</span>: <span class="title class_">Dog</span>[] = [dog]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">animals</span>: <span class="title class_">Animal</span>[] = dogs <span class="comment">// ok</span></span><br><span class="line">animals.<span class="title function_">push</span>(cat) <span class="comment">// ok</span></span><br><span class="line">dogs.<span class="title function_">forEach</span>(visitDog) <span class="comment">// 类型 ok，但运行时会抛出错误</span></span><br></pre></td></tr></table></figure>

<p>因为数组是协变的，所以我们可以在第 13 行把 dogs 数组赋值给 animals 数组，并且在第 14 行把 cat 对象塞到 animals 数组中。那么问题就来了，因为 animals 和 dogs 指向的是同一个数组，所以实际上我们是把 cat 塞到了 dogs 数组中。然后，我们在第 15 行使用了 visitDog 函数遍历 dogs 数组。虽然它可以通过静态类型检测，但是运行时 visitDog 遍历数组将接收一个混入的 cat 对象并抛出错误，因为 visitDog 中调用了 cat 上没有 woof 的方法。</p>
<p><strong>因此，对于可变的数组而言，不变似乎是更安全、合理的设定。不过，在 TypeScript 中可变、不变的数组都是协变的，这是需要我们注意的一个陷阱。</strong></p>
<blockquote>
<p>前面的函数类型 (p1: any) &#x3D;&gt; 1 和 (param: any) &#x3D;&gt; number 为什么兼容的问题已经给出答案了。因为返回值类型 1 是 number 的子类型，且返回值类型是协变的，所以 (p1: any) &#x3D;&gt; 1 是 (param: any) &#x3D;&gt; number 的子类型，即是兼容的。</p>
</blockquote>
<h2 id="函数类型兼容性"><a href="#函数类型兼容性" class="headerlink" title="函数类型兼容性"></a>函数类型兼容性</h2><p>因为函数类型的兼容性、子类型关系有着更复杂的考量（它还需要结合参数和返回值的类型进行确定），所以下面我们详细介绍一下函数类型兼容性的一般规则。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>前边我们已经讲过返回值类型是协变的，所以在参数类型兼容的情况下，函数的子类型关系与返回值子类型关系一致。也就是说返回值类型兼容，则函数兼容。</p>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>前边我们也讲过参数类型是逆变的，所以在参数个数相同、返回值类型兼容的情况下，函数子类型关系与参数子类型关系是反过来的（逆变）。</p>
<h3 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h3><p>在索引位置相同的参数和返回值类型兼容的前提下，函数兼容性取决于参数个数，参数个数少的兼容个数多，下面我们看一个具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">lessParams</span> = (<span class="params">one: <span class="built_in">number</span></span>) =&gt; <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">moreParams</span> = (<span class="params">one: <span class="built_in">number</span>, two: <span class="built_in">string</span></span>) =&gt; <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">lessParams = moreParams <span class="comment">// ts(2322)</span></span><br><span class="line">moreParams = lessParams <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你觉得参数个数少的函数兼容参数个数多的函数不好理解，那么可以试着从安全性角度理解</p>
</blockquote>
<h3 id="可选和剩余参数"><a href="#可选和剩余参数" class="headerlink" title="可选和剩余参数"></a>可选和剩余参数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">optionalParams</span> = (<span class="params">one?: <span class="built_in">number</span>, tow?: <span class="built_in">number</span></span>) =&gt; <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">requiredParams</span> = (<span class="params">one: <span class="built_in">number</span>, tow: <span class="built_in">number</span></span>) =&gt; <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">restParams</span> = (<span class="params">...args: <span class="built_in">number</span>[]</span>) =&gt; <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">requiredParams = optionalParams <span class="comment">// ok</span></span><br><span class="line">restParams = optionalParams <span class="comment">// ok</span></span><br><span class="line">optionalParams = restParams <span class="comment">// ts(2322)</span></span><br><span class="line">optionalParams = requiredParams <span class="comment">// ts(2322)</span></span><br><span class="line">restParams = requiredParams <span class="comment">// ok</span></span><br><span class="line">requiredParams = restParams <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>最让人费解的是，在第 8 行中，把不可选参数 requiredParams 赋值给剩余参数 restParams 其实是不安全的（但是符合类型检测），我们需要从方便性上理解这个设定。</p>
<p>正是基于这个设定，我们才可以将剩余参数类型函数定义为其他所有参数类型函数的父类型，并用来约束其他类型函数的类型范围，比如说在泛型中约束函数类型入参的范围。具体实例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetFun</span>&lt;F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">number</span>[]) =&gt; <span class="built_in">any</span>&gt; = <span class="title class_">Parameters</span>&lt;F&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetRequiredParams</span> = <span class="title class_">GetFun</span>&lt;<span class="keyword">typeof</span> requiredParams&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetRestParams</span> = <span class="title class_">GetFun</span>&lt;<span class="keyword">typeof</span> restParams&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetEmptyParams</span> = <span class="title class_">GetFun</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在示例中的第 1 行，我们使用剩余参数函数类型 (…args: number[]) &#x3D;&gt; any 约束了入参 F 的类型，而第 2~4 行传入的函数类型入参都是这个剩余参数函数类型的子类型。</p>
<h1 id="必备增强类型系统的方式大盘点"><a href="#必备增强类型系统的方式大盘点" class="headerlink" title="必备增强类型系统的方式大盘点"></a>必备增强类型系统的方式大盘点</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><h3 id="declare-变量"><a href="#declare-变量" class="headerlink" title="declare 变量"></a>declare 变量</h3><p>在运行时，前端代码 <code>&lt;script&gt;</code> 标签会引入一个全局的库，再导入全局变量。此时，如果你想安全地使用全局变量，那么就需要对变量的类型进行声明。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">val1</span>: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">val2</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">val3</span>: <span class="built_in">boolean</span></span><br><span class="line">val1 = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">val2 = <span class="number">1</span></span><br><span class="line">val2 = <span class="string">&#x27;2&#x27;</span> <span class="comment">// TS2322: Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line">val3 = <span class="literal">true</span> <span class="comment">// TS2588: Cannot assign to &#x27;val3&#x27; because it is a constant.</span></span><br></pre></td></tr></table></figure>

<h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="title function_">toString</span>(<span class="number">1</span>) <span class="comment">// =&gt; string</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 declare 关键字时，不能编写声明的变量、函数、类的具体实现</strong></p>
<h3 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span><br><span class="line">  <span class="title function_">getAge</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Mike&#x27;</span>)</span><br><span class="line">person.<span class="property">name</span> <span class="comment">// =&gt; string</span></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// TS2341: Property &#x27;age&#x27; is private and only accessible within class &#x27;Person&#x27;.</span></span><br><span class="line">person.<span class="title function_">getAge</span>() <span class="comment">// =&gt; number</span></span><br></pre></td></tr></table></figure>

<h3 id="声明枚举"><a href="#声明枚举" class="headerlink" title="声明枚举"></a>声明枚举</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> directions = [</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Up</span>,</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Down</span>,</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Left</span>,</span><br><span class="line">  <span class="title class_">Direction</span>.<span class="property">Right</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="declare-模块"><a href="#declare-模块" class="headerlink" title="declare 模块"></a>declare 模块</h2><p>在 JavaScript 还没有升级至 ES6 的时候，TypeScript 就提供了一种模块化方案，比如通过使用 module 关键字，我们就可以声明一个内部模块。但是由于 ES6 后来也使用了 module 关键字，为了兼容 ES6，所以 TypeScript 使用 namespace 替代了原来的 module，并更名为命名空间。</p>
<figure class="highlight ts"><figcaption><span>lodash.d.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;lodash&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> first&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>&gt;(<span class="attr">array</span>: T[]): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>index.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; first &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"><span class="title function_">first</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// =&gt; number;</span></span><br></pre></td></tr></table></figure>

<h2 id="declare-文件"><a href="#declare-文件" class="headerlink" title="declare 文件"></a>declare 文件</h2><p>在使用 TypeScript 开发前端应用时，我们可以通过 import 关键字导入文件，比如先使用 import 导入图片文件，再通过 webpack 等工具处理导入的文件。</p>
<p>但是，因为 TypeScript 并不知道我们通过 import 导入的文件是什么类型，所以需要使用 declare 声明导入的文件类型，下面看一个具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">src</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> src</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">src</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里标记的图片文件的默认导出的类型是 string ，通过 import 使用图片资源时，TypeScript 会将导入的图片识别为 string 类型，因此也就可以把 import 的图片赋值给 的 src 属性，因为它们的类型都是 string，是匹配的。</p>
<h2 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a>declare namespace</h2><p>不同于声明模块，命名空间一般用来表示具有很多子属性或者方法的全局对象变量。</p>
<p>我们可以将声明命名空间简单看作是声明一个更复杂的变量，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> $ &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">version</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">settings?: <span class="built_in">any</span></span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line">$.version <span class="comment">// =&gt; number</span></span><br><span class="line">$.<span class="title function_">ajax</span>()</span><br></pre></td></tr></table></figure>

<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>在 TypeScript 中，以 .d.ts 为后缀的文件为声明文件。如果你熟悉 C&#x2F;C++，那么可以把它当作 .h 文件。 在声明文件时，我们只需要定义三方类库所暴露的 API 接口即可。</p>
<p>在 TypeScript 中，存在类型、值、命名空间这 3 个核心概念。如果你掌握了这些核心概念，那么就能够为任何形式的类型书写声明文件了。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>类型别名声明</li>
<li>接口声明</li>
<li>类声明</li>
<li>枚举声明</li>
<li>导入的类型声明</li>
</ul>
<p>上面的每一个声明都创建了一个类型名称。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>我们可以通过以下 6 种方式创建值：</p>
<ul>
<li>var、let、const 声明</li>
<li>namespace、module 包含值的声明</li>
<li>枚举声明</li>
<li>类声明</li>
<li>导入的值</li>
<li>函数声明</li>
</ul>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在命名空间中，我们也可以声明类型。比如 const x: A.B.C 这个声明，这里的类型 C 就是在 A.B 命名空间下的。一个名称 A， 在 TypeScript 中可能表示一个类型、一个值，也可能是一个命名空间。通过类型、值、命名空间的组合，我们也就拥有了表达任意类型的能力。如果你想知道名称 A 代表的实际意义，则需要看它所在的上下文。</p>
<h3 id="使用声明文件"><a href="#使用声明文件" class="headerlink" title="使用声明文件"></a>使用声明文件</h3><p>安装 TypeScript 依赖后，一般我们会顺带安装一个 lib.d.ts 声明文件，这个文件包含了 JavaScript 运行时以及 DOM 中各种全局变量的声明，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typescript/lib/lib.d.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference lib=&quot;es5&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference lib=&quot;dom&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference lib=&quot;webworker.importscripts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference lib=&quot;scripthost&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的示例其实就是 TypeScript 中的 lib.d.ts 文件的内容。其中，&#x2F;&#x2F;&#x2F; 是 TypeScript 中三斜线指令，后面的内容类似于 XML 标签的语法，用来指代引用其他的声明文件。通过三斜线指令，我们可以更好地复用和拆分类型声明。no-default-lib&#x3D;”true” 表示这个文件是一个默认库。而最后 4 行的 lib&#x3D;”…” 表示引用内部的库类型声明。</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html">三斜线指令官方文档</a></p>
<h3 id="使用-types"><a href="#使用-types" class="headerlink" title="使用 @types"></a>使用 @types</h3><p>前面我们介绍了如何为 JavaScript 库编写类型声明，然而为库编写类型声明非常耗费精力，且难以在多个项目中复用。<a href="https://github.com/DefinitelyTyped/DefinitelyTyped?fileGuid=xxQTRXtVcqtHK6j8">Definitely Typed</a> 是最流行性的高质量 TypeScript 声明文件类库，正是因为有社区维护的这个声明文件类库，大大简化了 JavaScript 项目迁移 TypeScript 的难度。</p>
<p>目前，社区已经记录了 90% 的 JavaScript 库的类型声明，意味着如果我们想使用的库有社区维护的类型声明，那么就可以通过安装类型声明文件直接使用 JavaScript 编写的类库了。</p>
<p>具体操作：首先，<a href="https://www.typescriptlang.org/dt/search?search=&fileGuid=xxQTRXtVcqtHK6j8">点击这里的链接</a>搜索你想要导入的类库的类型声明，如果有社区维护的声明文件。然后，我们只需要安装 @types&#x2F;xxx 就可以在 TypeScript 中直接使用它了。</p>
<p>然而，因为 Definitely Typed 是由社区人员维护的，如果原来的三方库升级，那么 Definitely Typed 所导出的三方库的类型定义想要升级还需要经过 PR、发布的流程，就会导致无法与原库保持完全同步。针对这个问题，在 TypeScript 中，我们可以通过类型合并、扩充类型定义的技巧临时解决。</p>
<h2 id="类型合并"><a href="#类型合并" class="headerlink" title="类型合并"></a>类型合并</h2><h3 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数成员而言，每个同名的函数声明都会被当作这个函数的重载。<strong>需要注意的是后面声明的接口具有更高的优先级</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="title function_">identity</span>(<span class="attr">val</span>: <span class="built_in">any</span>): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="title function_">identity</span>(<span class="attr">val</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="title function_">identity</span>(<span class="attr">val</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="title function_">identity</span>(<span class="attr">val</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span></span><br><span class="line">  <span class="title function_">identity</span>(<span class="attr">val</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">identity</span>(<span class="attr">val</span>: <span class="built_in">any</span>): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="title function_">identity</span>(<span class="params">val: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t1 = obj.<span class="title function_">identity</span>(<span class="number">1</span>) <span class="comment">// =&gt; number</span></span><br><span class="line"><span class="keyword">const</span> t2 = obj.<span class="title function_">identity</span>(<span class="literal">true</span>) <span class="comment">// =&gt; boolean</span></span><br><span class="line"><span class="keyword">const</span> t3 = obj.<span class="title function_">identity</span>(<span class="string">&#x27;t3&#x27;</span>) <span class="comment">// =&gt; any</span></span><br></pre></td></tr></table></figure>

<h3 id="合并-namespace"><a href="#合并-namespace" class="headerlink" title="合并 namespace"></a>合并 namespace</h3><p>合并 namespace 与合并接口类似，命名空间的合并也会合并其导出成员的属性。不同的是，非导出成员仅在原命名空间内可见。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getMyAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age <span class="comment">// TS2304: Cannot find name &#x27;age&#x27;.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可合并"><a href="#不可合并" class="headerlink" title="不可合并"></a>不可合并</h3><p>介绍类类型时我们说过，定义一个类类型，相当于定义了一个类，又定义了一个类的类型。因此，对于类这个既是值又是类型的特殊对象不能合并。</p>
<p>除了可以通过接口和命名空间合并的方式扩展原来声明的类型外，我们还可以通过扩展模块或扩展全局对象来增强类型系统。</p>
<h2 id="扩充模块"><a href="#扩充模块" class="headerlink" title="扩充模块"></a>扩充模块</h2><p>JavaScript 是一门动态类型的语言，通过 prototype 我们可以很容易地扩展原来的对象。但是，如果我们直接扩展导入对象的原型链属性，TypeScript 会提示没有该属性的错误，因此我们就需要扩展原模块的属性。</p>
<figure class="highlight ts"><figcaption><span>person.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>index.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Person</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./person&#x27;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;./person&#x27;</span> &#123;</span><br><span class="line">  <span class="comment">// 扩展模块的声明</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">greet</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们删除了扩展模块的声明，则会报出 ts(2339) 不存在 greet 属性的类型错误。</p>
<h2 id="扩充全局"><a href="#扩充全局" class="headerlink" title="扩充全局"></a>扩充全局</h2><p>全局模块指的是不需要通过 import 导入即可使用的模块，如全局的 window、document 等。对全局对象的扩充与对模块的扩充是一样的，下面看一个具体示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>&gt; &#123;</span><br><span class="line">    <span class="title function_">getLen</span>(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getLen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ts笔记（5）：官方工具类、打造自己的工具类型</title>
    <url>/TypeScript/ts%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9A%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7%E7%B1%BB%E3%80%81%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>下面是 TypeScript 进阶内容</p>
<span id="more"></span>

<h1 id="官方工具类"><a href="#官方工具类" class="headerlink" title="官方工具类"></a>官方工具类</h1><h2 id="操作接口类型"><a href="#操作接口类型" class="headerlink" title="操作接口类型"></a>操作接口类型</h2><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p>Partial 工具类型可以将一个类型的所有属性变为可选的，且该工具类型返回的类型是给定类型的所有子集，下面我们看一个具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  weight?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPerson</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PartialPerson</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  weight?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>与 Partial 工具类型相反，Required 工具类型可以将给定类型的所有属性变为必填的，下面我们看一个具体示例。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequiredPerson</span> = <span class="title class_">Required</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RequiredPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">weight</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p>Readonly 工具类型可以将给定类型的所有属性设为只读，这意味着给定类型的属性不可以被重新赋值，下面我们看一个具体的示例。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">readonly</span> age?: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">readonly</span> weight?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p>Pick 工具类型可以从给定的类型中选取出指定的键值，然后组成一个新的类型，下面我们看一个具体的示例。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NewPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><p>与 Pick 类型相反，Omit 工具类型的功能是返回去除指定的键值之后返回的新类型，下面我们看一个具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;weight&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NewPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><p>在介绍 Omit 类型的实现中，我们使用了 Exclude 类型。通过使用 Exclude 类型，我们从接口的所有属性中去除了指定属性，因此，Exclude 的作用就是从联合类型中去除指定的类型。具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt; <span class="comment">// =&gt; &#x27;b&#x27; | &#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;weight&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Person</span>, <span class="title class_">Exclude</span>&lt;keyof <span class="title class_">Person</span>, <span class="string">&#x27;weight&#x27;</span>&gt;&gt;</span><br><span class="line"><span class="comment">// 其中</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExcludeKeys</span> = <span class="title class_">Exclude</span>&lt;keyof <span class="title class_">Person</span>, <span class="string">&#x27;weight&#x27;</span>&gt; <span class="comment">// =&gt; &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p>Extract 类型的作用与 Exclude 正好相反，Extract 主要用来从联合类型中提取指定的类型，类似于操作接口类型中的 Pick 类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt; <span class="comment">// =&gt; &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>此外，我们还可以基于 Extract 实现一个获取接口类型交集的工具类型，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Intersect</span>&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">Extract</span>&lt;keyof T, keyof U&gt;]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  weight?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NewPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Intersect</span>&lt;<span class="title class_">Person</span>, <span class="title class_">NewPerson</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> T = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><p>NonNullable 的作用是从联合类型中去除 null 或者 undefined 的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T</span><br><span class="line"><span class="comment">// 等同于使用 Exclude</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = <span class="title class_">Exclude</span>&lt;T, <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span> | <span class="literal">null</span>&gt; <span class="comment">// =&gt; string | number</span></span><br></pre></td></tr></table></figure>

<h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>Record 的作用是生成接口类型，然后我们使用传入的泛型参数分别作为接口类型的属性和值。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MenuKey</span> = <span class="string">&#x27;home&#x27;</span> | <span class="string">&#x27;about&#x27;</span> | <span class="string">&#x27;more&#x27;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Menu</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span></span><br><span class="line">  hidden?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">menus</span>: <span class="title class_">Record</span>&lt;<span class="title class_">MenuKey</span>, <span class="title class_">Menu</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">about</span>: &#123; <span class="attr">label</span>: <span class="string">&#x27;关于&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">home</span>: &#123; <span class="attr">label</span>: <span class="string">&#x27;主页&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">more</span>: &#123; <span class="attr">label</span>: <span class="string">&#x27;更多&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，keyof any 指代可以作为对象键的属性，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T = keyof <span class="built_in">any</span> <span class="comment">// =&gt; string | number | symbol</span></span><br><span class="line"><span class="comment">// 目前，JavaScript 仅支持string、number、symbol作为对象的键值。</span></span><br></pre></td></tr></table></figure>

<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h3><p>ConstructorParameters 可以用来获取构造函数的构造参数，而 ConstructorParameters 类型的实现则需要使用 infer 关键字推断构造参数的类型。</p>
<p>关于 infer 关键字，我们可以把它当成简单的模式匹配来看待。如果真实的参数类型和 infer 匹配的一致，那么就返回匹配到的这个类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ConstructorParameters</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Person</span>&gt; <span class="comment">// [name: string, age?: number]</span></span><br></pre></td></tr></table></figure>

<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters 的作用与 ConstructorParameters 类似，Parameters 可以用来获取函数的参数并返回序对，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: infer P</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? P</span><br><span class="line">  : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// [x: number, y?: string]</span></span><br></pre></td></tr></table></figure>

<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p>ReturnType 的作用是用来获取函数的返回类型，下面我们看一个具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// =&gt; void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// =&gt; string</span></span><br></pre></td></tr></table></figure>

<h3 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType</h3><p>ThisParameterType 可以用来获取函数的 this 参数类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ThisParameterType</span>&lt;T&gt; = T <span class="keyword">extends</span> (<span class="attr">this</span>: infer U, ...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? U</span><br><span class="line">  : <span class="built_in">unknown</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ThisParameterType</span>&lt;<span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span>, x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// Number</span></span><br></pre></td></tr></table></figure>

<h3 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType</h3><p>ThisType 的作用是可以在对象字面量中指定 this 的类型。ThisType 不返回转换后的类型，而是通过 ThisType 的泛型参数指定 this 的类型，下面看一个具体的示例：</p>
<blockquote>
<p>注意：如果你想使用这个工具类型，那么需要开启 noImplicitThis 的 TypeScript 配置。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectDescriptor</span>&lt;D, M&gt; = &#123;</span><br><span class="line">  data?: D</span><br><span class="line">  methods?: M &amp; <span class="title class_">ThisType</span>&lt;D &amp; M&gt; <span class="comment">// methods 中 this 的类型是 D &amp; M</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> makeObject&lt;D, M&gt;(<span class="attr">desc</span>: <span class="title class_">ObjectDescriptor</span>&lt;D, M&gt;): D &amp; M &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">data</span>: <span class="built_in">object</span> = desc.<span class="property">data</span> || &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">methods</span>: <span class="built_in">object</span> = desc.<span class="property">methods</span> || &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...data, ...methods &#125; <span class="keyword">as</span> D &amp; M</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">makeObject</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">moveBy</span>(<span class="params">dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> += dx <span class="comment">// this =&gt; D &amp; M</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> += dy <span class="comment">// this =&gt; D &amp; M</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">10</span></span><br><span class="line">obj.<span class="property">y</span> = <span class="number">20</span></span><br><span class="line">obj.<span class="title function_">moveBy</span>(<span class="number">5</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter</h3><p>OmitThisParameter 工具类型主要用来去除函数类型中的 this 类型。如果传入的函数类型没有显式声明 this 类型，那么返回的仍是原来的函数类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OmitThisParameter</span>&lt;T&gt; = <span class="built_in">unknown</span> <span class="keyword">extends</span> <span class="title class_">ThisParameterType</span>&lt;T&gt;</span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R</span><br><span class="line">  ? <span class="function">(<span class="params">...args: A</span>) =&gt;</span> R</span><br><span class="line">  : T</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">OmitThisParameter</span>&lt;<span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span>, x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// (x: number) =&gt; string</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>TypeScript 自 4.1 版本起开始支持模板字符串字面量类型。为此，TypeScript 也提供了 Uppercase、Lowercase、Capitalize、Uncapitalize 这 4 种内置的操作字符串的类型，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换字符串字面量到大写字母</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Uppercase</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic</span><br><span class="line"><span class="comment">// 转换字符串字面量到小写字母</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lowercase</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic</span><br><span class="line"><span class="comment">// 转换字符串字面量的第一个字母为大写字母</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Capitalize</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic</span><br><span class="line"><span class="comment">// 转换字符串字面量的第一个字母为小写字母</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Uncapitalize</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Uppercase</span>&lt;<span class="string">&#x27;Hello&#x27;</span>&gt; <span class="comment">// =&gt; &#x27;HELLO&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Lowercase</span>&lt;<span class="variable constant_">T0</span>&gt; <span class="comment">// =&gt; &#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Capitalize</span>&lt;<span class="variable constant_">T1</span>&gt; <span class="comment">// =&gt; &#x27;Hello&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Uncapitalize</span>&lt;<span class="variable constant_">T2</span>&gt; <span class="comment">// =&gt; &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，这 4 种操作字符串字面量工具类型的实现都是使用 JavaScript 运行时的字符串操作函数计算出来的，且不支持语言区域设置。以下代码是这 4 种字符串工具类型的实际实现。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyStringMapping</span>(<span class="params"><span class="built_in">symbol</span>: <span class="built_in">Symbol</span>, str: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (intrinsicTypeKinds.<span class="title function_">get</span>(<span class="built_in">symbol</span>.<span class="property">escapedName</span> <span class="keyword">as</span> <span class="built_in">string</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Uppercase</span>:</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Lowercase</span>:</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Capitalize</span>:</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IntrinsicTypeKind</span>.<span class="property">Uncapitalize</span>:</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toLowerCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中可以看到，字符串的转换使用了 JavaScript 中字符串的 toUpperCase 和 toLowerCase 方法，而不是 toLocaleUpperCase 和 toLocaleLowerCase。其中 toUpperCase 和 toLowerCase 采用的是 Unicode 编码默认的大小写转换规则。</p>
<h1 id="类型编程：如何打造属于自己的工具类型？"><a href="#类型编程：如何打造属于自己的工具类型？" class="headerlink" title="类型编程：如何打造属于自己的工具类型？"></a>类型编程：如何打造属于自己的工具类型？</h1><h2 id="类型物料"><a href="#类型物料" class="headerlink" title="类型物料"></a>类型物料</h2><p>在正式造轮子之前，我们先来熟悉一下即将用到的物料，这可能涉及前面每一讲中的知识点和一些新语法。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>首先是泛型（回顾 10 讲），笔者认为工具类型的本质就是构造复杂类型的泛型。如果一个工具类型不能接受类型入参，那么它和普通的类型别名又有什么区别？因此，使用泛型进行变量抽离、逻辑封装其实就是在造类型的轮子，下面举一个具体的示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> isXX = <span class="number">1</span> <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> isYY = <span class="string">&#x27;string&#x27;</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这明显是一种效率低下的做法，因为我们不能把其中的逻辑复用在对其他类型子类型关系的判断上。这时，我们就需要把确切的类型抽离为入参，然后封装成一个可复用的泛型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> isSubTying&lt;<span class="title class_">Child</span>, <span class="title class_">Par</span>&gt; = <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Par</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> isXX2 = isSubTyping&lt;<span class="number">1</span>, <span class="built_in">number</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> isYY2 = isSubTyping&lt;<span class="string">&#x27;string&#x27;</span>, <span class="built_in">string</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> isZZ2 = isSubTyping&lt;<span class="literal">true</span>, <span class="built_in">boolean</span>&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>如我们在泛型中提到，TypeScript 支持使用三元运算的条件类型，它可以根据 ？前面的条件判断返回不同的类型。同时，三元运算还支持嵌套。</p>
<p>在三元运算的条件判断逻辑中，它主要使用 extends 关键字判断两个类型的子类型关系，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> isSubTyping&lt;<span class="title class_">Child</span>, <span class="title class_">Par</span>&gt; = <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Par</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> isAssertable&lt;T, S&gt; = T <span class="keyword">extends</span> S ? <span class="literal">true</span> : S <span class="keyword">extends</span> T ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> isNumAssertable = isAssertable&lt;<span class="number">1</span>, <span class="built_in">number</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> isStrAssertable = isAssertable&lt;<span class="built_in">string</span>, <span class="string">&#x27;string&#x27;</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> isNotAssertable = isAssertable&lt;<span class="number">1</span>, <span class="built_in">boolean</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="分配条件类型（Distributive-Conditional-Types）"><a href="#分配条件类型（Distributive-Conditional-Types）" class="headerlink" title="分配条件类型（Distributive Conditional Types）"></a>分配条件类型（Distributive Conditional Types）</h3><p>在条件类型中，如果入参是联合类型，则会被拆解为一个个独立的（原子）类型（成员），然后再进行类型运算。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">BooleanOrString</span> = <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumberArray</span>&lt;E&gt; = E <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> ? E[] : E</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WhatIsThis</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="title class_">BooleanOrString</span>&gt; <span class="comment">// boolean | string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BooleanOrStringGot</span> = <span class="title class_">BooleanOrString</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  ? <span class="title class_">BooleanOrString</span>[]</span><br><span class="line">  : <span class="title class_">BooleanOrString</span> <span class="comment">//  string | boolean</span></span><br></pre></td></tr></table></figure>

<p>同样，通过某些手段强制类型入参被当成一个整体，也可以解除类型分配，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumberArray</span>&lt;E&gt; = [E] <span class="keyword">extends</span> [<span class="built_in">string</span> | <span class="built_in">number</span>] ? E[] : E</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WhatIsThis</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="built_in">string</span> | <span class="built_in">boolean</span>&gt; <span class="comment">// string | boolean</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：包含条件类型的泛型接收 never 作为泛型入参时，存在一定“陷阱”</strong></p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetSNums</span> = <span class="built_in">never</span> <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">  ? <span class="built_in">number</span>[]</span><br><span class="line">  : <span class="built_in">never</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">  ? <span class="built_in">string</span>[]</span><br><span class="line">  : <span class="built_in">never</span> <span class="comment">// number[];</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetNever</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>泛型 StringOrNumberArray 的实现与示例第 1 行“&#x3D;”右侧的逻辑并没有任何区别（除 never 被抽离成入参之外）。这是因为 never 是不能分配的底层类型，如果作为入参以原子形式出现在条件判断 extends 关键字左侧，则实例化得到的类型也是 never。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UsefulNeverX</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123;&#125; ? T[] : []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UselessNeverX</span>&lt;T, S&gt; = S <span class="keyword">extends</span> &#123;&#125; ? S[] : []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UselessNeverY</span>&lt;T, S&gt; = S <span class="keyword">extends</span> &#123;&#125; ? T[] : []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UselessNeverZ</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [&#123;&#125;] ? T[] : []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ThisIsNeverX</span> = <span class="title class_">UsefulNeverX</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ThisIsNotNeverX</span> = <span class="title class_">UselessNeverX</span>&lt;<span class="built_in">never</span>, <span class="built_in">string</span>&gt; <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ThisIsNotNeverY</span> = <span class="title class_">UselessNeverY</span>&lt;<span class="built_in">never</span>, <span class="built_in">string</span>&gt; <span class="comment">// never[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ThisIsNotNeverZ</span> = <span class="title class_">UselessNeverZ</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// never[]</span></span><br></pre></td></tr></table></figure>

<h3 id="条件类型中的类型推断-infer"><a href="#条件类型中的类型推断-infer" class="headerlink" title="条件类型中的类型推断 infer"></a>条件类型中的类型推断 infer</h3><p>另外，我们可以在条件类型中使用类型推断操作符 infer 来获取类型入参的组成部分，比如说获取数组类型入参里元素的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ElementTypeOfArray</span>&lt;T&gt; = T <span class="keyword">extends</span> (infer E)[] ? E : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> isNumber = <span class="title class_">ElementTypeOfArray</span>&lt;<span class="built_in">number</span>[]&gt; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> isNever = <span class="title class_">ElementTypeOfArray</span>&lt;<span class="built_in">number</span>&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>我们还可以通过 infer 创建任意个类型推断参数，以此获取任意的成员类型，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ElementTypeOfObj</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">name</span>: infer E; <span class="attr">id</span>: infer I &#125;</span><br><span class="line">  ? [E, I]</span><br><span class="line">  : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> isArray = <span class="title class_">ElementTypeOfObj</span>&lt;&#123; <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>; <span class="attr">id</span>: <span class="number">1</span>; <span class="attr">age</span>: <span class="number">30</span> &#125;&gt; <span class="comment">// [&#x27;name&#x27;, 1]</span></span><br><span class="line"><span class="keyword">type</span> isNever = <span class="title class_">ElementTypeOfObj</span>&lt;<span class="built_in">number</span>&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<h3 id="索引访问类型"><a href="#索引访问类型" class="headerlink" title="索引访问类型"></a>索引访问类型</h3><p>索引访问类型其实更像是获取物料的方式，首先我们可以通过属性名、索引、索引签名按需提取对象（接口类型）任意成员的类型（<strong>注意：只能使用 [索引名] 的语法</strong>），如下示例。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MixedObject</span> &#123;</span><br><span class="line">  <span class="attr">animal</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;animal&#x27;</span> | <span class="string">&#x27;dog&#x27;</span> | <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="attr">name</span>: <span class="built_in">number</span>]: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">nickname</span>: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="attr">name</span>: <span class="built_in">string</span>]: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> animal = <span class="title class_">MixedObject</span>[<span class="string">&#x27;animal&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> animalType = <span class="title class_">MixedObject</span>[<span class="string">&#x27;animal&#x27;</span>][<span class="string">&#x27;type&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> numberIndex = <span class="title class_">MixedObject</span>[<span class="built_in">number</span>]</span><br><span class="line"><span class="keyword">type</span> numberIndex0 = <span class="title class_">MixedObject</span>[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">type</span> stringIndex = <span class="title class_">MixedObject</span>[<span class="built_in">string</span>]</span><br><span class="line"><span class="keyword">type</span> stringIndex0 = <span class="title class_">MixedObject</span>[<span class="string">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>在示例的第 16 行，我们通过 ‘animal’ 索引获取了 MixedObject 接口的 animal 属性的类型。在第 17 行，我们通过多级属性索引获取了更深层级 type 属性的类型。</p>
<p>然后，在第 18 行、第 19 行，我们通过 number 类型索引签名和数字索引 0 获取了第 6~10 行定义的同一个接口类型。</p>
<p>最后，在第 20 行、第 21 行，我们通过 string 类型索引签名和字符串字面量索引 ‘string’ 获取了第 11~14 行定义的同一个接口类型。</p>
<h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p>可以使用 keyof 关键字提取对象属性名、索引名、索引签名的类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MixedObjectKeys</span> = keyof <span class="title class_">MixedObject</span> <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> animalKeys = keyof animal <span class="comment">// &#x27;type&#x27; | &#x27;age&#x27;</span></span><br><span class="line"><span class="keyword">type</span> numberIndexKeys = keyof numberIndex <span class="comment">// &quot;type&quot; | &quot;age&quot; | &quot;nickname&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>如果我们在表达式上下文中使用 typeof，则是用来获取表达式值的类型，如果在类型上下文中使用，则是用来获取变量或者属性的类型。当然，在 TypeScript 中，typeof 的主要用途是在类型上下文中获取变量或者属性的类型，下面我们通过一个具体示例来理解一下。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">StrA</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> unions = <span class="keyword">typeof</span> <span class="title class_">StrA</span> <span class="comment">// unions 类型是 &quot;string&quot; | &quot;number&quot; | &quot;bigint&quot; | &quot;boolean&quot; | &quot;symbol&quot; | &quot;undefined&quot; | &quot;object&quot; | &quot;function&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str</span>: <span class="keyword">typeof</span> <span class="title class_">StrA</span> = <span class="string">&#x27;string&#x27;</span> <span class="comment">// strs 类型是 string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DerivedFromStrA</span> = <span class="keyword">typeof</span> <span class="title class_">StrA</span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>对于任何未显式添加类型注解或值与类型注解一体（比如函数、类）的变量或属性，我们都可以使用 typeof 提取它们的类型，这是一个十分方便、有用的设计，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = <span class="keyword">typeof</span> animal</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">animalFun</span> = (<span class="params"></span>) =&gt; animal</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalFun</span> = <span class="keyword">typeof</span> animalFun</span><br></pre></td></tr></table></figure>

<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>我们可以使用索引签名语法和 in 关键字限定对象属性的范围，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SpecifiedKeys</span> = <span class="string">&#x27;id&#x27;</span> | <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetType</span> = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> <span class="title class_">SpecifiedKeys</span>]: <span class="built_in">any</span></span><br><span class="line">&#125; <span class="comment">// &#123; id: any; name: any; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGeneric</span>&lt;O <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> O]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetInstance</span> = <span class="title class_">TargetGeneric</span>&lt;<span class="title class_">SpecifiedKeys</span>&gt; <span class="comment">// &#123; id: any; name: any; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITargetInterface</span> &#123;</span><br><span class="line">  [key <span class="keyword">in</span> <span class="title class_">SpecifiedKeys</span>]: <span class="built_in">any</span> <span class="comment">// ts(1169)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：我们只能在类型别名定义中使用 in，如果在接口中使用，则会提示一个 ts(1169) 的错误</p>
</blockquote>
<p>在定义类型时，我们可以组合使用 in 和 keyof，并基于已有的类型创建一个新类型，使得新类型与已有类型保持一致的只读、可选特性，这样的泛型被称之为映射类型。</p>
<blockquote>
<p><strong>注意：in 和 keyof 也只能在类型别名定义中组合使用。</strong></p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SourceInterface</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetType</span> = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof <span class="title class_">SourceInterface</span>]: <span class="title class_">SourceInterface</span>[key]</span><br><span class="line">&#125; <span class="comment">// &#123; readonly id: number; name?: string | undefined &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericType</span>&lt;S&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof S]: S[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetInstance</span> = <span class="title class_">TargetGenericType</span>&lt;<span class="title class_">SourceInterface</span>&gt; <span class="comment">// &#123; readonly id: number; name?: string | undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>同样，我们可以在映射类型中使用 readonly、? 修饰符来描述属性的可读性、可选性，也可以在修饰符前添加 +、- 前缀表示添加、移除指定修饰符（默认是 +、添加），如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeReadonly</span>&lt;S&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof S]: S[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeReadonlyInstance</span> =</span><br><span class="line">  <span class="title class_">TargetGenericTypeReadonly</span>&lt;<span class="title class_">SourceInterface</span>&gt; <span class="comment">// &#123; readonly id: number; readonly name?: string | undefined &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeOptional</span>&lt;S&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof S]?: S[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeOptionalInstance</span> =</span><br><span class="line">  <span class="title class_">TargetGenericTypeOptional</span>&lt;<span class="title class_">SourceInterface</span>&gt; <span class="comment">// &#123; readonly id?: number; readonly name?: string | undefined &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeRemoveReadonly</span>&lt;S&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof S]: S[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeRemoveReadonlyInstance</span> =</span><br><span class="line">  <span class="title class_">TargetGenericTypeRemoveReadonly</span>&lt;<span class="title class_">SourceInterface</span>&gt; <span class="comment">// &#123; id: number; name?: string | undefined &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeRemoveOptional</span>&lt;S&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof S]-?: S[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeRemoveOptionalInstance</span> =</span><br><span class="line">  <span class="title class_">TargetGenericTypeRemoveOptional</span>&lt;<span class="title class_">SourceInterface</span>&gt; <span class="comment">// &#123; readonly id: number; name: string &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-as-重新映射-key"><a href="#使用-as-重新映射-key" class="headerlink" title="使用 as 重新映射 key"></a>使用 as 重新映射 key</h3><p>自 TypeScript 4.1 起，我们可以在映射类型的索引签名中使用类型断言</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeAssertiony</span>&lt;S&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof S <span class="keyword">as</span> <span class="title class_">Exclude</span>&lt;key, <span class="string">&#x27;id&#x27;</span>&gt;]: S[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetGenericTypeAssertionyInstance</span> =</span><br><span class="line">  <span class="title class_">TargetGenericTypeAssertiony</span>&lt;<span class="title class_">SourceInterface</span>&gt; <span class="comment">// &#123; name?: string | undefined; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h2><h3 id="ReturnTypeOfResolved"><a href="#ReturnTypeOfResolved" class="headerlink" title="ReturnTypeOfResolved"></a>ReturnTypeOfResolved</h3><p>ReturnTypeOfResolved 和官方 ReturnType 的区别：如果入参 F 的返回类型是泛型 Promise 的实例，则返回 Promise 接收的入参。</p>
<p>我们可以借鉴 ReturnType 的定义实现 ReturnTypeOfResolved，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnTypeOfResolved</span>&lt;F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = F <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; <span class="title class_">Promise</span>&lt;infer R&gt;</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="title class_">ReturnType</span>&lt;F&gt;</span><br><span class="line"><span class="keyword">type</span> isNumber = <span class="title class_">ReturnTypeOfResolved</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> isString = <span class="title class_">ReturnTypeOfResolved</span>&lt;<span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>基于映射类型将类型入参 A 和 B 合并为一个类型的泛型 <code>Merge&lt;A, B&gt;</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;A, B&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof A | keyof B]: key <span class="keyword">extends</span> keyof A</span><br><span class="line">    ? key <span class="keyword">extends</span> keyof B</span><br><span class="line">      ? A[key] | B[key]</span><br><span class="line">      : A[key]</span><br><span class="line">    : key <span class="keyword">extends</span> keyof B</span><br><span class="line">    ? B[key]</span><br><span class="line">    : <span class="built_in">never</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Merged</span> = <span class="title class_">Merge</span>&lt;&#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;, &#123; <span class="attr">id</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;&gt;</span><br><span class="line"><span class="comment">// =&gt; &#123; id: number | string; name: string; age: number &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><p>再来实现一个自定义工具类型 <code>Equal&lt;S, T&gt;</code>，它可以用来判断入参 S 和 T 是否是相同的类型。如果相同，则返回布尔字面量类型 true，否则返回 false。</p>
<p>此时，我们很容易想到，如果 S 是 T 的子类型且 T 也是 S 的子类型，则说明 S 和 T 是相同的类型，所以 Equal 的实现似乎是这样的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EqualV1</span>&lt;S, T&gt; = S <span class="keyword">extends</span> T ? (T <span class="keyword">extends</span> S ? <span class="literal">true</span> : <span class="literal">false</span>) : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV11</span> = <span class="title class_">EqualV1</span>&lt;<span class="number">1</span> | (<span class="built_in">number</span> &amp; &#123;&#125;), <span class="built_in">number</span>&gt; <span class="comment">// true but boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV12</span> = <span class="title class_">EqualV1</span>&lt;<span class="built_in">never</span>, <span class="built_in">never</span>&gt; <span class="comment">// true but never</span></span><br></pre></td></tr></table></figure>

<p>在示例中的第 1 行，我们实现了泛型 EqualV1；第 2 行中的第一个入参是联合类型，因为分配条件类型的设定，所以第一个类型入参被拆解，最终返回类型 boolean（实际上是联合类型 true | false）。同样，在第 3 行中，当入参是 never，则返回类型 never。因此，EqualV1 并不符合我们的预期。</p>
<p>此时，我们需要使用 [] 解除条件分配类型和 never “陷阱”，确保自定义泛型仅返回 true 或者 false，所以前面示例的改良版本 EqualV2 如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EqualV2</span>&lt;S, T&gt; = [S] <span class="keyword">extends</span> [T] ? ([T] <span class="keyword">extends</span> [S] ? <span class="literal">true</span> : <span class="literal">false</span>) : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV21</span> = <span class="title class_">EqualV2</span>&lt;<span class="number">1</span> | (<span class="built_in">number</span> &amp; &#123;&#125;), <span class="built_in">number</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV22</span> = <span class="title class_">EqualV2</span>&lt;<span class="built_in">never</span>, <span class="built_in">never</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV23</span> = <span class="title class_">EqualV2</span>&lt;<span class="built_in">any</span>, <span class="built_in">number</span>&gt; <span class="comment">// false but true</span></span><br></pre></td></tr></table></figure>

<p>在示例中的第 2 行、第 3 行，虽然我们解决了联合类型和 never 的问题，但是还是无法区分万金油类型 any 和其他类型。在第 4 行，当入参是 any 和 number，预期应该返回 false，却返回了 true。</p>
<p>这时，我们还需要使用一个可以能识别 any 的改良版 EqualV3 如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsAny</span>&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> &amp; T ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EqualV3</span>&lt;S, T&gt; = <span class="title class_">IsAny</span>&lt;S&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">  ? <span class="title class_">IsAny</span>&lt;T&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  : <span class="title class_">IsAny</span>&lt;T&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">  ? <span class="literal">false</span></span><br><span class="line">  : [S] <span class="keyword">extends</span> [T]</span><br><span class="line">  ? [T] <span class="keyword">extends</span> [S]</span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">  : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV31</span> = <span class="title class_">EqualV3</span>&lt;<span class="number">1</span> | (<span class="built_in">number</span> &amp; &#123;&#125;), <span class="built_in">number</span>&gt; <span class="comment">// true but false got</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV32</span> = <span class="title class_">EqualV3</span>&lt;<span class="built_in">never</span>, <span class="built_in">never</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV34</span> = <span class="title class_">EqualV3</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV33</span> = <span class="title class_">EqualV3</span>&lt;<span class="built_in">any</span>, <span class="built_in">number</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleV35</span> = <span class="title class_">EqualV3</span>&lt;<span class="built_in">never</span>, <span class="built_in">any</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考题：尝试找一个 ExampleV3 不能正确分区类型的反例，并改良 ExampleV3。</p>
</blockquote>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ts笔记（6）：常见TypeScript错误、开发Node.js应用</title>
    <url>/TypeScript/ts%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8TypeScript%E5%BC%80%E5%8F%91Node.js%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>下面讲解项目经历的常见 TypeScript 错误汇总分析、如何使用 TypeScript 开发 Node.js 应用</p>
<span id="more"></span>

<h1 id="常见-TypeScript-错误汇总分析"><a href="#常见-TypeScript-错误汇总分析" class="headerlink" title="常见 TypeScript 错误汇总分析"></a>常见 TypeScript 错误汇总分析</h1><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>ypeScript 错误信息由错误码和详细信息组成。其中，错误码是以“TS”开头 + 数字（一般是 4 位数字）结尾这样的格式组成的字符串，用来作为特定类型错误的专属代号。如果你想查看所有的错误信息和错误码，可以点击 <a href="https://github.com/Microsoft/TypeScript/blob/main/src/compiler/diagnosticMessages.json">TypeScript 源码仓库</a>。当然，随着 TypeScript 版本的更新，也会逐渐增加更多新的类型错误。</p>
<h3 id="TS2456：由于类型别名循环引用了自身造成的-TS2456-类型错误"><a href="#TS2456：由于类型别名循环引用了自身造成的-TS2456-类型错误" class="headerlink" title="TS2456：由于类型别名循环引用了自身造成的 TS2456 类型错误"></a>TS2456：由于类型别名循环引用了自身造成的 TS2456 类型错误</h3><p>类似函数循环调用自己，如果没有正确的终止条件，就会一直处于无限循环的状态，比如：<code>type T = Readonly&lt;T&gt;;</code></p>
<p>当然，如果在类型别名的定义中设定了正确的终止条件，我们就可以使用循环引用的特殊数据结构，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">JSON</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> | <span class="literal">null</span> | <span class="title class_">JSON</span>[] | &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="title class_">JSON</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">json1</span>: <span class="title class_">JSON</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">json2</span>: <span class="title class_">JSON</span> = [<span class="string">&#x27;str&#x27;</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">json3</span>: <span class="title class_">JSON</span> = &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：第 2 个例子只能在 TypeScript 3.7 以上的版本使用，如果版本小于 3.7 仍会提示 TS2456 错误。</p>
</blockquote>
<h3 id="TS2554：形参和实参个数不匹配"><a href="#TS2554：形参和实参个数不匹配" class="headerlink" title="TS2554：形参和实参个数不匹配"></a>TS2554：形参和实参个数不匹配</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">x: <span class="built_in">number</span> | <span class="literal">undefined</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">toString</span>() <span class="comment">// TS2554: Expected 1 arguments, but got 0.</span></span><br><span class="line"><span class="title function_">toString</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="title function_">toString</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如果在编程的过程中函数的参数是可选的，最好使用可选参数的语法:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">x?: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">x = <span class="string">&#x27;&#x27;</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，在 TypeScript 4.1 大版本的更新中，Promise 构造的 resolve 参数不再是默认可选的了，所以如以下示例第 2 行所示，在未指定入参的情况下，调用 resolve 会提示类型错误 （注意：为了以示区分，官方使用了 TS2794 错误码指代这个错误）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>() <span class="comment">// TS2794: Expected 1 arguments, but got 0. Did you forget to include &#x27;void&#x27; in your type argument to &#x27;Promise&#x27;?</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果我们不需要参数，只需要给 Promise 的泛型参数传入 void 即可</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="TS1169：在接口类型定义中由于使用了非字面量或者非唯一-symbol-类型作为属性名造成"><a href="#TS1169：在接口类型定义中由于使用了非字面量或者非唯一-symbol-类型作为属性名造成" class="headerlink" title="TS1169：在接口类型定义中由于使用了非字面量或者非唯一 symbol 类型作为属性名造成"></a>TS1169：在接口类型定义中由于使用了非字面量或者非唯一 symbol 类型作为属性名造成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Obj &#123;</span><br><span class="line">  [key in &#x27;id&#x27; | &#x27;name&#x27;]: any // TS1169: A computed property name in an interface must refer to an expression whose type is a literal type or a &#x27;unique symbol&#x27; type.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 interface 类型的属性必须是字面量类型(string、number) 或者是 unique symbol 类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">symbol</span>: unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span></span><br><span class="line">  [<span class="built_in">symbol</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在 type 关键字声明的类型别名中，我们却可以使用映射类型定义属性，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="comment">// 定义了一个包含 id 和 name 属性的类型别名 Obj</span></span><br><span class="line">  [key <span class="keyword">in</span> <span class="string">&#x27;id&#x27;</span> | <span class="string">&#x27;name&#x27;</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TS2345：在传参时由于类型不兼容造成"><a href="#TS2345：在传参时由于类型不兼容造成" class="headerlink" title="TS2345：在传参时由于类型不兼容造成"></a>TS2345：在传参时由于类型不兼容造成</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> A &#123;</span><br><span class="line">  x = <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  y = <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  z = <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> B &#123;</span><br><span class="line">  x = <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  y = <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  z = <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">val: A</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">fn</span>(B.<span class="property">x</span>) <span class="comment">// TS2345: Argument of type &#x27;B.x&#x27; is not assignable to parameter of type &#x27;A&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>这是因为枚举是在运行时真正存在的对象，因此 TypeScript 并不会判断两个枚举是否可以互相兼容。此时解决这个错误的方式也很简单，我们只需要让这两个枚举类型互相兼容就行，比如使用类型断言绕过 TypeScript 的类型检查:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">val: A</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">fn</span>(B.<span class="property">x</span> <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> A)</span><br></pre></td></tr></table></figure>

<h3 id="TS2589：由泛型实例化递归嵌套过深造成的"><a href="#TS2589：由泛型实例化递归嵌套过深造成的" class="headerlink" title="TS2589：由泛型实例化递归嵌套过深造成的"></a>TS2589：由泛型实例化递归嵌套过深造成的</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RepeatX</span>&lt;N <span class="keyword">extends</span> <span class="built_in">number</span>, T <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = T[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> N</span><br><span class="line">  ? T</span><br><span class="line">  : <span class="title class_">RepeatX</span>&lt;N, [...T, <span class="string">&#x27;X&#x27;</span>]&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">RepeatX</span>&lt;<span class="number">5</span>&gt; <span class="comment">// =&gt; [&quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;]</span></span><br><span class="line"><span class="comment">// TS2589: Type instantiation is excessively deep and possibly infinite.</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">RepeatX</span>&lt;<span class="number">50</span>&gt; <span class="comment">// =&gt; any</span></span><br></pre></td></tr></table></figure>

<p>因为 TypeScript 在处理递归类型的时候，最多实例化 50 层，如果超出了递归层数的限制，TypeScript 便不会继续实例化，并且类型会变为 top 类型 any。对于上面的错误，我们使用 @ts-ignore 注释忽略即可。</p>
<h3 id="TS2322"><a href="#TS2322" class="headerlink" title="TS2322"></a>TS2322</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CSSProperties</span> &#123;</span><br><span class="line">  <span class="attr">display</span>: <span class="string">&#x27;block&#x27;</span> | <span class="string">&#x27;flex&#x27;</span> | <span class="string">&#x27;grid&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  <span class="attr">display</span>: <span class="string">&#x27;flex&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TS2322: Type &#x27;&#123; display: string; &#125;&#x27; is not assignable to type &#x27;CSSProperties&#x27;.</span></span><br><span class="line"><span class="comment">//  Types of property &#x27;display&#x27; are incompatible.</span></span><br><span class="line"><span class="comment">//   Type &#x27;string&#x27; is not assignable to type &#x27;&quot;block&quot; | &quot;flex&quot; | &quot;grid&quot;&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cssStyle</span>: <span class="title class_">CSSProperties</span> = style</span><br></pre></td></tr></table></figure>

<p>两种解决这个错误的方法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">style</span>: <span class="title class_">CSSProperties</span> = &#123;</span><br><span class="line">  <span class="attr">display</span>: <span class="string">&#x27;flex&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法 2</span></span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  <span class="attr">display</span>: <span class="string">&#x27;flex&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;flex&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typeof style = &#123; display: &#x27;flex&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="TS2352："><a href="#TS2352：" class="headerlink" title="TS2352："></a>TS2352：</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  x.<span class="title function_">trim</span>()</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    x.<span class="title function_">trim</span>() <span class="comment">// TS2532: Object is possibly &#x27;undefined&#x27;.</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">if</span> (person <span class="keyword">instanceof</span> <span class="title class_">Person</span>) &#123;</span><br><span class="line">  person.<span class="title function_">greet</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">innerFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    person.<span class="title function_">greet</span>() <span class="comment">// TS2532: Object is possibly &#x27;undefined&#x27;.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对这种错误的处理方式也很简单，将类型收缩的代码放入函数体内部即可，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    x.<span class="title function_">trim</span>() <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> | <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">innerFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (person <span class="keyword">instanceof</span> <span class="title class_">Person</span>) &#123;</span><br><span class="line">    person.<span class="title function_">greet</span>() <span class="comment">// Ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>自 TS 3.9 版本起，官方支持了与 @ts-ignore 注释相反功能的 @ts-expect-error 注释。使用 @ts-expect-error 注释，我们可以标记代码中应该有类型错误的部分。与 ts-ignore 不同的是，如果下一行代码中没有错误，则会提示 TS2578 的错误，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: <span class="built_in">number</span> = <span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="comment">// TS2578: Unused &#x27;@ts-expect-error&#x27; directive.</span></span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>: <span class="built_in">number</span> = <span class="number">42</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：@ts-expect-error 注释命令在编写预期失败的单元测试中很有用处。</p>
</blockquote>
<h1 id="手把手教你使用-TypeScript-开发-Node-js-应用"><a href="#手把手教你使用-TypeScript-开发-Node-js-应用" class="headerlink" title="手把手教你使用 TypeScript 开发 Node.js 应用"></a>手把手教你使用 TypeScript 开发 Node.js 应用</h1><h2 id="开发-NPM-模块"><a href="#开发-NPM-模块" class="headerlink" title="开发 NPM 模块"></a>开发 NPM 模块</h2><p>在开发阶段，我们使用 ts-node 直接运行 TypeScript 源码就行。构建时，我们使用官方转译工具 tsc 将 TypeScript 源码转译为 JavaScript，并使用 TypeScript + Jest 做单元测试。</p>
<h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><p>执行“npm init”命令初始化 NPM 模块。通过命令行工具或者 IDE 创建 src 目录用来存放所有的 TypeScript 源码。TypeScript 转译为 JavaScript 后，lib 目录一般不需要手动创建，因为转译工具会自动创建，此时我们只需要修改 tsconfig.json 中相应的配置即可。此外，我们还需要按照如下命令手动创建单元测试文件目录 <code>__tests__</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir src; // 创建放 TypeScript 源码的目录</span><br><span class="line">touch src/cli.ts // CLI 命令入口文件</span><br><span class="line">touch src/http-serve.ts // CLI 命令入口文件</span><br><span class="line">mkdir lib; // 转译工具自动创建放 JavaScript 代码的目录</span><br><span class="line">mkdir __tests__; // 单元测试文件目录</span><br></pre></td></tr></table></figure>

<p>接下来我们可以按照如下命令先行安装项目需要的基本依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install typescript -D;</span><br><span class="line">npm install ts-node -D;</span><br><span class="line">npm install jest@24 -D;</span><br><span class="line">npm install ts-jest@24 -D;</span><br><span class="line">npm install @types/jest -D;</span><br></pre></td></tr></table></figure>

<p>安装完依赖后，我们需要把模块的 main&#x2F;bin 等参数、start&#x2F;build&#x2F;test 等命令写入 package.json 中，如下代码所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib/bin.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib/http-serve.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;lib&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc -p tsconfig.prod.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ts-node src/cli.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jest --all&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化-tsconfig"><a href="#初始化-tsconfig" class="headerlink" title="初始化 tsconfig"></a>初始化 tsconfig</h3><p>如果我们已经安装了全局的 TypeScript，那么就可以直接使用全局的 tsc 命令初始化。</p>
<p>当然，我们也可以直接使用当前模块目录下安装的 TypeScript 来初始化 tsconfig 配置。这里我推荐全局安装 npx，可以更方便地调用安装在当前目录下的各种 CLI 工具，如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc --init; // 使用全局</span><br><span class="line"></span><br><span class="line">npm install npx -g; // 安装 npx</span><br><span class="line">npx tsc --init; // 或者使用 npx 调用当前目录下 node_modules 目录里安装的 tsc 版本</span><br></pre></td></tr></table></figure>

<p>此外，一般我们会把 target 参数设置为 es5，module 参数设置为 commonjs，这样转译后模块的代码和格式就可以兼容较低版本的 Node.js 了。然后，我们需要把 tsc 转译代码的目标目录 outDir 指定为 “.&#x2F;lib”。</p>
<p>除了构建行为相关的配置之外，我们还需要按照如下命令将 esModuleInterop 配置为 true，以便在类型检测层面兼容 CommonJS 和 ES 模块的引用关系，最终适用于 Node.js 开发的 tsconfig。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./lib&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./src&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面我们需要手动创建一个 tsconfig.prod.json，告诉 tsc 在转译源码时忽略 <code>__tests__</code> 目录。当然，我们也可以根据实际情况把其他文件、目录添加到 exclude 配置中，如下代码所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;__tests__&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lib&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>出于统一和可控性考虑，我们可以将通用的 tsconfig 配置抽离为单独的 NPM 或直接使用第三方封装的配置，再通过 extends 参数进行复用，比如可以安装<a href="https://www.npmjs.com/package/@tsconfig/node10%E7%AD%89%EF%BC%8C%E5%9C%A8%E5%BD%93%E5%89%8D%E6%A8%A1%E5%9D%97%E7%9A%84">https://www.npmjs.com/package/@tsconfig/node10等，在当前模块的</a> tsconfig.json 中，我们只需保留路径相关的配置即可，其他配置可以继承自 node_modules 中安装的 tsconfig 模块，如下代码所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tsconfig/node10&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./lib&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们需要使用 Node.js 内置的 http 模块和第三方 ecstatic、commander 模块实现 http-serve 静态文件服务器。</p>
<h3 id="接口设计和编码实现"><a href="#接口设计和编码实现" class="headerlink" title="接口设计和编码实现"></a>接口设计和编码实现</h3><p>首先，我们需要安装以下相关依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @types/node -D;</span><br><span class="line">npm install commander -S;</span><br><span class="line">npm install ecstatic -S;</span><br></pre></td></tr></table></figure>

<p>不幸的是，ecstatic 并不是一个对 TypeScript 友好的模块，因为它没有内置类型声明文件，也没有第三方贡献的 @types&#x2F;ecstatic 类型声明模块。因此，我们需要在项目根目录下新建一个 types.d.ts 用来补齐缺失的类型声明，如下代码所示：</p>
<figure class="highlight ts"><figcaption><span>types.d.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;ecstatic&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> (options?: &#123;</span><br><span class="line">    root?: <span class="built_in">string</span></span><br><span class="line">    baseDir?: <span class="built_in">string</span></span><br><span class="line">    autoIndex?: <span class="built_in">boolean</span></span><br><span class="line">    showDir?: <span class="built_in">boolean</span></span><br><span class="line">    showDotfiles?: <span class="built_in">boolean</span></span><br><span class="line">    humanReadable?: <span class="built_in">boolean</span></span><br><span class="line">    hidePermissions?: <span class="built_in">boolean</span></span><br><span class="line">    si?: <span class="built_in">boolean</span></span><br><span class="line">    cache?: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">    cors?: <span class="built_in">boolean</span></span><br><span class="line">    gzip?: <span class="built_in">boolean</span></span><br><span class="line">    brotli?: <span class="built_in">boolean</span></span><br><span class="line">    defaultExt?: <span class="string">&#x27;html&#x27;</span> | (<span class="built_in">string</span> &amp; &#123;&#125;)</span><br><span class="line">    handleError?: <span class="built_in">boolean</span></span><br><span class="line">    serverHeader?: <span class="built_in">boolean</span></span><br><span class="line">    contentType?: <span class="string">&#x27;application/octet-stream&#x27;</span> | (<span class="built_in">string</span> &amp; &#123;&#125;)</span><br><span class="line">    weakEtags?: <span class="built_in">boolean</span></span><br><span class="line">    weakCompare?: <span class="built_in">boolean</span></span><br><span class="line">    handleOptionsMethod?: <span class="built_in">boolean</span></span><br><span class="line">  &#125;) =&gt; <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多时候因为类型声明补全的成本较高，所以我们也可以通过一行 “declare module ‘ecstatic’;”快速绕过 ts(2307) 错误提示。</p>
<blockquote>
<p>注意：在业务实践中，如果碰到某个模块缺失类型声明文件，则会提示一个 ts(2307) 的错误，此时我们可以先尝试通过 npm i @types&#x2F;模块名 -D 安装可能存在的第三方补齐类型声明。如果找不到，再通过 declare module 手动补齐。</p>
</blockquote>
<p>接下来，我们在 src&#x2F;http-serve.ts 中实现主逻辑。</p>
<p>首先，我们约定模块接收的参数及需要对外暴露的接口，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IHttpServerOptions</span> &#123;</span><br><span class="line">  <span class="comment">/** 静态文件目录，默认是当前目录 */</span></span><br><span class="line">  root?: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">/** 缓存时间 */</span></span><br><span class="line">  cache?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 对外暴露的方法 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IHttpServer</span> &#123;</span><br><span class="line">  <span class="comment">/** 启动服务 */</span></span><br><span class="line">  <span class="title function_">listen</span>(<span class="attr">port</span>: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">  <span class="comment">/** 关闭服务 */</span></span><br><span class="line">  <span class="title function_">close</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上定义的接口都可以通过 export 关键字对外导出，并基于接口约定实现主逻辑类 HttpServer，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HttpServer</span> <span class="keyword">implements</span> <span class="title class_">IHttpServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">server</span>: http.<span class="property">Server</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options: IHttpServerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> root = options.<span class="property">root</span> || process.<span class="title function_">cwd</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">server</span> = http.<span class="title function_">createServer</span>(</span><br><span class="line">      <span class="title function_">ecstatic</span>(&#123;</span><br><span class="line">        root,</span><br><span class="line">        <span class="attr">cache</span>: options.<span class="property">cache</span> === <span class="literal">undefined</span> ? <span class="number">3600</span> : options.<span class="property">cache</span>,</span><br><span class="line">        <span class="attr">showDir</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">defaultExt</span>: <span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">        <span class="attr">gzip</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;application/octet-stream&#x27;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">listen</span>(<span class="params">port: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">listen</span>(port)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">close</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，为了让 TypeScript 代码可以在 ts-node 中顺利跑起来，我们可以在 src&#x2F;http-serve.ts 引入模块依赖之前，显式地引入手动补齐的缺失的类型声明文件，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;../types.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;http&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ecstatic <span class="keyword">from</span> <span class="string">&#x27;ecstatic&#x27;</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们基于上边实现的 http-serve.ts 和 commander 模块编码实现 src&#x2F;cli.ts，具体示例如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; program &#125; <span class="keyword">from</span> <span class="string">&#x27;commander&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HttpServer</span>, &#123; <span class="title class_">IHttpServerOptions</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./http-serve&#x27;</span></span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;--cache, &lt;cache&gt;&#x27;</span>, <span class="string">&#x27;设置缓存时间，秒数&#x27;</span>)</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;--root, &lt;root&gt;&#x27;</span>, <span class="string">&#x27;静态文件目录&#x27;</span>)</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;-p, --port, &lt;port&gt;&#x27;</span>, <span class="string">&#x27;监听端口&#x27;</span>, <span class="string">&#x27;3000&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(</span><br><span class="line">    <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      options: Omit&lt;IHttpServerOptions, <span class="string">&#x27;cache&#x27;</span>&gt; &amp; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cache?: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">        port: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; root, cache, port &#125; = options</span><br><span class="line">      <span class="keyword">const</span> server = <span class="keyword">new</span> <span class="title class_">HttpServer</span>(&#123;</span><br><span class="line">        root,</span><br><span class="line">        <span class="attr">cache</span>: cache &amp;&amp; <span class="built_in">parseInt</span>(cache),</span><br><span class="line">      &#125;)</span><br><span class="line">      server.<span class="title function_">listen</span>(+port)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`监听 <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">program.<span class="title function_">parse</span>(process.<span class="property">argv</span>)</span><br></pre></td></tr></table></figure>

<p>接下来我们可以通过 npm start 直接运行 src&#x2F;cli.ts 或通过 npm run build 将 TypeScript 代码转译为 JavaScript 代码，并运行 node lib&#x2F;cli.js 启动静态服务，浏览器访问服务效果图如下：</p>
<h2 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h2><p>一个健壮的项目往往离不开充分的单元测试，接下来我们将学习如何使用 TypeScript + Jest 为 http-serve 模块编写单测。</p>
<p>在前面的步骤中，我们已经安装了 Jest 相关的依赖，并且配置好了 npm run test 命令，此时可以在项目的根目录下通过如下代码新建一个 jest.config.js 配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">collectCoverageFrom</span>: [<span class="string">&#x27;src/**/*.&#123;ts&#125;&#x27;</span>],</span><br><span class="line">  <span class="attr">setupFiles</span>: [<span class="string">&#x27;&lt;rootDir&gt;/__tests__/setup.ts&#x27;</span>],</span><br><span class="line">  <span class="attr">testMatch</span>: [<span class="string">&#x27;&lt;rootDir&gt;/__tests__/**/?(*.)(spec|test).ts&#x27;</span>],</span><br><span class="line">  <span class="attr">testEnvironment</span>: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  <span class="attr">testURL</span>: <span class="string">&#x27;http://localhost:4444&#x27;</span>,</span><br><span class="line">  <span class="attr">transform</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^.+\\.ts$&#x27;</span>: <span class="string">&#x27;ts-jest&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">transformIgnorePatterns</span>: [</span><br><span class="line">    <span class="string">&#x27;[/\\\\]node_modules[/\\\\].+\\.(js|jsx|mjs|ts|tsx)$&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">moduleNameMapper</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">moduleFileExtensions</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;ts&#x27;</span>],</span><br><span class="line">  <span class="attr">globals</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;ts-jest&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">tsConfig</span>: <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>).<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;tsconfig.test.json&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，运行 Node.js 端的模块转译单测代码使用的 tsconfig.test.json 配置和转译生成代码使用的 tsconfig.prod.json 配置完全一样，因此我们可以直接将 tsconfig.prod.json 复制到 tsconfig.test.json。</p>
<p>配置好 Jest 后，我们就可以把 http-serve 模块单元测试编入 <code>/_tests_/http-serve.test.ts</code> 中，具体示例如下（更多的 Jest 使用说明，请查看官方文档）：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;http&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HttpServer</span> <span class="keyword">from</span> <span class="string">&#x27;../src/http-serve&#x27;</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;http-serve&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">server</span>: <span class="title class_">HttpServer</span></span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    server = <span class="keyword">new</span> <span class="title class_">HttpServer</span>(&#123;&#125;)</span><br><span class="line">    server.<span class="title function_">listen</span>(<span class="number">8099</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    server.<span class="title function_">close</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;should listen port&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    http</span><br><span class="line">      .<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8099</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">end</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">done</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：源码中使用的路径别名，比如用“@&#x2F;module”代替“src&#x2F;sub-directory&#x2F;module”，这样可以缩短引用路径，这就需要我们调整相应的配置。</p>
</blockquote>
<h2 id="处理路径别名"><a href="#处理路径别名" class="headerlink" title="处理路径别名"></a>处理路径别名</h2><p>首先，我们需要在 tsconfig.json 中添加如下所示 paths 配置，这样 TypeScript 就可以解析别名模块。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    ...<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/sub-directory/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：需要显式设置 baseUrl，不然会提示一个无法解析相对路径的错误。</strong></p>
</blockquote>
<p>接下来我们在 jest.config.js 中通过如下代码配置相应的规则，告知 Jest 如何解析别名模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">moduleNameMapper</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^@/(.*)$&#x27;</span>: <span class="string">&#x27;&lt;rootDir&gt;/src/sub-directory/$1&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 tsc 在转译代码的时候不会把别名替换成真实的路径，所以我们引入额外的工具处理别名。此时我们可以按照如下命令安装 tsc-alias 和 tsconfig-paths 分别供 tsc 和 ts-node 处理别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install tsc-alias -D;</span><br><span class="line">npm install tsconfig-paths -D;</span><br></pre></td></tr></table></figure>

<p>最后，我们需要修改 package.json scripts 配置，如下代码所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ...<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc -p tsconfig.prod.json &amp;&amp; tsc-alias -p tsconfig.prod.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node -r tsconfig-paths/register -r ts-node/register src/cli.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>项目源码地址：<a href="https://github.com/gogoyqj/http-serve">https://github.com/gogoyqj/http-serve</a></p>
</blockquote>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ts笔记（3）：联合类型、交叉类型、枚举类型、泛型</title>
    <url>/TypeScript/ts%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E3%80%81%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>这一节讲解更复杂一点的数据结构，包括：联合类型、交叉类型、枚举类型、泛型。</p>
<span id="more"></span>

<h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型（Unions）用来表示变量、参数的类型不是单一原子类型，而可能是多种不同的类型的组合。</p>
<p>我们主要通过“|”操作符分隔类型的语法来表示联合类型。这里，我们可以把“|”类比为 JavaScript 中的逻辑或 “||”，只不过前者表示可能的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatPX</span>(<span class="params">size: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> size === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;size&#125;</span>px`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> size === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(size) || <span class="number">0</span>&#125;</span>px`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">formatPX</span>(<span class="number">13</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">formatPX</span>(<span class="string">&#x27;13px&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">formatPX</span>(<span class="literal">true</span>) <span class="comment">// ts(2345) &#x27;true&#x27; 类型不能赋予 &#x27;number | string&#x27; 类型</span></span><br><span class="line"><span class="title function_">formatPX</span>(<span class="literal">null</span>) <span class="comment">// ts(2345) &#x27;null&#x27; 类型不能赋予 &#x27;number | string&#x27; 类型</span></span><br></pre></td></tr></table></figure>

<p>当然，我们可以组合任意个、任意类型来构造更满足我们诉求的类型。比如，我们希望给前边的示例再加一个 unit 参数表示可能单位，这个时候就可以声明一个字符串字面类型组成的联合类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatUnit</span>(<span class="params"></span></span><br><span class="line"><span class="params">  size: <span class="built_in">number</span> | <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  unit: <span class="string">&#x27;px&#x27;</span> | <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span> | <span class="string">&#x27;%&#x27;</span> = <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">formatUnit</span>(<span class="number">1</span>, <span class="string">&#x27;em&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">formatUnit</span>(<span class="string">&#x27;1px&#x27;</span>, <span class="string">&#x27;rem&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">formatUnit</span>(<span class="string">&#x27;1px&#x27;</span>, <span class="string">&#x27;bem&#x27;</span>) <span class="comment">// ts(2345)</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用类型别名抽离上边的联合类型，然后再将其进一步地联合，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ModernUnit</span> = <span class="string">&#x27;vh&#x27;</span> | <span class="string">&#x27;vw&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Unit</span> = <span class="string">&#x27;px&#x27;</span> | <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MessedUp</span> = <span class="title class_">ModernUnit</span> | <span class="title class_">Unit</span> <span class="comment">// 类型是 &#x27;vh&#x27; | &#x27;vw&#x27; | &#x27;px&#x27; | &#x27;em&#x27; | &#x27;rem&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以把接口类型联合起来表示更复杂的结构，如下所示示例（援引官方示例，顺带复习一下类型断言 as）：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="title function_">fly</span>(): <span class="built_in">void</span></span><br><span class="line">  <span class="title function_">layEggs</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="title function_">swim</span>(): <span class="built_in">void</span></span><br><span class="line">  <span class="title function_">layEggs</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">getPet</span>: <span class="function">() =&gt;</span> <span class="title class_">Bird</span> | <span class="title class_">Fish</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="title class_">Bird</span> | <span class="title class_">Fish</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Pet</span> = <span class="title function_">getPet</span>()</span><br><span class="line"><span class="title class_">Pet</span>.<span class="title function_">layEggs</span>() <span class="comment">// ok</span></span><br><span class="line"><span class="title class_">Pet</span>.<span class="title function_">fly</span>() <span class="comment">// ts(2339) &#x27;Fish&#x27; 没有 &#x27;fly&#x27; 属性; &#x27;Bird | Fish&#x27; 没有 &#x27;fly&#x27; 属性</span></span><br></pre></td></tr></table></figure>

<p>从上边的示例可以看到，在联合类型中，我们可以直接访问各个接口成员都拥有的属性、方法，且不会提示类型错误。但是，如果是个别成员特有的属性、方法，我们就需要区分对待了，此时又要引入类型守卫来区分不同的成员类型。</p>
<p>只不过，在这种情况下，我们还需要使用基于 in 操作符判断的类型守卫，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Pet</span>.<span class="property">fly</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// ts(2339)</span></span><br><span class="line">  <span class="title class_">Pet</span>.<span class="title function_">fly</span>() <span class="comment">// ts(2339)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;fly&#x27;</span> <span class="keyword">in</span> <span class="title class_">Pet</span>) &#123;</span><br><span class="line">  <span class="title class_">Pet</span>.<span class="title function_">fly</span>() <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 Pet 的类型既可能是 Bird 也可能是 Fish，这就意味着在第 1 行可能会通过 Fish 类型获取 fly 属性，但 Fish 类型没有 fly 属性定义，所以会提示一个 ts(2339) 错误。</p>
<h1 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h1><p>在 TypeScript 中，我们可以使用“&amp;”操作符来声明交叉类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Useless</span> = <span class="built_in">string</span> &amp; <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<p>很显然，如果我们仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是 string 类型又是 number 类型。因此，在上述的代码中，类型别名 Useless 的类型就是个 never。</p>
<h2 id="合并接口类型"><a href="#合并接口类型" class="headerlink" title="合并接口类型"></a>合并接口类型</h2><p>联合类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionType</span> = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">mixed</span>: <span class="title class_">IntersectionType</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们通过交叉类型，使得 IntersectionType 同时拥有了 id、name、age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>
<blockquote>
<p>如果合并的多个接口类型存在同名属性会是什么效果呢？如果同名属性的类型不兼容，比如上面示例中两个接口类型同名的 name 属性类型一个是 number，另一个是 string，合并后，name 属性的类型就是 number 和 string 两个原子类型的交叉类型，即 never，如下代码所示：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionTypeConfict</span> = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">mixedConflict</span>: <span class="title class_">IntersectionTypeConfict</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ts(2322) 错误，&#x27;number&#x27; 类型不能赋给 &#x27;never&#x27; 类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们赋予 mixedConflict 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 IntersectionTypeConfict 类型是一个无用类型。</p>
<p>如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</p>
<p>如下所示示例中 name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionTypeConfict</span> = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="number">2</span> &#125; &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">mixedConflict</span>: <span class="title class_">IntersectionTypeConfict</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>, <span class="comment">// ok</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line">mixedConflict = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">22</span>, <span class="comment">// &#x27;22&#x27; 类型不能赋给 &#x27;2&#x27; 类型</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并联合类型"><a href="#合并联合类型" class="headerlink" title="合并联合类型"></a>合并联合类型</h1><p>另外，我们可以合并联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员。这里，我们也可以将合并联合类型理解为求交集。在如下示例中，两个联合类型交叉出来的类型 IntersectionUnion 其实等价于 ‘em’ | ‘rem’</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionA</span> = <span class="string">&#x27;px&#x27;</span> | <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span> | <span class="string">&#x27;%&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionB</span> = <span class="string">&#x27;vh&#x27;</span> | <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span> | <span class="string">&#x27;pt&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionUnion</span> = <span class="title class_">UnionA</span> &amp; <span class="title class_">UnionB</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">intersectionA</span>: <span class="title class_">IntersectionUnion</span> = <span class="string">&#x27;em&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">intersectionB</span>: <span class="title class_">IntersectionUnion</span> = <span class="string">&#x27;rem&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">intersectionC</span>: <span class="title class_">IntersectionUnion</span> = <span class="string">&#x27;px&#x27;</span> <span class="comment">// ts(2322)</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">intersectionD</span>: <span class="title class_">IntersectionUnion</span> = <span class="string">&#x27;pt&#x27;</span> <span class="comment">// ts(2322)</span></span><br></pre></td></tr></table></figure>

<p>既然是求交集，如果多个联合类型中没有相同的类型成员，交叉出来的类型自然就是 never 了，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionC</span> = <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionD</span> = <span class="string">&#x27;px&#x27;</span> | <span class="string">&#x27;pt&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectionUnionE</span> = <span class="title class_">UnionC</span> &amp; <span class="title class_">UnionD</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">intersectionE</span>: <span class="title class_">IntersectionUnionE</span> = <span class="string">&#x27;any&#x27;</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="comment">// ts(2322) 不能赋予 &#x27;never&#x27; 类型</span></span><br></pre></td></tr></table></figure>

<h2 id="联合、交叉组合"><a href="#联合、交叉组合" class="headerlink" title="联合、交叉组合"></a>联合、交叉组合</h2><p>在前面的示例中，我们把一些联合、交叉类型抽离成了类型别名，再把它作为原子类型进行进一步的联合、交叉。其实，联合、交叉类型本身就可以直接组合使用，这就涉及 |、&amp; 操作符的优先级问题。实际上，联合、交叉运算符不仅在行为上表现一致，还在运算的优先级和 JavaScript 的逻辑或 ||、逻辑与 &amp;&amp; 运算符上表现一致 。</p>
<p>联合操作符 | 的优先级低于交叉操作符 &amp;，同样，我们可以通过使用小括弧 () 来调整操作符的优先级。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionIntersectionA</span> =</span><br><span class="line">  | (&#123; <span class="attr">id</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;)</span><br><span class="line">  | (&#123; <span class="attr">id</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">number</span> &#125;) <span class="comment">// 交叉操作符优先级高于联合操作符</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionIntersectionB</span> =</span><br><span class="line">  | (<span class="string">&#x27;px&#x27;</span> | <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span> | <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">  | (<span class="string">&#x27;vh&#x27;</span> | <span class="string">&#x27;em&#x27;</span> | <span class="string">&#x27;rem&#x27;</span> | <span class="string">&#x27;pt&#x27;</span>) <span class="comment">// 调整优先级</span></span><br></pre></td></tr></table></figure>

<p>进而，我们也可以把分配率、交换律等基本规则引入类型组合中，然后优化出更简洁、清晰的类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionIntersectionC</span> = (</span><br><span class="line">  | (&#123; <span class="attr">id</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;)</span><br><span class="line">  | &#123; <span class="attr">id</span>: <span class="built_in">string</span> &#125;</span><br><span class="line">) &amp; &#123; <span class="attr">name</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionIntersectionD</span> =</span><br><span class="line">  | (&#123; <span class="attr">id</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">number</span> &#125;)</span><br><span class="line">  | (&#123; <span class="attr">id</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">number</span> &#125;) <span class="comment">// 满足分配率</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnionIntersectionE</span> = (</span><br><span class="line">  | &#123; <span class="attr">id</span>: <span class="built_in">string</span> &#125;</span><br><span class="line">  | (&#123; <span class="attr">id</span>: <span class="built_in">number</span> &#125; &amp; &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;)</span><br><span class="line">) &amp; &#123; <span class="attr">name</span>: <span class="built_in">number</span> &#125; <span class="comment">// 满足交换律</span></span><br></pre></td></tr></table></figure>

<h1 id="类型缩减"><a href="#类型缩减" class="headerlink" title="类型缩减"></a>类型缩减</h1><p>如果将 string 原始类型和“string 字面量类型”组合成联合类型会是什么效果？效果就是类型缩减成 string 了。同样，对于 number、boolean（其实还有枚举类型）也是一样的缩减逻辑，如下所示示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">URStr</span> = <span class="string">&#x27;string&#x27;</span> | <span class="built_in">string</span> <span class="comment">// 类型是 string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">URNum</span> = <span class="number">2</span> | <span class="built_in">number</span> <span class="comment">// 类型是 number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">URBoolen</span> = <span class="literal">true</span> | <span class="built_in">boolean</span> <span class="comment">// 类型是 boolean</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumUR</span> &#123;</span><br><span class="line">  <span class="variable constant_">ONE</span>,</span><br><span class="line">  <span class="variable constant_">TWO</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">URE</span> = <span class="title class_">EnumUR</span>.<span class="property">ONE</span> | <span class="title class_">EnumUR</span> <span class="comment">// 类型是 EnumUR</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 对这样的场景做了缩减，它把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化”。可是这个缩减，却极大地削弱了 IDE 自动提示的能力，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">BorderColor</span> = <span class="string">&#x27;black&#x27;</span> | <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;green&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;blue&#x27;</span> | <span class="built_in">string</span> <span class="comment">// 类型缩减成 string</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们希望 IDE 能自动提示显示注解的字符串字面量，但是因为类型被缩减成 string，所有的字符串字面量 black、red 等都无法自动提示出来了。不要慌，TypeScript 官方其实还提供了一个黑魔法，它可以让类型缩减被控制。如下代码所示，我们只需要给父类型添加“&amp; {}”即可。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">BorderColor</span> = <span class="string">&#x27;black&#x27;</span> | <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;green&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;blue&#x27;</span> | (<span class="built_in">string</span> &amp; &#123;&#125;) <span class="comment">// 字面类型都被保留</span></span><br></pre></td></tr></table></figure>

<p>此时，其他字面量类型就不会被缩减掉了，在 IDE 中字符串字面量 black、red 等也就自然地可以自动提示出来了。此外，当联合类型的成员是接口类型，如果满足其中一个接口的属性是另外一个接口属性的子集，这个属性也会类型缩减，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionInterce</span> =</span><br><span class="line">  | &#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  | &#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span></span><br><span class="line">      [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里因为 ‘1’ 是 ‘1’ | ‘2’ 的子集，所以 age 的属性变成 ‘1’ | ‘2’</p>
<p>如何定义如下所示 age 属性是数字类型，而其他不确定的属性是字符串类型的数据结构的对象？比如这样</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span>, <span class="comment">// 数字类型</span></span><br><span class="line">  <span class="attr">anyProperty</span>: <span class="string">&#x27;str&#x27;</span>, <span class="comment">// 其他不确定的属性都是字符串类型</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想必你应该明白了，我们肯定要用到两个接口的联合类型及类型缩减，这个问题的核心在于找到一个既是 number 的子类型，这样 age 类型缩减之后的类型就是 number；同时也是 string 的子类型，这样才能满足属性和 string 索引类型的约束关系。</p>
<p>哪个类型满足这个条件呢？我们一起回忆一下特殊类型 never。</p>
<p>never 有一个特性是它是所有类型的子类型，自然也是 number 和 string 的子类型，所以答案如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionInterce</span> =</span><br><span class="line">  | &#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line">  | &#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="built_in">never</span></span><br><span class="line">      [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">O</span>: <span class="title class_">UnionInterce</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">string</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们在第 3 行定义了 number 类型的 age 属性，第 6 行定义了 never 类型的 age 属性，等价于 age 属性的类型是由 number 和 never 类型组成的联合类型，所以我们可以把 number 类型的值（比如说数字字面量 1）赋予 age 属性；但是不能把其他任何类型的值（比如说字符串字面量 ‘string’ ）赋予 age。</p>
<p>同时，我们在第 5 行<del>第 8 行定义的接口类型中，还额外定义了 string 类型的字符串索引签名。因为 never 同时又是 string 类型的子类型，所以 age 属性的类型和字符串索引签名类型不冲突。如第 9 行</del>第 12 行所示，我们可以把一个 age 属性是 2、string 属性是 ‘string’ 的对象字面量赋值给 UnionInterce 类型的变量 O。</p>
<h1 id="枚举类型：详解常见枚举类型的-7-种用法"><a href="#枚举类型：详解常见枚举类型的-7-种用法" class="headerlink" title="枚举类型：详解常见枚举类型的 7 种用法"></a>枚举类型：详解常见枚举类型的 7 种用法</h1><p>在 TypeScript 中，我们可以使用枚举定义包含被命名的常量的集合，比如 TypeScript 支持数字、字符两种常量值的枚举类型。我们也可以使用 enum 关键字定义枚举类型，格式是 enum + 枚举名字 + 一对花括弧，花括弧里则是被命名了的常量成员。下面我们把前边表示星期的联合类型示例使用枚举类型实现一遍，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">  <span class="variable constant_">TUESDAY</span>,</span><br><span class="line">  <span class="variable constant_">WEDNESDAY</span>,</span><br><span class="line">  <span class="variable constant_">THURSDAY</span>,</span><br><span class="line">  <span class="variable constant_">FRIDAY</span>,</span><br><span class="line">  <span class="variable constant_">SATURDAY</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转译为 JavaScript 后:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Day</span> = <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Day</span>) &#123;</span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;SUNDAY&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;SUNDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;MONDAY&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;MONDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;TUESDAY&#x27;</span>] = <span class="number">2</span>)] = <span class="string">&#x27;TUESDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;WEDNESDAY&#x27;</span>] = <span class="number">3</span>)] = <span class="string">&#x27;WEDNESDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;THURSDAY&#x27;</span>] = <span class="number">4</span>)] = <span class="string">&#x27;THURSDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;FRIDAY&#x27;</span>] = <span class="number">5</span>)] = <span class="string">&#x27;FRIDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;SATURDAY&#x27;</span>] = <span class="number">6</span>)] = <span class="string">&#x27;SATURDAY&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Day</span> || (<span class="title class_">Day</span> = &#123;&#125;))</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，我们可以通过“枚举名字.常量命名”的格式获取枚举集合里的成员，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params">d: Day</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">SUNDAY</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">SATURDAY</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;take a rest&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">MONDAY</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">TUESDAY</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">WEDNESDAY</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">THURSDAY</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">FRIDAY</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;work hard&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果等效于:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (d) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;take a rest&#x27;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;work hard&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就意味着在 JavaScript 中调用 work 函数时，传递的参数无论是 enum 还是数值，逻辑上将没有区别，当然这也符合 TypeScript 静态类型检测规则，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">work</span>(<span class="title class_">Day</span>.<span class="property">SUNDAY</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">work</span>(<span class="number">0</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>如果我们希望枚举值从其他值开始递增，则可以通过“常量命名 &#x3D; 数值” 的格式显示指定枚举成员的初始值，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>, <span class="comment">// 2</span></span><br><span class="line">  <span class="variable constant_">TUESDAY</span>, <span class="comment">// 3</span></span><br><span class="line">  <span class="variable constant_">WEDNESDAY</span>, <span class="comment">// ...</span></span><br><span class="line">  <span class="variable constant_">THURSDAY</span>,</span><br><span class="line">  <span class="variable constant_">FRIDAY</span>,</span><br><span class="line">  <span class="variable constant_">SATURDAY</span>, <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以给任意位置的成员指定值，如下所示示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">  <span class="variable constant_">TUESDAY</span>,</span><br><span class="line">  <span class="variable constant_">WEDNESDAY</span>,</span><br><span class="line">  <span class="variable constant_">THURSDAY</span>,</span><br><span class="line">  <span class="variable constant_">FRIDAY</span>,</span><br><span class="line">  <span class="variable constant_">SATURDAY</span> = <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转移后</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;FRIDAY&#x27;</span>] = <span class="number">5</span>)] = <span class="string">&#x27;FRIDAY&#x27;</span></span><br><span class="line"><span class="title class_">Day</span>[(<span class="title class_">Day</span>[<span class="string">&#x27;SATURDAY&#x27;</span>] = <span class="number">5</span>)] = <span class="string">&#x27;SATURDAY&#x27;</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 MyDay.FRIDAY 和 MyDay.SATURDAY 的值都是数字 5，这就导致使用 Day 枚举作为 switch 分支条件的函数 work，在接收 MyDay.SATURDAY 作为入参时，也会进入 MyDay.FRIDAY 的分支，从而出现逻辑错误。</p>
<p>这个经验告诉我们，由于枚举默认的值自递增且完全无法保证稳定性，所以给部分数字类型的枚举成员显式指定数值或给函数传递数值而不是枚举类型作为入参都属于不明智的行为。</p>
<p>此外，常量命名、结构顺序都一致的两个枚举，即便转译为 JavaScript 后，同名成员的值仍然一样（满足恒等 &#x3D;&#x3D;&#x3D; ）。但在 TypeScript 看来，它们不相同、不满足恒等，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyDay</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Day</span>.<span class="property">SUNDAY</span> === <span class="title class_">MyDay</span>.<span class="property">SUNDAY</span> <span class="comment">// ts(2367) 两个枚举值恒不相等</span></span><br><span class="line"><span class="title function_">work</span>(<span class="title class_">MyDay</span>.<span class="property">SUNDAY</span>) <span class="comment">// ts(2345) &#x27;MyDay.SUNDAY&#x27; 不能赋予 &#x27;Day&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h2><p>在 TypeScript 中，我们将定义值是字符串字面量的枚举称之为字符串枚举，字符串枚举转译为 JavaScript 之后也将保持这些值，我们来看下如下所示示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span> = <span class="string">&#x27;SUNDAY&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span> = <span class="string">&#x27;MONDAY&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转译后</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Day</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Day</span>) &#123;</span><br><span class="line">  <span class="title class_">Day</span>[<span class="string">&#x27;SUNDAY&#x27;</span>] = <span class="string">&#x27;SUNDAY&#x27;</span></span><br><span class="line">  <span class="title class_">Day</span>[<span class="string">&#x27;MONDAY&#x27;</span>] = <span class="string">&#x27;MONDAY&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Day</span> || (<span class="title class_">Day</span> = &#123;&#125;))</span><br></pre></td></tr></table></figure>

<p>这里我们定义了成员 SUNDAY 的值是 ‘SUNDAY’、MONDAY 的值是 ‘MONDAY’。</p>
<h2 id="异构枚举（Heterogeneous-enums）"><a href="#异构枚举（Heterogeneous-enums）" class="headerlink" title="异构枚举（Heterogeneous enums）"></a>异构枚举（Heterogeneous enums）</h2><p>从技术上来讲，TypeScript 支持枚举类型同时拥有数字和字符类型的成员，这样的枚举被称之为异构枚举。</p>
<p>当然，异构枚举也被认为是很“鸡肋”的类型。比如如下示例中，我们定义了成员 SUNDAY 是 ‘SUNDAY’、MONDAY 是 2，很抱歉，我也不知道这样的枚举能在哪些有用的场合进行使用。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span> = <span class="string">&#x27;SUNDAY&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span> = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量成员和计算（值）成员"><a href="#常量成员和计算（值）成员" class="headerlink" title="常量成员和计算（值）成员"></a>常量成员和计算（值）成员</h2><p>在前边示例中，涉及的枚举成员的值都是字符串、数字字面量和未指定初始值从 0 递增数字常量，都被称作常量成员。</p>
<p>另外，在转译时，通过被计算的常量枚举表达式定义值的成员，也被称作常量成员，比如如下几种情况：</p>
<ul>
<li>引用来自预先定义的常量成员，比如来自当前枚举或其他枚举；</li>
<li>圆括弧 () 包裹的常量枚举表达式；</li>
<li>在常量枚举表达式上应用的一元操作符 +、 -、~ ；</li>
<li>操作常量枚举表达式的二元操作符 +、-、*、&#x2F;、%、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;、|、^。</li>
</ul>
<p>除以上这些情况之外，其他都被认为是计算（值）成员。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FileAccess</span> &#123;</span><br><span class="line">  <span class="comment">// 常量成员</span></span><br><span class="line">  <span class="title class_">None</span>,</span><br><span class="line">  <span class="title class_">Read</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Write</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">ReadWrite</span> = <span class="title class_">Read</span> | <span class="title class_">Write</span>,</span><br><span class="line">  <span class="comment">// 计算成员</span></span><br><span class="line">  G = <span class="string">&#x27;123&#x27;</span>.<span class="property">length</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：关于常量成员和计算成员的划分其实比较难理解，实际上它们也并没有太大的用处，只是告诉我们通过这些途径可以定义枚举成员的值。因此，我们只需记住缺省值（从 0 递增）、数字字面量、字符串字面量肯定是常量成员就够了。</p>
</blockquote>
<h2 id="枚举成员类型和联合枚举"><a href="#枚举成员类型和联合枚举" class="headerlink" title="枚举成员类型和联合枚举"></a>枚举成员类型和联合枚举</h2><p>枚举成员和枚举类型之间的关系分两种情况： 如果枚举的成员同时包含字面量和非字面量枚举值，枚举成员的类型就是枚举本身（枚举类型本身也是本身的子类型）；如果枚举成员全部是字面量枚举值，则所有枚举成员既是值又是类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyDay</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span> = <span class="title class_">Day</span>.<span class="property">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">mondayIsDay</span>: <span class="title class_">Day</span>.<span class="property">MONDAY</span> = <span class="title class_">Day</span>.<span class="property">MONDAY</span> <span class="comment">// ok: 字面量枚举成员既是值，也是类型</span></span><br><span class="line"><span class="keyword">const</span> mondayIsSunday = <span class="title class_">MyDay</span>.<span class="property">SUNDAY</span> <span class="comment">// ok: 类型是 MyDay，MyDay.SUNDAY 仅仅是值</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mondayIsMyDay2</span>: <span class="title class_">MyDay</span>.<span class="property">MONDAY</span> = <span class="title class_">MyDay</span>.<span class="property">MONDAY</span> <span class="comment">// ts(2535)，MyDay 包含非字面量值成员，所以 MyDay.MONDAY 不能作为类型，应该是MyDay类型</span></span><br></pre></td></tr></table></figure>

<p>另外，如果枚举仅有一个成员且是字面量成员，那么这个成员的类型等于枚举类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mondayIsDay</span>: <span class="title class_">Day</span> = <span class="title class_">Day</span>.<span class="property">MONDAY</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mondayIsDay1</span>: <span class="title class_">Day</span>.<span class="property">MONDAY</span> = mondayIsDay <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>联合类型使得 TypeScript 可以更清楚地枚举集合里的确切值，从而检测出一些永远不会成立的条件判断（俗称 Dead Code），如下所示示例（援引自官方恒为真的示例）：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">work</span> = (<span class="params">x: Day</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="title class_">Day</span>.<span class="property">SUNDAY</span> || x !== <span class="title class_">Day</span>.<span class="property">MONDAY</span>) &#123;</span><br><span class="line">    <span class="comment">// ts(2367)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上边示例中，TypeScript 确定 x 的值要么是 Day.SUNDAY，要么是 Day.MONDAY。因为 Day 是纯字面量枚举类型，可以等价地看作联合类型 Day.SUNDAY | Day.MONDAY，所以我们判断出第 7 行的条件语句恒为真，于是提示了一个 ts(2367) 错误。</p>
<p>不过，如果枚举包含需要计算（值）的成员情况就不一样了。如下示例中，TypeScript 不能区分枚举 Day 中的每个成员。因为每个成员类型都是 Day，所以无法判断出第 7 行的条件语句恒为真，也就不会提示一个 ts(2367) 错误。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span> = +<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span> = <span class="string">&#x27;aa&#x27;</span>.<span class="property">length</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">work</span> = (<span class="params">x: Day</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="title class_">Day</span>.<span class="property">SUNDAY</span> || x !== <span class="title class_">Day</span>.<span class="property">MONDAY</span>) &#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，字面量类型所具有的类型推断、类型缩小的特性，也同样适用于字面量枚举类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">SUNDAY</span> = <span class="title class_">Day</span>.<span class="property">SUNDAY</span> <span class="comment">// 类型是 Day</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SUNDAY2</span> = <span class="title class_">Day</span>.<span class="property">SUNDAY</span> <span class="comment">// 类型 Day.SUNDAY</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">work</span> = (<span class="params">x: Day</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="title class_">Day</span>.<span class="property">SUNDAY</span>) &#123;</span><br><span class="line">    x <span class="comment">// 类型缩小为 Day.SUNDAY</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量枚举（const-enums）"><a href="#常量枚举（const-enums）" class="headerlink" title="常量枚举（const enums）"></a>常量枚举（const enums）</h2><p>我们可以通过添加 const 修饰符定义常量枚举，常量枚举定义转译为 JavaScript 之后会被移除，并在使用常量枚举成员的地方被替换为相应的内联值，因此常量枚举的成员都必须是常量成员（字面量 + 转译阶段可计算值的表达式），如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">work</span> = (<span class="params">d: Day</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">SUNDAY</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;take a rest&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Day</span>.<span class="property">MONDAY</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;work hard&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转译后</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">work</span> = (<span class="params">d</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="comment">/* SUNDAY */</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;take a rest&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> <span class="comment">/* MONDAY */</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;work hard&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部枚举（Ambient-enums）"><a href="#外部枚举（Ambient-enums）" class="headerlink" title="外部枚举（Ambient enums）"></a>外部枚举（Ambient enums）</h2><p>在 TypeScript 中，我们可以通过 declare 描述一个在其他地方已经定义过的变量，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">$</span>: <span class="built_in">any</span></span><br><span class="line">$(<span class="string">&#x27;#id&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;show&#x27;</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>第 1 行我们使用 declare 描述类型是 any 的外部变量 $，在第 2 行则立即使用 $ ，此时并不会提示一个找不到 $ 变量的错误。</p>
<p>同样，我们也可以使用 declare 描述一个在其他地方已经定义过的枚举类型，通过这种方式定义出来的枚举类型，被称之为外部枚举，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Day</span> &#123; <span class="comment">// 转译成js后抹除掉</span></span><br><span class="line">  <span class="variable constant_">SUNDAY</span>,</span><br><span class="line">  <span class="variable constant_">MONDAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">work</span> = (<span class="params">x: Day</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="title class_">Day</span>.<span class="property">SUNDAY</span>) &#123;</span><br><span class="line">    x <span class="comment">// 类型是 Day</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部枚举和常规枚举的差异在于以下几点：</p>
<ul>
<li>在外部枚举中，如果没有指定初始值的成员都被当作计算（值）成员，这跟常规枚举恰好相反；</li>
<li>即便外部枚举只包含字面量成员，这些成员的类型也不会是字面量成员类型，自然完全不具备字面量类型的各种特性。</li>
</ul>
<p>我们可以一起使用 declare 和 const 定义外部常量枚举，使得它转译为 JavaScript 之后仍像常量枚举一样。在抹除枚举定义的同时，我们可以使用内联枚举值替换对枚举成员的引用。外部枚举的作用在于为两个不同枚举（实际上是指向了同一个枚举类型）的成员进行兼容、比较、被复用提供了一种途径，这在一定程度上提升了枚举的可用性，让其显得不那么“鸡肋”。</p>
<h1 id="泛型：如何正确使用泛型约束类型变量？"><a href="#泛型：如何正确使用泛型约束类型变量？" class="headerlink" title="泛型：如何正确使用泛型约束类型变量？"></a>泛型：如何正确使用泛型约束类型变量？</h1><p>接下来就是 ts 类型的精华：泛型</p>
<h2 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h2><p>关于什么是泛型这个问题不是太好回答，比如在面试中，如果有候选人反过来问我这个问题，可能我也给不出一个特别标准的答案。</p>
<p>不过，我们可以借用 Java 中泛型的释义来回答这个问题：泛型指的是类型参数化，即将原来某种具体的类型进行参数化。和定义函数参数一样，我们可以给泛型定义若干个类型参数，并在调用时给泛型传入明确的类型参数。设计泛型的目的在于有效约束类型成员之间的关系，比如函数参数和返回值、类或者接口成员和方法之间的关系。</p>
<h2 id="泛型类型参数"><a href="#泛型类型参数" class="headerlink" title="泛型类型参数"></a>泛型类型参数</h2><p>泛型最常用的场景是用来约束函数参数的类型，我们可以给函数定义若干个被调用时才会传入明确类型的参数。比如以下定义的一个 reflect 函数 ，它可以接收一个任意类型的参数，并原封不动地返回参数的值和类型，那我们该如何描述这个函数呢？好像得用上 unknown 了（其实我想说的是 any，因为 any is 魔鬼，所以还是用 unknown 吧）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reflect</span>(<span class="params">param: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> param</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str = <span class="title function_">reflect</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// str 类型是 unknown</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">reflect</span>(<span class="number">1</span>) <span class="comment">// num 类型 unknown</span></span><br></pre></td></tr></table></figure>

<p>这时候可以用泛型来约束：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> reflect&lt;P&gt;(<span class="attr">param</span>: P): P &#123;</span><br><span class="line">  <span class="keyword">return</span> param</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reflectStr = reflect&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// str 类型是 string</span></span><br><span class="line"><span class="keyword">const</span> reflectNum = reflect&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>) <span class="comment">// num 类型 number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用泛型函数时受泛型约束的参数有传值，泛型参数的入参可以从参数的类型中进行推断，而无须再显式指定类型（可缺省）</span></span><br><span class="line"><span class="keyword">const</span> reflectStr2 = <span class="title function_">reflect</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// str 类型是 string</span></span><br><span class="line"><span class="keyword">const</span> reflectNum2 = <span class="title function_">reflect</span>(<span class="number">1</span>) <span class="comment">// num 类型 number</span></span><br></pre></td></tr></table></figure>

<p>泛型不仅可以约束函数整个参数的类型，还可以约束参数属性、成员的类型，比如参数的类型可以是数组、对象，如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> reflectArray&lt;P&gt;(<span class="attr">param</span>: P[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> param</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reflectArr = <span class="title function_">reflectArray</span>([<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>]) <span class="comment">// reflectArr 是 (string | number)[]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：函数的泛型入参必须和参数&#x2F;参数成员建立有效的约束关系才有实际意义。</p>
</blockquote>
<p>我们可以给函数定义任何个数的泛型入参，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> reflectExtraParams&lt;P, Q&gt;(<span class="attr">p1</span>: P, <span class="attr">p2</span>: Q): [P, Q] &#123;</span><br><span class="line">  <span class="keyword">return</span> [p1, p2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>在类的定义中，我们还可以使用泛型用来约束构造函数、属性、方法的类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span>&lt;S&gt; &#123;</span><br><span class="line">  <span class="attr">store</span>: S</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">store: S</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">store</span> = store</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">store: S</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">store</span> = store</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">store</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numMemory = <span class="keyword">new</span> <span class="title class_">Memory</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>) <span class="comment">// &lt;number&gt; 可缺省</span></span><br><span class="line"><span class="keyword">const</span> getNumMemory = numMemory.<span class="title function_">get</span>() <span class="comment">// 类型是 number</span></span><br><span class="line">numMemory.<span class="title function_">set</span>(<span class="number">2</span>) <span class="comment">// 只能写入 number 类型</span></span><br><span class="line"><span class="keyword">const</span> strMemory = <span class="keyword">new</span> <span class="title class_">Memory</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 缺省 &lt;string&gt;</span></span><br><span class="line"><span class="keyword">const</span> getStrMemory = strMemory.<span class="title function_">get</span>() <span class="comment">// 类型是 string</span></span><br><span class="line">strMemory.<span class="title function_">set</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// 只能写入 string 类型</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>我们可以使用 Array&lt;类型&gt; 的语法来定义数组类型，这里的 Array 本身就是一种类型。在 TypeScript 中，类型本身就可以被定义为拥有不明确的类型参数的泛型，并且可以接收明确类型作为入参，从而衍生出更具体的类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">reflectFn</span>: &lt;P&gt;<span class="function">(<span class="params">param: P</span>) =&gt;</span> P = reflect <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>我们也可以把 reflectFn 的类型注解提取为一个能被复用的类型别名或者接口，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReflectFuncton</span> = &lt;P&gt;<span class="function">(<span class="params">param: P</span>) =&gt;</span> P</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IReflectFuncton</span> &#123;</span><br><span class="line">  &lt;P&gt;(<span class="attr">param</span>: P): P</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">reflectFn2</span>: <span class="title class_">ReflectFuncton</span> = reflect</span><br><span class="line"><span class="keyword">const</span> <span class="attr">reflectFn3</span>: <span class="title class_">IReflectFuncton</span> = reflect</span><br></pre></td></tr></table></figure>

<p>将类型入参的定义移动到类型别名或接口名称后，此时定义的一个接收具体类型入参后返回一个新类型的类型就是泛型类型。如下示例中，我们定义了两个可以接收入参 P 的泛型类型（GenericReflectFunction 和 IGenericReflectFunction ）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GenericReflectFunction</span>&lt;P&gt; = <span class="function">(<span class="params">param: P</span>) =&gt;</span> P</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGenericReflectFunction</span>&lt;P&gt; &#123;</span><br><span class="line">  (<span class="attr">param</span>: P): P</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">reflectFn4</span>: <span class="title class_">GenericReflectFunction</span>&lt;<span class="built_in">string</span>&gt; = reflect <span class="comment">// 具象化泛型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">reflectFn5</span>: <span class="title class_">IGenericReflectFunction</span>&lt;<span class="built_in">number</span>&gt; = reflect <span class="comment">// 具象化泛型</span></span><br><span class="line"><span class="keyword">const</span> reflectFn3Return = <span class="title function_">reflectFn4</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// 入参和返回值都必须是 string 类型</span></span><br><span class="line"><span class="keyword">const</span> reflectFn4Return = <span class="title function_">reflectFn5</span>(<span class="number">1</span>) <span class="comment">//  入参和返回值都必须是 number 类型</span></span><br></pre></td></tr></table></figure>

<p>在泛型定义中，我们甚至可以使用一些类型操作符进行运算表达，使得泛型可以根据入参的类型衍生出各异的类型，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumberArray</span>&lt;E&gt; = E <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> ? E[] : E</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringArray</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="built_in">string</span>&gt; <span class="comment">// 类型是 string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumberArray</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="built_in">number</span>&gt; <span class="comment">// 类型是 number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NeverGot</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="built_in">boolean</span>&gt; <span class="comment">// 类型是 boolean</span></span><br></pre></td></tr></table></figure>

<p><strong>发散一下，如果我们给上面这个泛型传入了一个 string | boolean 联合类型作为入参，将会得到什么类型呢？且看如下所示示例：</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">BooleanOrString</span> = <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">WhatIsThis</span> = <span class="title class_">StringOrNumberArray</span>&lt;<span class="title class_">BooleanOrString</span>&gt; <span class="comment">// 好像应该是 string | boolean ?</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BooleanOrStringGot</span> = <span class="title class_">BooleanOrString</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  ? <span class="title class_">BooleanOrString</span>[]</span><br><span class="line">  : <span class="title class_">BooleanOrString</span> <span class="comment">//  string | boolean</span></span><br></pre></td></tr></table></figure>

<p>但是实际上 WhatIsThis 的类型是<code>boolean | string[]</code>，而 BooleanOrStringGot 变成了<code>string | boolean</code>，为什么呢？</p>
<p>这个就是所谓的分配条件类型（Distributive Conditional Types），官方的释义：<strong>在条件类型判断的情况下（比如上边示例中出现的 extends），如果入参是联合类型，则会被拆解成一个个独立的（原子）类型（成员）进行类型运算。</strong></p>
<p>而 BooleanOrStringGot 并没有用到泛型，所以不会有分配条件类型。</p>
<blockquote>
<p><strong>注意：枚举类型不支持泛型。</strong></p>
</blockquote>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>比如最前边提到的原封不动返回参数的 reflect 函数，我们希望把接收参数的类型限定在几种原始类型的集合中，此时就可以使用“泛型入参名 extends 类型”语法达到这个目的，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> reflectSpecified&lt;P <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>&gt;(<span class="attr">param</span>: P): P &#123;</span><br><span class="line">  <span class="keyword">return</span> param</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">reflectSpecified</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">reflectSpecified</span>(<span class="number">1</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">reflectSpecified</span>(<span class="literal">true</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">reflectSpecified</span>(<span class="literal">null</span>) <span class="comment">// ts(2345) &#x27;null&#x27; 不能赋予类型 &#x27;number | string | boolean&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们还可以在多个不同的泛型入参之间设置约束关系，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjSetter</span> &#123;</span><br><span class="line">  &lt;O <span class="keyword">extends</span> &#123;&#125;, K <span class="keyword">extends</span> keyof O, V <span class="keyword">extends</span> O[K]&gt;(<span class="attr">obj</span>: O, <span class="attr">key</span>: K, <span class="attr">value</span>: V): V</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">setValueOfObj</span>: <span class="title class_">ObjSetter</span> = <span class="function">(<span class="params">obj, key, value</span>) =&gt;</span> (obj[key] = value)</span><br><span class="line"><span class="title function_">setValueOfObj</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> &#125;, <span class="string">&#x27;id&#x27;</span>, <span class="number">2</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">setValueOfObj</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> &#125;, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;new name&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">setValueOfObj</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> &#125;, <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>) <span class="comment">// ts(2345)</span></span><br><span class="line"><span class="title function_">setValueOfObj</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> &#125;, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;2&#x27;</span>) <span class="comment">// ts(2345)</span></span><br></pre></td></tr></table></figure>

<p>泛型入参的约束与默认值还可以组合使用，如下代码所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReduxModelMixed</span>&lt;<span class="title class_">State</span> <span class="keyword">extends</span> &#123;&#125; = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt; &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">State</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>有用的网站推荐</title>
    <url>/%E5%B9%B2%E8%B4%A7/webRecommend/</url>
    <content><![CDATA[<h1 id="图片类网站"><a href="#图片类网站" class="headerlink" title="图片类网站"></a>图片类网站</h1><h2 id="pexels"><a href="#pexels" class="headerlink" title="pexels"></a>pexels</h2><p>这里有全世界的摄影师分享的高清图片，主要是免费下载哦<br><a href="https://www.pexels.com/">https://www.pexels.com/</a></p>
<h2 id="Visual-Hunt"><a href="#Visual-Hunt" class="headerlink" title="Visual Hunt"></a>Visual Hunt</h2><p>一个无版权图片网站<br><a href="https://visualhunt.com/">https://visualhunt.com/</a></p>
<h2 id="gratisography"><a href="#gratisography" class="headerlink" title="gratisography"></a>gratisography</h2><p>一个另类图片的网站，也是无版权可商用<br><a href="https://gratisography.com/">https://gratisography.com</a></p>
<h2 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a>Unsplash</h2><p>同上<br><a href="https://unsplash.com/">https://unsplash.com/</a></p>
<h2 id="Magdeleine"><a href="#Magdeleine" class="headerlink" title="Magdeleine"></a>Magdeleine</h2><p>每日推荐的图片还是不错的<br><a href="https://magdeleine.co/browse/">https://magdeleine.co/browse/</a></p>
<hr>
<h1 id="学生优惠"><a href="#学生优惠" class="headerlink" title="学生优惠"></a>学生优惠</h1><h2 id="学生服务器优惠"><a href="#学生服务器优惠" class="headerlink" title="学生服务器优惠"></a>学生服务器优惠</h2><p><a href="https://promotion.aliyun.com/ntms/act/xsgroup/buy.html?group=h2neBpEial">阿里云</a>118元&#x2F;年，阿里云ECS+OSS+域名+机器学习API+Clouder认证。 24岁以下实名认证即可获得，无需验证学生身份<br><a href="https://cloud.tencent.com/act/campus">腾讯云</a>10元一个月的云服务器租用，免费域名、云储存，需要抢购<br><a href="https://developer.huaweicloud.com/campus">华为云</a>9块钱一个月,99一年，我已经入了一年，用起来感觉还不错，ping广州数据中心在30ms左右<br><a href="https://cloud.baidu.com/campaign/campus-2018/index.html">百度云</a>18块钱3个月，不过半年要124，这是什么鬼套路，感觉有点坑</p>
<h2 id="Github-学生包"><a href="#Github-学生包" class="headerlink" title="Github 学生包"></a><a href="https://education.github.com/pack">Github 学生包</a></h2><p>高质量的开发工具集合，并提供 DIgitalocean 的 50美元代金券，免费域名一枚。</p>
<h2 id="Autodesk-学生包"><a href="#Autodesk-学生包" class="headerlink" title="Autodesk 学生包"></a><a href="https://www.autodesk.com.cn/education/home">Autodesk 学生包</a></h2><p>旗下有AutoCAD , 3DMAX , Maya 等软件，其（教育版）免费试用期可延长至三年。<br>（已白嫖AutoCAD，非常舒服）</p>
<h2 id="JetBrains-学生包"><a href="#JetBrains-学生包" class="headerlink" title="JetBrains 学生包"></a><a href="https://www.jetbrains.com/student/">JetBrains 学生包</a></h2><p>免费使用各类开发工具和集成工具。<br>（这个貌似需要edu邮箱，和github一样，怎么申请详情查看百度）</p>
<h2 id="Microsoft-Imagine-学生包"><a href="#Microsoft-Imagine-学生包" class="headerlink" title="Microsoft Imagine 学生包"></a><a href="https://imagine.microsoft.com/zh-cn/catalog">Microsoft Imagine 学生包</a></h2><p>免费使用微软的开发软件，包括 Windows Server 系统(是送激活码的形式)，以及 Azure 学生订阅。</p>
<h2 id="苹果商店学生优惠"><a href="#苹果商店学生优惠" class="headerlink" title="苹果商店学生优惠"></a><a href="https://www.apple.com/cn-k12/shop/back-to-school">苹果商店学生优惠</a></h2><p>苹果设备优惠，Music和 Pro APP 优惠，暑假还会有学生优惠大促销。<br>(有些商品优惠力度还是挺大的，比如iPad mini之前能减400)</p>
<hr>
<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><h2 id="百度脑图"><a href="#百度脑图" class="headerlink" title="百度脑图"></a>百度脑图</h2><p>像做思维导图或者其他流程图，但是很多软件要钱，但又不行折腾什么破解注册，甚至不想安装软件，那么搜索这个吧<br><a href="http://naotu.baidu.com/">http://naotu.baidu.com/</a></p>
<h2 id="panzoid"><a href="#panzoid" class="headerlink" title="panzoid"></a>panzoid</h2><p>做视频不会做片头？来试试别人做好的模板吧，只要改一下文字就能用了（进入编辑器后如果不翻墙有可能没办法加载出来）<br><a href="https://panzoid.com/">https://panzoid.com/</a></p>
<h2 id="cloudconvert"><a href="#cloudconvert" class="headerlink" title="cloudconvert"></a>cloudconvert</h2><p>一个很强的转码神器，能转200多种的音频视频文档电子书图片等文件（官方：CloudConvert supports the conversion between more than 200 different audio, video, document, ebook, archive, image, spreadsheet and presentation formats. ）<br><a href="https://cloudconvert.com/">https://cloudconvert.com/</a></p>
<h2 id="smallpdf"><a href="#smallpdf" class="headerlink" title="smallpdf"></a>smallpdf</h2><p>文档转pdf，pdf转文档，也是很强大的网站啊<br><a href="https://smallpdf.com/">https://smallpdf.com/</a></p>
<h2 id="Waifu2x"><a href="#Waifu2x" class="headerlink" title="Waifu2x"></a>Waifu2x</h2><p>介绍请看上面<br><a href="http://waifu2x.udp.jp/index.zh-CN.html">http://waifu2x.udp.jp/index.zh-CN.html</a></p>
<h2 id="Cloud-Studio"><a href="#Cloud-Studio" class="headerlink" title="Cloud Studio"></a>Cloud Studio</h2><p>一个云端开发平台&#x2F;工作站，能开发很多项目，C&#x2F;C++,java,python,nodejs等等，可以自己安装需要的开发环境，用来写个简单的C语言装个B也是不错的，目前来看应该是长期免费。<br><a href="https://studio.dev.tencent.com/">https://studio.dev.tencent.com/</a></p>
<h2 id="docsmall"><a href="#docsmall" class="headerlink" title="docsmall"></a>docsmall</h2><p>一个图片、PDF压缩网站，还能对PDF合并、分割，官方示例将一个2m的图片几乎无损压缩成740K。<br><a href="https://docsmall.com/">https://docsmall.com/</a></p>
<h2 id="msdn"><a href="#msdn" class="headerlink" title="msdn"></a>msdn</h2><p>一个微软官方软件、系统的镜像站，在这里下载不用担心下载到恶心的流氓软件和病毒，记住下面的这个网站哦（我之前用搜狗360之类的搜索引擎会搜到假的）<br><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p>
<hr>
<h1 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h1><h2 id="片源网"><a href="#片源网" class="headerlink" title="片源网"></a><a href="http://pianyuan.la/">片源网</a></h2><p>影视资源下载网站，不过是以bt种子或者磁力链方式下载，需要特定的软件，不如网盘方便。<br>但是这里的资源比较多。</p>
<h2 id="盒子部落"><a href="#盒子部落" class="headerlink" title="盒子部落"></a><a href="https://www.hezibuluo.com/">盒子部落</a></h2><p>软件分享网站,里面的软件还算比较新。</p>
<h2 id="大眼仔旭"><a href="#大眼仔旭" class="headerlink" title="大眼仔旭"></a><a href="http://www.dayanzai.me/">大眼仔旭</a></h2><p>官网介绍：专注视频剪辑、解压、录屏、思维导图等办公软件分享。<br>实际上和上一个差不多，也是软件分享网站。</p>
<h2 id="爱给"><a href="#爱给" class="headerlink" title="爱给"></a><a href="http://www.aigei.com/">爱给</a></h2><p>音效配乐、3D模型、视频素材、游戏素材等资源免费下载的网站。</p>
<h2 id="字体天下"><a href="#字体天下" class="headerlink" title="字体天下"></a><a href="http://www.fonts.net.cn/">字体天下</a></h2><p>提供各种字体的免费下载，包括可以免费商用的字体。</p>
<hr>
<h1 id="在线观看类"><a href="#在线观看类" class="headerlink" title="在线观看类"></a>在线观看类</h1><h2 id="土豪漫画"><a href="#土豪漫画" class="headerlink" title="土豪漫画"></a><a href="https://www.tohomh123.com/">土豪漫画</a></h2><p>免费看漫画的网站</p>
<h2 id="看剧社"><a href="#看剧社" class="headerlink" title="看剧社"></a><a href="http://kanjushe.com/">看剧社</a></h2><p>免费影片的网站</p>
<h2 id="樱花动漫网"><a href="#樱花动漫网" class="headerlink" title="樱花动漫网"></a><a href="http://www.yhdm.tv/">樱花动漫网</a></h2><p>免费看动漫的网站</p>
<blockquote>
<p>亲测上面三个网站没有太多广告（看剧社在底部会有一条广告，不影响观看），但是看剧社需要手机浏览器（建议qq浏览器）。</p>
</blockquote>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="音乐搜索器"><a href="#音乐搜索器" class="headerlink" title="音乐搜索器"></a>音乐搜索器</h2><p>找到好听的歌想下载但是要收费？听听的歌在某个软件里面找不到但是又不想下载其他软件？我相信这个网站能帮到你<br><a href="http://music.cccyun.cc/">http://music.cccyun.cc/</a><br><a href="http://music.bbbbbb.me/">http://music.bbbbbb.me/</a></p>
<h2 id="一堆软件的仓库"><a href="#一堆软件的仓库" class="headerlink" title="一堆软件的仓库"></a>一堆软件的仓库</h2><p>这是一个小伙伴分享给我的git仓库，里面有TeamViewer破解版、一些思维导图工具的破解版、xshell的破解版、Guitar Pro7破解补丁等等，有兴趣的可以去看看<br><a href="http://183.91.54.237:7080/masuit/soft/tree/master">gitlab仓库</a>、<br><a href="https://www.fxxkmakeding.xyz/downloads.html">备用仓库1</a>、<br><a href="https://delivery.yuntu.com.tw/makeding/">备用仓库2</a>、<br><a href="https://mkd.byci.ca/makeding/">备用仓库3</a></p>
<h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><p>里面又很多很多的程序语言和很多其他的教程，想不要钱学知识或者大学在考试前不知道怎么复习，可以看看里面的知识<br><a href="http://www.runoob.com/">http://www.runoob.com/</a></p>
<blockquote>
<p>2019-8-11更新：更新了一个百度云服务器优惠、一堆破解软件的仓库<br>2019-8-27更新：更新了一些可以学生免费获得正版软件授权的网站（Autodesk、JetBrains、Microsoft Imagine）、有学生折扣的商城（苹果商店）、资源免费下载网站（片源网、盒子部落、大眼仔旭、爱给、字体天下）、影视类三个（土豪漫画、看剧社、樱花动漫网）</p>
</blockquote>
]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>网站</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习笔记（1）：入门</title>
    <url>/uncategorized/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>开始学习webpack打包</p>
<span id="more"></span>

<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>首先新建一个非常简单的页面，目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└─ learn</span><br><span class="line">   ├── src</span><br><span class="line">   │   ├── heading.js</span><br><span class="line">   │   └── index.js</span><br><span class="line">   └── index.html</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/heading.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">  element.<span class="property">textContent</span> = <span class="string">&#x27;Hello webpack&#x27;</span></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;Hello webpack&#x27;</span>))</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> createHeading <span class="keyword">from</span> <span class="string">&#x27;./heading.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> heading = <span class="title function_">createHeading</span>()</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(heading)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack - 快速上手<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./src/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>type&#x3D;”module” 这种用法是 ES Modules 中提出的标准，用来区分加载的是一个普通 JS 脚本还是一个模块。</p>
</blockquote>
<p>因为上面的<code>type=&quot;module&quot;</code>是ES6语法，但是在不支持中这个语法的浏览器可能会出现错误，所以我们使用webpack把按照模块化方式拆分的 JS 代码再次打包到一起。</p>
<p>首先按照webpack</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm init --yes                            //新建package.json文件</span><br><span class="line">$ npm i webpack webpack-cli --save-dev      //安装本体和cli模块</span><br></pre></td></tr></table></figure>
<p>不过现在因为webpack更新后导致打包结果和视频教学的结果不一样，所以使用这个方法：</p>
<ol>
<li>把package.json里的webpack版本改为4.44.2，cli改成3.3.12</li>
<li>删掉<code>node_modules</code>，再执行<code>npm install</code></li>
</ol>
<p>最后使用<code>npx webpack</code>即可执行打包</p>
<p>结果会出现在 <code>./dist/main.js</code> </p>
<p>然后我们就可以删掉 <code>type=&quot;module&quot;</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack - 快速上手<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="配置-Webpack-的打包过程"><a href="#配置-Webpack-的打包过程" class="headerlink" title="配置 Webpack 的打包过程"></a>配置 Webpack 的打包过程</h1><p>Webpack 4 以后的版本支持零配置的方式直接启动打包，整个过程会按照约定将 src&#x2F;index.js 作为打包入口，最终打包的结果会存放到 dist&#x2F;main.js 中。</p>
<p>如果需要自定义打包过程，那就需要在根目录下添加 <code>webpack.config.js</code> ，因为这个是运行在node环境中所以需要按照CommonJS方式编写代码，首先试试修改Webpack 打包的入口文件路径和输出文件的文件名和目录：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;output&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>webpack.config.js 是运行在 Node.js 环境中的代码，所以直接可以使用 path 之类的 Node.js 内置模块。</p>
</blockquote>
<p>全部的配置项可以看<a href="https://webpack.js.org/configuration/#options">Webpack官网</a></p>
<h1 id="让配置文件支持智能提示"><a href="#让配置文件支持智能提示" class="headerlink" title="让配置文件支持智能提示"></a>让配置文件支持智能提示</h1><p>在配置文件中通过import方法导入Webpack中的 <code>Configuration</code> 类型，并通过ts的注解，vs就能提供正确的提示了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Configuration</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;webpack&#x27;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = config</span><br></pre></td></tr></table></figure>
<p>不过由于node不支持import语句，所以打包时要注释掉import语句。不过还有一种更方法的方法，利用vscode对ts的原生支持，在配置文件中使用ts的动态导入方式，实现智能提示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;webpack&#x27;).Configuration</span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = config</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种 @type 类型注释的方式是基于 <a href="https://jsdoc.app/">JSDoc</a> 实现的。JSDoc 中类型注释的用法还有很多，详细可以参考<a href="https://jsdoc.app/tags-type.html">官方文档中对 @type 标签的介绍</a>。</p>
</blockquote>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><p>webpack 4新增了工作模式功能，提供了三种预设</p>
<ul>
<li>production 模式下，启动内置优化插件，自动优化打包结果，打包速度偏慢；</li>
<li>development 模式下，自动优化打包速度，添加一些调试过程中的辅助插件；</li>
<li>none 模式下，运行最原始的打包，不做任何额外处理。</li>
</ul>
<p>默认情况下使用production模式。</p>
<p>修改 Webpack 工作模式的方式有两种：</p>
<ul>
<li>通过 CLI –mode 参数传入；</li>
<li>通过配置文件设置 mode 属性。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>什么是事务处理，如何使用COMMIT和ROLLBACK进行操作？</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>什么是事务呢？事务的英文是 transaction，从英文中你也能看出来它是进行一次处理的基本单元，要么完全执行，要么都不执行。</p>
<span id="more"></span>

<p>不知道你是否遇到过这样的情况，你去家门口的小卖铺买东西，已经交了钱，但是老板比较忙接了个电话，忘记你是否交过钱，然后让你重新付款，这时你还要找之前的付款记录证明你已经完成了付款。</p>
<p>实际上如果我们线下的交易也能支持事务（满足事务的特性），就不会出现交了钱却拿不到商品的烦恼了，同样，对于小卖铺的老板来说，也不存在给出了商品但没有收到款的风险。总之，事务保证了一次处理的完整性，也保证了数据库中的数据一致性。它是一种高级的数据处理方式，如果我们在增加、删除、修改的时候某一个环节出了错，它允许我们回滚还原。正是因为这个特点，事务非常适合应用在安全性高的场景里，比如金融行业等。</p>
<p>下面是事务的内容：</p>
<ol>
<li>事务的特性是什么？如何理解它们？</li>
<li>如何对事务进行控制？控制的命令都有哪些？</li>
<li>为什么我们执行 COMMIT、ROLLBACK 这些命令的时候，有时会成功，有时会失败？</li>
</ol>
<h1 id="事务的特性：ACID"><a href="#事务的特性：ACID" class="headerlink" title="事务的特性：ACID"></a>事务的特性：ACID</h1><p>事务的 4 个特性用英文字母来表达就是 ACID：</p>
<ol>
<li>A，也就是原子性（Atomicity）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。</li>
<li>C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</li>
<li>I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。</li>
<li>最后一个 D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。</li>
</ol>
<p>ACID 可以说是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p>
<p>我之前讲到过数据表的 7 种常见约束（主键、外唯一性、NOT NULL、DEFAULT、CHECK）。这里指的一致性本身是由具体的业务定义的，也就是说，任何写入数据库中的数据都需要满足我们事先定义的约束规则。</p>
<p>比如说，在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名非唯一，就破坏了事务的一致性要求。所以说，事务操作会让数据表的状态变成另一种一致的状态，如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
<p>事务的另一个特点就是持久性，持久性是通过事务日志来保证的。日志包括了回滚日志和重做日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h1 id="事务的控制"><a href="#事务的控制" class="headerlink" title="事务的控制"></a>事务的控制</h1><p>在Oracle中是支持事务的，而MySQL只有InnoDB是支持事务的。</p>
<p>事务的控制语句有：</p>
<ol>
<li><code>START TRANSACTION</code> 或者 <code>BEGIN</code>，作用是显式开启一个事务。</li>
<li><code>COMMIT</code>：提交事务。当提交事务后，对数据库的修改是永久性的。</li>
<li><code>ROLLBACK</code> 或者 <code>ROLLBACK TO [SAVEPOINT]</code>，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。</li>
<li><code>SAVEPOINT</code>：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</li>
<li><code>RELEASE SAVEPOINT</code>：删除某个保存点。</li>
<li><code>SET TRANSACTION</code>，设置事务的隔离级别。</li>
</ol>
<p>需要说明的是，使用事务有两种方式，分别为隐式事务和显式事务。隐式事务实际上就是自动提交，Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交，当然我们可以配置 MySQL 的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set autocommit = 0;  // 关闭自动提交</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set autocommit = 1;  // 开启自动提交</span><br></pre></td></tr></table></figure>
<p>试一下下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;关羽&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>
<p>结果只有一行数据：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>关羽</td>
</tr>
</tbody></table>
<blockquote>
<p>要注意如果是在某些软件（比如我用的navicat和datagrip）中，因为第二次插入‘张飞’时因为报错软件会停止执行，导致后面的ROLLBACK没有执行（datagrip可以点ignore继续执行），所以要记得执行后面的ROLLBACK。</p>
</blockquote>
<p>在这个事务中，整个 SQL 一共执行了 2 个事务，第一个是插入“关羽”，提交后执行成功，第二个是插入两次“张飞”，这里需要注意的是，我们将 name 设置为了主键，也就是说主键的值是唯一的，那么第二次插入“张飞”时就会产生错误，然后执行 ROLLBACK 相当于对事务进行了回滚，所以我们看到最终结果只有一行数据，也就是第一个事务执行之后的结果，即“关羽”。</p>
<p>那么如果我们进行下面的操作又会怎样呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;关羽&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>
<p>运行结果（2 行数据）：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>关羽</td>
</tr>
<tr>
<td>张飞</td>
</tr>
</tbody></table>
<p>你能看到这次数据是 2 行，上一次操作我把两次插入“张飞”放到一个事务里，而这次操作它们不在同一个事务里，那么对于 MySQL 来说，默认情况下这实际上就是两个事务，因为在 autocommit&#x3D;1 的情况下，MySQL 会进行隐式事务，也就是自动提交，因此在进行第一次插入“张飞”后，数据表里就存在了两行数据，而第二次插入“张飞”就会报错：1062 - Duplicate entry ‘张飞’ for key ‘PRIMARY’。</p>
<p>最后我们在执行 ROLLBACK 的时候，实际上事务已经自动提交了，就没法进行回滚了。</p>
<p>同样的我们再来看下这段代码，你又能发现什么不同呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@completion</span>_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;关羽&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>关羽</td>
</tr>
</tbody></table>
<p>你能看到还是相同的 SQL 代码，只是我在事务开始之前设置了SET @@completion_type &#x3D; 1;，结果就和我们第一次处理的一样，只有一个“关羽”。这是为什么呢？</p>
<p>这里讲解下 MySQL 中 completion_type 参数的 3 种可能：</p>
<p>completion&#x3D;0，这是默认情况。也就是说当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要我们使用 START TRANSACTION 或者 BEGIN 来开启。<br>completion&#x3D;1，这种情况下，当我们提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务（隔离级别会在下一节中进行介绍）。<br>completion&#x3D;2，这种情况下 COMMIT&#x3D;COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断开连接。<br>在上面这段代码里，我使用了 completion&#x3D;1，也就是说当我提交之后，相当于在下一行写了一个 START TRANSACTION 或 BEGIN。这时两次插入“张飞”会被认为是在同一个事务之内的操作，那么第二次插入“张飞”就会导致事务失败，而回滚也将这次事务进行了撤销，所以你能看到的结果就只有一个“关羽”。</p>
<p>通过这样简单的练习，你应该能体会到事务提交和回滚的操作。</p>
<p>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p>
<p>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。<br>不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 SQL 中的事务处理，内容相对比较多，因此我会采用两节来进行讲解。今天我们对事务的概念进行了理解，并进行了简单的事务操作。我们在做数据库操作的时候，可能会失败，但正是因为有事务的存在，即使在数据库操作失败的情况下，也能保证数据的一致性。同样，多个应用程序访问数据库的时候，事务可以提供隔离，保证事务之间不被干扰。最后，事务一旦提交，结果就会是永久性的，这就意味着，即使系统崩溃了，数据库也可以对数据进行恢复。</p>
<p>在使用事务的过程中，我们会采用控制流语句对事务进行操作，不过在实际操作中，不一定每次使用 COMMIT 或 ROLLBACK 都会成功，你还需要知道当前系统的事务执行方式，也就是一些常用的参数情况，比如 MySQL 中的 autocommit 和 completion_type 等。</p>
<p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能导论学习笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>老师提到要考的知识点和课后习题</p>
<span id="more"></span>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="第一章-基本概念"><a href="#第一章-基本概念" class="headerlink" title="第一章 基本概念"></a>第一章 基本概念</h2><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。<br>或者<br><strong>一门研究如何构造智能机器（智能计算机）或智能系统，使它能模拟、延伸、扩展人类智能的学科</strong>。</p>
<h3 id="智能的特征"><a href="#智能的特征" class="headerlink" title="智能的特征"></a>智能的特征</h3><ol>
<li>具有感知能力</li>
<li>具有记忆能力与思维能力</li>
<li>具有学习能力</li>
<li>具有行为能力</li>
</ol>
<h3 id="人工智能研究的基本内容"><a href="#人工智能研究的基本内容" class="headerlink" title="人工智能研究的基本内容"></a>人工智能研究的基本内容</h3><ol>
<li>知识表示：将人类知识形式化或者模型化。</li>
<li>机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主。</li>
<li>机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理。</li>
<li>机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识。</li>
<li>机器行为：计算机的表达能力，即“说”、“写”、“画”等能力。</li>
</ol>
<h3 id="人工智能三大学派"><a href="#人工智能三大学派" class="headerlink" title="人工智能三大学派"></a>人工智能三大学派</h3><ol>
<li><strong>符号主义</strong>(symbolicism)，又称为逻辑主义(logicism)、心理学派(psychologism)或计算机学派(computerism)，其原理主要为物理符号系统(即符号操作系统)假设和有限合理性原理。</li>
<li><strong>连接主义</strong>(connectionism)，又称为仿生学派(bionicsism)或生理学派(physiologism)，其主要原理为神经网络及神经网络间的连接机制与学习算法。</li>
<li><strong>行为主义</strong>(actionism)，又称为进化主义(evolutionism)或控制论学派(cyberneticsism)，其原理为控制论及感知-动作型控制系统。</li>
</ol>
<h3 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h3><p>将人类知识形式化或者模型化。表示方法：符号表示法、连接机制表示法。</p>
<h3 id="人工智能目标"><a href="#人工智能目标" class="headerlink" title="人工智能目标"></a>人工智能目标</h3><p>用机器实现人类的部分智能。近期：实现机器智能，远期：制造智能机器。</p>
<h2 id="第二章-知识表示"><a href="#第二章-知识表示" class="headerlink" title="第二章 知识表示"></a>第二章 知识表示</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p><strong>把相关信息关联在一起所形成的信息结构</strong>。<br>在长期的生活及社会实践中、在科学研究及实验中积累起来的对客观世界的认识与经验。</p>
<h3 id="知识的特性"><a href="#知识的特性" class="headerlink" title="知识的特性"></a>知识的特性</h3><ol>
<li><strong>相对正确性</strong></li>
<li><strong>不确定性</strong>，包括：由随机性引起的不确定性、由模糊性引起的不确定性、由经验引起的不确定性、由不完全性引起的不确定性</li>
<li><strong>可表示性与可利用性</strong></li>
</ol>
<h3 id="知识的表示"><a href="#知识的表示" class="headerlink" title="知识的表示"></a>知识的表示</h3><p><strong>知识表示就是将人类知识形式化或者模型化。</strong></p>
<h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h3><p><strong>命题是一个非真即假的陈述句</strong>。一个命题能同时即为真又为假，但可以在一种条件下为真，在另一种条件下为假。</p>
<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p><strong>用来描述或判断客体性质、特征或客体之间关系的词项</strong>。用于刻画个体的性质、状态或个体间的关系的概念。</p>
<h3 id="一阶谓词"><a href="#一阶谓词" class="headerlink" title="一阶谓词"></a>一阶谓词</h3><p>在谓词P (x1, x2,…, xn)中，若xi都是个体常量、变元或函数，称它为一阶谓词，即个体都是常量、变元或函数的谓词是一阶谓词。<br>特点：优点：<strong>自然性、精确性、严密性、容易实现</strong>；局限性：<strong>不能表示不确定的知识、组合爆炸、效率低</strong></p>
<h3 id="产生式"><a href="#产生式" class="headerlink" title="产生式"></a>产生式</h3><p>一个产生式系统由<strong>规则库、控制系统（推理机）、综合数据库</strong>三部分组成。<br>产生式通常用于表示<strong>事实</strong>、<strong>规则以及它们的不确定性度量</strong>，适合于表示<strong>事实性知识和规则性知识</strong>。<br>形式：<strong>确定性规则知识P→Q、不确定性规则知识P→Q(置信度)、确定性事实性知识：（对象，属性，值）、不确定性事实性知识：（对象，属性，值，置信度）</strong></p>
<h3 id="产生式表示法的特点"><a href="#产生式表示法的特点" class="headerlink" title="产生式表示法的特点"></a>产生式表示法的特点</h3><p>优点：<strong>自然性、模块性、有效性、清晰性</strong><br>缺点：<strong>效率不高、不能表达具有结构性的知识</strong></p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><strong>一种描述所论对象（一个事物、事件或概念）属性的数据结构</strong>。<br>特点：<strong>结构性、继承性、自然性</strong></p>
<h2 id="第三章-确定性推理方法"><a href="#第三章-确定性推理方法" class="headerlink" title="第三章 确定性推理方法"></a>第三章 确定性推理方法</h2><h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><p><strong>从已知事实出发，按某种策略不断运用知识库中的已知知识，逐步推出结论的过程</strong>。<br>方式：<strong>演绎推理（一般→个别）、归纳推理（个别→一般）、默认推理（缺省推理）</strong><br>推理方向：<strong>正向推理、逆向推理、混合推理、双向推理</strong></p>
<h3 id="冲突消解"><a href="#冲突消解" class="headerlink" title="冲突消解"></a>冲突消解</h3><p>按一定的策略从匹配成功的多个知识中挑出一个知识用于当前的推理过程。</p>
<h3 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h3><p>从一组已知为真的事实出发，运用经典逻辑的推理规则推出结论的过程。</p>
<h3 id="谓词公式化为子句集步骤"><a href="#谓词公式化为子句集步骤" class="headerlink" title="谓词公式化为子句集步骤"></a>谓词公式化为子句集步骤</h3><ol>
<li>消去谓词公式中的→和←→符号</li>
<li>把否定符号 ¬ 移到紧靠谓词的位置上</li>
<li>变量标准化（每个辖域变量不同）</li>
<li>消去存在量词(常量、函数)</li>
<li>化为前束形（量词提前）</li>
<li>化为Skolem标准形（合取式）</li>
<li>略去全称量词</li>
<li>消去合取词，母式用子句集表示</li>
<li>子句变量标准化，即使每个子句的变量符号不同</li>
</ol>
<h3 id="鲁宾逊归结原理"><a href="#鲁宾逊归结原理" class="headerlink" title="鲁宾逊归结原理"></a>鲁宾逊归结原理</h3><p>消解原理，又称不可满足性原理<br>基本思想：检查子句集S中是否包含空子句，若包含，则S不可满足。若不包含，在S中选择合适的子句进行归结，一旦归结出空子句，就说明S是不可满足的。</p>
<h2 id="第四章-不确定性推理方法"><a href="#第四章-不确定性推理方法" class="headerlink" title="第四章 不确定性推理方法"></a>第四章 不确定性推理方法</h2><h3 id="推理-1"><a href="#推理-1" class="headerlink" title="推理"></a>推理</h3><p>从<strong>已知事实</strong>（证据）出发，通过运用相关知识逐步推出结论或者证明某个假设成立或不成立的思维过程。</p>
<h3 id="不确定性推理"><a href="#不确定性推理" class="headerlink" title="不确定性推理"></a>不确定性推理</h3><p>从<strong>不确定性的初始证据</strong>出发，通过运用不确定性的知识，最终推出具有一定程度的不确定性但却是合理或者近乎合理的结论的思维过程。</p>
<h3 id="知识的不确定性表示"><a href="#知识的不确定性表示" class="headerlink" title="知识的不确定性表示"></a>知识的不确定性表示</h3><p>在专家系统中知识的不确定性一般是由领域专家给出的，通常是一个数值——知识的静态强度</p>
<h3 id="可信度方法"><a href="#可信度方法" class="headerlink" title="可信度方法"></a>可信度方法</h3><p>是在确定性理论的基础上，结合概率论等提出的一种不确定性推理方法。<br>优点：比较直观、简单、效果比较好。<br>可信度：根据经验对一个事物或者想象为真的相信程度。</p>
<h3 id="C－F模型"><a href="#C－F模型" class="headerlink" title="C－F模型"></a>C－F模型</h3><p>基于可信度表示的不确定性推理的基本方法。   </p>
<h3 id="知识不确定性的表示"><a href="#知识不确定性的表示" class="headerlink" title="知识不确定性的表示"></a>知识不确定性的表示</h3><p>C-F模型中，知识是用产生式规则表示，一般形式<br>IF	E	THEN	H	（CF（H，E））<br>CF（H，E）是该条件知识的可信度，称为可信度因子，反映前提条件E与结论H的联系强度。CF &gt; 0 支持H为真，CF &lt; 0 支持H为假，CF &#x3D; 0证据与结论无关。知识的静态强度（当 E 所对应的证据为真时对 H 的影响程度。）</p>
<h3 id="证据的不确定性表示"><a href="#证据的不确定性表示" class="headerlink" title="证据的不确定性表示"></a>证据的不确定性表示</h3><p>在C-F模型中，证据的不确定性也是用可信度因子表示。CF（E），证据的动态强度</p>
<h3 id="组合证据不确定性的算法"><a href="#组合证据不确定性的算法" class="headerlink" title="组合证据不确定性的算法"></a>组合证据不确定性的算法</h3><p>组合证据E是多个单一证据（E1、E2）合取时，CF（E）为多个单一证据中可信度最小值。（CF（E）&#x3D; min{CF（E1），CF（E2）}）<br>组合证据E是多个单一证据（E1、E2）析取时，CF（E）为多个单一证据中可信度最大值。（CF（E）&#x3D; max{CF（E1），CF（E2）}）</p>
<h3 id="不确定性的传递算法"><a href="#不确定性的传递算法" class="headerlink" title="不确定性的传递算法"></a>不确定性的传递算法</h3><p>结论H的可信度计算：CF（H）&#x3D; CF（H，E）× max{0，CF（E）}</p>
<h3 id="结论不确定性的合成算法"><a href="#结论不确定性的合成算法" class="headerlink" title="结论不确定性的合成算法"></a>结论不确定性的合成算法</h3><p>IF	E1	THEN	H	（CF（H，E1））<br>IF	E2	THEN	H	（CF（H，E2））<br>CF1（H）&#x3D; CF（H，E1）× max{0，CF（E1）}<br>CF2（H）&#x3D; CF（H，E2）× max{0，CF（E2）}<br>CF1,2（H）&#x3D;<br>    若CF1（H）≥ 0，CF2（H）≥ 0<br>        CF1（H）+ CF2（H）-  CF1（H）×CF2（H）<br>    若CF1（H）&lt;  0，CF2（H）&lt;  0<br>        CF1（H）+ CF2（H）+  CF1（H）×CF2（H）<br>    若CF1（H）CF2（H）&lt;  0<br>        CF1（H）+ CF2（H）&#x2F;  1 – min{|CF1（H）|，|CF2（H）|}	</p>
<h3 id="模糊集合"><a href="#模糊集合" class="headerlink" title="模糊集合"></a>模糊集合</h3><p>论域：所讨论的全体对象<br>元素：论域中的每个对象<br>集合：论域中具有某种相同属性的确定的、可以彼此区别的元素的全体<br>隶属度：模糊逻辑给集合中每一个元素赋予一个介于0和1之间的实数，描述其属于一个集合的强度，该实数称为元素属于一个集合的隶属度<br>隶属函数：集合中所有元素的隶属度全体构成集合的隶属函数</p>
<h3 id="模糊集合的表示方法"><a href="#模糊集合的表示方法" class="headerlink" title="模糊集合的表示方法"></a>模糊集合的表示方法</h3><ol>
<li><strong>Zadeh表示法</strong></li>
<li><strong>序偶表示法</strong></li>
<li><strong>向量表示法</strong></li>
</ol>
<h3 id="模糊集合运算"><a href="#模糊集合运算" class="headerlink" title="模糊集合运算"></a>模糊集合运算</h3><p>包含、相等、并补交（取大取小运算）、代数运算</p>
<h3 id="模糊关系合成"><a href="#模糊关系合成" class="headerlink" title="模糊关系合成"></a>模糊关系合成</h3><p>模糊关系Q与模糊关系R的合成S是模糊矩阵的叉乘S &#x3D; Q ° R<br>常用计算方法：<strong>最大-最小合成（最大最小运算）</strong>、<strong>最大-代数合成（求和最大运算）</strong></p>
<h3 id="模糊决策"><a href="#模糊决策" class="headerlink" title="模糊决策"></a>模糊决策</h3><p>(“模糊判决”、“解模糊”或“清晰化”）：由模糊推理得到的结论或者操作是一个模糊向量，转化为确定值的过程。<br>模糊决策方法：最大隶属度法（取最大隶属度量作为推理结构）、加权平均判决法、中位数法</p>
<h2 id="第五章-搜索求解策略"><a href="#第五章-搜索求解策略" class="headerlink" title="第五章 搜索求解策略"></a>第五章 搜索求解策略</h2><h3 id="问题求解基本方法"><a href="#问题求解基本方法" class="headerlink" title="问题求解基本方法"></a>问题求解基本方法</h3><p>搜索法、归约法、归结法、推理法及产生式等。</p>
<h3 id="搜索中需要解决的基本问题"><a href="#搜索中需要解决的基本问题" class="headerlink" title="搜索中需要解决的基本问题"></a>搜索中需要解决的基本问题</h3><p>（1）是否一定能找到一个解。<br>（2）找到的解是否是最佳解。<br>（3）时间与空间复杂性如何。<br>（4）是否终止运行或是否会陷入一个死循环。</p>
<h3 id="搜索的主要过程"><a href="#搜索的主要过程" class="headerlink" title="搜索的主要过程"></a>搜索的主要过程</h3><p>(1) 从初始或目的状态出发，并将它作为当前状态。<br>(2)	扫描操作算子集，将适用当前状态的一些操作算子作用于当前状态而得到新的状态，并建立指向其父结点的指针 。<br>(3) 检查所生成的新状态是否满足结束状态，如果满足，则得到问题的一个解，并可沿着有关指针从结束状态反向到达开始状态，给出一解答路径；否则，将新状态作为当前状态，返回第(2)步再进行搜索</p>
<h3 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h3><p>数据驱动：从初始状态出发的正向搜索。正向搜索：从问题给出的条件出发。<br>目的驱动：从目的状态出发的逆向搜索。逆向搜索：从想达到的目的入手，看哪些操作算子能产生该目的以及应用这些操作算子产生目的时需要哪些条件。</p>
<p>双向搜索：从开始状态出发作正向搜索，同时又从目的状态出发作逆向搜索，直到两条路径在中间的某处汇合为止</p>
<h3 id="启发式搜索和盲目搜索"><a href="#启发式搜索和盲目搜索" class="headerlink" title="启发式搜索和盲目搜索"></a>启发式搜索和盲目搜索</h3><p>盲目搜索：在不具有对特定问题的任何有关信息的条件下，按固定的步骤（依次或随机调用操作算子）进行的搜索。<br>启发式搜索：考虑特定问题领域可应用的知识，动态地确定调用操作算子的步骤，优先选择较适合的操作算子，尽量减少不必要的搜索，以求尽快地到达结束状态。</p>
<h3 id="盲目的图搜索策略"><a href="#盲目的图搜索策略" class="headerlink" title="盲目的图搜索策略"></a>盲目的图搜索策略</h3><p>回溯策略、宽度（广度）优先搜索策略、深度优先搜索策略</p>
<h3 id="回溯搜索的算法用三张表来保存状态空间"><a href="#回溯搜索的算法用三张表来保存状态空间" class="headerlink" title="回溯搜索的算法用三张表来保存状态空间"></a>回溯搜索的算法用三张表来保存状态空间</h3><ol>
<li>PS（path states路径状态）表：保存当前搜索路径上的状态。如果找到了目的，PS就是解路径上的状态有序集。 </li>
<li>NPS（new path states新的路径状态）表：它包含了等待搜索的状态，其后裔状态还未被搜索到，即未被生成扩展 。</li>
<li>NSS（no solvable states不可解状态）表：列出了找不到解题路径的状态。如果在搜索中扩展出的状态是它的元素，则可立即将之排除，不必沿该状态继续搜索。</li>
</ol>
<p>CS（当前正在被检测的状态），最近加入PS中的状态<br>回溯思想：</p>
<ol>
<li>用未处理状态表（NPS）使算法能返回（回溯）到其中任一状态。 </li>
<li>用一张“死胡同”状态表（NSS）来避免算法重新搜索无解的路径。 </li>
<li>在PS 表中记录当前搜索路径的状态，当满足目的时可以将它作为结果返回。 </li>
<li>为避免陷入死循环必须对新生成的子状态进行检查，看它是否在该三张表中 。</li>
</ol>
<h3 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h3><p>同一层拓展完再进入下一层</p>
<p>为了保存状态空间搜索的轨迹，用到了两个表：open表和closed表。<br>Open表与回溯算法中NPS表类似，包含了已经生成出来但其子状态未被搜索的状态。	<br>Open表的排序次序就是搜索的次序。（队列，先进先出）<br>Closed表记录了已被生成拓展过的状态，它相当于回溯算法的PS表和NSS表的合并。</p>
<h3 id="深度优先搜索："><a href="#深度优先搜索：" class="headerlink" title="深度优先搜索："></a>深度优先搜索：</h3><p>沿一个方向一直扩展下去，直到达到一定的深度。未找到目的状态或无法再拓展时，回溯另一条路径。<br>Open表是个堆栈，先进后出；open表与closed表用途与广度一致；适用解题路径长、搜索有大量分支；易迷失方向<br>并不能保证第一次找到的路径是最短路径、后裔状态先于兄弟状态</p>
<h3 id="估价函数f（n）"><a href="#估价函数f（n）" class="headerlink" title="估价函数f（n）"></a>估价函数f（n）</h3><p>从初始结点经过n结点到达目的结点的路径的最小代价估计值，其一般形式是：f（n）&#x3D; g（n）+ h（n）<br>其中，g（n）是从初始状态点到n结点的实际代价，h（n）是从n结点到目的结点的最佳路径的估计代价（已经付出代价和即将付出代价）</p>
<h3 id="A搜索算法"><a href="#A搜索算法" class="headerlink" title="A搜索算法"></a>A搜索算法</h3><p>基于估价函数的一种加权启发式图搜索算法（根据启发信息来排序open表，每次选择估计函数最小值进行拓展；每个状态保留父状态信息）</p>
<h3 id="A-搜索算法（最佳图搜索算法）"><a href="#A-搜索算法（最佳图搜索算法）" class="headerlink" title="A*搜索算法（最佳图搜索算法）"></a><code>A*搜索算法</code>（最佳图搜索算法）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义：h*(n)为状态n到目的状态的最优路径的代价，则当A搜索算法的启发函数h(n)小于等于h*(n)，即h(n)≤h*(n)，对于全部结点n时，称为A*搜索算法。（有解时一定能找到最优解）</span><br><span class="line">A*算法特性：可采纳性（有限步找到最优解）、单调性（局部可采纳性，一个状态和任一子状态差由实际代价所限定）、信息性（启发策略h1（n）&lt; h2（n），则h2具有更多的信息）</span><br></pre></td></tr></table></figure>

<h2 id="第六章-智能计算及其应用"><a href="#第六章-智能计算及其应用" class="headerlink" title="第六章 智能计算及其应用"></a>第六章 智能计算及其应用</h2><h3 id="遗传算法（genetic-algorithms，GA）"><a href="#遗传算法（genetic-algorithms，GA）" class="headerlink" title="遗传算法（genetic algorithms，GA）"></a>遗传算法（genetic algorithms，GA）</h3><p><strong>一类借鉴生物界自然选择和自然遗传机制的随机搜索算法，非常适用于处理传统搜索方法难以解决的复杂和非线性优化问题</strong>。<br>三种基本遗传算子：选择算子、交叉算子和变异算子</p>
<ul>
<li>两种数据转换操作：<ul>
<li>编码：表现型到基因型的转换，将搜索空间的参数或解转换成遗传空间中的染色体	或个体</li>
<li>解码：基因型到表现型的转换，个体转换成搜索空间的参数<br>遗传算法可广泛应用于组合优化、机器学习、自适应控制、规划设计和人工生命等领域。</li>
</ul>
</li>
</ul>
<h3 id="遗传算法的基本思想"><a href="#遗传算法的基本思想" class="headerlink" title="遗传算法的基本思想"></a>遗传算法的基本思想</h3><p>在求解问题时从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解。</p>
<h3 id="遗传算法五个基本要素"><a href="#遗传算法五个基本要素" class="headerlink" title="遗传算法五个基本要素"></a>遗传算法五个基本要素</h3><p><strong>参数编码、初始群体的设定、适应度函数设计、遗传操作设计、控制参数设定</strong></p>
<h3 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h3><p>是用来区分群体中的个体好坏的标准，是算法演化过程的驱动力，是进行自然选择的唯一依据。</p>
<h3 id="遗传算法特点"><a href="#遗传算法特点" class="headerlink" title="遗传算法特点"></a>遗传算法特点</h3><ol>
<li>对结构对象直接操作</li>
<li>有方向的随机搜索</li>
<li>采用群体搜索策略</li>
<li>应用适应度函数值来评估个体</li>
</ol>
<p>适应度函数是用来区分群体中的个体好坏的标准，是算法演化过程的驱动力，是进行自然选择的唯一依据</p>
<h2 id="第七章-专家系统与机器学习"><a href="#第七章-专家系统与机器学习" class="headerlink" title="第七章 专家系统与机器学习"></a>第七章 专家系统与机器学习</h2><p>专家系统：一类包含知识和推理的智能计算机程序。专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题。</p>
<p>专家系统知识三个层次：数据级、知识库级、控制级</p>
<p>专家系统的特点：</p>
<ol>
<li>专业性（具有专家水平的专业知识）</li>
<li>推理性（能进行有效推理）</li>
<li>启发性（做出假设，使推理进行）</li>
<li>灵活性（知识库与推理机相互联系又相互独立）</li>
<li>透明性（解释推理过程）</li>
<li>交互性（与专家、工程师进行对话获取知识；从用户获得所需已知事实）</li>
</ol>
<p>专家组成：完整的专家系统一般应包括人机接口、推理机、知识库、数据库、知识获取机构和解释机构</p>
<h2 id="第8章-人工神经网络及其应用"><a href="#第8章-人工神经网络及其应用" class="headerlink" title="第8章 人工神经网络及其应用"></a>第8章 人工神经网络及其应用</h2><ul>
<li>BP算法的基本思想：将输出误差以某种形式通过隐层向输入层逐层反转。</li>
<li>BP 网络结构：输入层、隐层、输出层</li>
<li>输入层：输入与输出线性函数关系</li>
<li>隐层：输入与输出非线性函数关系</li>
<li>工作过程：<br>  第一阶段或网络训练阶段：对网络的连接权进行学习和调整，以使该网络实现给定样本的输入输出映射关系。<br>  第二阶段或称工作阶段：把实验数据或实际数据输入到网络，网络在误差范围内预测计算出结果。</li>
<li>学习算法：<br>  正向传播：输入信息由输入层传至隐层，最终在输出层输出。<br>   反向传播：修改各层神经元的权值，使误差信号最小。</li>
<li>BP网络的主要优缺点<ul>
<li>优点：<ul>
<li>很好的逼近特性。</li>
<li>具有较强的泛化能力。</li>
<li>具有较好的容错性。</li>
</ul>
</li>
<li>缺点：<ul>
<li>收敛速度慢。</li>
<li>局部极值。</li>
<li>难以确定隐层和隐层结点的数目。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的网站推荐（2）</title>
    <url>/%E5%B9%B2%E8%B4%A7/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>距离第一篇网站推荐已经过去挺久的了，但是里面的那篇文章里的大部分内容还是有效的，有兴趣可以去看看：<a href="/%E5%B9%B2%E8%B4%A7/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90%EF%BC%882%EF%BC%89/">大量有用的网站推荐</a> 、<a href="/%E5%B9%B2%E8%B4%A7/search/">大量资源搜索网站</a> 。因为那两篇文章里面的内容也挺多的所以这里新开一篇。</p>
</blockquote>
<span id="more"></span>

<h1 id="免费下载百度文库文档"><a href="#免费下载百度文库文档" class="headerlink" title="免费下载百度文库文档"></a>免费下载百度文库文档</h1><p>现在百度文库改版了，有资料就算有下载券也不给你下载，比用户开vip，可以说十分的恶心（但是百度还是得吃饭的嘛），如果平时不怎么用但是突然想下载但是又不想给钱怎么办，可以试试这个网站，原理估计是用某些算法对文件进行解析生成一个想要的文档，不过我试了一下发现还不是很完美，我试着对一个两百多页的文档导出，word格式只能导出几十页，pdf格式能导出200页，emmmmm，勉强能解决大部分的需求吧</p>


<p>这是网址：<a href="http://www.html22.com/doc/">www.html22.com/doc</a></p>
<h1 id="网课助手"><a href="#网课助手" class="headerlink" title="网课助手"></a>网课助手</h1><p>天下苦网课久矣，在这帮你们解决一下刷网课的难题，原理是利用脚本自动点击播放点击下一节自动答题自动提交，真的是一条龙服务，咳咳，只能说脚本有风险，请自行考虑是否使用。</p>
<p><a href="https://weigirl.gq/">网课助手专用浏览器</a></p>
<h1 id="github-仓库下载代理"><a href="#github-仓库下载代理" class="headerlink" title="github 仓库下载代理"></a>github 仓库下载代理</h1><p>知道GitHub的应该都知道什么情况了，这不多说了。</p>

<p><a href="https://g.widora.cn/">代下载网址</a></p>
<h1 id="github-release-下载代理"><a href="#github-release-下载代理" class="headerlink" title="github release 下载代理"></a>github release 下载代理</h1><p>功能不多说了，仅仅支持release，不支持git clone，用法：<br>将<code>https://github.com/</code> 改为 <code>http://github.strcpy.cn</code></p>
<p>比如：<code>https://github.com/theme-next/hexo-theme-next/archive/v7.8.0.zip</code> 替换为： <code>http://github.strcpy.cn/theme-next/hexo-theme-next/archive/v7.8.0.zip</code></p>
<p>注意不要平凡使用或者恶意使用，否则会对url进行封禁。<br><a href="https://jinfeijie.cn/post-805.html?replytocom=20">这是作者的官网</a></p>
<h1 id="配色类网址"><a href="#配色类网址" class="headerlink" title="配色类网址"></a>配色类网址</h1><p>这些应该是UI和前端最喜欢的网址了吧，不多说自行体验</p>
<ul>
<li><a href="http://colorhunt.co/">Color Hunt</a></li>
<li><a href="https://color.adobe.com/zh/create/color-wheel">Adobe Color CC</a></li>
<li><a href="https://www.webdesignrankings.com/resources/lolcolors">LOLCOLORS</a></li>
<li><a href="http://www.bootcss.com/p/websafecolors">Web安全色</a></li>
<li><a href="https://uigradients.com/">渐变配色1</a></li>
<li><a href="https://www.bestvist.com/css-gradient">渐变配色2</a></li>
<li><a href="http://zhongguose.com/">中国色</a></li>
<li><a href="http://nipponcolors.com/">日本色</a></li>
</ul>
<h1 id="在线PS网址"><a href="#在线PS网址" class="headerlink" title="在线PS网址"></a>在线PS网址</h1><p>一个基本功能还算齐全的工具，需要高级功能还是装一个吧。<br><a href="https://www.uupoop.com/">在线ps</a></p>
]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>前端大仓实践（1）：monorepo介绍</title>
    <url>/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BB%93%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89%EF%BC%9Amonorepo%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="什么是-MONOREPO"><a href="#什么是-MONOREPO" class="headerlink" title="什么是 MONOREPO"></a>什么是 MONOREPO</h1><p>monorepo 是一个包含较小项目的项目 - 而每个项目可以是从单个应用程序到可重用包（例如函数，组件）的任何内容。合并项目的做法可以追溯到 2000 年初，当时它被称为共享代码库。</p>
<p>monorepo 的名字源于 mono（单个）和 repo（存储库）这两个词。虽然前者是不言自明的，但后者来自版本控制系统（例如 git），其中 project：存储库以 n：n 关系（polyrepo）或 n：1 关系（monorepo）托管。</p>
<p>通常，monorepo 被误认为是 monolith。但是，在整体式应用程序中，所有较小的项目都合并到一个大项目中。相比之下，monorepo 可以将其较小的项目合并到多个项目中。</p>
<span id="more"></span>

<img src="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BB%93%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89%EF%BC%9Amonorepo%E4%BB%8B%E7%BB%8D/1.webp" class="">

<h1 id="为什么使用-MONOREPO"><a href="#为什么使用-MONOREPO" class="headerlink" title="为什么使用 MONOREPO"></a>为什么使用 MONOREPO</h1><p>对于大规模代码库，使用 monorepo 有两个主要优点。首先，共享包可以在没有联机注册表的本地计算机上的多个应用程序中使用（例如 npm）。开发人员体验在这里得到了极大的改善，因为所有内容都位于同一代码库中，而无需通过第三方更新依赖项。当共享包更新时，它会立即反映在依赖于它的所有应用程序中。</p>
<p>其次，它改善了代码库之间的协作。处理不同项目的团队可以改进其他团队的代码库，而无需处理多个存储库。它还提高了可访问性而不必担心不同的设置，并且为跨团队引入了更灵活的源代码所有权。另一个好处是能跨许多项目进行代码重构。</p>
<h1 id="MONOREPO-的结构"><a href="#MONOREPO-的结构" class="headerlink" title="MONOREPO 的结构"></a>MONOREPO 的结构</h1><p>monorepo 可以包含多个应用（apps），而每个应用都可以访问共享的包。这是一个非常常见的单存储库结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- apps/</span><br><span class="line">--- app-one</span><br><span class="line">--- app-two</span><br><span class="line">- packages/</span><br><span class="line">--- package-one</span><br><span class="line">--- package-two</span><br><span class="line">--- package-three</span><br></pre></td></tr></table></figure>

<p>一个包，它只是一个文件夹，可以是任何东西，从 UI 组件（例如框架特定的组件）到函数（例如实用程序）到配置（例如 ESLint，TypeScript）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- apps/</span><br><span class="line">--- app-one</span><br><span class="line">--- app-two</span><br><span class="line">- packages/</span><br><span class="line">--- ui</span><br><span class="line">--- utilities</span><br><span class="line">--- eslint-config</span><br><span class="line">--- ts-config</span><br></pre></td></tr></table></figure>

<p>一个包可以是另一个包的依赖项。例如，ui  包可能使用 utilities 包中的函数，因此  ui  包依赖于 utilities 包。ui  和 utilities 包都可以使用其他  *-config  包中的配置。</p>
<p>这些 apps 通常不相互依赖，而是仅选择加入 packages。如果包相互依赖，monorepo 管道（请参阅  Monorepo 工具）可以强制实施“仅当 utilities 生成成功完成时才开始  ui  生成”等方案。</p>
<img src="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BB%93%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89%EF%BC%9Amonorepo%E4%BB%8B%E7%BB%8D/2.webp" class="">
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>monorepo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署mysql</title>
    <url>/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2mysql/</url>
    <content><![CDATA[<p>总是会忘docker部署mysql的方法，所以拿小本本记下来。</p>
<span id="more"></span>

<h1 id="拉镜像"><a href="#拉镜像" class="headerlink" title="拉镜像"></a>拉镜像</h1><p><code>docker pull mysql:8.0.20</code></p>
<p>Other tags: <code>latest</code>,<code>5.7.30</code>,<code>5.6.48</code></p>
<p>查看镜像：<code>docker images | grep mysql</code></p>
<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql8 -e MYSQL_ROOT_PASSWORD=123456 -v /root/mysql/data:/var/lib/mysql -d mysql:8.0.20</span><br></pre></td></tr></table></figure>

<p>查看容器：<code>docker ps</code></p>
<h1 id="设置可以远程登录"><a href="#设置可以远程登录" class="headerlink" title="设置可以远程登录"></a>设置可以远程登录</h1><p>从上面得到容器id，然后进入容器：<code>docker exec -it 容器id bash</code></p>
<p>登录mysql：<code>mysql -u root -p</code>，然后输入密码</p>
<p>进入MySQL表：<code>use mysql;</code></p>
<p>授权root用户：<code>GRANT ALL ON *.* TO &#39;root&#39;@&#39;%;&#39;</code></p>
<p>可以修改密码：<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;新的密码&#39;;</code></p>
<p>刷新权限：<code>flush privileges;</code></p>
<blockquote>
<p>经过测试，MySQL5.7.30并不需要设置远程登录权限，可以直接使用。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>前端动画实现-1</title>
    <url>/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0-1/</url>
    <content><![CDATA[<h1 id="动画的基本原理"><a href="#动画的基本原理" class="headerlink" title="动画的基本原理"></a>动画的基本原理</h1><h2 id="什么是动画"><a href="#什么是动画" class="headerlink" title="什么是动画?"></a>什么是动画?</h2><p>动画是通过快速连续排列批次差异极小的连续图像来制造运动错觉和变化错觉的过程 ——维基百科</p>
<p>满足四个条件：</p>
<ul>
<li>快速</li>
<li>连续排列</li>
<li>彼此差异极小</li>
<li>制造错觉</li>
</ul>
<h2 id="动画的发展"><a href="#动画的发展" class="headerlink" title="动画的发展"></a>动画的发展</h2><p>常见的前端动画技术：Sprite 动画、CSS 动画、JS 动画、SVG 动画、WebGL 动画</p>
<p>按应用分类：UI 动画、基于 Web 的游戏动画和动画数据可视化</p>
<span id="more"></span>

<h2 id="计算机动画原理"><a href="#计算机动画原理" class="headerlink" title="计算机动画原理"></a>计算机动画原理</h2><h3 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学:"></a>计算机图形学:</h3><p>计算机视觉的基础，涵盖点、线、面、体、场的数学构造方法。</p>
<ul>
<li>几何和图形数据的输入、存储和压缩。</li>
<li>描述纹理、曲线、光影等算法。</li>
<li>物体图形的数据输出(图形接口、动画技术)，硬件和图形的交互技术。</li>
<li>图形开发软件的相关技术标准。</li>
</ul>
<h3 id="计算机动画"><a href="#计算机动画" class="headerlink" title="计算机动画:"></a>计算机动画:</h3><p>计算机图形学的分支，主要包含 2D、3D 动画。</p>
<p>无论动画多么简单，始终需要定义两个基本状态，即<strong>开始状态和结束状态</strong>。没有它们，我们将无法定义插值状态，从而填补了两者之间的空白。</p>
<p>帧：连续变换的多张画面,其中的每一幅画面都是一帧。</p>
<p>帧率：用于度量一定时间段内的帧数，通常的测量单位是 FPS (frame per second) 。</p>
<p>帧率与人眼：一般每秒 10-12 帧人会认为画面是连贯的，这个现象称为视觉暂留。对于一些电脑动画和游戏来说低于 30FPS 会感受到明显卡顿，目前主流的屏幕、显卡输出为 60FPS，效果会明显更流畅。</p>
<p>空白的补全方式有以下两种</p>
<ul>
<li>补间动画: 传统动画，主画师绘制关键帧，交给清稿部门，清稿部门的补间动画师补充关键帧进行交付。(类比到这里，补间动画师由浏览器来担任，如 keyframe，transition)</li>
<li>逐帧动画(Frame By Frame) : 从词语来说意味着全片每一帧逐帧都是纯手绘。(如 CSS 的 steps 实现精灵动画)</li>
</ul>
<h1 id="前端动画分类"><a href="#前端动画分类" class="headerlink" title="前端动画分类"></a>前端动画分类</h1><h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><h3 id="CSS-animation"><a href="#CSS-animation" class="headerlink" title="CSS animation"></a>CSS animation</h3><ul>
<li>animation-name : 指定应用的一系列动画</li>
<li>animation-duration : 制定一个动画周期的时长</li>
<li>animation-timing-function : 定义 CSS 动画在每一动画周期中执行的节奏</li>
<li>animation-delay : 定义动画于何时开始</li>
<li>animation-iteration-count : 定义动画在结束前运行的次数</li>
<li>animation-direction : 定义动画是否反向播放</li>
<li>animation-fill-mode : 设置 CSS 动画在执行之前和之后如何将样式应用于目标</li>
<li>animation-play-state : 定义一个动画是否运行或暂停</li>
</ul>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>translate : 平移<br>scale : 缩放<br>rotate : 旋转<br>skew : 倾斜</p>
<h3 id="transition-API"><a href="#transition-API" class="headerlink" title="transition API"></a>transition API</h3><p>transition-property : 指定哪个或者哪些 CSS 属性用于过渡<br>transition-duration : 指定过度的时长<br>transition-timing-function : 指定一个函数,定义属性值怎么变化<br>transition-delay : 指定延迟</p>
<h3 id="关键帧-Keyframe"><a href="#关键帧-Keyframe" class="headerlink" title="关键帧 @Keyframe"></a>关键帧 @Keyframe</h3><p>可以使用：from to、百分比</p>
<p>优点 : 简单、高效 声明式的 不依赖于主线程，采用硬件加速(GPU) 简单的控制 keyframe animation 的播放盒暂停</p>
<p>缺点 : 不能动态修改或定义动画内容、不同的动画无法实现同步、多个动画无法堆叠</p>
<p>适用场景 : 简单的 h5 活动&#x2F;宣传页</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>推荐库 : animation.css、shake.css</p>
<p>CSS 补间动画使用 Transition API 和 Keyframe 实现</p>
<p>CSS 逐帧动画使用 Animation API 中的 steps 实现</p>
<h2 id="SVG-动画"><a href="#SVG-动画" class="headerlink" title="SVG 动画"></a>SVG 动画</h2><p>svg 是基于 XML 的矢量图形描述语言，它可以与 CSS 和 S 较好的配合，实现 svg 动画通常有三种方式：SMIL、JS、CSS</p>
<p>我们经常使用 animation, transform, transition 来实现 svg 动画，它比 JS 更加简单方便。</p>
<p>优点：通过矢量元素实现动画，不同的屏幕下均可获得较好的清晰度。可以实现一些特殊的效果，如：描字，形变，墨水扩散等。</p>
<p>缺点：使用方式较为复杂，过多使用可能会带来性能问题。</p>
<h3 id="简单的例子："><a href="#简单的例子：" class="headerlink" title="简单的例子："></a>简单的例子：</h3><ul>
<li>通过 js 修改 filter&#x2F;optaicy 等属性实现“溶解”效果</li>
<li>通过 svg 的 stroke-dashoffset 和 stroke-dasharray 实现画笔效果。<ul>
<li>stroke-dasharray 可控制用来描边的点划线的图案范式。它是一个数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2 等同于 5,3,2,5,3,2。</li>
<li>stroke-dashoffset 属性指定了 dash 模式到路径开始的距离。</li>
</ul>
</li>
</ul>
<h3 id="画笔效果"><a href="#画笔效果" class="headerlink" title="画笔效果"></a>画笔效果</h3><p>stroke-dasharray：可以理解为虚线的产生，比如下面的效果就是 5px 的实线、5px 的空白交替虚线 如果是奇数元素就会自动重复一遍，会变成长度不一的虚线段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span> <span class="attr">stroke-dasharray</span>=<span class="string">&quot;5, 5&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>stroke-dashoffset：偏移量，就是相对于绘制起点的偏移量，偏移量不会大于线段总长度 比如设置为-20，就相当于向右移动了 20px。这个也是画线的核心实现属性。 画线效果就是让偏移量从 0 到线段的长度，长度可以用 path 属性的 getTotalLength()函数获取 比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#path</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: move <span class="number">3s</span> linear forwards;</span><br><span class="line">  stroke-dasharray: <span class="number">511px</span>, <span class="number">511px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">511px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    stroke-dashoffset: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个效果原理：最初线条分为 511px 实线，和 511px 空隙，但是由于设置了 offset 使线条偏移不可见了，当不断修改 offset 后，线条慢慢出现。</p>
<h2 id="JS-动画"><a href="#JS-动画" class="headerlink" title="JS 动画"></a>JS 动画</h2><p>自己封装一个动画函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">&#123; easing, draw, duration &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = performance.<span class="title function_">now</span>() <span class="comment">//开始时间，使用perfromance更精确</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//便于拿到动画的终态(resolve)</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">time</span>) &#123;</span><br><span class="line">      <span class="comment">//time表示当前执行时间</span></span><br><span class="line">      <span class="keyword">let</span> timeFraction = (time - start) / duration <span class="comment">//timeFraction是一个0-1的进度</span></span><br><span class="line">      <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) timeFraction = <span class="number">1</span> <span class="comment">//表示结束，则令为1并结束</span></span><br><span class="line">      <span class="keyword">let</span> progress = <span class="title function_">easing</span>(timeFraction) <span class="comment">//通过缓动函数改变到真实进度</span></span><br><span class="line">      <span class="title function_">draw</span>(progress) <span class="comment">//根据进度绘制</span></span><br><span class="line">      <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心参数：</p>
<ul>
<li>easing：缓动函数，是物理运动的核心参数，</li>
<li>draw：绘制函数，绘制具体的图形，利用 dom.style.transfrom 做主要变化</li>
<li>duration：持续时间</li>
</ul>
<p>调用的时候分别传入三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animate(&#123;</span><br><span class="line">  easing(timeFraction) &#123;</span><br><span class="line">    return timeFraction;</span><br><span class="line">  &#125;,</span><br><span class="line">  draw(progress) &#123;</span><br><span class="line">    elem.style.transform = `translate($&#123;progress&#125;px,0)`;</span><br><span class="line">  &#125;</span><br><span class="line">  duration: 1000,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="easing"><a href="#easing" class="headerlink" title="easing"></a>easing</h3><p>可以模拟一些物理过程，比如匀速、匀加速、平抛等等 比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">easing</span>(<span class="params">timeFraction</span>) &#123;</span><br><span class="line">  <span class="comment">// 重力加速</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.5</span> * <span class="number">9.8</span> * timeFraction ** <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">easing</span>(<span class="params">timeFractionX, timeFractionY</span>) &#123;</span><br><span class="line">  <span class="comment">// 平抛</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: timeFractionX,</span><br><span class="line">    <span class="attr">y</span>: timeFractionY ** <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">easing</span>(<span class="params">timeFraction</span>) &#123;</span><br><span class="line">  <span class="comment">// 拉弓 x=∫v⋅dt=−v0t+1/2at^2</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: timeFraction,</span><br><span class="line">    <span class="attr">y</span>: -<span class="number">2</span> * timeFraction - timeFraction ** <span class="number">2</span>, <span class="comment">// v0 = 2，a = 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三次贝塞尔曲线B(t)=(1−t)^3 * P0 + 3t * (1−t)^2 * P1 + 3t^2 * (1−t) P2+ t^3 * P3,t∈[0,1]</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bezierPath</span> = (<span class="params">x1, y1, x2, y2, t</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">3</span> * t * (<span class="number">1</span> - t) ** <span class="number">2</span> * x1 + <span class="number">3</span> * t ** <span class="number">2</span> * (<span class="number">1</span> - t) * x2 + t ** <span class="number">3</span> * <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">3</span> * t * (<span class="number">1</span> - t) ** <span class="number">2</span> * y1 + <span class="number">3</span> * t ** <span class="number">2</span> * (<span class="number">1</span> - t) * y2 + t ** <span class="number">3</span> * <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂动画"><a href="#复杂动画" class="headerlink" title="复杂动画"></a>复杂动画</h3><p>弹跳小球</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">autoDamping</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> damping = <span class="number">0.7</span>, <span class="comment">// 衰减系数</span></span><br><span class="line">    duration = <span class="number">1000</span>,</span><br><span class="line">    height = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当衰减到一定边界值时停止动画</span></span><br><span class="line">  <span class="keyword">while</span> (height &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">down</span> = (<span class="params">progress</span>) =&gt; &#123;</span><br><span class="line">      ball.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(0, <span class="subst">$&#123;height * (progress - <span class="number">1</span>)&#125;</span>px)`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">animate</span>(&#123;</span><br><span class="line">      <span class="attr">duration</span>: duration,</span><br><span class="line">      <span class="title function_">easing</span>(<span class="params">t</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t ** <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">draw</span>: down,</span><br><span class="line">    &#125;)</span><br><span class="line">    height *= damping ** <span class="number">2</span> <span class="comment">// ** 2 可以使动画效果更加柔和</span></span><br><span class="line">    duration *= damping</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">up</span> = (<span class="params">progress</span>) =&gt; &#123;</span><br><span class="line">      ball.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(0, <span class="subst">$&#123;-height * progress&#125;</span>px)`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">animate</span>(&#123;</span><br><span class="line">      <span class="attr">duration</span>: duration,</span><br><span class="line">      <span class="title function_">easing</span>(<span class="params">t</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * t - t ** <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">draw</span>: down,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>椭圆运动，公式：x^2 &#x2F; a^2 + y^2 &#x2F; b^2 &#x3D; 1, x &#x3D; a * cos(a), y &#x3D; b *sin(a)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">draw</span> = (<span class="params">progress</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">150</span> * <span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span> * progress)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">100</span> * <span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span> * progress)</span><br><span class="line">  ball.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(<span class="subst">$&#123;x&#125;</span>px, <span class="subst">$&#123;y&#125;</span>px)`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">animate</span>(&#123;</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">  <span class="title function_">easing</span>(<span class="params">t</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * t - t ** <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  draw,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为什么使用<code>performance.now()</code>而非<code>Date.now()</code>？为什么使用<code>requestAnimationFrame</code>而非<code>setTimeout</code>或者<code>setInterval</code>:</p>
<ul>
<li>performance.now()会以恒定速度自增,精确到微妙级别,不易被篡改.</li>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。</li>
</ul>
<h2 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h2><h3 id="动画资源"><a href="#动画资源" class="headerlink" title="动画资源"></a>动画资源</h3><p>动画代码示例：</p>
<ul>
<li>codepen.com</li>
<li>codesandbox.com</li>
</ul>
<p>设计网站：</p>
<ul>
<li>dribbble.com</li>
</ul>
<p>动画制作工具（一般都是 UE、UI 同学使用)：</p>
<ul>
<li>2D：Animate CC、After Effects</li>
<li>3D：Cinema 4D、Blender、Autodesk Maya</li>
</ul>
<p>svg :</p>
<ul>
<li>Snap.svg - 现代 SVG 图形的 JavaScript 库。</li>
<li>Svg.js - 用于操作和动画 SVG 的轻量级库。</li>
</ul>
<p>js :</p>
<ul>
<li></li>
<li>GSAP - JavaScript 动画库。</li>
<li>TweenJs - 一个简单但功能强大的 JavaScript 补间&#x2F;动画库。CreateJS 库套件的一部分。</li>
<li>Velocity - 加速的 JavaScript 动画。</li>
</ul>
<p>css :</p>
<ul>
<li><p>Animate.css - CSS 动画的跨浏览器库。像一件简单的事情一样容易使用。</p>
</li>
<li><p>canvas :</p>
</li>
<li><p>EaselJs - EaselJS 是一个用于在 HTML5 中构建高性能交互式 2D 内容的库</p>
</li>
<li><p>Fabric.js - 支持动画的 JavaScript 画布库。</p>
</li>
<li><p>Paper.js - 矢量图形脚本的瑞士军刀 - Scriptographer 使用 HTML5Canvas 移植到 JavaScript 和浏览器。</p>
</li>
<li><p>Pixijs - 使用最快、最灵活的 2D WebGL 渲染器创建精美的数字内容。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>JS常用60余种工具方法</title>
    <url>/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A860%E4%BD%99%E7%A7%8D%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一些JavaScript的代码</p>
<span id="more"></span>

<p>1.邮箱</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isEmail</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/</span>.<span class="title function_">test</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.手机号码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isMobile</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[0-9]&#123;10&#125;$/</span>.<span class="title function_">test</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.电话号码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isPhone</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/</span>.<span class="title function_">test</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.是否url地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isURL</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^http[s]?:\/\/.*/</span>.<span class="title function_">test</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.是否字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isString</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;String&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.是否数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isNumber</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Number&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.是否boolean</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isBoolean</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Boolean&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.是否函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isFunction</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Function&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.是否为null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isNull</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Null&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.是否undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isUndefined</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Undefined&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.是否对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isObj</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Object&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.是否数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isArray</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13.是否时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isDate</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Date&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.是否正则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isRegExp</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;RegExp&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.是否错误对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isError</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Error&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16.是否Symbol函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isSymbol</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Symbol&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17.是否Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isPromise</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Promise&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18.是否Set对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isSet</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Set&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ua = navigator.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>();</span><br></pre></td></tr></table></figure>
<p>19.是否是微信浏览器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isWeiXin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ua.<span class="title function_">match</span>(<span class="regexp">/microMessenger/i</span>) == <span class="string">&#x27;micromessenger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20.是否是移动端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isDeviceMobile</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/android|webos|iphone|ipod|balckberry/i</span>.<span class="title function_">test</span>(ua)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>21.是否是QQ浏览器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isQQBrowser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !!ua.<span class="title function_">match</span>(<span class="regexp">/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22.是否是爬虫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isSpider</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider/</span>.<span class="title function_">test</span>(ua)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23.是否ios</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isIos</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> u = navigator.<span class="property">userAgent</span>;</span><br><span class="line">    <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.<span class="title function_">indexOf</span>(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>) &#123;  <span class="comment">//安卓手机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span>) &#123;<span class="comment">//苹果手机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&#x27;iPad&#x27;</span>) &gt; -<span class="number">1</span>) &#123;<span class="comment">//iPad</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows Phone&#x27;</span>) &gt; -<span class="number">1</span>) &#123;<span class="comment">//winphone手机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24.是否为PC端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isPC</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> userAgentInfo = navigator.<span class="property">userAgent</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Agents</span> = [<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>,</span><br><span class="line">        <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; <span class="title class_">Agents</span>.<span class="property">length</span>; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userAgentInfo.<span class="title function_">indexOf</span>(<span class="title class_">Agents</span>[v]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25.去除html标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">removeHtmltag</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26.获取url参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getQueryString</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;(^|&amp;)&#x27;</span> + name + <span class="string">&#x27;=([^&amp;]*)(&amp;|$)&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> search = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> r = search.<span class="title function_">match</span>(reg) || [];</span><br><span class="line">    <span class="keyword">return</span> r[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>27.动态引入js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">injectScript</span> = (<span class="params">src</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    s.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">    s.<span class="property">async</span> = <span class="literal">true</span>;</span><br><span class="line">    s.<span class="property">src</span> = src;</span><br><span class="line">    <span class="keyword">const</span> t = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    t.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>28.根据url地址下载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">download</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> isChrome = navigator.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(<span class="string">&#x27;chrome&#x27;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> isSafari = navigator.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(<span class="string">&#x27;safari&#x27;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (isChrome || isSafari) &#123;</span><br><span class="line">        <span class="keyword">var</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        link.<span class="property">href</span> = url;</span><br><span class="line">        <span class="keyword">if</span> (link.<span class="property">download</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> fileName = url.<span class="title function_">substring</span>(url.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>, url.<span class="property">length</span>);</span><br><span class="line">            link.<span class="property">download</span> = fileName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">createEvent</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> e = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&#x27;MouseEvents&#x27;</span>);</span><br><span class="line">            e.<span class="title function_">initEvent</span>(<span class="string">&#x27;click&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            link.<span class="title function_">dispatchEvent</span>(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span><br><span class="line">        url += <span class="string">&#x27;?download&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_self&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>29.el是否包含某个class</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">hasClass</span> = (<span class="params">el, className</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;(^|\\s)&#x27;</span> + className + <span class="string">&#x27;(\\s|$)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(el.<span class="property">className</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30.el添加某个class</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addClass</span> = (<span class="params">el, className</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasClass</span>(el, className)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newClass = el.<span class="property">className</span>.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    newClass.<span class="title function_">push</span>(className)</span><br><span class="line">    el.<span class="property">className</span> = newClass.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31.el去除某个class</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">removeClass</span> = (<span class="params">el, className</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">hasClass</span>(el, className)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;(^|\\s)&#x27;</span> + className + <span class="string">&#x27;(\\s|$)&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    el.<span class="property">className</span> = el.<span class="property">className</span>.<span class="title function_">replace</span>(reg, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32.获取滚动的坐标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getScrollPosition</span> = (<span class="params">el = <span class="variable language_">window</span></span>) =&gt; (&#123;</span><br><span class="line">    <span class="attr">x</span>: el.<span class="property">pageXOffset</span> !== <span class="literal">undefined</span> ? el.<span class="property">pageXOffset</span> : el.<span class="property">scrollLeft</span>,</span><br><span class="line">    <span class="attr">y</span>: el.<span class="property">pageYOffset</span> !== <span class="literal">undefined</span> ? el.<span class="property">pageYOffset</span> : el.<span class="property">scrollTop</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>33.滚动到顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">scrollToTop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(scrollToTop);</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, c - c / <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>34.el是否在视口范围内</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">elementIsVisibleInViewport</span> = (<span class="params">el, partiallyVisible = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; top, left, bottom, right &#125; = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; innerHeight, innerWidth &#125; = <span class="variable language_">window</span>;</span><br><span class="line">    <span class="keyword">return</span> partiallyVisible</span><br><span class="line">        ? ((top &gt; <span class="number">0</span> &amp;&amp; top &lt; innerHeight) || (bottom &gt; <span class="number">0</span> &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;</span><br><span class="line">        ((left &gt; <span class="number">0</span> &amp;&amp; left &lt; innerWidth) || (right &gt; <span class="number">0</span> &amp;&amp; right &lt; innerWidth))</span><br><span class="line">        : top &gt;= <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>35.洗牌算法随机</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">shuffle</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [],</span><br><span class="line">        random;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        random = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);</span><br><span class="line">        result.<span class="title function_">push</span>(arr[random])</span><br><span class="line">        arr.<span class="title function_">splice</span>(random, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>36.劫持粘贴板</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">copyTextToClipboard</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> textArea = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;textarea&quot;</span>);</span><br><span class="line">    textArea.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;transparent&#x27;</span>;</span><br><span class="line">    textArea.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(textArea);</span><br><span class="line">    textArea.<span class="title function_">select</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> successful = <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Oops, unable to copy&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(textArea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>37.判断类型集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkStr</span> = (<span class="params">str, type</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;phone&#x27;</span>:   <span class="comment">//手机号码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;tel&#x27;</span>:     <span class="comment">//座机</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;card&#x27;</span>:    <span class="comment">//身份证</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;pwd&#x27;</span>:     <span class="comment">//密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]\w&#123;5,17&#125;$/</span>.<span class="title function_">test</span>(str)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;postal&#x27;</span>:  <span class="comment">//邮政编码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/[1-9]\d&#123;5&#125;(?!\d)/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;QQ&#x27;</span>:      <span class="comment">//QQ号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[1-9][0-9]&#123;4,9&#125;$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;email&#x27;</span>:   <span class="comment">//邮箱</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;money&#x27;</span>:   <span class="comment">//金额(小数点2位)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^\d*(?:\.\d&#123;0,2&#125;)?$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;URL&#x27;</span>:     <span class="comment">//网址</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/</span>.<span class="title function_">test</span>(str)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;IP&#x27;</span>:      <span class="comment">//IP</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;date&#x27;</span>:    <span class="comment">//日期时间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/</span>.<span class="title function_">test</span>(str) || <span class="regexp">/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/</span>.<span class="title function_">test</span>(str)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:  <span class="comment">//数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[0-9]$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;english&#x27;</span>: <span class="comment">//英文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;chinese&#x27;</span>: <span class="comment">//中文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[\\u4E00-\\u9FA5]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;lower&#x27;</span>:   <span class="comment">//小写</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[a-z]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;upper&#x27;</span>:   <span class="comment">//大写</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[A-Z]+$/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;HTML&#x27;</span>:    <span class="comment">//HTML标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/&lt;(&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*&gt;/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>38.严格的身份证校验</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isCardID</span> = (<span class="params">sId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>.<span class="title function_">test</span>(sId)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你输入的身份证长度或格式错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//身份证城市</span></span><br><span class="line">    <span class="keyword">var</span> aCity = &#123; <span class="number">11</span>: <span class="string">&quot;北京&quot;</span>, <span class="number">12</span>: <span class="string">&quot;天津&quot;</span>, <span class="number">13</span>: <span class="string">&quot;河北&quot;</span>, <span class="number">14</span>: <span class="string">&quot;山西&quot;</span>, <span class="number">15</span>: <span class="string">&quot;内蒙古&quot;</span>, <span class="number">21</span>: <span class="string">&quot;辽宁&quot;</span>, <span class="number">22</span>: <span class="string">&quot;吉林&quot;</span>, <span class="number">23</span>: <span class="string">&quot;黑龙江&quot;</span>, <span class="number">31</span>: <span class="string">&quot;上海&quot;</span>, <span class="number">32</span>: <span class="string">&quot;江苏&quot;</span>, <span class="number">33</span>: <span class="string">&quot;浙江&quot;</span>, <span class="number">34</span>: <span class="string">&quot;安徽&quot;</span>, <span class="number">35</span>: <span class="string">&quot;福建&quot;</span>, <span class="number">36</span>: <span class="string">&quot;江西&quot;</span>, <span class="number">37</span>: <span class="string">&quot;山东&quot;</span>, <span class="number">41</span>: <span class="string">&quot;河南&quot;</span>, <span class="number">42</span>: <span class="string">&quot;湖北&quot;</span>, <span class="number">43</span>: <span class="string">&quot;湖南&quot;</span>, <span class="number">44</span>: <span class="string">&quot;广东&quot;</span>, <span class="number">45</span>: <span class="string">&quot;广西&quot;</span>, <span class="number">46</span>: <span class="string">&quot;海南&quot;</span>, <span class="number">50</span>: <span class="string">&quot;重庆&quot;</span>, <span class="number">51</span>: <span class="string">&quot;四川&quot;</span>, <span class="number">52</span>: <span class="string">&quot;贵州&quot;</span>, <span class="number">53</span>: <span class="string">&quot;云南&quot;</span>, <span class="number">54</span>: <span class="string">&quot;西藏&quot;</span>, <span class="number">61</span>: <span class="string">&quot;陕西&quot;</span>, <span class="number">62</span>: <span class="string">&quot;甘肃&quot;</span>, <span class="number">63</span>: <span class="string">&quot;青海&quot;</span>, <span class="number">64</span>: <span class="string">&quot;宁夏&quot;</span>, <span class="number">65</span>: <span class="string">&quot;新疆&quot;</span>, <span class="number">71</span>: <span class="string">&quot;台湾&quot;</span>, <span class="number">81</span>: <span class="string">&quot;香港&quot;</span>, <span class="number">82</span>: <span class="string">&quot;澳门&quot;</span>, <span class="number">91</span>: <span class="string">&quot;国外&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!aCity[<span class="built_in">parseInt</span>(sId.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">2</span>))]) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你的身份证地区非法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出生日期验证</span></span><br><span class="line">    <span class="keyword">var</span> sBirthday = (sId.<span class="title function_">substr</span>(<span class="number">6</span>, <span class="number">4</span>) + <span class="string">&quot;-&quot;</span> + <span class="title class_">Number</span>(sId.<span class="title function_">substr</span>(<span class="number">10</span>, <span class="number">2</span>)) + <span class="string">&quot;-&quot;</span> + <span class="title class_">Number</span>(sId.<span class="title function_">substr</span>(<span class="number">12</span>, <span class="number">2</span>))).<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&quot;/&quot;</span>),</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Date</span>(sBirthday)</span><br><span class="line">    <span class="keyword">if</span> (sBirthday != (d.<span class="title function_">getFullYear</span>() + <span class="string">&quot;/&quot;</span> + (d.<span class="title function_">getMonth</span>() + <span class="number">1</span>) + <span class="string">&quot;/&quot;</span> + d.<span class="title function_">getDate</span>())) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;身份证上的出生日期非法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 身份证号码校验</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>,</span><br><span class="line">        weights = [<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">        codes = <span class="string">&quot;10X98765432&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; sId.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        sum += sId[i] * weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> last = codes[sum % <span class="number">11</span>]; <span class="comment">//计算出来的最后一位身份证号码</span></span><br><span class="line">    <span class="keyword">if</span> (sId[sId.<span class="property">length</span> - <span class="number">1</span>] != last) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你输入的身份证号非法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>39.随机数范围</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">random</span> = (<span class="params">min, max</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(min + <span class="title class_">Math</span>.<span class="title function_">random</span>() * ((max + <span class="number">1</span>) - min))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>40.将阿拉伯数字翻译成中文的大写数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">numberToChinese</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable constant_">AA</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;零&quot;</span>, <span class="string">&quot;一&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>, <span class="string">&quot;四&quot;</span>, <span class="string">&quot;五&quot;</span>, <span class="string">&quot;六&quot;</span>, <span class="string">&quot;七&quot;</span>, <span class="string">&quot;八&quot;</span>, <span class="string">&quot;九&quot;</span>, <span class="string">&quot;十&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="variable constant_">BB</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;十&quot;</span>, <span class="string">&quot;百&quot;</span>, <span class="string">&quot;仟&quot;</span>, <span class="string">&quot;萬&quot;</span>, <span class="string">&quot;億&quot;</span>, <span class="string">&quot;点&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> a = (<span class="string">&quot;&quot;</span> + num).<span class="title function_">replace</span>(<span class="regexp">/(^0*)/g</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">        k = <span class="number">0</span>,</span><br><span class="line">        re = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = a[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                re = <span class="variable constant_">BB</span>[<span class="number">7</span>] + re;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;0&#123;4&#125;//d&#123;&quot;</span> + (a[<span class="number">0</span>].<span class="property">length</span> - i - <span class="number">1</span>) + <span class="string">&quot;&#125;$&quot;</span>)</span><br><span class="line">                    .<span class="title function_">test</span>(a[<span class="number">0</span>]))</span><br><span class="line">                    re = <span class="variable constant_">BB</span>[<span class="number">4</span>] + re;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                re = <span class="variable constant_">BB</span>[<span class="number">5</span>] + re;</span><br><span class="line">                <span class="variable constant_">BB</span>[<span class="number">7</span>] = <span class="variable constant_">BB</span>[<span class="number">5</span>];</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">4</span> == <span class="number">2</span> &amp;&amp; a[<span class="number">0</span>].<span class="title function_">charAt</span>(i + <span class="number">2</span>) != <span class="number">0</span> &amp;&amp; a[<span class="number">0</span>].<span class="title function_">charAt</span>(i + <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            re = <span class="variable constant_">AA</span>[<span class="number">0</span>] + re;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>].<span class="title function_">charAt</span>(i) != <span class="number">0</span>)</span><br><span class="line">            re = <span class="variable constant_">AA</span>[a[<span class="number">0</span>].<span class="title function_">charAt</span>(i)] + <span class="variable constant_">BB</span>[k % <span class="number">4</span>] + re;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="property">length</span> &gt; <span class="number">1</span>) <span class="comment">// 加上小数部分(如果有小数部分)</span></span><br><span class="line">    &#123;</span><br><span class="line">        re += <span class="variable constant_">BB</span>[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a[<span class="number">1</span>].<span class="property">length</span>; i++)</span><br><span class="line">            re += <span class="variable constant_">AA</span>[a[<span class="number">1</span>].<span class="title function_">charAt</span>(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (re == <span class="string">&#x27;一十&#x27;</span>)</span><br><span class="line">        re = <span class="string">&quot;十&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (re.<span class="title function_">match</span>(<span class="regexp">/^一/</span>) &amp;&amp; re.<span class="property">length</span> == <span class="number">3</span>)</span><br><span class="line">        re = re.<span class="title function_">replace</span>(<span class="string">&quot;一&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>41.将数字转换为大写金额</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">changeToChinese</span> = (<span class="params">Num</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//判断如果传递进来的不是字符的话转换为字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Num</span> == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="title class_">Num</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="title class_">Num</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Num</span> = <span class="title class_">Num</span>.<span class="title function_">replace</span>(<span class="regexp">/,/g</span>, <span class="string">&quot;&quot;</span>) <span class="comment">//替换tomoney()中的“,”</span></span><br><span class="line">    <span class="title class_">Num</span> = <span class="title class_">Num</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&quot;&quot;</span>) <span class="comment">//替换tomoney()中的空格</span></span><br><span class="line">    <span class="title class_">Num</span> = <span class="title class_">Num</span>.<span class="title function_">replace</span>(<span class="regexp">/￥/g</span>, <span class="string">&quot;&quot;</span>) <span class="comment">//替换掉可能出现的￥字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="title class_">Num</span>)) &#123; <span class="comment">//验证输入的字符是否为数字</span></span><br><span class="line">        <span class="comment">//alert(&quot;请检查小写金额是否正确&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//字符处理完毕后开始转换，采用前后两部分分别转换</span></span><br><span class="line">    <span class="keyword">var</span> part = <span class="title class_">String</span>(<span class="title class_">Num</span>).<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> newchar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//小数点前进行转化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = part[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (part[<span class="number">0</span>].<span class="property">length</span> &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//若数量超过拾亿单位，提示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> tmpnewchar = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> perchar = part[<span class="number">0</span>].<span class="title function_">charAt</span>(i);</span><br><span class="line">        <span class="keyword">switch</span> (perchar) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;零&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;壹&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;贰&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;叁&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;肆&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;伍&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;6&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;陆&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;7&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;柒&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;8&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;捌&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;9&quot;</span>:</span><br><span class="line">                tmpnewchar = <span class="string">&quot;玖&quot;</span> + tmpnewchar;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (part[<span class="number">0</span>].<span class="property">length</span> - i - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                tmpnewchar = tmpnewchar + <span class="string">&quot;元&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;佰&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;仟&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                tmpnewchar = tmpnewchar + <span class="string">&quot;万&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;佰&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">if</span> (perchar != <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;仟&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                tmpnewchar = tmpnewchar + <span class="string">&quot;亿&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                tmpnewchar = tmpnewchar + <span class="string">&quot;拾&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> newchar = tmpnewchar + newchar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小数点之后进行转化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Num</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;.&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (part[<span class="number">1</span>].<span class="property">length</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);</span></span><br><span class="line">            part[<span class="number">1</span>] = part[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; part[<span class="number">1</span>].<span class="property">length</span>; i++) &#123;</span><br><span class="line">            tmpnewchar = <span class="string">&quot;&quot;</span></span><br><span class="line">            perchar = part[<span class="number">1</span>].<span class="title function_">charAt</span>(i)</span><br><span class="line">            <span class="keyword">switch</span> (perchar) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;零&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;壹&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;贰&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;叁&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;肆&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;伍&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;6&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;陆&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;7&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;柒&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;8&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;捌&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;9&quot;</span>:</span><br><span class="line">                    tmpnewchar = <span class="string">&quot;玖&quot;</span> + tmpnewchar;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;角&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) tmpnewchar = tmpnewchar + <span class="string">&quot;分&quot;</span>;</span><br><span class="line">            newchar = newchar + tmpnewchar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换所有无用汉字</span></span><br><span class="line">    <span class="keyword">while</span> (newchar.<span class="title function_">search</span>(<span class="string">&quot;零零&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">        newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零零&quot;</span>, <span class="string">&quot;零&quot;</span>);</span><br><span class="line">    newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零亿&quot;</span>, <span class="string">&quot;亿&quot;</span>);</span><br><span class="line">    newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;亿万&quot;</span>, <span class="string">&quot;亿&quot;</span>);</span><br><span class="line">    newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零万&quot;</span>, <span class="string">&quot;万&quot;</span>);</span><br><span class="line">    newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零元&quot;</span>, <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零角&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    newchar = newchar.<span class="title function_">replace</span>(<span class="string">&quot;零分&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (newchar.<span class="title function_">charAt</span>(newchar.<span class="property">length</span> - <span class="number">1</span>) == <span class="string">&quot;元&quot;</span>) &#123;</span><br><span class="line">        newchar = newchar + <span class="string">&quot;整&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newchar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>42.判断一个元素是否在数组中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">contains</span> = (<span class="params">arr, val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(val) != -<span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>43.数组排序，{type} 1：从小到大 2：从大到小 3：随机</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sort</span> = (<span class="params">arr, type = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44.去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;from&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n = &#123;&#125;, r = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!n[arr[i]]) &#123;</span><br><span class="line">                n[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">                r.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>45.求两个集合的并集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">union</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = a.<span class="title function_">concat</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">unique</span>(newArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>46.求两个集合的交集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">intersect</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    a = <span class="variable language_">this</span>.<span class="title function_">unique</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">map</span>(a, <span class="keyword">function</span> (<span class="params">o</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _this.<span class="title function_">contains</span>(b, o) ? o : <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>47.删除其中一个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">remove</span> = (<span class="params">arr, ele</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> index = arr.<span class="title function_">indexOf</span>(ele);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>48.将类数组转换为数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">formArray</span> = (<span class="params">ary</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(ary)) &#123;</span><br><span class="line">        arr = ary;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(ary);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>49.最大值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">max</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>50.最小值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">min</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>51.求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>52.平均值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">average</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sum</span>(arr) / arr.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>53.去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">trim</span> = (<span class="params">str, type</span>) =&gt; &#123;</span><br><span class="line">    type = type || <span class="number">1</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/(^\s*)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>54.字符转换，type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">changeCase</span> = (<span class="params">str, type</span>) =&gt; &#123;</span><br><span class="line">    type = type || <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/\b\w+\b/g</span>, <span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> word.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">toUpperCase</span>() + word.<span class="title function_">substring</span>(<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/\b\w+\b/g</span>, <span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> word.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">toLowerCase</span>() + word.<span class="title function_">substring</span>(<span class="number">1</span>).<span class="title function_">toUpperCase</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="regexp">/[a-z]/</span>.<span class="title function_">test</span>(word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> word.<span class="title function_">toUpperCase</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> word.<span class="title function_">toLowerCase</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">toUpperCase</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> str.<span class="title function_">toLowerCase</span>();</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>55.检测密码强度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkPwd</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Lv</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="property">length</span> &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Lv</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[0-9]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">        <span class="title class_">Lv</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[a-z]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">        <span class="title class_">Lv</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[A-Z]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">        <span class="title class_">Lv</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[\.|-|_]/</span>.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">        <span class="title class_">Lv</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Lv</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>56.函数节流器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">debouncer</span> = (<span class="params">fn, time, interval = <span class="number">200</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (time - (<span class="variable language_">window</span>.<span class="property">debounceTimestamp</span> || <span class="number">0</span>) &gt; interval) &#123;</span><br><span class="line">        fn &amp;&amp; <span class="title function_">fn</span>();</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">debounceTimestamp</span> = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>57.在字符串中插入新字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">insertStr</span> = (<span class="params">soure, index, newStr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> str = soure.<span class="title function_">slice</span>(<span class="number">0</span>, index) + newStr + soure.<span class="title function_">slice</span>(index);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>58.判断两个对象是否键值相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">isObjectEqual</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> aProps = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(a);</span><br><span class="line">    <span class="keyword">var</span> bProps = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aProps.<span class="property">length</span> !== bProps.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aProps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> propName = aProps[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[propName] !== b[propName]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>59.16进制颜色转RGBRGBA字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">colorToRGB</span> = (<span class="params">val, opa</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pattern = <span class="regexp">/^(#?)[a-fA-F0-9]&#123;6&#125;$/</span>; <span class="comment">//16进制颜色值校验规则</span></span><br><span class="line">    <span class="keyword">var</span> isOpa = <span class="keyword">typeof</span> opa == <span class="string">&#x27;number&#x27;</span>; <span class="comment">//判断是否有设置不透明度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pattern.<span class="title function_">test</span>(val)) &#123; <span class="comment">//如果值不符合规则返回空字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> v = val.<span class="title function_">replace</span>(<span class="regexp">/#/</span>, <span class="string">&#x27;&#x27;</span>); <span class="comment">//如果有#号先去除#号</span></span><br><span class="line">    <span class="keyword">var</span> rgbArr = [];</span><br><span class="line">    <span class="keyword">var</span> rgbStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = v.<span class="title function_">substring</span>(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">parseInt</span>(item, <span class="number">16</span>);</span><br><span class="line">        rgbArr.<span class="title function_">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rgbStr = rgbArr.<span class="title function_">join</span>();</span><br><span class="line">    rgbStr = <span class="string">&#x27;rgb&#x27;</span> + (isOpa ? <span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;(&#x27;</span> + rgbStr + (isOpa ? <span class="string">&#x27;,&#x27;</span> + opa : <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> rgbStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>60.追加url参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">appendQuery</span> = (<span class="params">url, key, value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> options = key;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options == <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        options = &#123;&#125;;</span><br><span class="line">        options[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    options = $.<span class="title function_">param</span>(options);</span><br><span class="line">    <span class="keyword">if</span> (url.<span class="title function_">includes</span>(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">        url += <span class="string">&#x27;&amp;&#x27;</span> + options</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url += <span class="string">&#x27;?&#x27;</span> + options</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://segmentfault.com/a/1190000022736837?utm_source=weekly&utm_medium=email&utm_campaign=SegmentFault%20%E7%B2%BE%E9%80%89%E6%AF%8F%E5%91%A8%E7%B2%BE%E9%80%89%E4%B8%A8%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A860+%20%E7%A7%8D%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%E4%B8%A8SegmentFault%20%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85%E6%94%AF%E6%8C%81%E8%AE%A1%E5%88%92%E5%BC%80%E5%90%AF%EF%BC%8C%E5%B8%AE%E5%8A%A9%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E7%AB%8B%E5%BD%B1%E5%93%8D%E5%8A%9B%EF%BC%81">来源</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>前端打包：vite</title>
    <url>/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%EF%BC%9Avite/</url>
    <content><![CDATA[<p>上篇文章讲了如何使用 tsup 打包一些使用 ts 编写的工具，这次讲解如何使用 vite 打包一些 vue 组件（React、Svelte 等框架也同理）。</p>
<span id="more"></span>

<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>使用下面命令快速创建一个 helloworld 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm create vite lib-test</span><br><span class="line"><span class="built_in">cd</span> lib-test</span><br><span class="line">pnpm add -D @types/node vite-plugin-dts vite-plugin-libcss</span><br></pre></td></tr></table></figure>

<p>其中<code>@types/node</code>用来提供正确的 node 类型提示， <code>vite-plugin-dts</code>用来打包出组件的类型定义文件， <code>vite-plugin-libcss</code>用来在打包产物第一行加入<code>import &#39;./style.css&#39;</code>，这样比较适合 css 比较少的组件，如果 css 很多，整个 css 文件导入的话可能会导致项目的打包尺寸比较大。</p>
<h1 id="编写-entry-文件"><a href="#编写-entry-文件" class="headerlink" title="编写 entry 文件"></a>编写 entry 文件</h1><p>打包的组件库通常都由一个 entry 文件进行导出，可以这样写：</p>
<figure class="highlight ts"><figcaption><span>src/index.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">HelloWorld</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld.vue&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后你可以编写你自己的组件：</p>
<figure class="highlight plaintext"><figcaption><span>src/components/MyBtn/MyBtn.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;my-btn&quot; :style=&quot;&#123; &#x27;--padding&#x27;: padding + &#x27;px&#x27; &#125;&quot;&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">withDefaults(</span><br><span class="line">  defineProps&lt;&#123;</span><br><span class="line">    text: string;</span><br><span class="line">    padding: number;</span><br><span class="line">  &#125;&gt;(),</span><br><span class="line">  &#123;</span><br><span class="line">    text: &quot;hello&quot;,</span><br><span class="line">    padding: 4,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">@import &quot;./style.css&quot;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><figcaption><span>src/components/MyBtn/style.css</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.my-btn</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">var</span>(--padding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以安装 sass 或者 less，然后<code>&lt;style lang=&quot;sass/less&quot; scoped&gt;</code>，就能直接使用 sass 或者 less，或者导入 sass 或者 less 文件</p>
<figure class="highlight ts"><figcaption><span>src/components/MyBtn/index.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">MyBtn</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./MyBtn.vue&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后在 index.ts 也导出一下：</p>
<figure class="highlight ts"><figcaption><span>src/index.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">HelloWorld</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld.vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">MyBtn</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./components/MyBtn&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>然后在默认的 tsconfig.json 里的<code>&quot;compilerOptions&quot;</code>加入：<code>&quot;types&quot;: [&quot;node&quot;]</code>。</p>
<p>接下来编写<code>vite.config.ts</code>：</p>
<figure class="highlight ts"><figcaption><span>vite.config.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> dts <span class="keyword">from</span> <span class="string">&quot;vite-plugin-dts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> libCss <span class="keyword">from</span> <span class="string">&quot;vite-plugin-libcss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">lib</span>: &#123;</span><br><span class="line">      <span class="attr">entry</span>: <span class="title function_">fileURLToPath</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;./src/index.ts&quot;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>)),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;MyLib&quot;</span>,</span><br><span class="line">      <span class="attr">formats</span>: [<span class="string">&quot;es&quot;</span>],</span><br><span class="line">      <span class="attr">fileName</span>: <span class="function">() =&gt;</span> <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="attr">external</span>: [<span class="string">&quot;vue&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>(), <span class="title function_">dts</span>(), <span class="title function_">libCss</span>()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>打包模式还能启用 cjs、umd、iife 模式，但是 vite-plugin-libcss 只支持 es 模式，而且 vue3 也推荐使用 es 模式这里就只写 es 吧。</p>
<p>其中<code>rollupOptions</code>的<code>external</code>用于表明 vue 的外部导入包，不需要打包 vue 的代码到构建产物，这样能大幅减少打包的体积。</p>
<blockquote>
<p>到这里就能开始快乐的编译你的组件库了，输入：<code>pnpm build</code>试试吧。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>TypeScript</tag>
        <tag>工具</tag>
        <tag>打包</tag>
        <tag>vite</tag>
      </tags>
  </entry>
  <entry>
    <title>前端打包：tsup</title>
    <url>/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%EF%BC%9Atsup/</url>
    <content><![CDATA[<blockquote>
<p>使用 tsup 的目的是为了快速的打包 TS 项目，使用 tsup 基于 esbuild 进行构建，打包 ts 文件速度是 tsc 的 100 多倍，下面的示例也基于 TS 来说明</p>
</blockquote>
<span id="more"></span>

<h1 id="建立-TS-库项目"><a href="#建立-TS-库项目" class="headerlink" title="建立 TS 库项目"></a>建立 TS 库项目</h1><p>tsup 作者编写了一个：<a href="https://github.com/egoist/ts-lib-starter">ts-lib-starter</a>，可以使用该 template 创建一个自己的项目。</p>
<p>当然也可以自己创建一个比较纯净的 npm 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化项目</span></span><br><span class="line">pnpm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">pnpm add -D typescript tsup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化tsconfig.json</span></span><br><span class="line">npx typescript --init</span><br></pre></td></tr></table></figure>

<h1 id="使用-tsup-打包"><a href="#使用-tsup-打包" class="headerlink" title="使用 tsup 打包"></a>使用 tsup 打包</h1><p>如果是使用 ts-lib-starter 的话，package.json 已经默认写好了 build 指令：tsup src&#x2F;index.ts –format cjs,esm ，可以看到如果只是简单的进行打包甚至不需要编写配置文件，如果需要打包多入口文件只需要这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsup src/index.ts src/cli.ts</span><br></pre></td></tr></table></figure>

<p>或者 src 下的所有 ts 文件作为打包入口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsup src/*.ts</span><br></pre></td></tr></table></figure>

<p>出口默认是 dist 文件夹，并且默认是符合 commonJS 的 cjs 格式，只需要通过 format 参数指定即可打包出 cjs,esm,iife 格式的文件，iife 比较适合浏览器通过<code>&lt;script&gt;</code>标签引入，如果没这个需求通常只需要打包出 cjs 和 esm 即可。</p>
<ul>
<li>这样打包出来的 js 文件并不会附带类型定义文件，如果需要带上类型定义文件只需要在打包命令加上：<code>--dts</code> 参数即可。</li>
<li>如果打包时需要清除上一次的打包需要使用：<code>--clean</code> 参数。</li>
<li>默认情况下打包 esm 会进行代码分割，但是 cjs 并不默认支持，如果需要启用 cjs 代码分割需要加上：<code>--splitting</code> 参数。</li>
</ul>
<h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><p>如果配置稍微多了一些，也可以使用配置文件的方式进行打包，创建 tsup.config.ts 配置文件</p>
<figure class="highlight ts"><figcaption><span>tsup.config.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Options</span> &#125; <span class="keyword">from</span> <span class="string">&quot;tsup&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">tsup</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: [<span class="string">&quot;src/*.ts&quot;</span>],</span><br><span class="line">  <span class="attr">format</span>: [<span class="string">&quot;cjs&quot;</span>, <span class="string">&quot;esm&quot;</span>],</span><br><span class="line">  <span class="attr">dts</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">splitting</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="配置-package-json"><a href="#配置-package-json" class="headerlink" title="配置 package.json"></a>配置 package.json</h1><p>如果需要让组件库发布到 npm 源上的话，必须要配置一下 package.json，才能让别人正确的读到打包出来的 js 文件和类型定义，假设 src 目录下有 index.ts 和 test.ts 入口文件并且使用上述的配置文件进行打包，那么打包出来的文件最少应该有<code>index.js</code> <code>index.mjs</code> <code>index.d.ts</code> <code>test.js</code> <code>test.mjs</code> <code>test.d.ts</code>。</p>
<p>下面是笔者测试出比较符合实际使用的 package.json 配置：</p>
<figure class="highlight json"><figcaption><span>package.jsom</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/index.mjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/index.d.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;dist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.d.ts&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exports&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/index.mjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/index.d.ts&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;./*&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/*.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/*.mjs&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typesVersions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./dist/index.d.ts&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./dist/test.d.ts&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果是多个入口文件的话，重点在于 exports 和 typesVersions 两个配置，如果是只有一个入口则不需要配置这两项，只需要使用 main、module、types 即可。</p>
<p>其中 exports 字段的作用是可以通过<code>import xxx from &#39;npmpkg/test&#39;</code>这样直接访问到上述配置的<code>./dist/test.js</code>，而 typesVersions 这个配置是用来配置 ts 类型检测的，笔者也试过和 exports 一样写入：<code>&quot;*&quot;: [&quot;./dist/*.d.ts&quot;]</code>，但是使用星号通配会将<code>&quot;.&quot;: [&quot;./dist/index.d.ts&quot;]</code>覆盖，导致无法正确找到<code>index.d.ts</code>的位置。</p>
<p>如果使用多入口文件的话，必须要这样配置才能在项目中使用 import xxx from ‘xxx&#x2F;test’，否则只能 from ‘xxx&#x2F;dist&#x2F;test’ 这样导入。</p>
<p>如果你的目录可能有多层：</p>
<ul>
<li>index.ts</li>
<li>test.ts<ul>
<li>test1<ul>
<li>test1.ts</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>然后tsup的入口配置成<code>entry: [&#39;src/**/*.ts&#39;,]</code>，这样打包会递归打包，打包出来的目录也会和src的目录结构一样，如果想要通过<code>import xxx from &#39;npmpkg/test1&#39;</code>，这样配置文件可能就需要变成这样:</p>
<figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exports&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/index.mjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/index.d.ts&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;./test&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/test.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/test.mjs&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;./test1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/test/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/test/index.mjs&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typesVersions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./dist/index.d.ts&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./dist/test.d.ts&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;test1&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;./dist/test1/index.d.ts&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相信你已经掌握了package.json的配置，快来试一下吧</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>TypeScript</tag>
        <tag>工具</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机原理笔记-1</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>笔记</p>
<span id="more"></span>

<h1 id="MCS51单片机的型号和组成"><a href="#MCS51单片机的型号和组成" class="headerlink" title="MCS51单片机的型号和组成"></a>MCS51单片机的型号和组成</h1><p>MCS51系列单片机最早是Intel在80年推出的，包括51和52两个子系列，51系列包括8031、8051、9751三种。</p>
<p>MCS51系列明明规范：</p>
<p><strong>xx8xc5x</strong></p>
<p>第一个xx是厂家前缀，包括：AT（Atmel）、P（Philps）、STC（宏晶）、T（Toshiba）</p>
<p>8是指8位机</p>
<p>第三个x是值ROM种类，包括：0（OTP PROM或者无）、7（EPROM）、9（E2PROM）</p>
<p>c指芯片采用cmos制作工艺，还有：无、F、S</p>
<p>5指51系列</p>
<p>最后一个x指储存器容量，还有：1、2、5、8、16，书中乘以4K就是储存器的容量</p>
<h2 id="运算部件"><a href="#运算部件" class="headerlink" title="运算部件"></a>运算部件</h2><p>以一个8位的算术逻辑运算单元ALU为核心，包括累加器ACC、B寄存器、标志寄存器PSW等部件</p>
<p>寄存器b也叫辅助寄存器，为乘法和除法指令而设置</p>
<p>PSW是一个8位寄存器，用于保存指令执行结果的状态，其中包括</p>
<table>
<thead>
<tr>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>AC</td>
<td>F0</td>
<td>RS1</td>
<td>RS0</td>
<td>OV</td>
<td>-</td>
<td>P</td>
</tr>
</tbody></table>
<p>RS：寄存器组选择位，单片机有8个一组的寄存器，4组一共32个寄存器</p>
<table>
<thead>
<tr>
<th>RS1</th>
<th>RS0</th>
<th>工作寄存器组</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0组（00H-07H）</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1组（08H-0FH）</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>2组（10H-17H）</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>3组（18H-1FH）</td>
</tr>
</tbody></table>
<p>C(Carry): 进位标志位</p>
<p>AC(Auxiliary Carry): 辅助进位标志位</p>
<p>F0(Flag Zero): 用户标志位</p>
<p>OV(Overflow): 溢出标志位，指第三位是否向第四位产生进位</p>
<p>P(Parity): 奇偶标志位，表示累加器ACC的值二进制表示时1的个数，为奇数时P&#x3D;1</p>
<h1 id="51单片机储存器结构"><a href="#51单片机储存器结构" class="headerlink" title="51单片机储存器结构"></a>51单片机储存器结构</h1><h2 id="程序储存器ROM"><a href="#程序储存器ROM" class="headerlink" title="程序储存器ROM"></a>程序储存器ROM</h2><p>存放单片机工作时的程序，不能没有ROM，不然不能工作</p>
<p>51单片机有一个16位的程序计数器（PC），所以储存器空间大小为64kB，最大地址从0000到FFFFH</p>
<p>物理结构上也分为片内和片外两种。</p>
<p>判断是否使用外部储存器是通过EA引脚，如果EA&#x3D;1，PC值大于某值为访问外部存储器，PC小于某值为内存存储器，如果EA&#x3D;0，则忽略内部存储器。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>十个实用的ES6特性</title>
    <url>/%E5%89%8D%E7%AB%AF/%E5%8D%81%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84ES6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>记录一些ES6的新特性</p>
<span id="more"></span>

<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247486985&idx=1&sn=66c0f5df5f2f80df546e044b588481a8&chksm=97c593a7a0b21ab1c9816657ef42910e0bfcf84cbb77be884441c5fce1e9ecff71e262b2ecae&mpshare=1&scene=23&srcid=&sharer_sharetime=1590973043053&sharer_shareid=b7cae91520a141b16a6c7eb7f03383f1#rd">Vue中文社区</a></p>
<h1 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h1><p>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstHalf = [ <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> secondHalf = [<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, ...firstHalf];</span><br></pre></td></tr></table></figure>
<p>非常简洁的一个特性。如果不用展开符的话需要这样写:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstHalf = [ <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> secondHalf = [<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, i &lt;firstHalf.<span class="property">length</span>; i++ ) &#123;</span><br><span class="line">  secondHalf.<span class="title function_">push</span>(firstHalf[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展开操作符也适用于合并对象的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hero = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;李白&#x27;</span>,</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&#x27;刺客&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> heroWithAttackRange = &#123;</span><br><span class="line">    ...hero,</span><br><span class="line">    <span class="title class_">AttackRange</span>: <span class="string">&#x27;近战&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用展开操作符的话，需要遍历对象的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(hero);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">   obj[keys[i]] = keys[props[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h1><p>剩余参数将剩余的参数收入数列。JavaScript 的特性是参数数目很灵活。通常会有一个 arguments 变量收集参数。直接上例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">first, second, ...remaining</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> first + second + remaining.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很像go语言的可变参数。</p>
<h1 id="字符串插值-x2F-模板字符串"><a href="#字符串插值-x2F-模板字符串" class="headerlink" title="字符串插值&#x2F;模板字符串"></a>字符串插值&#x2F;模板字符串</h1><p>见过这样的语句吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, description, price</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">description</span> = description;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; Full description \n&quot;</span> +</span><br><span class="line">    <span class="string">&quot; name: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> +</span><br><span class="line">    <span class="string">&quot; description: &quot;</span> + <span class="variable language_">this</span>.<span class="property">description</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我指的是 getDescription() 方法中那个可读性不佳的多行长语句。大多数编程语言中都存在类似现象。一些语言提供了字符串插值，幸运的是，JavaScript 正是其中之一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">`Full description \n:</span></span><br><span class="line"><span class="string">   name: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span></span></span><br><span class="line"><span class="string">   description <span class="subst">$&#123;<span class="variable language_">this</span>.description&#125;</span></span></span><br><span class="line"><span class="string">   `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h1><p>在 ES5 中必须这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCoord</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: x,</span><br><span class="line">    <span class="attr">y</span>: y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 以后可以使用简写属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCoord</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来也简洁很多了。</p>
<h1 id="方法属性简写"><a href="#方法属性简写" class="headerlink" title="方法属性简写"></a>方法属性简写</h1><p>方法属性是在对象中定义指向方法的属性。在ES5要这样写:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> math = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a + b; &#125;,</span><br><span class="line">  <span class="attr">sub</span>: <span class="keyword">function</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a - b; &#125;,</span><br><span class="line">  <span class="attr">multiply</span>: <span class="keyword">function</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 以后只需这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> math = &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a + b; &#125;,</span><br><span class="line">  <span class="title function_">sub</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a - b; &#125;,</span><br><span class="line">  <span class="title function_">multiply</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>大佬说：解构赋值有利于开发者本人的心理健康。先来看看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = req.<span class="property">body</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">const</span> description = req.<span class="property">body</span>.<span class="property">description</span>;</span><br><span class="line">    <span class="keyword">const</span> url = req.<span class="property">url</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;url endpoint&#x27;</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo:后续业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管从什么角度来看，上面的代码都不完美，但它确实体现了一种应用场景，我们想要从对象的不同层次获取数据。你也许会问，这里有什么问题？好吧，我可以不用声明这么多变量，省下一些敲击键盘的次数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">body</span>: &#123; name, description &#125;, url &#125; = req;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;url endpoint&#x27;</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo:后续业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码从三行缩成了一行。解构赋值并不仅仅局限于对象，它同样适用于数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> a = array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> c = array[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>可以写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> [a, ,c, ...another] = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// another = [4,5,6]，a = 1，b = 3</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用上面的模式匹配分解数组的值。我们使用 , , 跳过某些值。上面提到过的剩余参数这里也能用，在这里我们通过剩余参数捕获了剩余的数组成员。</p>
<p>解构赋值还可以用于函数和参数。函数有不止 2-3 个参数时，使用一个对象收集所有参数是 JavaScript 的事实标准。<br>比如下面的一个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">a</span>) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">b</span>) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">c</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用更好的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">&#123; a, b, c &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(a) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span>(b) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span>(c) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.runoob.com/w3cnote/deconstruction-assignment.html">runoob上还有其他用法</a></p>
<h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><p>ES6 引入了许多有用的数组方法，例如：</p>
<ul>
<li><code>find()</code>，查找列表中的成员，返回 null 表示没找到</li>
<li><code>findIndex()</code>，查找列表成员的索引</li>
<li><code>some()</code>，检查某个断言是否至少在列表的一个成员上为真</li>
<li><code>includes</code>，列表是否包含某项</li>
</ul>
<p>下面的代码有助于你理解它们的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">checked</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;];</span><br><span class="line">arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === <span class="number">2</span>) <span class="comment">// &#123; id: 2 &#125;</span></span><br><span class="line">arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">checked</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">numberArray.<span class="title function_">includes</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Promises + Async&#x2F;Await<br>如果你在这个圈子里呆了些年头，也许会记得曾经有一个时期我们只有回调，就像：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>  &#123;</span><br><span class="line">    <span class="title function_">cb</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done here&#x27;</span>, arg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们使用回调是因为有些操作是异步的，需要时间来完成。后来我们有了 promise 库，人们开始使用它。然后 JavaScript 逐渐加入了对 promise 的原生支持。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>  &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done here&#x27;</span>, arg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们甚至可以这样调用，将 promise 串起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getUser</span>()</span><br><span class="line">    .<span class="title function_">then</span>(getOrderByUser)</span><br><span class="line">    .<span class="title function_">then</span>(getOrderItemsByOrder)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">orderItems</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理排序后的成员</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>后来生活更加美好，我们有了 async&#x2F;await，上面代码可以写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>();</span><br><span class="line">        <span class="keyword">const</span> order = <span class="keyword">await</span> <span class="title function_">getOrderByUser</span>(user);</span><br><span class="line">        <span class="keyword">const</span> items = <span class="keyword">await</span> <span class="title function_">getOrderItemsByOrder</span>(order);</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="comment">// 在这里处理错误，建议返回某个值或者重新抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getItems</span>().<span class="title function_">then</span>(<span class="function"><span class="params">items</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理排序后的成员</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>大部分编程语言都支持模块这一概念（C++20标准才支持），也就是将代码分为多个文件，每个文件是一个自我包含的单元（模块）。<br>看看下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">mult</span>(a,b) =&gt; a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> mult, &#123; add, sub &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mult</span>(<span class="number">2</span>, <span class="number">4</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>,<span class="number">1</span>)   <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">sub</span>(<span class="number">1</span>,<span class="number">2</span>)   <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>我们在上面用 <code>export</code> 关键字注明了 <code>add</code> 和 <code>sub</code> 这两个结构对任何引入该模块的模块都公开可见。<code>export default</code> 关键字则注明仅仅 <code>import</code> 模块时得到的结构。在 <code>main.js</code> 中，我们将导入的 <code>default</code> 命名为 <code>mult</code>，同时指明我们引入 <code>add()</code> 和 <code>sub()</code> 这两个方法。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数和字典作用域 <code>this</code>：我在这篇文章中很多地方都用到了箭头函数，它不过是另一种函数表示法。过去我们只能这么声明函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们也可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">printArray</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以写成一行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a,b</span>) =&gt; a + b</span><br></pre></td></tr></table></figure>
<p>我们也可以采用下面的语法返回一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> create = (a,b) = &gt; (&#123; <span class="attr">x</span>: a, <span class="attr">y</span>: b &#125;)</span><br></pre></td></tr></table></figure>
<p>过去会碰到搞不清 this 是什么的问题，看看下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">total</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">total</span> += item;  <span class="comment">// 糟糕，`this` 是内层函数的 `this`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的 this 指向 forEach 内部函数的 this，这可不是我们想要的。过去可以通过这个方法解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">total</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        self.<span class="property">total</span>+= item;  <span class="comment">// 这里我们使用 `self` 来指向外层的this，它虽然能解决问题，但是感觉有点别扭</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在代码看起来是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">total</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">total</span>+= item;  <span class="comment">// 一切安好，`this` 指向外层函数</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 方面的还有很多内容，不过这篇文章只介绍最常用的特性。我觉得你应该从今天开始使用这些特性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在云端编程(1)：CloudStudio</title>
    <url>/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/</url>
    <content><![CDATA[<blockquote>
<p>因为操作系统课程实验需要用到 Linux 系统，但是很多小伙伴不会装 Linux 系统，那有没有不用装系统和一些奇奇怪怪的软件的方法呢？还真有，用云端编程软件就可以</p>
</blockquote>
<span id="more"></span>

<p>你需要准备的东西：</p>
<ul>
<li>一台能上网的电脑（手机也可以）</li>
<li>一个浏览器</li>
<li>一个脑子</li>
</ul>
<p>好了，我们废话不多说直接进入教程。</p>
<h1 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h1><p>打开<a href="https://cloudstudio.net/">CloudStudio 官网</a>，点击右上方的注册。都 0202 年了大家不会连账号注册都不会吧。</p>
<h1 id="进入-CloudStudio-页面"><a href="#进入-CloudStudio-页面" class="headerlink" title="进入 CloudStudio 页面"></a>进入 CloudStudio 页面</h1><p>登录之后点击侧边栏的 CloudStudio</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/2.png" class="">
<p>点击新建 Bate 版，工作空间名称随便写写，代码来源选空</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/3.png" class="">
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/4.png" class="">
<p>然后就能进入编程界面了</p>
<h1 id="安装编译环境"><a href="#安装编译环境" class="headerlink" title="安装编译环境"></a>安装编译环境</h1><p>在顶部菜单栏-终端-新建终端</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/5.png" class="">
<p>在下面终端输入：<code>apt-get update</code>，<br>然后输入：<code>apt install build-essential -y</code></p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/7.png" class="">
<p>最后输入：<code>gcc --version</code>检查是否安装成功</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/8.png" class="">

<h1 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h1><p>在左边侧边栏右键，新建文件，回车确认</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/9.png" class="">
<p>然后我们在右边代码编辑区域随便写写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1, p2;</span><br><span class="line">    <span class="keyword">while</span> ((p1 = fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((p2 = fork()) == <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止你的代码就写好了</p>
<h1 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h1><p>这时候我们开始编译，比如我的源码文件是 a.c 那么我们使用<code>gcc a.c</code>，就可以编译出一个 a.out 的可执行文件，当然你也可以加个参数，控制生成的可执行文件的名称，比如：<code>gcc a.c -o a</code>就可以编译成一个叫 a 的可执行文件</p>
<p>接下来输入：<code>./a</code>，就可以执行 a 文件</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9ACloudStudio/10.png" class="">
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>在云端编程(2)：CloudStudio调试C语言</title>
    <url>/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>教一下你们怎么快速搭建 C 语言的开发环境、调试环境，和上一篇文章一样，你需要准备的东西：</p>
<ul>
<li>一台能上网的电脑（手机也可以）</li>
<li>一个浏览器</li>
<li>一个脑子</li>
</ul>
<p>还是废话不多说直接开始。</p>
<span id="more"></span>

<h1 id="注册-CloudStudio-账号"><a href="#注册-CloudStudio-账号" class="headerlink" title="注册 CloudStudio 账号"></a>注册 CloudStudio 账号</h1><p>打开<a href="https://cloudstudio.net/">CloudStudio 官网</a>，点击右上方的注册。都 1202 年了大家不会连账号注册都不会吧。</p>
<h1 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h1><p>通过注册你已经获得了一个域名：<code>https://你注册时填写的名称.cloudstudio.net/</code>。在后面加上：<code>/dashboard/workspace</code>进入控制面板<br>就比如：<code>https://你的域名.cloudstudio.net/dashboard/workspace</code></p>
<p>点击左下角的新建工作空间</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/1.png" class="">

<p>选择 All in One</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/2.png" class="">

<p>随便填点信息</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/3.png" class="">

<p>可以看到右侧列表已经出现了新增的，点击进入环境</p>
<h1 id="开始试一下-HelloWorld"><a href="#开始试一下-HelloWorld" class="headerlink" title="开始试一下 HelloWorld"></a>开始试一下 HelloWorld</h1><p>在左侧的：<code>REMOTEWORKING</code>目录下右键，新建文件</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/4.png" class="">

<p>输入我们的 HelloWorld 代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦多么优雅简介的代码，让我们来运行一下：</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/5.png" class="">

<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/6.png" class="">
<p>就连结果也是这么简洁优雅。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>如果你不知道什么是调试，可以百度一下，这里不多废话，直接讲一下调试功能。</p>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>开始调试前我们需要让 ide 给我生成调试配置文件，正如把大象装进冰箱需要三部一样，生成配置文件也是一样</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/7.png" class="">

<p>不过这个过程可能会失败，可以尝试多几次，直到出现这个界面，我们选择第一个就可以了：</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/8.png" class="">

<p>然后就可以看到我们的配置文件已经自动生成了：</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/9.png" class="">

<p>回到我们的 main.c，文件然后开始调试</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/10.png" class="">

<p>然后如果你看到这个结果就成功了</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/11.png" class="">

<h2 id="逐步调试"><a href="#逐步调试" class="headerlink" title="逐步调试"></a>逐步调试</h2><p>首先说几个概念：</p>
<ul>
<li>断点：如果某一行前打上断点，那么程序运行到这一行前会停下来，等待你的操作</li>
<li>继续：程序继续运行下去，直到下一个断点或者程序结束</li>
<li>单步跳过：如果这一行是调用某个函数，直接执行完调用函数，不进入内部函数</li>
<li>单步调试：如果这一行是调用函数，那么进入函数内部，并在第一行停下</li>
<li>单步跳出：如果已经在某个函数里面，你不想在这个函数里继续单步调试，可以使用单步跳出，如果你是在 main 函数用这个，而且下面的代码没有断点，那么会直接执行完整个 main 函数。</li>
</ul>
<p>那么我们先试试断点然后调试：</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/12.png" class="">

<p>可以看到程序神奇的停在断点前，然后下一步我们应该逐步跳过，因为我们不需要看 printf 函数内部的代码：</p>
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/13.png" class="">
<img src="/%E6%95%99%E7%A8%8B/%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B-2-%EF%BC%9ACloudStudio%E8%B0%83%E8%AF%95C%E8%AF%AD%E8%A8%80/14.png" class="">

<blockquote>
<p>还有一些操作可以百度搜一下 C 语言调试技术跟着进行操作，比如变量值修改等等。但这些知识不属于本节课，或者你可以去看：<a href="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95">C 语言的调试方法</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发之Jetpack：DataBinding</title>
    <url>/%E5%AE%89%E5%8D%93/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B9%8BJetpack%EF%BC%9ADataBinding/</url>
    <content><![CDATA[<p>本节内容可能非常多，请耐心看完。</p>
<span id="more"></span>

<h1 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h1><p>先在build.gradle导入DataBinding</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        dataBinding &#123;</span><br><span class="line">            enable <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个Idol类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.databinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Idol</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Idol</span><span class="params">(String name, String star)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String star;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在布局文件加入一个ImageView和两个TextView，然后光标移到文件开头，alt+enter，转成DataBinding布局，并在data里加入变量：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;idol&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.databinding.Idol&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;300dip&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;300dip&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.495&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.803&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:srcCompat</span>=<span class="string">&quot;@tools:sample/avatars&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;idol.name&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;姓名&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;idol.star&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;姓名&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后在activity的java文件里改成databingding模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.databinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.DataBindingUtil;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> com.example.databinding.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="type">ActivityMainBinding</span> <span class="variable">activityMainBinding</span> <span class="operator">=</span> DataBindingUtil.setContentView(<span class="built_in">this</span>, R.layout.activity_main);</span><br><span class="line">        <span class="type">Idol</span> <span class="variable">idol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Idol</span>(<span class="string">&quot;斋藤飞鸟&quot;</span>, <span class="string">&quot;五星&quot;</span>);</span><br><span class="line">        activityMainBinding.setIdol(idol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="import标签与事件绑定"><a href="#import标签与事件绑定" class="headerlink" title="import标签与事件绑定"></a>import标签与事件绑定</h1><p>现在需要把Idol的star从String转成int，通过传入一个数字然后界面显示x星<br>先创建一个转换方法，StarUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.databinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStar</span><span class="params">(<span class="type">int</span> star)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (star) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;一星&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;二星&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;三星&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;四星&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;五星&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在布局文件的variable里加入import标签，然后在TextView里直接使用这个类的方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;idol&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;com.example.databinding.Idol&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;com.example.databinding.StarUtil&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;StarUtil.getStar(idol.star)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:text</span>=<span class="string">&quot;姓名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>在界面上添加一个按钮：<br>创建一个EventHandleListener.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.databinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventHandleListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventHandleListener</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buttonOnClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;喜欢成功&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在布局文件引入，并且设置button的onClick：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;idol&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;com.example.databinding.Idol&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;eventHandle&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;com.example.databinding.EventHandleListener&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;com.example.databinding.StarUtil&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;喜欢&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;eventHandle.buttonOnClick&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.498&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在MainActivity创建并传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">activityMainBinding.setEventHandle(<span class="keyword">new</span> <span class="title class_">EventHandleListener</span>(<span class="built_in">this</span>));</span><br></pre></td></tr></table></figure>

<h1 id="二级页面的绑定"><a href="#二级页面的绑定" class="headerlink" title="二级页面的绑定"></a>二级页面的绑定</h1><p>创建一个二级页面sub.xml，同样转成databinding:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;idol&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.databinding2.Idol&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">&quot;com.example.databinding2.StarUtil&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingBottom</span>=<span class="string">&quot;16dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;34sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;姓名&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;idol.name&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;五星&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;StarUtil.getStar(idol.star)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在主界面引入这个布局，并用app:xxx&#x3D;”xxx”传进去：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span></span></span><br><span class="line"><span class="tag">    <span class="attr">layout</span>=<span class="string">&quot;@layout/sub&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:idol</span>=<span class="string">&quot;@&#123;idol&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样子界面就能接收到传进来的对象，java代码不需要动</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>安卓</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>存储过程笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>存储过程的英文是 Stored Procedure。它的思想很简单，就是 SQL 语句的封装。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。存储过程实际上由 SQL 语句和流控制语句共同组成。</p>
</blockquote>
<span id="more"></span>

<h1 id="什么是存储过程，如何创建一个存储过程"><a href="#什么是存储过程，如何创建一个存储过程" class="headerlink" title="什么是存储过程，如何创建一个存储过程"></a>什么是存储过程，如何创建一个存储过程</h1><p>存储过程定义：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    需要执行的语句</span><br><span class="line"><span class="keyword">END</span>    </span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 CREATE PROCEDURE 创建一个存储过程，后面是存储过程的名称，以及过程所带的参数，可以包括输入参数和输出参数。最后由 BEGIN 和 END 来定义我们所要执行的语句块。</p>
<p>和视图一样，我们可以删除已经创建的存储过程，使用的是 DROP PROCEDURE。如果要更新存储过程，我们需要使用 ALTER PROCEDURE。</p>
<p>实现一个从1到n的求和：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `add_num`(<span class="keyword">IN</span> n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> i <span class="type">INT</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> sum <span class="type">INT</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">SET</span> sum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       WHILE i <span class="operator">&lt;=</span> n DO</span><br><span class="line">              <span class="keyword">SET</span> sum <span class="operator">=</span> sum <span class="operator">+</span> i;</span><br><span class="line">              <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">       <span class="keyword">END</span> WHILE;</span><br><span class="line">       <span class="keyword">SELECT</span> sum;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>当使用时直接使用<code>CALL add_num(n)</code>,比如传入50，就可以实现1+2+…+50。</p>
<table>
<thead>
<tr>
<th>sum</th>
</tr>
</thead>
<tbody><tr>
<td>1275</td>
</tr>
</tbody></table>
<h1 id="使用DELIMITER-定义语句的结束符"><a href="#使用DELIMITER-定义语句的结束符" class="headerlink" title="使用DELIMITER 定义语句的结束符"></a>使用DELIMITER 定义语句的结束符</h1><p>我们先来看下 DELIMITER 的作用。如果你使用 Navicat 这个工具来管理 MySQL 执行存储过程，那么直接执行上面这段代码就可以了。如果用的是 MySQL，你还需要用 DELIMITER 来临时定义新的结束符。因为默认情况下 SQL 采用（；）作为结束符，这样当存储过程中的每一句 SQL 结束之后，采用（；）作为结束符，就相当于告诉 SQL 可以执行这一句了。但是存储过程是一个整体，我们不希望 SQL 逐条执行，而是采用存储过程整段执行的方式，因此我们就需要临时定义新的 DELIMITER，新的结束符可以用（&#x2F;&#x2F;）或者（$$）。如果你用的是 MySQL，那么上面这段代码，应该写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `add_num`(<span class="keyword">IN</span> n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> i <span class="type">INT</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> sum <span class="type">INT</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">SET</span> sum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       WHILE i <span class="operator">&lt;=</span> n DO</span><br><span class="line">              <span class="keyword">SET</span> sum <span class="operator">=</span> sum <span class="operator">+</span> i;</span><br><span class="line">              <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">       <span class="keyword">END</span> WHILE;</span><br><span class="line">       <span class="keyword">SELECT</span> sum;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>PS：使用Navicat工具时，在编写存储过程的时候它会自动使用DELIMITER将结束符设置成其他符号，就不需要我们手写。</p>
<h1 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h1><p>我们再来看下存储过程的 3 种参数类型。在刚才的存储过程中，我们使用了 IN 类型的参数，另外还有 OUT 类型和 INOUT 类型，作用如下：</p>
<table>
<thead>
<tr>
<th>参数类型</th>
<th>是否返回</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>否</td>
<td>向存储过程传入参数，存储过程中修改该参数的值，不能被返回</td>
</tr>
<tr>
<td>OUT</td>
<td>是</td>
<td>把存储过程计算的结构放入该参数，调用者可以得到返回值</td>
</tr>
<tr>
<td>INOUT</td>
<td>是</td>
<td>IN和OUT的结合，先传入然后将结构放入该参数，可以得到返回值</td>
</tr>
</tbody></table>
<p>拿<a href="https://github.com/cystanford/sql_heros_data">heros表</a>举例，假设我想创建一个存储类型 get_hero_scores，用来查询某一类型英雄中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，那么该怎么写呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `get_hero_scores`(</span><br><span class="line">    <span class="keyword">OUT</span> max_max_hp <span class="type">FLOAT</span>,</span><br><span class="line">    <span class="keyword">OUT</span> min_max_mp <span class="type">FLOAT</span>,</span><br><span class="line">    <span class="keyword">OUT</span> avg_max_attack <span class="type">FLOAT</span>,  </span><br><span class="line">    s <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hp_max), <span class="built_in">MIN</span>(mp_max), <span class="built_in">AVG</span>(attack_max) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main <span class="operator">=</span> s <span class="keyword">INTO</span> max_max_hp, min_max_mp, avg_max_attack;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>能看到我定义了 4 个参数类型，其中 3 个为 OUT 类型，分别为 max_max_hp、min_max_mp 和 avg_max_attack，另一个参数 s 为 IN 类型。（这里IN省略了估计是缺省值是IN）</p>
<p>这里我们从 heros 数据表中筛选主要英雄定位为 s 的英雄数据，即筛选条件为 role_main&#x3D;s，提取这些数据中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，分别赋值给变量 max_max_hp、min_max_mp 和 avg_max_attack。</p>
<p>接下来我们调用存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> get_hero_scores(<span class="variable">@max</span>_max_hp, <span class="variable">@min</span>_max_mp, <span class="variable">@avg</span>_max_attack, <span class="string">&#x27;战士&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@max</span>_max_hp, <span class="variable">@min</span>_max_mp, <span class="variable">@avg</span>_max_attack;</span><br></pre></td></tr></table></figure>
<p>（单个@加变量名在 MySQL 代表自定义变量，这里相当于自定义个变量，然后接收函数返回的结果）</p>
<p>得到下面结果：</p>
<table>
<thead>
<tr>
<th>@max_max_hp</th>
<th>@min_max_mp</th>
<th>@avg_max_attack</th>
</tr>
</thead>
<tbody><tr>
<td>8050</td>
<td>0</td>
<td>342.1666564941406</td>
</tr>
</tbody></table>
<h1 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h1><p>流控制语句是用来做流程控制的，我刚才讲了两个简单的存储过程的例子，一个是 1+2+…+n 的结果计算，一个是王者荣耀的数据查询，你能看到这两个例子中，我用到了下面的流控制语句：</p>
<ol>
<li>BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</li>
<li>DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。</li>
<li>SET：赋值语句，用于对变量进行赋值。</li>
<li>SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</li>
</ol>
<p>除了上面这些用到的流控制语句以外，还有一些常用的流控制语句：</p>
<ol>
<li>IF…THEN…ENDIF：条件判断语句，我们还可以在 IF…THEN…ENDIF 中使用 ELSE 和 ELSEIF 来进行条件判断。</li>
<li>CASE：CASE 语句用于多条件的分支判断，使用的语法是下面这样的。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">	<span class="keyword">WHEN</span> expression1 <span class="keyword">THEN</span> ...</span><br><span class="line">	<span class="keyword">WHEN</span> expression2 <span class="keyword">THEN</span> ...</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">ELSE</span> </span><br><span class="line">    <span class="comment">--ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li>
<li>LOOP、LEAVE 和 ITERATE：LOOP 是循环语句，使用 LEAVE 可以跳出循环，使用 ITERATE 则可以进入下一次循环。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 BREAK，把 ITERATE 理解为 CONTINUE。</li>
<li>REPEAT…UNTIL…END REPEAT：这是一个循环语句，首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</li>
<li>WHILE…DO…END WHILE：这也是循环语句，和 REPEAT 循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</li>
</ol>
<h1 id="关于存储过程使用的争议"><a href="#关于存储过程使用的争议" class="headerlink" title="关于存储过程使用的争议"></a>关于存储过程使用的争议</h1><p>尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p>
<p>我们得从存储过程的特点来找答案。</p>
<p>你能看到存储过程有很多好处。</p>
<p>首先存储过程可以一次编译多次使用。存储过程只在创造时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。其次它可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。还有一点，存储过程的安全性强，我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。最后它可以减少网络传输量，因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。同时在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
<p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p>
<p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<p>它的可移植性差，存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
<p>其次调试困难，只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</p>
<p>此外，存储过程的版本管理也很困难，比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
<p>最后它不适合高并发的场景，高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p>
<p>了解了存储过程的优缺点之后，我想说的是，存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
<h1 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h1><blockquote>
<p>针对王者荣耀的英雄数据表 heros 表，请编写存储过程 get_sum_score，用来得到某一类型英雄（主要定位为某一类型即可）的最大生命值的总和。</p>
</blockquote>
<p>这里是我的答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `get_sum_scores`(<span class="keyword">IN</span> mainRule <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(hp_max) <span class="keyword">AS</span> sum_hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main <span class="operator">=</span> role_main;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>和有返回值，而且可以在MySQl用的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `get_sum_scores`(<span class="keyword">IN</span> mainRule <span class="type">VARCHAR</span>(<span class="number">255</span>), <span class="keyword">OUT</span> hp_max_sum <span class="type">FLOAT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(hp_max) <span class="keyword">AS</span> sum_hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main <span class="operator">=</span> role_main <span class="keyword">INTO</span> hp_max_sum;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>对应的执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> get_sum_scores1(<span class="string">&#x27;战士&#x27;</span>, <span class="variable">@sum</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@sum</span> <span class="keyword">AS</span> sum_hp_max;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>大学生数码产品推荐</title>
    <url>/%E6%95%B0%E7%A0%81%E4%BA%A7%E5%93%81%E6%8E%A8%E8%8D%90/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E7%A0%81%E4%BA%A7%E5%93%81%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<blockquote>
<p>2020-4-16更新：如果现在看到这篇文章，那么它大部分的内容已经过时，仅供参考。</p>
</blockquote>
<p>这里为大家分享一波手机、充电宝、平板、U盘、机械键盘、游戏鼠标的推荐，下面我们开始吧。</p>
<span id="more"></span>

<p><em><strong>手机浏览建议在浏览器打开然后把屏幕横过来会好看很多哦</strong></em><br><em><strong>手机浏览建议在浏览器打开然后把屏幕横过来会好看很多哦</strong></em><br><em><strong>手机浏览建议在浏览器打开然后把屏幕横过来会好看很多哦</strong></em></p>
<h1 id="手机推荐"><a href="#手机推荐" class="headerlink" title="手机推荐"></a>手机推荐</h1><h2 id="1500元以内"><a href="#1500元以内" class="headerlink" title="1500元以内"></a>1500元以内</h2><table>
    <tbody>
        <tr class="firstRow">
            <td width="63" valign="top"></td>
            <td width="63" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                处理器
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                内存
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                电池容量
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                充电功率
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                厚度
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                重量
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                发布时间
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                评价
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                红米note8Pro
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                1399
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                联发科G90T
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                6+64G
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                4500mAH
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                18W
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8.8mm
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                199.8g
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年8月底
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                性价比还不错
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                魅族16x
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                1298
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                高通710
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                6+64G
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                3100
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                24W
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                7.5
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                154
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                18年9月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                轻便、充电快
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                OPPO K3
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                1439
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                高通710
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                6+64G
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                3765
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                20W
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                9.4
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                191
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年5月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                售后方便、全面屏
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                RealmeQ
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                1498
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                高通712
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8+128G
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                4035
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                20W
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8.9
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                184
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年9月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">新出的机器，712性能不比710强多少，但是有一个998和1198的版本，分别是4+64和6+64，除非真的没钱不然还是不要选这两个</span>
            </td>
        </tr>
    </tbody>
</table>

<h2 id="2000元左右"><a href="#2000元左右" class="headerlink" title="2000元左右"></a>2000元左右</h2><table width="-76">
    <tbody>
        <tr class="firstRow">
            <td width="55" valign="top"></td>
            <td width="55" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                处理器
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                储存
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                电池容量/mAH
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                充电功率/W
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                厚度/mm
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                重量/g
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                发布时间<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                评价
            </td>
        </tr>
        <tr>
            <td width="55" valign="top" style="word-break: break-all;">
                小米MIX2s
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                <p>
                    1599
                </p>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                高通845
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                6+128
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                3400<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                18
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                8.1
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                189
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                18年6月<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">如果没钱买K20P，小米mix2s基本上是最便宜的带845的手机了，还有7.5w无线充电，玩游戏性价比极高</span>
            </td>
        </tr>
        <tr>
            <td width="55" valign="top" style="word-break: break-all;">
                Redmi K20 Pro<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                2299
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                高通855
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                6+128<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                4000
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                27
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                8.1<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                198
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                19年7月<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                性价比最高，玩游戏推荐这个
            </td>
        </tr>
        <tr>
            <td width="55" valign="top" style="word-break: break-all;">
                魅族16
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                1998
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                高通845
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                8+128
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                3010<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                24
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                7.3
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                152<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                18年8月
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;"></span><span style="font-size: 10px;">非刘海屏，轻薄，但屏下指纹比较菜而且电池少</span><br/>
            </td>
        </tr>
        <tr>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                IQOO Neo<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                1998<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                高通845
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                6+128<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                4500
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                22.5
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                8.13
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                198.5
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                19年7月
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                和k20一样很厚而且很重，有水滴屏，电池容量非常大
            </td>
        </tr>
        <tr>
            <td width="55" valign="top" style="word-break: break-all;">
                荣耀V20
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                2099<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                麒麟980
            </td>
            <td valign="top" colspan="1" rowspan="1" width="55" style="word-break: break-all;">
                6+128
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                4000<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                22.5<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                8.1<br/>
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                180
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                18年12月
            </td>
            <td width="55" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">最便宜的980，但非常不建议，背板有点丑，打孔屏而且前置摄像头旁容易发黄</span>
            </td>
        </tr>
    </tbody>
</table>

<h2 id="3000以上"><a href="#3000以上" class="headerlink" title="3000以上"></a>3000以上</h2><table>
    <tbody>
        <tr class="firstRow">
            <td width="63" valign="top" style="word-break: break-all;"></td>
            <td width="63" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    处理器
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    内存
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    电池容量/mAH
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    充电功率/W
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    厚度/mm
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    重量/g
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    发布时间
                </p>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <p>
                    评价
                </p>
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                魅族16sPro
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                3099
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                骁龙855plus
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8+128（UFS3.0）<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                3500
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                刚出，网上还没有数据<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                7.65<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                166<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年08月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">最便宜的855+手机，</span><span style="font-size: 10px;">性价比最高</span>
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                一加7pro<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                4499
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                骁龙855
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8+256（UFS3.0）
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                4000<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                30
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8.8<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                206
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年05月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">安卓阵营最强屏幕，2K90Hz高清高刷新率，充电快，美中不足的是855而不是855+。</span>
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                华为P30<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                3688
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                麒麟980
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                6+128
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                4000<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                标配充电头22.5<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                7.57
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                165
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年04月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">安卓阵营拍照最强手机之一，4000万像素徕卡三摄，5倍光学变焦30倍数码变焦，支持204800ISO超高感光率。</span>
            </td>
        </tr>
        <tr>
            <td width="63" valign="top" style="word-break: break-all;">
                iQOO Pro
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                3798<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                骁龙855plus
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                8+128（UFS3.0）
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                4500<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                44
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                9.325<br/>
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                215
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                19年08月
            </td>
            <td width="63" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">充电快，但是厚度和重量你也看到数据了。</span>
            </td>
        </tr>
    </tbody>
</table>
<p>
    <br/>
</p>

<hr>
<h1 id="充电宝"><a href="#充电宝" class="headerlink" title="充电宝"></a>充电宝</h1><table width="784">
    <tbody>
        <tr class="firstRow">
            <td width="72" valign="top"></td>
            <td width="72" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                容量/mAH<br/>
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                充电功率/W
            </td>
            <td valign="top" colspan="1" rowspan="1" width="72">
                电芯类型
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                电芯品牌<br/>
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                重量/g
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                评价<br/>
            </td>
        </tr>
        <tr>
            <td width="72" valign="top" style="word-break: break-all;">
                小米移动电源3
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                199<br/>
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                20000
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                45（PD）
            </td>
            <td valign="top" colspan="1" rowspan="1" width="72">
                聚合物软包
            </td>
            <td width="72" valign="top">
                ATL<br/>
            </td>
            <td width="72" valign="top">
                439
            </td>
            <td width="72" valign="top">
                需要快充可以无脑上这个，可以为一些新的笔记本供电
            </td>
        </tr>
        <tr>
            <td width="72" valign="top">
                AKER a1275<br/>
            </td>
            <td width="72" valign="top">
                398<br/>
            </td>
            <td width="72" valign="top">
                20000
            </td>
            <td width="72" valign="top">
                22.5（PD）<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" width="72">
                18650
            </td>
            <td width="72" valign="top">
                松下
            </td>
            <td width="72" valign="top">
                360
            </td>
            <td width="72" valign="top">
                体积小而且比较轻
            </td>
        </tr>
        <tr>
            <td width="72" valign="top">
                紫米QB910
            </td>
            <td width="72" valign="top">
                149<br/>
            </td>
            <td width="72" valign="top">
                10000<br/>
            </td>
            <td width="72" valign="top">
                18（PD）
            </td>
            <td valign="top" colspan="1" rowspan="1" width="72">
                聚合物软包
            </td>
            <td width="72" valign="top">
                力神
            </td>
            <td width="72" valign="top">
                205
            </td>
            <td width="72" valign="top">
                小巧而且有颜值
            </td>
        </tr>
    </tbody>
</table>
<p>
    <br/>
</p>

<hr>
<h1 id="平板"><a href="#平板" class="headerlink" title="平板"></a>平板</h1><table width="-95">
    <tbody>
        <tr class="firstRow">
            <td width="72" valign="top"></td>
            <td width="72" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                屏幕大小/英寸
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                处理器
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                屏幕分辨率
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                厚度
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                重量
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                评价
            </td>
        </tr>
        <tr>
            <td width="72" valign="top" style="word-break: break-all;">
                小米平板4
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                1199
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                8
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                高通660
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                1080p
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                7.9
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                342
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">千元的话基本只能选择这个了，但性能太弱不适合玩游戏，基本只能看剧和上网冲浪</span>
            </td>
        </tr>
        <tr>
            <td width="72" valign="top" style="word-break: break-all;">
                华为M6
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                1999
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                8.4
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                麒麟980
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                2k
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                7.4
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                320
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                系统优化不错，办公和购物非常方便，安卓阵营推荐这个
            </td>
        </tr>
        <tr>
            <td width="72" valign="top" style="word-break: break-all;">
                华为M6
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                2299
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                10.8
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                麒麟980
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                2k
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                7.2
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                496
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                同上
            </td>
        </tr>
        <tr>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                iPad mini5
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                2799
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                7.9
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                A12
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                比1080P稍大
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                6.1
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                300.5
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                最便宜的A12机器（最强游戏机），打游戏的话买爆<br/>
            </td>
        </tr>
        <tr>
            <td width="72" valign="top" style="word-break: break-all;">
                iPad Air3&nbsp;<br/>
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                3577
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                10.5
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                A12
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                接近2k
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                6.1
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                456
            </td>
            <td width="72" valign="top" style="word-break: break-all;">
                适合学习/做笔记/看剧
            </td>
        </tr>
    </tbody>
</table>

<blockquote>
<p>价格仅供参考，内存建议和选手机一样，6+128起步。</p>
</blockquote>
<hr>
<h1 id="U盘"><a href="#U盘" class="headerlink" title="U盘"></a>U盘</h1><p>
    <br/>
</p>
<table>
    <tbody>
        <tr class="firstRow">
            <td width="119" valign="top"></td>
            <td width="119" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                容量G
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                读取速度/MB/s
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                写入速度/MB/s
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                评价
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                闪迪DDC2至尊高速
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                59
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                32
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                130<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                30
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">性价比不错，适合学生党人手一个，比竟大学有个U盘放重要资料还是挺需要的（我经常遇到同学找我帮忙恢复电脑里的数据，如果懒得放网盘可以放U盘）</span>
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                闪迪CZ73<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                69<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                64
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                150
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                60到90（4k对齐后速度有所提升）
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">性价比不错，但是速度可能不稳定</span>
            </td>
        </tr>
        <tr>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                闪迪CZ800
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                149
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                64
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                200
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                130
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                速度快
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                闪迪CZ880
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                279
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                128
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                400
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                300左右
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                需要速度极快而且需要经常拷贝大文件可选
            </td>
        </tr>
    </tbody>
</table>

<h1 id="机械键盘"><a href="#机械键盘" class="headerlink" title="机械键盘"></a>机械键盘</h1><table>
    <tbody>
        <tr class="firstRow">
            <td width="84" valign="top"></td>
            <td width="84" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                键数
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                键帽材质
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                字符工艺
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                轴体品牌
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                背光灯
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                评价
            </td>
        </tr>
        <tr>
            <td width="84" valign="top" style="word-break: break-all;">
                达尔优DK100
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                99
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                87
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                ABS
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                双色注塑
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                达尔优自研
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                无
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                最便宜的机械键盘之一，易油腻，不是很推荐
            </td>
        </tr>
        <tr>
            <td width="84" valign="top" style="word-break: break-all;">
                IKBC C104
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                358
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                104
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                PBT
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                双色注塑
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                樱桃
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                无
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                清爽，简单
            </td>
        </tr>
        <tr>
            <td width="84" valign="top" style="word-break: break-all;">
                富勒G900s纯享版
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                299
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                104
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                PBT
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                双色注塑
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                樱桃
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                无
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">差不多是最便宜的樱桃轴键盘，而且键帽使用晒纹工艺使用手感非常不错（已使用了一年感觉真的不错）</span>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top" style="word-break: break-all;">
                富勒G900s
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                448
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                104
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                PBT
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                双色注塑
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                樱桃
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                单色绿光
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                <span style="font-size: 10px;">相对于纯享版多了一个掌托和背光，还有一个RGB版的但是还要再加一百多</span><br/>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top" style="word-break: break-all;">
                AKKO 3084
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                409
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                84
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                PBT
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                热升华
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                樱桃
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                无
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                蓝牙 外观简朴，但ABS键帽还是容易打油
            </td>
        </tr>
        <tr>
            <td width="84" valign="top" style="word-break: break-all;">
                FILCO圣手二代（有线）
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                1099
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                104
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                ABS
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                未知<br/>
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                樱桃
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                无
            </td>
            <td width="84" valign="top" style="word-break: break-all;">
                也是ABS键帽，但是有类肤涂层可能手感不错<br/>
            </td>
        </tr>
    </tbody>
</table>
<p>
    <br/>
</p>

<h1 id="游戏鼠标"><a href="#游戏鼠标" class="headerlink" title="游戏鼠标"></a>游戏鼠标</h1><table>
    <tbody>
        <tr class="firstRow">
            <td width="119" valign="top"></td>
            <td width="119" valign="top" style="word-break: break-all;">
                价格
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                传感器
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                用途
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                适合人群
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                评价
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                罗技M330
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                97
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                —<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                办公
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                小手
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                静音办公鼠，适合女生（不推荐，原因看下面）
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                蝰蛇标准版（6400DPI）<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                129
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                PAW3328
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                游戏
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                中手/大手
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                入门鼠标，可以轻度游戏
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                罗技G102<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                119<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                水星
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                —<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                小手/中手
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                入门鼠标，可以轻度游戏
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                罗技G403
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                299<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                PMW3366DM
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                游戏
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                中手/大手
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                深度游戏建议这个起步
            </td>
        </tr>
        <tr>
            <td width="119" valign="top" style="word-break: break-all;">
                罗技G502（hero版）
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                349<br/>
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                HERO 16K
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                游戏
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                中手/大手
            </td>
            <td width="119" valign="top" style="word-break: break-all;">
                传感器比G403强，也更适合玩游戏，而且可加配重，但是本身重量也挺重的，看个人取舍
            </td>
        </tr>
        <tr>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                赛睿Rival 310
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                379<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                TureMove3(3360深度定制)
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                游戏
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                中手/大手
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                带RGB（想要灯效好还是需要买雷蛇），橡胶线，不想要罗技的钢丝线可以选这个
            </td>
        </tr>
        <tr>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                卓威 EC2-A/EC-B
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                379/479<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                PMW3360
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                打CSGO<br/>
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                小手/中手
            </td>
            <td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">
                因为滚轮极度不好用所以只能用来打CSGO等不怎么需要滚轮的游戏
            </td>
        </tr>
    </tbody>
</table>
<p>
    <br/>
</p>]]></content>
      <categories>
        <category>数码产品推荐</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>推荐</tag>
        <tag>数码产品</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发之Jetpack：LifeCycle</title>
    <url>/%E5%AE%89%E5%8D%93/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B9%8BJetpack%EF%BC%9ALifeCycle/</url>
    <content><![CDATA[<p>使用LifeCycle的好处</p>
<ul>
<li>帮助开发者建立可感知生命周期的组件</li>
<li>组件在其内部管理自己的生命周期，降低模块耦合度</li>
<li>降低内存泄漏发生的可能性</li>
<li>Activity、Fragment、Service、Application均有LifeCycle支持</li>
</ul>
<span id="more"></span>

<h1 id="解耦页面和组件"><a href="#解耦页面和组件" class="headerlink" title="解耦页面和组件"></a>解耦页面和组件</h1><p>这里使用Chronometer组件进行演示。<br>创建一个自己的MyChronometer类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyChronometer</span> <span class="keyword">extends</span> <span class="title class_">Chronometer</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyChronometer</span><span class="params">(Context context, AttributeSet attributeSet)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attributeSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startMeter</span><span class="params">()</span> &#123;</span><br><span class="line">        setBase(SystemClock.elapsedRealtime() - time);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopMeter</span><span class="params">()</span> &#123;</span><br><span class="line">        time = SystemClock.elapsedRealtime() - getBase();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在布局界面使用这个组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.lifecycle.MyChronometer</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/chronometer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;34sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在activity启动时添加监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyChronometer myChronometer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        myChronometer = findViewById(R.id.chronometer);</span><br><span class="line">        getLifecycle().addObserver(myChronometer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样组件跟activity就已经解耦了，不再需要在activity里管理组件的生命周期</p>
<h1 id="组件与Service解耦"><a href="#组件与Service解耦" class="headerlink" title="组件与Service解耦"></a>组件与Service解耦</h1><p>创建一个定位Service：<br>MyLocationObserver.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.location.Location;</span><br><span class="line"><span class="keyword">import</span> android.location.LocationListener;</span><br><span class="line"><span class="keyword">import</span> android.location.LocationManager;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Lifecycle;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LifecycleObserver;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.OnLifecycleEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLocationObserver</span>  <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> LocationListener locationListener;</span><br><span class="line">    <span class="keyword">private</span> LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLocationObserver</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startGetLocation</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;startGetLocation&quot;</span>);</span><br><span class="line">        locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">        locationListener = <span class="keyword">new</span> <span class="title class_">MyLocationListener</span>();</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class="number">3000</span>, <span class="number">1</span>, locationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopGetLocation</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;stopGetLocation&quot;</span>);</span><br><span class="line">        locationManager.removeUpdates(locationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyLocationListener</span> <span class="keyword">implements</span> <span class="title class_">LocationListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLocationChanged</span><span class="params">(<span class="meta">@NonNull</span> Location location)</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;location changed: &quot;</span> + location.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyLocationService.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LifecycleService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLocationService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLocationService</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;MyLocationService: &quot;</span>);</span><br><span class="line">        <span class="type">MyLocationObserver</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLocationObserver</span>(<span class="built_in">this</span>);</span><br><span class="line">        getLifecycle().addObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在activity里创建两个button：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.two&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">&quot;monospace&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">&quot;startGps&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;开始&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;34sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">&quot;monospace&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">&quot;stopGps&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;停止&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;34sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/button&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在activity加上两个onCLick事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">two</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_two);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopGps</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        stopService(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyLocationService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startGps</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        startService(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyLocationService.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="监听应用程序生命周期"><a href="#监听应用程序生命周期" class="headerlink" title="监听应用程序生命周期"></a>监听应用程序生命周期</h1><p>创建一个ApplicationObserver.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Lifecycle;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LifecycleObserver;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.OnLifecycleEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;onCreate: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;onStart: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;onResume: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;onPause: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;onStop: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;lc&quot;</span>, <span class="string">&quot;onDestroy: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个MyApplication.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ProcessLifecycleOwner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">ApplicationObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在manifest里的application标签添加属性：<code>android:name=&quot;.MyApplication&quot;</code>。<br>至此ApplicationObserver就会监听整个Application，而且Application与Activity无关，只要有一个activity是在运行，application就是onResume之后的状态，所有的activity都onPause那么application也就onPause。</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>安卓</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发之Jetpack：MVVM</title>
    <url>/%E5%AE%89%E5%8D%93/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B9%8BJetpack%EF%BC%9AMVVM/</url>
    <content><![CDATA[<p>这章讲解如何将DataBinding、ViewModel、LiveData一起使用</p>
<span id="more"></span>

<h1 id="篮球比赛计分板"><a href="#篮球比赛计分板" class="headerlink" title="篮球比赛计分板"></a>篮球比赛计分板</h1><p>先创建一个ViewModel，然后加入需要的数据和方法。</p>
<figure class="highlight java"><figcaption><span>DataViewModel.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mvvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.MutableLiveData;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; aTeamScore;    <span class="comment">// a队分数</span></span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; bTeamScore;    <span class="comment">// b队分数</span></span><br><span class="line">    <span class="keyword">private</span> Integer aLast;                          <span class="comment">// a队上一次的分数</span></span><br><span class="line">    <span class="keyword">private</span> Integer bLast;                          <span class="comment">// b队上一次的分数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title function_">getaTeamScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(aTeamScore == <span class="literal">null</span>)&#123;</span><br><span class="line">            aTeamScore = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line">            aTeamScore.setValue(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aTeamScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title function_">getbTeamScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(bTeamScore == <span class="literal">null</span>)&#123;</span><br><span class="line">            bTeamScore = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line">            bTeamScore.setValue(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bTeamScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aTeamAdd</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        saveLastScore();</span><br><span class="line">        aTeamScore.setValue(aTeamScore.getValue() + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bTeamAdd</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        saveLastScore();</span><br><span class="line">        bTeamScore.setValue(bTeamScore.getValue() + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>&#123;</span><br><span class="line">        aTeamScore.setValue(aLast);</span><br><span class="line">        bTeamScore.setValue(bLast);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>&#123;</span><br><span class="line">        aTeamScore.setValue(<span class="number">0</span>);</span><br><span class="line">        bTeamScore.setValue(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录上一次的分数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveLastScore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.aLast = aTeamScore.getValue();</span><br><span class="line">        <span class="built_in">this</span>.bLast = bTeamScore.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@android:color/holo_red_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.aTeamAdd(1)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:shadowColor</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@string/button1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline9&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.423&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.564&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button4&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dip&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorAccent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.bTeamAdd(1)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:shadowColor</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@string/button1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline9&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintVertical_bias</span>=<span class="string">&quot;0.564&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@android:color/holo_red_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.aTeamAdd(2)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:shadowColor</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@string/button2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline10&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline9&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@android:color/holo_red_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.aTeamAdd(3)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:shadowColor</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@string/button3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button6&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorAccent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.bTeamAdd(3)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:shadowColor</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@string/button3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button5&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/colorAccent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.bTeamAdd(2)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:shadowColor</span>=<span class="string">&quot;@android:color/background_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@string/button2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline10&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline9&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageButton&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/undoButton&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.undo()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline12&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/ic_undo_black_24dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageButton2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/resetButton&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;()-&gt;viewModel.reset()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline12&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">&quot;0.2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/ic_refresh_black_24dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Team A&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;@dimen/teamTextSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline7&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Team B&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;@dimen/teamTextSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline7&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/scoreA&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;String.valueOf(viewModel.getaTeamScore())&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;@android:color/holo_red_light&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;@dimen/scoreTextSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline7&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;120&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/scoreB&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;@&#123;String.valueOf(viewModel.getbTeamScore())&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;@color/colorAccent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;@dimen/scoreTextSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline7&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline4&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_end</span>=<span class="string">&quot;-220dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline7&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.15&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.35&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline9&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline10&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.65&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline11&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline12&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.9&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.mvvm.MyViewModel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Activity的onCreate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="type">ActivityMainBinding</span> <span class="variable">mainBinding</span> <span class="operator">=</span> DataBindingUtil.setContentView(<span class="built_in">this</span>, R.layout.activity_main);</span><br><span class="line">    <span class="type">MyViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>.AndroidViewModelFactory(getApplication())).get(MyViewModel.class);</span><br><span class="line">    mainBinding.setViewModel(viewModel);</span><br><span class="line">    mainBinding.setLifecycleOwner(<span class="built_in">this</span>);        <span class="comment">// 监听数据变化，实时改变数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用setLifecycleOwner就不需要自己写observe来监听数据变化，还能实现数据双向绑定。</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>安卓</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发之Jetpack：ViewModel</title>
    <url>/%E5%AE%89%E5%8D%93/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B9%8BJetpack%EF%BC%9AViewModel/</url>
    <content><![CDATA[<p>ViewModel的诞生</p>
<ul>
<li>瞬态数据丢失（比如屏幕旋转）</li>
<li>异步调用的内存泄漏</li>
<li>类膨胀提高维护难度和测试难度</li>
</ul>
<p>ViewModel负责把Model中的数据提供给View</p>
<span id="more"></span>

<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><p>先编写一个简单的演示<br>MyViewModel.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.viewmodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>布局xml，一个textview显示数量，一个button用来加一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;34sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">&quot;plusNumber&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;+1s&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>入口java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.viewmodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> MyViewModel viewModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        viewModel = <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>.AndroidViewModelFactory(getApplication())).get(MyViewModel.class);</span><br><span class="line">        textView.setText(String.valueOf(viewModel.number));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">plusNumber</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        textView.setText(String.valueOf(++viewModel.number));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="生命周期特性"><a href="#生命周期特性" class="headerlink" title="生命周期特性"></a>生命周期特性</h1><p>ViewModel独立于配置变化，生命周期与activity生命周期无关</p>
<blockquote>
<p>注意：不要向ViewModel中传入Context，会导致内存泄漏。如果要使用Context，请使用AndroidViewModel中的Application</p>
</blockquote>
<p>比如上面的MyViewModel.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.viewmodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.AndroidViewModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">AndroidViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewModel</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@org</span>.jetbrains.annotations.NotNull Application application)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(application);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>安卓</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>蹲坑读物系列</title>
    <url>/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>为了方便给后来进群的同学查看进群前的分享信息，在这里记录一下历史分享信息</p>
<span id="more"></span>

<h1 id="目录导航"><a href="#目录导航" class="headerlink" title="目录导航"></a>目录导航</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#C-C">C 语言</a></p>
<h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><p><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#Java">java</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#Golang">golang</a></p>
<h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><p><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#Javascript-Typescript">JavaScript 、Typescript</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#Vue">Vue</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#React">Vue</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3">前端相关</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3">开发相关</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#Git">Git</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95">数据结构和算法</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E5%B7%A5%E5%85%B7">工具</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">开源项目</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E5%85%B6%E4%BB%96%E6%9C%AA%E5%88%86%E7%B1%BB">未分类</a><br><a href="/%E5%B9%B2%E8%B4%A7/%E5%BC%80%E5%8F%91%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/#%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB">文件分享</a></p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/lFGIH2mk7y4HhtapUmtSZQ">C 语言 printf() 详解之终极无惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/PX9pCVHWrZsu7TokarxtTA">C 语言必须写 main 函数？最简单的 Hello world 你其实一点都不懂！</a></li>
<li><a href="https://mp.weixin.qq.com/s/TwDiDmApmsIVSIFh2h1osQ">C 语言指针-从底层原理到花式技巧，用图文和代码帮你讲解透彻</a></li>
<li><a href="https://mp.weixin.qq.com/s/i9p88bjb_sgKHCsCc94y-w">C 语言 | 函数执行成功时，return 1 还是 return 0？</a></li>
<li><a href="https://mp.weixin.qq.com/s/9xoL92pRwfMgsFLgKq37BA">不懂指针类型，8 个例子给你讲明白</a></li>
<li><a href="https://mp.weixin.qq.com/s/vBHDa5-vqRUYvu-2J8jB_w">C++入口不是 main？知乎上打起来了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/-RG2y2dGzYNLD7YNrBCRwQ">面试官问:malloc(0)时程序会返回什么？！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Hftu0FXRtIkZ8ulurm6k6Q">同事 C 代码中的#、##把我秀了~</a></li>
<li><a href="https://mp.weixin.qq.com/s/BUB1PmiE4E7FjzOnnM13pw">一篇很棒的 C 语言入门笔记，推荐收藏！</a></li>
<li><a href="https://mp.weixin.qq.com/s/HaNDp7qNeMAqlKdMScb3Bg">利用 Makfile 给多文件、多目录 C 源码建立工程</a></li>
<li><a href="https://mp.weixin.qq.com/s/foQcxDODsPfW_7bVAWBxWg">写了一段“高端”C 语言代码</a></li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/JH6IF-EiPpelTv6ixB-ODg">Java8 Stream 数据流，大数据量下的性能效率怎么样？</a></li>
<li><a href="https://mp.weixin.qq.com/s/cban7sJW4jXSgbcnf366VQ">还在手动部署 springboot 项目？不妨试试它，让你部署项目飞起来！</a></li>
<li><a href="https://mp.weixin.qq.com/s/4EfuvEfkvXlJpzXCzXwo8Q">PO,VO,DAO,BO,POJO 之间的区别你懂吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/DRYcjLYvS9Tca0PW6funFw">Spring Boot 切面 AOP 实现权限校验（实例演示与注解全解）</a></li>
<li><a href="https://segmentfault.com/a/1190000040038334">卷不动了？300 秒快速了解 Java 9 - 16 新特性，助你脱离内卷</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZjOVGy0uVze3vAQEUYHnlw">一款基于 Spring Boot 的 BBS 系统，APP 和后台管理齐全，拿来即用</a></li>
<li><a href="https://mp.weixin.qq.com/s/0U8t-iGgq_qznONZ3wT6Uw">Spring Boot + MyBatis + MySQL 读写分离</a></li>
<li><a href="https://mp.weixin.qq.com/s/o0-u-DBzx8LWib5_AvCj4Q">SpringBoot 集成 Shiro 极简教程（实战版）</a></li>
<li><a href="https://mp.weixin.qq.com/s/E8rHQWfSKqBupIo23oj6JA">一个注解搞定 Spring Boot 接口防刷</a></li>
<li><a href="https://mp.weixin.qq.com/s/vYA1cL79yzUzhaqFNyvmiw">如何把 Spring Boot 的 Jar 包做成 exe？</a></li>
<li><a href="https://mp.weixin.qq.com/s/LtXPdM9OOSlGypqCd5Asmw">你还在用分页？试试 MyBatis 流式查询！</a></li>
<li><a href="https://mp.weixin.qq.com/s/0Z1An7hf1e3_b6MQYwM3nA">强烈不建议你用 a.equals(b) 判断对象相等！</a></li>
<li><a href="https://mp.weixin.qq.com/s/HFQXadkkQnRkyuOlqQ8FBg">同事用单例模式花式实现雪花算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/ELkPdWhO3jWO404Jbiljlw">让 SpringBoot 不再需要 Controller、Service、Mapper，这款开源工具绝了！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/-hlB-3KgJiVnQN6b-ToSNw">Guava RateLimiter 实现 API 限流，这才是正确的姿势！</a></li>
<li><a href="https://mp.weixin.qq.com/s/X-WPNQDTgeiDOoQJghANHw">朋友问我单例模式是什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/jq7ec7jXxIvCTX57EMjMvA">面试官：啥是适配器模式？</a></li>
<li><a href="https://mp.weixin.qq.com/s/nQG_FJXJmi5Q4201T-dadw">第十篇！组合模式</a></li>
<li><a href="https://mp.weixin.qq.com/s/9p8-Ps5pYI-uQVz1i43NCA">装饰模式，不难！</a></li>
<li><a href="https://mp.weixin.qq.com/s/jOuscF3Hx-jlhmT4K81vkQ">1024，我还在啃外观模式！</a></li>
<li><a href="https://mp.weixin.qq.com/s/FW_bHx9SmM0obKXAGg46jQ">常见的代理模式</a></li>
<li><a href="https://mp.weixin.qq.com/s/qg0ISx44-9vfIWNzWqz4QQ">Spring 中的 AOP！</a></li>
<li><a href="https://mp.weixin.qq.com/s/amyAf5mr9k9qhpF28cflmg">原创|MybaitsPlus 快速入门教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/BvOzzcc2L9PUb4oXl4mxkw">聊聊 Spring 数据库开发</a></li>
<li><a href="https://mp.weixin.qq.com/s/VTkA3DXtawc11ZNxdrNYtA">Spring 事务还能这样管理？</a></li>
<li><a href="https://mp.weixin.qq.com/s/QfvUrG789jr8UY28KQHFNA">老师问我 Spring MVC 的工作流程</a></li>
<li><a href="https://mp.weixin.qq.com/s/Y90LGtJAn4G5hbx3pkosGg">几行烂代码，我赔了 16 万。</a></li>
<li><a href="https://mp.weixin.qq.com/s/3vV5i-5DLlKCP4TWioyzwA">分享 | 后端必会的 Spring MVC 核心类和注解</a></li>
<li><a href="https://mp.weixin.qq.com/s/MEtoC9FWL5Pr_WILeCrWdw">SpringBoot 居然有 44 种应用启动器</a></li>
<li><a href="https://mp.weixin.qq.com/s/pV5iKnMUw-jqqQZ7Jcdr3A">头条三面：toString()、String.valueOf、(String)强转，有啥区别？</a></li>
<li><a href="https://mp.weixin.qq.com/s/MKb9le7zLcwn7IWJ_vtGAw">使用 SpringBoot Operator 部署 Spring Boot 到 K8S</a></li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyNjE0MDI1NQ==&action=getalbum&album_id=2113998463406227457&scene=173&from_msgid=2247486597&from_itemidx=2&count=3&nolastread=1#wechat_redirect">死磕算法系列，包括《剑指 offer》、leetcode 等等</a></li>
<li><a href="https://mp.weixin.qq.com/s/GqHwIxGYRpRqr0Qalx4VXQ">为什么不推荐使用 BeanUtils 属性转换工具</a></li>
<li><a href="https://mp.weixin.qq.com/s/DhddlRkI3vbrYzXeGuvRLA">SpringBoot 巧用 @Async 提升 API 接口并发能力！</a></li>
</ul>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/JkTVv52WZXhP3KDH1eNLPg">面试官：如何避免 Go 变量被 GC？</a></li>
<li><a href="https://mp.weixin.qq.com/s/v3VUU_lp9z_FJYz9Z0xWjQ">10 年 Java 经验，转行 Go 的 7 个理由</a></li>
<li><a href="https://mp.weixin.qq.com/s/3gwYPLwbEPjAkye4kJfwzg">Go 语言中的零拷贝优化</a></li>
<li><a href="https://mp.weixin.qq.com/s/0q0k8gGX56SBKJvfMquQkQ">漫谈 Go 语言编译器（01）</a></li>
<li><a href="https://mp.weixin.qq.com/s/e8sUwTBfgzXdCXd3ViCNdw">在 Go 中如何用 Redlock 实现分布式锁呢？</a></li>
<li><a href="https://mp.weixin.qq.com/s/pfYTRuJSw5Pkm6Co9bawhw">全面讲解 Go 中的 interface{}</a></li>
<li><a href="https://mp.weixin.qq.com/s/YB_mBJMAmRruNrb4NPy8sw">Go select 竟然死锁了</a></li>
<li><a href="https://mp.weixin.qq.com/s/Je03lXgyO9dVY8oHhPwKjg">Go 与 C 的指针</a></li>
<li><a href="https://mp.weixin.qq.com/s/mc0B2ZLBIMXD-og-HThHOw">Golang 泛型要来了吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/oITEzd4ynUVAzSfUAo-71g">有趣的面试题：Go 语言中 nil 的比较结果</a></li>
<li><a href="https://mp.weixin.qq.com/s/jDRHKRZa3NcezBbF4xk8ww">使用 context、WaitGroup 优雅处理 goroutine</a></li>
<li><a href="https://mp.weixin.qq.com/s/MWe5EsAYpU7F-FuXrbfFYA">在 Go 容器里设置 GOMAXPROCS 的正确姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s/zm5rp4DkgrWIduZAMhzNzA">Go 语言内存逃逸之谜</a></li>
<li><a href="https://mp.weixin.qq.com/s/ciAQo0bgjFd3Ktq9ryYecQ">如何组织 Go 代码？Go 作者的回答惊呆了</a></li>
<li><a href="https://mp.weixin.qq.com/s/T83QgMGrheGdB0_7lwpZ4w">Go：环境变量知多少？</a></li>
<li><a href="https://mp.weixin.qq.com/s/6aEV4qY6KvL7nb1P8Nwkow">Go interface 原理剖析：类型转换</a></li>
<li><a href="https://mp.weixin.qq.com/s/SPu0uOcQR8utrsRkoCrP-w">Go1.18 快讯：新增的 Cut 函数太方便了</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZJvGqPYbudzjd8KcAozA_A">一定记住，Go 中不要犯这 5 个错误</a></li>
<li><a href="https://mp.weixin.qq.com/s/4P1jRbvCH8NTyNFROrZGmQ">一个 Go 方法，五种变换</a></li>
<li><a href="https://mp.weixin.qq.com/s/_RPPsUQuZdrsPdzw4OJPTg">Go 如何利用 Linux 内核的负载均衡能力？</a></li>
<li><a href="https://mp.weixin.qq.com/s/7rCsaGy8B2lwbZ4duEC7Nw">命中率极高的 Go 面试题，赶紧收藏！</a></li>
<li><a href="https://mp.weixin.qq.com/s/gc34RYqmzeMndEJ1-7sOwg">性能优化 | Go Ballast 让内存控制更加丝滑</a></li>
<li><a href="https://mp.weixin.qq.com/s/Pwg8QK1FqSMsNSA4SahPTQ">用手写一个工具的过程讲清楚 Go 反射的使用方法和应用场景</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&mid=2247485929&idx=1&sn=f1587865cf4d49a28b57d09fd2895eef">Go 工程师必学 – 信号量的原理与使用</a></li>
<li><a href="https://mp.weixin.qq.com/s/1ozBAEYpf07aei0xh3_kNQ">Go 常见错误集锦 | 字符串底层原理及常见错误</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&mid=2247485933&idx=1&sn=9dee187b13c1bd3953d41472f243f4c3">在 Go 中创建 CLI 应用，就用 Cobra 神器</a></li>
<li><a href="https://mp.weixin.qq.com/s/XdRe_yOiFGI8NiR9eWLEoQ">万字长文：Go error 处理最佳实践</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&mid=2247485937&idx=1&sn=b7dede971a9b219a4542b5aa9df7976b">图解 Go 运行时调度器，原来这么简单</a></li>
<li><a href="https://mp.weixin.qq.com/s/5XMmVqdcji8jpRnC2p0F3w">什么是 Go runtime.KeepAlive?</a></li>
<li><a href="https://mp.weixin.qq.com/s/jsU2DoUSk2-7g1giOClfXQ">Go 源码里的这些 &#x2F;&#x2F;go: 指令，你知道吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/PkOYRAoJyemMe5LGb-_eQA">Go 编程模式：详解函数式选项模式</a></li>
<li><a href="https://mp.weixin.qq.com/s/9yLd7kkYzmbCriolhbvK_g">Go 程序崩了？煎鱼教你用 PProf 工具来救火！</a></li>
<li><a href="https://mp.weixin.qq.com/s/mH51UmolTqCAb7E0LxEjDA">Go 读者提问：值为 nil 能调用函数吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/nLwUS47e6ZL7Yi8kwLXzmg">Go 实现一个简单而强大的反向代理</a></li>
<li><a href="https://mp.weixin.qq.com/s/g_LpPZPO_vhF6ZFhLd3TSA">必看！6 步入门 Go</a></li>
<li><a href="https://mp.weixin.qq.com/s/IFwyg14raR4HJa5Y_pYMcw">Go：最简单的服务响应时长优化方法，没有之一</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&mid=2247485976&idx=1&sn=875b8ae41e9c5076af859b2132dd0079">Google：12 条 Golang 最佳实践</a></li>
<li><a href="https://mp.weixin.qq.com/s/UcuKgKnt4fwrg3c-UHc3sw">「GoCN 酷 Go 推荐」go 语言位操作库 — bitset</a></li>
<li><a href="https://mp.weixin.qq.com/s/XY6sPZQcDa27JdXMNptJvA">『每周译 Go』Rust 与 Go: 为何相得益彰</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&mid=2247485981&idx=1&sn=642d7032ff216b3b57b0f0b6def801bb">深度细节 | Go 的 panic 秘密都在这</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&mid=2247485903&idx=2&sn=105889ef603c38098f3b337a6b089452">Go 面试题 013：Go 中闭包的底层原理是？</a></li>
<li><a href="https://mp.weixin.qq.com/s/TDIM1tspIEWpQCH_SNGnog">从 CPU 角度理解 Go 中的结构体内存对齐</a></li>
<li><a href="https://mp.weixin.qq.com/s/JCmIxaHmmIS-mPLW6AYT9Q">吹爆这个 Go 语言万能的通道编程公式</a></li>
</ul>
<h2 id="Javascript-x2F-Typescript"><a href="#Javascript-x2F-Typescript" class="headerlink" title="Javascript &#x2F; Typescript"></a>Javascript &#x2F; Typescript</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/Do8lTY9j0IB5PGZe0rQj8Q">JavaScript 中的函数式编程</a></li>
<li><a href="https://mp.weixin.qq.com/s/F37dMLXqR1nS54vLzVR-JA">34 个 JavaScript 简写优化技术</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQXJCM_RW9gbke5NptBlqA">不一样的 JavaScript</a></li>
<li><a href="https://mp.weixin.qq.com/s/hDM8mrNp2R6P5YTAydTfAA">这 JavaScript 闭包把我的学妹气哭了，学妹的苦衷！</a></li>
<li><a href="https://mp.weixin.qq.com/s/DfJN6vvSzySYwppzRsMhTg">如何写出干净的 JavaScript 代码</a></li>
<li><a href="https://mp.weixin.qq.com/s/vVw61YGYwfbSVBxlz1Yqlg">面试官：说说你对 TypeScript 中类的理解？应用场景？</a></li>
<li><a href="https://mp.weixin.qq.com/s/c7p4IbGKjKqifVNmErU0Mw">比同事更秀? TS 这 7 个方法，你需要知道的！</a></li>
<li><a href="https://mp.weixin.qq.com/s/ognHGg6ptHmvWOWb9B4bPw">Node.js 底层原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/c9SwF1VgM_9c8dT1QfB2VA">这 6 个 TS 新特性经常用到，用了之后我再也离不开它！</a></li>
<li><a href="https://mp.weixin.qq.com/s/UrkSxuhcKzAjul5-KSiWKg">ES6 面试、复习干货知识点汇总</a></li>
<li><a href="https://mp.weixin.qq.com/s/P242wprG9xUiGwqxBwn8cg">常见的数组基本用法</a></li>
<li><a href="https://mp.weixin.qq.com/s/2kDURi-4TkShsfFLA9s76Q">ES6 中对象新增扩展盘点</a></li>
<li><a href="https://mp.weixin.qq.com/s/zbPh2rwdl-YofZZQcOVzNg">该来的还是来了，盘点 ES12 中有新特性！</a></li>
<li><a href="https://mp.weixin.qq.com/s/9MAKi2NDVF67i-XQ5rYdVw">什么是 Promise.allSettled() ！新手老手都要会？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Acg4p72r14rP7Jhqc06gRQ">一文彻底读懂 ESLint</a></li>
<li><a href="https://mp.weixin.qq.com/s/KWk6JUzRrppX8MiO8CmefQ">你会用 ES6，那倒是用啊！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Jgr72y1pV7qu4bIiRkqSWQ">TS 类这十个知识点你都掌握了么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/LT15xiU13NFG5bmdHTAIRw">你不知道的 TypeScript 泛型</a></li>
<li><a href="/%E5%89%8D%E7%AB%AF/js%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9Athis%E6%8C%87%E5%90%91/">js 核心知识进阶笔记：this 指向</a></li>
<li><a href="https://mp.weixin.qq.com/s/aHRn0HPmyRTKGYB9_PygVg">这些 JavaScript 细节，你未必知道</a></li>
<li><a href="https://mp.weixin.qq.com/s/i-FpapDtMy7izBRIGZZgEQ">【JS】1150- 如何写出更优雅的 JavaScript 代码</a></li>
<li><a href="https://mp.weixin.qq.com/s/HS0fwQFOrDRE28MrpLJaQA">未来让人看不懂的那些 JavaScript 语法</a></li>
<li><a href="https://mp.weixin.qq.com/s/tYYAh2zfoZuN11RWMkXtMg">面试官：能不能手写一个 Promise？</a></li>
<li><a href="https://mp.weixin.qq.com/s/yKMHb30LWZC8TM4Ge5rSGQ">[面试] 考验你对 Promise 的熟度之进阶应用题</a></li>
<li><a href="https://mp.weixin.qq.com/s/8tJb3Tpw8XVEQbh3vN-Fow">使用 JavaScript 进行数据分组最优雅的方式</a></li>
<li><a href="https://juejin.cn/post/7043348598595158030">给你一个可以中断的 Promise</a></li>
<li><a href="https://mp.weixin.qq.com/s/DPtqJVI2GanL7Hmr9S_Y4A">【Babel】1186- 保姆级教学！这次一定学会 Babel 插件开发！</a></li>
<li><a href="https://mp.weixin.qq.com/s/uIkeydRZnqS-tjoDD1T0Tg">【Web 技术】192- JS 社区臭名昭著的一个问题</a></li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/D9csJDQLAUfzx_76QzuQnw">25 个 Vue 技巧，开发了 5 年了，才知道还能这么用</a></li>
<li><a href="https://mp.weixin.qq.com/s/oDxAANZ9-Ni7ks-sh_3zmQ">用这招监听 Vue 的插槽变化</a></li>
<li><a href="https://mp.weixin.qq.com/s/sWZn41_Fs-zD9OLQGzZ3Sg">史上最全 Vue 前端代码风格指南</a></li>
<li><a href="https://mp.weixin.qq.com/s/lXtWoHpBki83BAogGccDqA">揭秘 Vue.js 九个性能优化技巧</a></li>
<li><a href="https://www.jianshu.com/p/cfe25e757d0e">全面解析 Vue3 Reactive 家族和 Ref 家族 API</a></li>
<li><a href="https://mp.weixin.qq.com/s/o2i19azCkSBTlAr-I1cAAQ">【总结】1132- 在 Vue 中为什么不推荐用 index 做 key</a></li>
<li><a href="https://mp.weixin.qq.com/s/cxWw-LX1CA2_wKLLanETjA">【总结】1143- 10 个建立和维护大型 Vue.js 项目的最佳实践</a></li>
<li><a href="https://mp.weixin.qq.com/s/PtrrjMxo9una8m7WKf4hfA">分享 8 个非常实用的 Vue 自定义指令</a></li>
<li><a href="https://mp.weixin.qq.com/s/loCsMYMVpGT5IvqHfuEJTw">【前车之鉴】Vue，你真的熟练了么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/CV6rz73IA-tTI5JAPnJM5Q">Keep-alive 缓存及其缓存优化原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/wZfK_k2oMpLOk62Esh0UGA">【Vuejs】1156- 聊聊 vue 中的 keep-alive</a></li>
<li><a href="https://mp.weixin.qq.com/s/aME6gP4d6TgN5JPUiyHW9g">详解 30 道 Vue 面试题（建议收藏）</a></li>
<li><a href="https://mp.weixin.qq.com/s/spTZ-Ga6LS82onP9TE7xOA">做好这 16 个方向，逐步搭建出团队的 vue3 前端架构</a></li>
<li><a href="https://mp.weixin.qq.com/s/mPR-aiEhht76KjfIkCW_qA">研究大佬用 Vue 写的倒计时组件，学到了不少东西</a></li>
<li><a href="https://mp.weixin.qq.com/s/BujIaBnPS5QrVJE_Yh0Xqg">手摸手教你封装几个 Vue3 中很有用的组合式 API</a></li>
<li><a href="https://mp.weixin.qq.com/s/mBTxBtlZh05Iduli5JTWNQ">【Web 技术】1173- 用了这么久的 require，你真的懂它的原理吗？</a></li>
</ul>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ul>
<li><a href="https://juejin.cn/post/7035628270439809055">探索 React 源码：初探 React fiber</a></li>
<li><a href="https://juejin.cn/post/7040030267636973605">探索 React 源码：React Diff</a></li>
</ul>
<h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/LSAo2wvmP78gQx3oe7DDoA">5 个不常提及的 HTML 技巧</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZBbNzAnlCl6o8fsZ242AbQ">从 10 多秒到 1.05 秒！前端性能优化实践</a></li>
<li><a href="https://mp.weixin.qq.com/s/wI-_69GV3r55EMG-DaTNUA">应用性能前端监控，字节跳动这些年经验都在这了</a></li>
<li><a href="https://mp.weixin.qq.com/s/K_FhwpgQTXDIS0qsKTq9_Q">学姐叫我看 CSS 新出的容器查询，然后把公共组件重构成响应式的！</a></li>
<li><a href="https://mp.weixin.qq.com/s/B3vVLzkgt8TAcTtMgFeHqg">现代 Web CI&#x2F;CD 系统的搭建</a></li>
<li><a href="https://mp.weixin.qq.com/s/ECQAxwAXISumKddHeyOIKw">谈谈我这些年对前端框架的理解</a></li>
<li><a href="https://mp.weixin.qq.com/s/ABsHQVp7plY75OSAmINXYA">不常见但是有用的 Chrome 调试技巧</a></li>
<li><a href="https://mp.weixin.qq.com/s/IAWStFP2cCRa4es6liiAFA">灵感 | 12 组简单网页对话框设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/dKB8FG7zZWUqds5IKMr8KA">使用 Performance 看看浏览器在做些什么</a></li>
<li><a href="https://mp.weixin.qq.com/s/tCEsdLMdurcaVg7eOd5Iog">如何创建可扩展和可维护的前端架构</a></li>
<li><a href="https://mp.weixin.qq.com/s/wWXow0FN8_-qRbSvuRR_cQ">【Web 技术】1130- 有趣的二维码</a></li>
<li><a href="https://mp.weixin.qq.com/s/Hd_-uRmhC_1iUwf23T1u_A">Microsoft Edge：你不能不知道的 6 个 Web 开发者工具</a></li>
<li><a href="https://mp.weixin.qq.com/s/U8Y_9erztwIr0Nve3mbOYA">【总结】1135- 图解虚拟 DOM 之 DIff 算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/TTYttwmdpoVxPkT120-HxA">当通用优化已完成，我们应该做什么？ — 飞书文档移动端优化实践</a></li>
<li><a href="https://mp.weixin.qq.com/s/kYSs3jiSZ6xxrrLemH1ZaQ">关于 Web Component</a></li>
<li><a href="https://mp.weixin.qq.com/s/248pCavOjAQYr_u6OTJvNg">【优化】1141- 网页渲染性能优化 —— 渲染原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/BPHYIA34M_orajhUzufU9w">「前端基建」带你在 Babel 的世界中畅游</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&mid=2247490940&idx=1&sn=72511a0795a954bbaa0125b2cbb42751">2021 年你需要知道的 CSS 工程化技术</a></li>
<li><a href="https://mp.weixin.qq.com/s/Xm323TiYCvQ2fEforpWt1w">【Web 技术】1159- 浅析 Web 录屏技术方案与实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/BmH2_BZAI7UveDFPTo5b4g">2021 年在 Web 领域有哪些关键进展？</a></li>
<li><a href="https://mp.weixin.qq.com/s/9qv6lShXSAw9424ApGvAvQ">Twitter 和微博都在用的 @ 人的功能是如何设计与实现的？</a></li>
<li><a href="https://mp.weixin.qq.com/s/N-gPNUE7gAJQLrOfnYIYfg">微前端 x 重构实践落地总结</a></li>
<li><a href="https://mp.weixin.qq.com/s/DiEuJa8QXt2Ne2DJRW7NIA">当 Vite 遇上微前端</a></li>
<li><a href="https://juejin.cn/post/7051783671455416351">探讨一下 To C 营销页面服务端渲染的必要性以及其背后的原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/ADw-MOrRco2bxGgOraFGzw">LPL Ban&#x2F;Pick 选人阶段的遮罩效果是如何实现的？</a></li>
</ul>
<h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjU5NjEwMA==&mid=2247503225&idx=1&sn=114089c430d1fd940ebfee7f19749a31">傻傻分不清之 Cookie、Session、Token、JWT</a></li>
<li><a href="https://mp.weixin.qq.com/s/73aJLxU-rlpo9zxpQl2rpA">1 分钟带你认识从 “�” 到 “锟斤拷”</a></li>
<li><a href="https://mp.weixin.qq.com/s/Qf4AUlRHr4bvmIIsDRaw9Q">八幅漫画理解使用 JWT 设计的单点登录系统</a></li>
<li><a href="https://mp.weixin.qq.com/s/I69v_lX-Wx7jxx9ddjT2Og">localhost 就一定是 localhost 么?</a></li>
<li><a href="https://mp.weixin.qq.com/s/leE2DgDOl5z90hG2gG1Urw">听说你 ping 用的很 6 ？给我图解一下 ping 的工作原理！</a></li>
<li><a href="https://mp.weixin.qq.com/s/xAfgoX9NJCV7aZW6DXYqzg">分布式之接口幂等性</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODUzNzMyNQ==&mid=2247484935&idx=1&sn=8ebc7afb0056b973fbcccdaf64a61c79">记住看小电影前一定要检查一下域名是不是 HTTPS 的，不然……</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzgzODI5NA==&mid=2454062447&idx=2&sn=3d2ada8f61547a9bff735b43f246b213">75 张图带你了解网络设备、网络地址规划、静态路由、实战演练</a></li>
<li><a href="https://mp.weixin.qq.com/s/w5yRfmRH6anG8pgW1-5Ykg">面试官问：生成订单 30 分钟未支付，则自动取消，该怎么实现？</a></li>
<li><a href="https://mp.weixin.qq.com/s/RthQvzLHZRGNo-z6X_7jQQ">把 Redis 当作队列来用，真的合适吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/_3fkUOGQcKtgaTJyDnOz0w">大一学生想换 Linux 怎么样？</a></li>
<li><a href="https://mp.weixin.qq.com/s/qetX2j0TnxXwC-PQfnReWw">23 种设计模式，我竟然秒懂了…</a></li>
<li><a href="https://mp.weixin.qq.com/s/Y807oUfCDCrigFxziRCEMQ">彻底搞懂观察者模式</a></li>
<li><a href="https://mp.weixin.qq.com/s/pMK9kI-umUT3g5I9emymqA">在树莓派上构建你的专属 K8S 集群！</a></li>
<li><a href="https://mp.weixin.qq.com/s/7JIvM4gaLYKMv2q4X4rfoA">为啥妹子给我发的 Excel 打开之后是乱码？</a></li>
<li><a href="https://segmentfault.com/a/1190000040846926">就因为这三个知识点，我彻底学废了”正则表达式“</a></li>
<li><a href="https://mp.weixin.qq.com/s/3vgv4nqOOXxRlb-Q1RVyBg">开发必掌握！JSON 数据交互和 RESTful 开发</a></li>
<li><a href="https://mp.weixin.qq.com/s/RHOiMbLn6PNO4B_ODoGxew">B 站，强的离谱！</a></li>
<li><a href="https://mp.weixin.qq.com/s/ggBydWbbTsYoBsv5PlU6eQ">常用正则表达式速查手册</a></li>
<li><a href="https://segmentfault.com/a/1190000040978572">一文讲透自适应熔断的原理和实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZtUapwzgiCkXzC2TiDoG3Q">《赵海平与张宏波谈编程语言》访谈实录</a></li>
<li><a href="https://mp.weixin.qq.com/s/5NYKCDjJpaK_iPLv592iBg">HTTP Host 头攻击，这是什么鬼？</a></li>
<li><a href="https://www.bilibili.com/video/BV1aF411v7hU">IPv6 和 IPv4 的主要区别？子网掩码，二进制转化，地址分类，头部，安全有什么不同？</a></li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的 GIT 入门</a></li>
<li><a href="https://mp.weixin.qq.com/s/uEFq9HMJ_1c9oUTbuFaoog">从原理上搞懂 Git，一篇文章就够了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/KqDlaI_gMLfUN3At1WlBLg">说说对 git pull 和 git fetch 的理解？有什么区别？</a></li>
<li><a href="https://mp.weixin.qq.com/s/OabE6UjACJQikEMtPo0F1g">Git 各指令的本质，真是通俗易懂啊</a></li>
<li><a href="https://mp.weixin.qq.com/s/KuyxyyQpXxinFv0lJEdIog">图解 Git 各种用法，简单明了，一目了然！</a></li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/C25UbyVaRjqGP3ybIjQr-g">MySQL-InnoDB 究竟如何巧妙实现，4 种事务的隔离级别</a></li>
<li><a href="https://mp.weixin.qq.com/s/jITpaKSar7BlG0KVcjsf_A">历经 60 年，数据库的王者终于出现了……</a></li>
<li><a href="https://mp.weixin.qq.com/s/iYIf8aAbwX54A3ndypGXKw">ClickHouse SQL 的十项优化规则</a></li>
<li><a href="https://mp.weixin.qq.com/s/eWgsR2QX5ef1ZfxVZFjjmQ">面试被问执行 count(1)、count(*) 与 count(列名) 到底有什么区别？</a></li>
<li><a href="https://mp.weixin.qq.com/s/RSRzKwARDQky0JDqotwiYg">Kubernetes 上使用 Istio 对数据库进行蓝绿部署</a></li>
<li><a href="https://mp.weixin.qq.com/s/OFPSsOfHhdQa4HYdvDTaRg">即使删了全库，如何半小时恢复？</a></li>
<li><a href="https://mp.weixin.qq.com/s/iFWuOiwGGZhj0SrVPApeNA">MySQL 用 limit 为什么会影响性能？</a></li>
</ul>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NjQyMzI2Ng==&mid=2247491282&idx=1&sn=234ede22e3ec1a14ccb39d74b129a307">据说程序员等电梯的时候都想过调度算法</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDU4Njk2Nw==&mid=2247486653&idx=1&sn=4b2466429e8c9aa4daf2572f52e44543">经典智力面试题：一家人过桥</a></li>
<li><a href="https://mp.weixin.qq.com/s/CISO6yks2L7775Pf4j-LMg">图解索引</a></li>
<li><a href="https://mp.weixin.qq.com/s/6XvcBIVblFz3Fdj15t6mzA">比冒泡算法还简单的排序算法：看起来满是 bug 的程序，居然是对的</a></li>
<li><a href="https://mp.weixin.qq.com/s/yh7CVt_Vl7viTzn1hoH__g">腾讯终面：求两个文件中的 QQ 交集</a></li>
<li><a href="https://mp.weixin.qq.com/s/b5kdt9aMs9SD4DmZb8TUmg">超详细教程！手把手带你使用 Raft 分布式共识性算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/mb0gMPMRxh3tsQQ3NnhOfw">干货 | 手撕十大经典排序算法</a></li>
</ul>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247498262&idx=1&sn=886534663bb8209d4d9ad32232eb3d5d">推荐 130 个令你眼前一亮的网站，总有一个用得着</a></li>
<li><a href="https://mp.weixin.qq.com/s/f2EgnA-aC9aB3XitYI9hog">这个 GitHub 项目能克隆你的声音</a></li>
<li><a href="https://mp.weixin.qq.com/s/GBLjmQlTo1PkW-8fQFKHgA">微软开源超强工具箱：PowerToys</a> <a href="http://d0.ananas.chaoxing.com/download/0e8920eb50dc5a13391d359f7ce18447?at_=1620895454009&ak_=1996d2e1303e43e24bd4d213a7175ec2&ad_=98eb4fe6f58518090ccae24362d5d582&fn=PowerToysSetup-0.37.2-x64.exe">(右键复制链接地址打开新窗口下载)</a></li>
<li><a href="https://mp.weixin.qq.com/s/TZD8_3vLiWTWAU-jNtnLUQ">手痒想写项目？我挑了 10 个开源项目送你</a></li>
<li><a href="https://mp.weixin.qq.com/s/aPCjaPkQYS7DS-WnBOqBsw">推荐一个基于 SpringBoot2 + MybatisPlus 的商城管理系统</a> ：<a href="https://gitee.com/guchengwuyue/yshopmall">yshop 意象商城系统</a></li>
<li><a href="https://mp.weixin.qq.com/s/TVs4CIwIu5RsthzoI68ROQ">前端进阶道路上不可错过的 21 个开源项目</a></li>
<li><a href="https://mp.weixin.qq.com/s/SfLIkU8E2b3sAO1qSUkyXA">无恒实验室联合 GORM 推出安全好用的 ORM 框架-GEN</a></li>
<li><a href="https://mp.weixin.qq.com/s/NtmEKePOgymQPlS5PmvDig">终于，Python 也可以写前端了</a></li>
<li><a href="https://mp.weixin.qq.com/s/TIDZ8q7RwZQ6-c4zdMQG_Q">都 2021 年了，你还在用 Jenkins ？赶快看看这些替代方案吧！</a></li>
<li><a href="https://mp.weixin.qq.com/s/DHqkGojwyWrj7gIaelIGsQ">一行命令堆出你的新垣结衣（已开源），有点牛！</a></li>
<li><a href="https://mp.weixin.qq.com/s/7FZBI4zUUjK5D8-lhYwt6A">RedisJson 横空出世，性能碾压 ES 和 Mongo！</a></li>
<li><a href="https://mp.weixin.qq.com/s/SpPcKEHnaGtQEkgv08V6Sg">2021 年 JavaScript 明星项目公布，最受欢迎的竟是它？</a></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/JQA4Noq2FQYISKJRwtl99A">带有 WebUI 的 HTTP Benchmark 小工具你用过吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/TvJ8Ev7uP-FrVlGHHHUr8A">让你纵横 GitHub 的五大神器</a></li>
<li><a href="https://mp.weixin.qq.com/s/fLX_Yx_sUl8m9R2ZSmUjPQ">一文全面解析 postman 工具</a></li>
<li><a href="https://mp.weixin.qq.com/s/QjwT2voiRhllnkvSpG4FyQ">这个开源工作流自动化工具，用了就不想丢！</a></li>
<li><a href="https://mp.weixin.qq.com/s/TpECaPdn2BIADpL0hiJLuQ">使用插件直接访问谷歌大陆镜像网站</a></li>
<li><a href="https://mp.weixin.qq.com/s/8oYJ-GjtsCULHUWEGlwrHQ">再见 Typora！这款 Markdown 神器绝了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/8gAGMW_3V2WLrrd2Qo-CQA">字节工程师自研基于 IntelliJ 的终极文档套件</a></li>
</ul>
<h2 id="嵌入式、单片机"><a href="#嵌入式、单片机" class="headerlink" title="嵌入式、单片机"></a>嵌入式、单片机</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/NUVxNqOz7efVvGgK8RjLfA">STM32 夺命 100 问！你知道几个？</a></li>
</ul>
<h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><h2 id="其他未分类"><a href="#其他未分类" class="headerlink" title="其他未分类"></a>其他未分类</h2><ul>
<li><a href="/%E5%B9%B2%E8%B4%A7/developer-roadmap">程序员学习路线</a></li>
<li><a href="https://mp.weixin.qq.com/s/PZbV0hjn_vxazUnelM1xEg">常见代码重构技巧</a></li>
<li><a href="https://mp.weixin.qq.com/s/LZqaFG7CHGoHmrnSR4Nouw">萌新第一次用鸿蒙跑 hello world</a></li>
<li><a href="https://mp.weixin.qq.com/s/gysYSMhHEBFej0YxhKdn9A">深度剖析 Linux 的 3 种“拷贝”命令</a></li>
<li><a href="https://www.bilibili.com/video/BV1Mf4y1a7PZ">OpenHarmony 鸿蒙内核 Liteos-a 最小系统移植教程(IMX6ULL 开发板)</a></li>
<li><a href="https://www.bilibili.com/video/BV1eU4y1V73d">HarmonyOS × Ant Design | 鸿蒙图标设计规范评测</a></li>
<li><a href="https://www.bilibili.com/video/BV1Ry4y1t7Tj">2021 年最全面的 Jetpack 系统学习课程，看他就够了，更新中</a></li>
<li><a href="https://www.bilibili.com/video/BV1V64y197nj">【设计】Figma 的 Auto Layout 与组件的 Variants ｜ Auto Layout 等于 CSS Flex？</a></li>
<li><a href="https://mp.weixin.qq.com/s/bUehBVed8AhqTJs-0T5ogQ">FAQ | 使用 Kotlin 进行 Android 开发</a></li>
<li><a href="https://mp.weixin.qq.com/s/DC6lMBZ9axCuqgg1Rtkn_Q">剑指 offer | 认识面试</a></li>
</ul>
<h2 id="文件分享"><a href="#文件分享" class="headerlink" title="文件分享"></a>文件分享</h2><ol>
<li>java 华山版：链接: <a href="https://pan.baidu.com/s/17qqv-p8GmMkLydpx-5bl5Q">https://pan.baidu.com/s/17qqv-p8GmMkLydpx-5bl5Q</a> 提取码: 8hyh</li>
<li>程序员必知的硬核知识大全：链接: <a href="https://pan.baidu.com/s/1QVs0Cu-F_0AYRHDuU_OXkQ">https://pan.baidu.com/s/1QVs0Cu-F_0AYRHDuU_OXkQ</a> 提取码: ft64</li>
<li>Git 的奇技淫巧：链接: <a href="https://pan.baidu.com/s/1an4yLUo6brX339vxj0OCzA">https://pan.baidu.com/s/1an4yLUo6brX339vxj0OCzA</a> 提取码: 9tr3</li>
<li>Linux 高性能服务器编程：链接：<a href="https://pan.baidu.com/s/1SmF9P3YddQu0S3ohTgTP0g">https://pan.baidu.com/s/1SmF9P3YddQu0S3ohTgTP0g</a> 提取码：2333</li>
<li>计算机程序的构造和解释（SICP 中文第 2 版）：链接：<a href="https://pan.baidu.com/s/15yy_MbzfG_-NJMvMIdViyQ">https://pan.baidu.com/s/15yy_MbzfG_-NJMvMIdViyQ</a> 提取码：2333</li>
<li>MySQL 笔记 链接：<a href="https://pan.baidu.com/s/1YjIWGnpAOk1SoOaPalVODw">https://pan.baidu.com/s/1YjIWGnpAOk1SoOaPalVODw</a> 提取码：2333</li>
<li>机器学习资料：夕小瑶 NLP 全栈手册 链接：<a href="https://pan.baidu.com/s/18R2dx5_Xm8o9bcAmM0o5FQ">https://pan.baidu.com/s/18R2dx5_Xm8o9bcAmM0o5FQ</a> 提取码：2333</li>
</ol>
]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与接口技术笔记（1）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>记录一下书本的知识点、练习题、课后题</p>
<span id="more"></span>

<h1 id="8086处理器参数"><a href="#8086处理器参数" class="headerlink" title="8086处理器参数"></a>8086处理器参数</h1><p>16根数据线、20根地址线，寻址范围：2^20 &#x3D; 1MB，内部总线和ALU为16位，可以进行8位和16位操作。按照功能分为<strong>执行部件EU(Execution Unit)</strong> 和 <strong>总线接口BIU(Bus Interface Unit)</strong> 。</p>
<h2 id="执行部件EU"><a href="#执行部件EU" class="headerlink" title="执行部件EU"></a>执行部件EU</h2><p>由4个通用寄存器（AX、BX、CX、DX）、4个专用寄存器（SP、BP、DI、SI）、1个16位算术逻辑单元ALU、1个16位标志寄存器PSW、1个数据暂存寄存器和EU控制电路。</p>
<table>
<thead>
<tr>
<th>通用寄存器</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>AX(Accumulator)</td>
<td>字乘法，字除法，字I&#x2F;O</td>
</tr>
<tr>
<td>AL</td>
<td>字节乘，字节除，字节I&#x2F;O，十进制算术运算</td>
</tr>
<tr>
<td>AH</td>
<td>字节乘，字节除</td>
</tr>
<tr>
<td>BX (Base)</td>
<td>转移</td>
</tr>
<tr>
<td>CX(Count)</td>
<td>串操作，循环次数</td>
</tr>
<tr>
<td>CL</td>
<td>变量移位，循环控制</td>
</tr>
<tr>
<td>DX (Data)</td>
<td>字节乘，字节除，间接I&#x2F;O</td>
</tr>
</tbody></table>
<p>指针寄存器: SP(Stack Pointer)为堆栈指针寄存器，和SS一起确定堆栈在内存的位置；BP(Base Pointer)为基数指针寄存器，通常用于存放基地址</p>
<p>变址寄存器: SI(Source Index)为源变址寄存器，DI(Destination Index)是目的变址寄存器</p>
<table>
<thead>
<tr>
<th>标志寄存器</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>CF（Carry FLag）<br>进位标志（第 0 位）</td>
<td>进位标志是用来反映计算时是否产生了由低位向高位的进位，或者产生了从高位到低位的借位 。1有进借位。</td>
</tr>
<tr>
<td>PF（Parity FLag）<br>奇偶标志（第 2 位）</td>
<td>运算结果低8位中 1 的个数是否为偶数 。</td>
</tr>
<tr>
<td>AF（Auxiliary Carry FLag）<br>半进位标志（第 4 位）</td>
<td>字节加法时低四位向高四位进位或减法时低四位向高四位借位时置1。用于BCD算术运算结果调整。</td>
</tr>
<tr>
<td>ZF（Zero FLag）<br>零标志（第 6 位）</td>
<td>运算结果为0置1，否则清零</td>
</tr>
<tr>
<td>SF（Sign FLag）<br>符号标志（第 7 位）</td>
<td>运算结果最高位是否为1（或者说结果为负），置1否则清零</td>
</tr>
<tr>
<td>TF（Trap FLag）<br>追踪标志（第 8 位）</td>
<td>追踪标志，主要是用于调试时使用 。1为CPU进入单步方式</td>
</tr>
<tr>
<td>IF（Interrupt-Enable FLag）<br>中断允许标志（第 9 位）</td>
<td>中断允许标志，其决定CPU是否能够响应外部可屏蔽中断请求，1为CPU能够响应外部的可屏蔽中断请求</td>
</tr>
<tr>
<td>DF（Direction  FLag）<br>方向标志（第 10 位）</td>
<td>方向标志，其用于在串处理指令中，用来控制每次操作后SI和DI是自增还是自减。0为自加1为自减</td>
</tr>
<tr>
<td>OF（OverFlow  FLag）<br>溢出标志（第 11 位）</td>
<td>溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 。发生溢出置1</td>
</tr>
</tbody></table>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/2.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/3.png" class="">

<h2 id="总线接口部件BIU"><a href="#总线接口部件BIU" class="headerlink" title="总线接口部件BIU"></a>总线接口部件BIU</h2><p>指针寄存器IP: 16位，用于控制CPU指令执行顺序，顺序执行程序时，CPU完成取指令，IP+1，指向下一个要读取的指令。</p>
<p>段寄存器：</p>
<ul>
<li>CS (Code Segment)：代码段寄存器</li>
<li>DS (Data Segment)：数据段寄存器</li>
<li>SS (Stack Segment)：堆栈段寄存器</li>
<li>ES (Extra Segment)：附加段寄存器</li>
</ul>
<p>通常CS划定并控制程序区，DS和ES控制数据区，SS控制堆栈区</p>
<p>20位地址加法器：用来产生20位物理地址，物理地址&#x3D;CS（16进制）左移一位+IP，如：CS&#x3D;2000H，IP&#x3D;0400H，物理地址为20400H</p>
<p><strong>BIU和EU按照流水线技术原理协调工作</strong></p>
<h2 id="8086储存的管理"><a href="#8086储存的管理" class="headerlink" title="8086储存的管理"></a>8086储存的管理</h2><p>8086有20条地址总线，最大寻址空间为：2^20B &#x3D; 1MB。从00000H到0FFFFFH。寄存器只有16位，为了取得20位地址要使用下面方法。</p>
<h3 id="存储器分段"><a href="#存储器分段" class="headerlink" title="存储器分段"></a>存储器分段</h3><p>因为8086内部寄存器是16位的，能寻址的内存空间只能是64KB，所以8086系统采用了<strong>地址分段</strong>的方法，将1M空间分成4段，<strong>每段最多64KB</strong>，在段内寻址仍可采用传统的16位地址寻址方法。每个段的起始地址低4位必须为0，高16位放在16位的段寄存器内，这<strong>高16位地址称为段基址</strong>。</p>
<p>段寄存器分别为CS、DS、SS和ES，段基址存放在这4个段寄存器内。</p>
<h3 id="20位物理地址的产生"><a href="#20位物理地址的产生" class="headerlink" title="20位物理地址的产生"></a>20位物理地址的产生</h3><p>8086规定每个段的段起始地址必须能被16整除，其特征是20位段起始地址的最低4位为0（用16进制表示为××××0H）。<br>段基址可确定某个段在内存中的起始位置，而段中某个单元在该段中的位置则可由该单元在段内相对于段起始地址的偏移量来决定，称为偏移地址，也是16位。<br>也就是说，内存中某单元的位置可用16位的段基址和16位的偏移地址确定。 计算公式为：<strong>20位物理地址&#x3D;16位段地址×16＋16位偏移地址</strong>。</p>
<h3 id="段的分配"><a href="#段的分配" class="headerlink" title="段的分配"></a>段的分配</h3><p>在对存储器进行操作时，内存一般可分成4个段，分别称为代码段、数据段、堆栈段和附加数据段，每个段存放不同性质的数据，进行不同的操作。<br><strong>代码段</strong>：存放指令。<br><strong>堆栈段</strong>：程序的堆栈区（子程序调用、系统功能调用、中断处理等操作使用）或作为临时数据存储区。<br><strong>数据段</strong>：存放程序所使用的数据。<br><strong>附加数据段</strong>：辅助的数据区（串操作指令使用）。</p>
<p>4个逻辑段的段基址分别放在相应的代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS和附加段寄存器ES中，由这<strong>4个段寄存器来指明每个段在内存中的起始地址</strong>。</p>
<p>例如:设当前有效的代码段、数据段、堆栈段、附加段的段地址分别为1066H、251BH、900CH、F001H，则各段在内存中的分配情况如图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/4.png" class="">

<p>4个段可分配在1MB的任何地方，段与段间可重叠或不重叠、可连续排列、断续排列。尽管CPU在某一时刻最多只能同时访问4个段，但用户在程序中可根据需要定义多个这样的段。若CPU要访问4个段以外的其他段，只要改变相应段寄存器的内容即可。</p>
<h3 id="8086存储区的分配"><a href="#8086存储区的分配" class="headerlink" title="8086存储区的分配"></a>8086存储区的分配</h3><ol>
<li>00000H～003FFH共1KB区域用来存放中断矢量，这一区域称为中断矢量表。中断矢量表的定义和作用参阅中断一章的有关内容。</li>
<li>B0000H～B0F9FH是单色显示器的显示缓冲区，存放单色显示器当前屏幕显示字符所对应的ASCII码和属性。</li>
<li>B8000H～BBF3FH约16KB是彩色显示器的显示缓冲区，存放彩色显示器当前屏幕像点所对应的代码。</li>
<li>FFFF0H～FFFFFH共16个单元，<strong>一般用来存放一条无条件转移指令，转到系统的初始化程序</strong>。这是因为系统加电或者复位时，会自动转到FFFF0H执行。</li>
</ol>
<h1 id="8086引脚功能"><a href="#8086引脚功能" class="headerlink" title="8086引脚功能"></a>8086引脚功能</h1><h2 id="8086CPU引脚"><a href="#8086CPU引脚" class="headerlink" title="8086CPU引脚"></a>8086CPU引脚</h2><p>两种工作方式相同的引脚：</p>
<ul>
<li>AD15～AD0（address databus）：地址&#x2F;数据总线，双向，三态。这是一组采用分时的方法传送地址或数据的复用引脚。根据不同时钟周期的要求，决定当前是传送要访问的存储单元或I&#x2F;O端口的低16位地址，还是传送16位数据，或是处于高阻状态。</li>
<li>A19&#x2F;S6～A16&#x2F;S3（address&#x2F;status）：地址&#x2F;状态信号，输出，三态。这是采用分时的方法传送地址或状态的复用引脚。其中A19～A16为20位地址总线的高4位地址，S6～S3是状态信号。S6表示CPU与总线连接的情况，S5指示当前中断允许标志IF的状态。S4，S3的代码组合用来指明当前正在使用的段寄存器。S4，S3的代码组合及对应段寄存器的情况。</li>
<li>BHE（低）&#x2F;S7（bushighenable&#x2F;status）：允许总线高8位数据传送&#x2F;状态信号，输出，三态。为总线高8位数据允许信号，当低电平有效时，表明在高8位数据总线D15～D8上传送1个字节的数据。S7为设备的状态信号。</li>
<li>RD&#x2F;（read）：读信号，输出，三态，低电平有效。</li>
<li>READY（22脚）：准备就绪信号，输入，高电平有效。当READY&#x3D;1时，表示CPU访问的存储器或I&#x2F;O端口已准备好传送数据。若CPU在总线周期T3状态检测到READY信号为低电平，表示存储器或I&#x2F;O设备尚未准备就绪，CPU自动插入一个或多个等待状态TW，直到READY信号变为高电平为止。　　</li>
<li>INTR（18脚）：可屏蔽请求信号，输入，电平触发，高电平有效。当INTR&#x3D;1时，表示外设向CPU发出中断请求，CPU在当前指令周期的最后一个T状态去采样该信号，若此时中断允许标志IF&#x3D;1，则CPU响应中断，停止执行原指令序列，转去执行中断服务程序。 </li>
<li>RESET（21脚）:复位信号，输入，高电平有效。RESET信号至少要保持4个时钟周期。CPU接到RESET信号后，停止进行操作，并将标志寄存器、IP、DS、SS、ES及指令队列清零，将CS设置为FFFFH。当复位信号为低电平时，CPU从FFFF0H开始执行程序。</li>
<li>CLK（19脚）：主时钟信号，输入。8086要求时钟信号的占空比为33%，即1&#x2F;3周期为高电平，2&#x2F;3周期为低电平。8086的时钟频率要求为5MHz，8086-1的时钟频率为10MHz，8086-2的时钟频率为8MHz。不同型号的芯片使用的时钟频率不同。</li>
<li>VCC（40脚）:电源输入引脚。</li>
<li>GND（1、20脚）：接地引脚。 </li>
<li>MN&#x2F;（33脚）：最小&#x2F;最大模式输入控制信号。</li>
</ul>
<h2 id="最小模式和最大模式"><a href="#最小模式和最大模式" class="headerlink" title="最小模式和最大模式"></a>最小模式和最大模式</h2><p>8086&#x2F;8088可以在两种工作模式下工作，即最小模式和最大模式。</p>
<ul>
<li>最小模式－－即系统中只有8086一个微处理器。最小模式是单处理器系统。系统中所需要的控制信号全部由8086CPU本身直接提供。还需要地址锁存缓冲器、双向数据缓冲器、8284A时钟发生器。</li>
<li>最大模式－－系统中有两个或两个以上的微处理器，即除了主处理器8086以外，还有协处理器（8087算术协处理器或8089输入&#x2F;输出协处理器）、地址锁存缓冲器、双向数据缓冲器、8284A时钟发生器、总线控制器8288。最大模式可构成多处理器系统，系统中所需要的控制信号由总线控制器8288提供。</li>
</ul>
<p>最大模式是相对最小模式而言的。最大模式用在中等规模的或者大型的8086／8088系统中。在最大模式系统中，总是包含有两个或多个微处理器，其中一个主处理器就是8086或者8088，其他的处理器称为协处理器，它们是协助主处理器工作的。</p>
<p>8087是一种专用于数值运算的处理器，它能实现多种类型的数值操作，比如高精度的整数和浮点运算，也可以进行超越函数(如三角函数、对数函数)的计算。</p>
<p>CPU工作模式的选择是由硬件决定的，将8086&#x2F;8088的第33号（MN&#x2F;MX）引脚接地，则工作于最大模式，第33号引脚接高电平，则工作于最小模式。8086CPU有8条引腿（第24号～31号）在两种不同工作模式中具有不同的功能。</p>
<h3 id="最小模式下的典型配置"><a href="#最小模式下的典型配置" class="headerlink" title="最小模式下的典型配置"></a>最小模式下的典型配置</h3><ol>
<li>N&#x2F;MX端接+5V，决定了CPU的工作模式。</li>
<li>用一片8284A，作为<strong>时钟信号发生器</strong>。</li>
<li>用三片8282或74LS273，作为<strong>地址信号的锁存器</strong>。</li>
<li>当系统中所连的存储器和外设端口较多时，需要增加数据总线的驱动能力，这时，需用2片74LS245或8286&#x2F;8287作为<strong>总线收发器</strong>。</li>
</ol>
<h3 id="最大模式下的典型配置"><a href="#最大模式下的典型配置" class="headerlink" title="最大模式下的典型配置"></a>最大模式下的典型配置</h3><p>最大模式和最小模式在配置上的主要差别: 在最大模式下，要用8288总线控制器来对CPU发出的控制信号进行变换和组合，以得到对存储器或I&#x2F;O 端口的读&#x2F;写信号和对锁存器8282及总线收发器8286的控制信号。</p>
<p><strong>原因在于</strong>：在最大模式的系统中，一般包含2个或多个处理器，这样就要解决主处理器和协处理器之间的协调工作，和对系统总线的共享控制问题，8288总线控制器就起了这个作用。</p>
<p>在最大模式的系统中，一般还有中断优先级管理部件8259A。8259A用以对多个中断源进行中断优先级的管理，但如果中断源不多，也可以不用中断优先级管理部件。</p>
<h1 id="8086总线的操作时序"><a href="#8086总线的操作时序" class="headerlink" title="8086总线的操作时序"></a>8086总线的操作时序</h1><h2 id="时序基本概念"><a href="#时序基本概念" class="headerlink" title="时序基本概念"></a>时序基本概念</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>指令周期指CPU从内存取出<strong>一条指令</strong>并执行这条指令的时间总和。一般由若干个机器周期组成，是从取指令、分析取数到执行完所需的全部时间。通常含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称为双周期指令。</p>
<h3 id="总线周期"><a href="#总线周期" class="headerlink" title="总线周期"></a>总线周期</h3><p>把CPU通过总线与内存或I&#x2F;O端口之间，进行一个字节数据交换所进行的操作，称为一次总线操作，相应于某个总线操作的时间即为总线周期。</p>
<h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p>微机系统工作的最小时间单元，取决于系统的主频率，系统完成任何操作所需要的时间，均是时钟周期的整数倍。时钟周期又称为T状态。<br>基本定时脉冲是由外部振荡器产生的，通过CPU的CLK输入端输入，基本定时脉冲的频率，我们称之为系统的主频率。例如8086CPU的主频率是5MHz，其时钟周期为200ns(1&#x2F;f)。<br><strong>一个最基本的总线周期是由4个时钟周期（T状态）组成</strong>，也称为4个状态，即T1、T2、T3和T4，在每个T状态下，CPU完成不同的动作。</p>
<h2 id="8086时序分析"><a href="#8086时序分析" class="headerlink" title="8086时序分析"></a>8086时序分析</h2><h3 id="系统复位和启动操作"><a href="#系统复位和启动操作" class="headerlink" title="系统复位和启动操作"></a>系统复位和启动操作</h3><p>当CPU通过RESET引脚接收到有效的RESET信号且至少维持4个时钟周期，不管之前在执行什么动作，只要正常供电，8086就结束现行操作，进入复位状态，直到RESET信号失效。在复位状态下，CPU内部的各寄存器被置为缺省值（<strong>段寄存器CS和指令指针IP分别被初始化为FFFFH和0000H</strong>）。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/1.png" class="">
<p>因此，8086 CPU复位后重新启动，执行的第一条指令所在存储单元的物理地址为FFFFH×16+0000H＝FFFF0H。</p>
<h3 id="最小模式下的典型时序"><a href="#最小模式下的典型时序" class="headerlink" title="最小模式下的典型时序"></a>最小模式下的典型时序</h3><p>一个最基本的读周期包含4个状态，即T1、T2、T3、T4，当慢速设备在3个时钟周期（T）内无法完成数据传输时插入TW,插入TW的多少取决于数据传输的快慢。</p>
<p>……</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>微机系统由 <code>硬件系统</code> 和 <code>软件系统</code> 两部分组成。</li>
<li>8086有 <code>20</code> 位地址线，存储器容量为 <code>1M</code> B。</li>
<li>8086CPU内部组成结构从功能上讲，可分为 <code>BIU</code> 和 <code>EU</code> 两部分。</li>
<li>8086的四个段寄存器为 <code>DS</code> 、<code>ES</code> 、<code>SS</code> 、<code>CS</code> 。</li>
<li>用来存放指令地址的寄存器是 <code>IP</code> 。</li>
<li>8086的16位标志寄存器中OF&#x3D;1表示运算结果 <code>溢出</code> ，ZF&#x3D;1表示运算结果为 <code>0</code> 。</li>
<li>8086的16位标志寄存器中IF&#x3D;1表示CPU <code>允许</code> 中断，TF&#x3D;1表示CPU进入 <code>单步</code> 工作方式。</li>
<li>地址4000H:0300H，其物理地址是  <code>40300H</code> ，段地址是 <code>4000H</code>  ，偏移地址是   <code>0300H</code>  。</li>
<li>8086存储器管理采用 <code>分段管理</code> 技术。</li>
</ol>
<h1 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h1><ol>
<li><p>总线接口部件（BIU）中包含哪些部件？执行部件（EU）中包含哪些部件？<br><br>答：EU由4个通用寄存器：AX、BX、CX、DX，4个专用寄存器：SP、BP、SI、DI，一个16位通用寄存器，一个16位状态寄存器PSW，1 个数据暂存寄存器和 EU 控制电路等组成。<br>BIU由一个16位段寄存器：DS、CS、ES、SS，一个16位指令指针寄存器IP，20位地址加法器和6 字节指令队列缓冲器组成。</p>
</li>
<li><p>设段地址为 4ABFH，物理地址为 50000H，求有效地址是什么？<br><br>答：有效地址为物理地址减去左移一位的段地址，即50000H-4ABF0H&#x3D;5410H</p>
</li>
<li><p>8086CPU 读写总线周期各包含多少个时钟周期？什么情况下需要插入 TW 周期？插入多少个 TW 取决于什么因素？<br><br>答：(1)在最小和最大配置下，读和写的总线周期都为4个，分别是T1、T2、T3、T4.<br>（2）当储存器或者I&#x2F;O设备的速度慢时，会通过READY线通知CPU，CPU会在T3时检测READY，如果是0则插入或者多个TW周期，并且在每个TW周期检测READY，如果恢复为1则推出TW状态。<br>（3）取决于I&#x2F;O设备是否将READY设置为1</p>
</li>
<li><p>什么是指令周期？什么是总线周期？什么是时钟周期？它们之间的关系如何？<br><br>答：指令周期是 CPU 从内存取出一条指令并执行完毕指令所需要的时间；<br>CPU通过总线和内存或I&#x2F;O端进行一个数据交换所进行的操作成为总线操作，对应的某个总线操作的时间为总线周期；<br>时钟周期是 CPU 进行操作的最小单位，是由系统的时钟频率决定的，又称为T状态。<br>关系：一般一个指令周期由几个总线周期组成，一个最基本的总线周期至少包含 4 个时钟周期。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与接口技术知识点总结</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结一下考试可能会考的知识点。</p>
<span id="more"></span>
<h1 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h1><h2 id="8086处理器概述"><a href="#8086处理器概述" class="headerlink" title="8086处理器概述"></a>8086处理器概述</h2><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p>从功能上看，8086可分为两大部分：执行部件<strong>EU(Execution Unit)</strong> 和 总线接口<strong>BIU(Bus Interface Unit)</strong> 。</p>
<h4 id="执行单元EU"><a href="#执行单元EU" class="headerlink" title="执行单元EU"></a>执行单元EU</h4><p>负责进行所有指令的解释和执行，同时管理有关的寄存器。</p>
<p><strong>相关寄存器</strong>：4个通用寄存器（AX、BX、CX、DX）、4个专用寄存器（SI、DI、SP、BP）、PSW状态寄存器</p>
<p>全称和功能：<a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/#%E6%89%A7%E8%A1%8C%E9%83%A8%E4%BB%B6EU">#执行部件EU</a></p>
<h4 id="总线接口BIU"><a href="#总线接口BIU" class="headerlink" title="总线接口BIU"></a>总线接口BIU</h4><p>负责完成取指令送指令队列，配合执行部件的动作，从内存单元或者I&#x2F;O端口取操作数，或者将操作结果送到内存单元或者I&#x2F;O端口。</p>
<p><strong>相关寄存器</strong>：指针寄存器IP和四个段寄存器（CS、SS、DS、ES）</p>
<p>还包括：6字节指令队列缓冲器和20位地址加法器</p>
<p>寄存器功能和地址加法：<a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6BIU">#总线接口部件BIU</a></p>
<h3 id="8086储存器管理"><a href="#8086储存器管理" class="headerlink" title="8086储存器管理"></a>8086储存器管理</h3><p>8086有20条地址总线，最大寻址空间为：2^20B &#x3D; 1MB。从00000H到0FFFFFH。在对存储器进行操作时，内存一般可分成4个段，分别称为代码段、数据段、堆栈段和附加数据段，每个段存放不同性质的数据，进行不同的操作。</p>
<p>详情：<a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/#%E6%AE%B5%E7%9A%84%E5%88%86%E9%85%8D">段的分配</a></p>
<h2 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h2><ul>
<li>AD15～AD0：地址&#x2F;数据总线</li>
<li>A19&#x2F;S6～A16&#x2F;S3：地址&#x2F;状态信号</li>
<li>BHE（低）&#x2F;S7（bushighenable&#x2F;status）：允许总线高8位数据传送&#x2F;状态信号</li>
<li>RD&#x2F;（read）：读信号，输出，三态，低电平有效</li>
<li>READY（22脚）：准备就绪信号，输入，READY&#x3D;1代表I&#x2F;O端口准备好数据</li>
</ul>
<h2 id="8086总线的操作时序"><a href="#8086总线的操作时序" class="headerlink" title="8086总线的操作时序"></a>8086总线的操作时序</h2><p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/#%E6%97%B6%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">时序基本概念</a></p>
<h2 id="指令格式和寻址方式"><a href="#指令格式和寻址方式" class="headerlink" title="指令格式和寻址方式"></a>指令格式和寻址方式</h2><p>通常一条指令包括一个或两个操作数，双操作数分别称为源操作数（SRC）和目的操作数（DST）</p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/#8086%E3%80%818088%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">8086、8088的寻址方式</a></p>
<h3 id="指令总结"><a href="#指令总结" class="headerlink" title="指令总结"></a>指令总结</h3><p>加粗为考试考点</p>
<table cellpadding="0" cellspacing="0" width="864" style="width: 804px;">
    <tbody>
        <tr height="31" style=";height:31px" class="firstRow">
            <td height="31" width="103" style="">
                <p>
                    指令类
                </p>
            </td>
            <td width="164" style="">
                <p>
                    指令名称
                </p>
            </td>
            <td width="597" style="">
                <p>
                    指令助记符
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="4" height="122" width="103" style="">
                <p>
                    数据传送
                </p>
            </td>
            <td width="164" style="">
                <p>
                    数据传送
                </p>
            </td>
            <td width="597" style="">
                <p>
                    MOV、LEA、LDS、LES、LAHF、SAHF
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    堆栈操作
                </p>
            </td>
            <td width="597" style="">
                <p>
                    PUSH、POP、PUSHF、POPF
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    数据交换
                </p>
            </td>
            <td width="597" style="">
                <p>
                    XCHG、XLAT
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    输入输出
                </p>
            </td>
            <td width="597" style="">
                <p>
                    IN、OUT
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="6" height="183" width="103" style="">
                <p>
                    算术运算
                </p>
            </td>
            <td width="164" style="">
                <p>
                    加法
                </p>
            </td>
            <td width="597" style="">
                <p>
                    ADD、ADC、INC
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    减法；比较
                </p>
            </td>
            <td width="597" style="">
                <p>
                    SUB、SBB、DEC、NEG；CMP
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    乘法
                </p>
            </td>
            <td width="597" style="">
                <p>
                    MUL、IMUL
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    除法
                </p>
            </td>
            <td width="597" style="">
                <p>
                    DIV、IDIV
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    扩展
                </p>
            </td>
            <td width="597" style="">
                <p>
                    CBW、CWD
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    十进制调整
                </p>
            </td>
            <td width="597" style="">
                <p>
                    AAA、AAS、DAA、DAS、AAM、AAD
                </p>
            </td>
        </tr>
    </tbody>
</table>

<table cellpadding="0" cellspacing="0" width="896" style="width: 804px;">
    <tbody>
        <tr height="31" style=";height:31px" class="firstRow">
            <td rowspan="3" height="94" width="105" style="">
                <p>
                    位操作
                </p>
            </td>
            <td width="171" style="">
                <p>
                    逻辑运算
                </p>
            </td>
            <td width="620" style="">
                <p>
                    AND、OR、NOT、XOR、TEST
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    移位运算
                </p>
            </td>
            <td width="620" style="">
                <p>
                    SAL、SAR、SHL、SHR
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    循环移位
                </p>
            </td>
            <td width="620" style="">
                <p>
                    ROL、ROR、RCL、RCR
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="5" height="157" width="105" style="">
                <p>
                    串操作
                </p>
            </td>
            <td width="171" style="">
                <p>
                    串传送
                </p>
            </td>
            <td width="620" style="">
                <p>
                    MOVS、MOVSB、MOVSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串存取
                </p>
            </td>
            <td width="620" style="">
                <p>
                    STOS、STOSB、STOSW、LODS、LODSB、LODSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串比较
                </p>
            </td>
            <td width="620" style="">
                <p>
                    CMPS、CMPSB、CMPSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串搜索
                </p>
            </td>
            <td width="620" style="">
                <p>
                    SCAS、SCASB、SCASW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串输入输出
                </p>
            </td>
            <td width="620" style="">
                <p>
                    INS、INSB、INSW、OUTS、OUTSB、OUTSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="4" height="164" width="105" style="">
                <p>
                    程序控制
                </p>
            </td>
            <td width="171" style="">
                <p>
                    调用
                </p>
            </td>
            <td width="620" style="">
                <p>
                    CALL、RET
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    中断
                </p>
            </td>
            <td width="620" style="">
                <p>
                    INT、INTO、IRET
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    重复操作
                </p>
            </td>
            <td width="620" style="">
                <p>
                    LOOP、LOOPE/LOOPZ、LOOPNE/LOOPNZ、JCXZ
                </p>
            </td>
        </tr>
        <tr height="70" style=";height:70px">
            <td height="70" width="171" style="">
                <p>
                    跳转
                </p>
            </td>
            <td width="620" style="">
                <p>
                    JA/JNBE、JAE/JNB、JB/JNAE、JBE/JNA、JG/JNLE、JE/JZ、JNE/JNZ、JGE/JNL、JL/JNGE、JNC、JC、JNS、JS、JP/JPE、JNP/JPO、JNO、JO
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="2" height="63" width="105" style="">
                <p>
                    处理器控制
                </p>
            </td>
            <td width="171" style="">
                <p>
                    清除标志
                </p>
            </td>
            <td width="620" style="">
                <p>
                    CLC、STC、CMC、CLD、STD、CLI、STI
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    时序控制
                </p>
            </td>
            <td width="620" style="">
                <p>
                    NOP、WAIT、HLT、ESC
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="3" height="94" width="105" style="">
                <p>
                    前缀操作
                </p>
            </td>
            <td width="171" style="">
                <p>
                    重复前缀
                </p>
            </td>
            <td width="620" style="">
                <p>
                    REP、REPZ/REPE、REPNZ/REPNE
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    段前缀
                </p>
            </td>
            <td width="620" style="">
                <p>
                    ES：、DS：、CS：、SS：
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    总线封锁前缀
                </p>
            </td>
            <td width="620" style="">
                <p>
                    LOCK
                </p>
            </td>
        </tr>
    </tbody>
</table>

<p>比较两个数大小的转移指令的现行指令都是CMP。小结：</p>
<table data-sort="sortDisabled">
    <tbody>
        <tr class="firstRow">
            <td width="143" valign="top" rowspan="2" colspan="1" style="word-break: break-all;">
                <p>
                    比较情况
                </p>
            </td>
            <td valign="top" rowspan="1" colspan="2" style="word-break: break-all;">
                <p>
                    无符号数
                </p>
            </td>
            <td valign="top" rowspan="1" colspan="2" style="word-break: break-all;">
                <p>
                    带符号数
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    指令助记符
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    满足条件
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    指令助记符
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    满足条件
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&lt;B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JB/JNAE/JC
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=1
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JL/JNGE
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=1且ZF=0
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&lt;=B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JBE/JNA
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=1或ZF=1
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JLE/JNG
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=1或ZF=1
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&gt;B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JA/JNBE
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=0且ZF=0
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JG/JNLE
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=0且ZF=0
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&gt;=B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JAE/JNB
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=0或ZF=1
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JGE/JNL
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=0或ZF=0
                </p>
            </td>
        </tr>
    </tbody>
</table>

<h1 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h1><p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E6%A0%BC%E5%BC%8F">汇编语言程序格式 和 汇编语言程序书写格式</a></p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/#%E4%BC%AA%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5">伪指令语句</a></p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/#BIOS%E5%92%8CDOS%E4%B8%AD%E6%96%AD">BIOS和DOS中断</a></p>
<h1 id="并行接口8255A"><a href="#并行接口8255A" class="headerlink" title="并行接口8255A"></a>并行接口8255A</h1><p>8255A是Intel公司生产的通用可编程并行接口芯片,8255A采用40脚双列直插封装，单一+5V电源，全部输入&#x2F;输出与TTL电平兼容。它有三个输入&#x2F;输出端口：端口A、端口B、端口C。每个端口都可通过编程设定为输入端口或输出端口，但有各自不同的方式和特点。端口C可作为一个独立的端口使用，但通常是配合端口A和端口B的工作，为这两个端口的输入&#x2F;输出提供控制联络信号。</p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#%E8%8A%AF%E7%89%87%E5%BC%95%E8%84%9A">芯片引脚 和 内部结构</a></p>
<h2 id="工作方式选择控制字（考试重点）"><a href="#工作方式选择控制字（考试重点）" class="headerlink" title="工作方式选择控制字（考试重点）"></a>工作方式选择控制字（考试重点）</h2><p><strong>工作方式选择控制字</strong> <a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9%E6%8E%A7%E5%88%B6%E5%AD%97">查看详细</a><br><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/2.png" alt="控制字必背"><br><strong>端口C按位置位／复位控制字</strong> <a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#%E7%AB%AF%E5%8F%A3C%E6%8C%89%E4%BD%8D%E7%BD%AE%E4%BD%8D%EF%BC%8F%E5%A4%8D%E4%BD%8D%E6%8E%A7%E5%88%B6%E5%AD%97">查看详细</a><br><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/3.png" alt="端口C按位置位／复位控制字必背"></p>
<h2 id="8255A的工作方式"><a href="#8255A的工作方式" class="headerlink" title="8255A的工作方式"></a>8255A的工作方式</h2><p>8255A有3种工作方式，可以通过编程来进行设置。</p>
<ul>
<li><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#%E6%96%B9%E5%BC%8F0">方式0</a>为简单I&#x2F;O，查询方式，端口A、端口B、端口C均可使用。</li>
<li><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#%E6%96%B9%E5%BC%8F1">方式1</a>为选通I&#x2F;O，中断方式，端口A、端口B可以使用。</li>
<li><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/#%E6%96%B9%E5%BC%8F2">方式2</a>为双向I&#x2F;O，中断方式，只有端口A可以使用。</li>
</ul>
<h1 id="可编程定时器-x2F-计数器8253"><a href="#可编程定时器-x2F-计数器8253" class="headerlink" title="可编程定时器&#x2F;计数器8253"></a>可编程定时器&#x2F;计数器8253</h1><p>可编程定时器&#x2F;计数器，是一种软硬件结合的定时器&#x2F;计数器，将定时器&#x2F;计数器电路做成通用的定时器&#x2F;计数器并集成到一个芯片上，定时器&#x2F;计数器工作方式又可由软件来控制选择。这种定时器&#x2F;计数器芯片可直接对系统时钟进行计数，通过写入不同的计数初值，可方便地改变定时与计数时间，在定时期间不占用CPU资源，更不需要CPU管理。Intel公司生产的8253就是这样的可编程定时器&#x2F;计数器芯片。8253具有三个独立的功能完全相同的16位减法计数器，24脚DIP封装，由单一的+5V电源供电。</p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/#%E5%BC%95%E8%84%9A">引脚</a> 、 <a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/#%E5%BC%95%E8%84%9A">内部结构</a></p>
<h2 id="8253的控制字和读写操作（考试重点）"><a href="#8253的控制字和读写操作（考试重点）" class="headerlink" title="8253的控制字和读写操作（考试重点）"></a>8253的控制字和读写操作（考试重点）</h2><p>8253的控制字主要用于：选择哪个计数器通道工作，决定用8位的计数值或是用16位的计数值，按二进制计数或按十进制计数(BCD码)，工作在那种方式。<br><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/4.png" alt="控制字必背"></p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/#%E5%9C%A8%E8%B5%8B%E5%88%9D%E5%80%BC%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%A4%E7%82%B9">赋初值时需要注意！</a></p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/#8253%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%96%E7%A8%8B%EF%BC%88%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%89">8253的初始化编程（写操作）</a> 、 <a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/#8253%E5%BD%93%E5%89%8D%E8%AE%A1%E6%95%B0%E5%80%BC%E7%9A%84%E8%AF%BB%E5%8F%96%EF%BC%88%E8%AF%BB%E6%93%8D%E4%BD%9C%EF%BC%89">当前计数值的读取（读操作）</a></p>
<h2 id="8253的工作方式-6种"><a href="#8253的工作方式-6种" class="headerlink" title="8253的工作方式(6种)"></a><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/#8253%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">8253的工作方式(6种)</a></h2><ul>
<li>方式0 —— 计数到零产生中断请求</li>
<li>方式1 —— 可重触发的单稳态触发器</li>
<li>方式2 —— 分频器</li>
<li>方式3 —— 方波发生器</li>
<li>方式4 —— 软件触发选通方式</li>
<li>方式5 —— 硬件触发选通方式</li>
</ul>
<h2 id="六种工作方式小结"><a href="#六种工作方式小结" class="headerlink" title="六种工作方式小结"></a>六种工作方式小结</h2><p>在六种工作方式中，只有方式0在写入控制字后OUT输出为低电平，其他五种方式OUT输出都为高电平。方式2、方式4和方式5都是输出宽度为一个CLK周期的负脉冲，输出波形都相同，但方式2是连续工作的，方式4是由软件触发的，方式5是由硬件门控脉冲触发的。<br><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/11.png" alt="6种工作方式"><br>一般情况下，GATE信号为低电平时禁止计数，为高电平时允许计数，方式1和方式5则需要有由低变高的上升沿触发脉冲来启动计数。<br><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/12.png" alt="GATE门控信号的作用"><br>8253在计数过程中写入新的计数初值，对计数过程的影响见表所示。<br><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/13.png" alt="GATE门控信号的作用"></p>
<p><a href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%BE%AE%E6%9C%BA%E7%BB%83%E4%B9%A0%E9%A2%98.docx">练习题</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与接口技术笔记（3）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<p>依然是第三章的内容，上一篇整理完了8086指令系统中主要的指令，这次主要讲程序格式和程序结构</p>
<span id="more"></span>

<h1 id="汇编语言程序格式"><a href="#汇编语言程序格式" class="headerlink" title="汇编语言程序格式"></a>汇编语言程序格式</h1><p>汇编语言源程序汇编成目标平台的可执行文件的步骤是：</p>
<ol>
<li>编写源程序，保存到xxx.asm或者xxx.a文件</li>
<li>通过汇编程序转换成xxx.obj或者xxx.o文件</li>
<li>通过连接程序连接成xxx.exe或者xxx.out文件</li>
</ol>
<h2 id="汇编语言程序书写格式"><a href="#汇编语言程序书写格式" class="headerlink" title="汇编语言程序书写格式"></a>汇编语言程序书写格式</h2><p>汇编语言源程序的结构采用分段结构形式，一个汇编语言源程序时由若干个逻辑段组成，<strong>每个逻辑段由SEGMENT语句开始，由ENDS语句结束</strong>。<strong>整个源程序以END语句结束</strong>。通常，一个汇编语言源程序一般应该由3个逻辑段组成，即<strong>数据段、堆栈段和代码段</strong>。</p>
<p>作为汇编源程序主模块，以下几部分不可缺少：</p>
<ul>
<li>必须使用ASSUME伪指令告诉汇编程序，哪一段和哪一个段寄存器对应，即某一段地址应该放入哪一个段寄存器。这样对源程序模块进行汇编时，才能确定段中各项的偏移量。</li>
<li>DOS的装入程序在装入执行时，将把CS初始化为代码段地址，把SS初始化为堆栈段地址，因此在源程序中不需要再对它们进行初始化。<br>对数据段初始化语句如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AX，DATA（数据段段名）</span><br><span class="line">MOV  DS，AX</span><br></pre></td></tr></table></figure></li>
<li>在DOS环境下，通常采用DOS的4CH号中断功能调用使汇编语言返回DOS，即采用如下两条指令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，4CH</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure></li>
</ul>
<p>8086宏汇编MASM使用的语句有3种类型：指令语句、伪指令语句和宏指令语句。</p>
<p>汇编语言程序中的每个语句可以由四项组成，格式如下：<br> <strong>[名字]: 操作符 操作数，操作数 ；注释</strong><br>其中各项之间必须用空格（space）符隔开，名字项与操作数项间一般使用“∶”作分隔符，操作数项之间一般使用“，”作分隔符，操作数项与注释项间使用“；”作分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START∶ MOV  AX，1234H；立即数送往寄存器AX</span><br><span class="line">        MOV  BX，AX ；AX内容送往寄存器BX</span><br></pre></td></tr></table></figure>

<h3 id="名字项"><a href="#名字项" class="headerlink" title="名字项"></a>名字项</h3><p>名字项是一个符号，它表示本条语句的符号地址。一般来讲，名字项可以是标号或变量。它是由非数字开头的字符串，可由下列字符组成：</p>
<ol>
<li>字母  A～Z，a～z。</li>
<li>数字  0～9。</li>
<li>专用字符  ？、· 、@、-、$。</li>
</ol>
<p>除数字外，所有字符均可以作名字的开始字符；专用字符“·”只能作为标号的开始符号。</p>
<h3 id="操作符项"><a href="#操作符项" class="headerlink" title="操作符项"></a>操作符项</h3><p>操作符项可以是指令、伪指令或宏指令的助记符。伪指令没有对应的机器码，只是在汇编过程中完成相应的控制操作。</p>
<h3 id="操作数项"><a href="#操作数项" class="headerlink" title="操作数项"></a>操作数项</h3><p>操作数项由一个或多个表达式组成，多个操作数项之间一般用逗号分开。</p>
<h3 id="注释项"><a href="#注释项" class="headerlink" title="注释项"></a>注释项</h3><p>注释项用来说明一段程序、一条或多条指令的功能，提高程序的可读性，便于程序的阅读。</p>
<h2 id="表达式与运算符"><a href="#表达式与运算符" class="headerlink" title="表达式与运算符"></a>表达式与运算符</h2><p>表达式由常数、寄存器、标号、变量与一些运算符组合而成，可以有数字表达式和地址表达式两种。</p>
<p>8086汇编语言中的运算符：</p>
<table cellpadding="0" cellspacing="0" width="864" style="width: 804px;">
    <tbody>
        <tr height="61" style=";height:61px" class="firstRow">
            <td height="61" width="135" style="">
                <p>
                    算术运算符
                </p>
            </td>
            <td width="183" style="">
                <p>
                    逻辑与移位运算符
                </p>
            </td>
            <td width="177" style="">
                <p>
                    关系运算符
                </p>
            </td>
            <td width="213" style="">
                <p>
                    分析运算符
                </p>
            </td>
            <td width="156" style="">
                <p>
                    属性运算符
                </p>
            </td>
        </tr>
        <tr height="35" style=";height:35px">
            <td height="35" width="135" style="">
                <p>
                    +（加法）
                </p>
            </td>
            <td width="183" style="">
                <p>
                    AND（与）
                </p>
            </td>
            <td width="177" style="">
                <p>
                    EQ（相等）
                </p>
            </td>
            <td width="213" style="">
                <p>
                    SEG（求段基值）
                </p>
            </td>
            <td width="156" style="">
                <p>
                    PTR
                </p>
            </td>
        </tr>
        <tr height="35" style=";height:35px">
            <td height="35" width="135" style="">
                <p>
                    -（减法）
                </p>
            </td>
            <td width="183" style="">
                <p>
                    OR（或）
                </p>
            </td>
            <td width="177" style="">
                <p>
                    NE（不相等）
                </p>
            </td>
            <td width="213" style="">
                <p>
                    OFFSET（求偏移量）
                </p>
            </td>
            <td width="156" style="">
                <p>
                    “：”段运算符
                </p>
            </td>
        </tr>
        <tr height="35" style=";height:35px">
            <td height="35" width="135" style="">
                <p>
                    *（乘法）
                </p>
            </td>
            <td width="183" style="">
                <p>
                    XOR（异或）
                </p>
            </td>
            <td width="177" style="">
                <p>
                    LT（小于）
                </p>
            </td>
            <td width="213" style="">
                <p>
                    TYPE（求变量类型）
                </p>
            </td>
            <td width="156" style="">
                <p>
                    THIS
                </p>
            </td>
        </tr>
        <tr height="61" style=";height:61px">
            <td height="61" width="135" style="">
                <p>
                    /（除法）
                </p>
            </td>
            <td width="183" style="">
                <p>
                    NOT（非）
                </p>
            </td>
            <td width="177" style="">
                <p>
                    GT（大于）
                </p>
            </td>
            <td width="213" style="">
                <p>
                    LENGTH（求变量长度）
                </p>
            </td>
            <td width="156" style="">
                <p>
                    SHORT
                </p>
            </td>
        </tr>
        <tr height="35" style=";height:35px">
            <td height="35" width="135" style="">
                <p>
                    MOD（求余）
                </p>
            </td>
            <td width="183" style="">
                <p>
                    SHL（左移）
                </p>
            </td>
            <td width="177" style="">
                <p>
                    LE（小于或等于）
                </p>
            </td>
            <td width="213" style="">
                <p>
                    SIZE（求字节数）
                </p>
            </td>
            <td width="156" style="">
                <p>
                    HIGH
                </p>
            </td>
        </tr>
        <tr height="74" style=";height:74px">
            <td height="74" width="135" style=""></td>
            <td width="183" style="">
                <p>
                    SHR（右移）
                </p>
            </td>
            <td width="177" style="">
                <p>
                    GE（大于或等于）
                </p>
            </td>
            <td width="213" style=""></td>
            <td width="156" style="">
                <p>
                    LOW
                </p>
            </td>
        </tr>
    </tbody>
</table>

<h2 id="伪指令语句"><a href="#伪指令语句" class="headerlink" title="伪指令语句"></a>伪指令语句</h2><p>伪指令是控制汇编过程的命令，又称为汇编控制命令。它具有数据定义、存储区分配、指示程序的开始与结束等功能，但是没有对应的机器码。将汇编语言源程序翻译为目标程序后，其作用消失。</p>
<h3 id="段定义伪指令"><a href="#段定义伪指令" class="headerlink" title="段定义伪指令"></a>段定义伪指令</h3><p>此伪指令实现存储器的分段管理，在汇编和连接程序时，控制不同段的定位类型、组合类型与连接，形成一个可执行程序。<br>常用的段定义伪指令有SEGMENT、ENDS和ASSUME等。</p>
<h4 id="SEGMENT-x2F-ENDS伪指令"><a href="#SEGMENT-x2F-ENDS伪指令" class="headerlink" title="SEGMENT&#x2F;ENDS伪指令"></a>SEGMENT&#x2F;ENDS伪指令</h4><p>指令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">段名    SEGMENT     [定位类型][组合类型][类别]</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">段名    ENDS</span><br></pre></td></tr></table></figure>
<p><strong>定位类型</strong>（align_type）说明段的起始地址应是如何的边界值。</p>
<table cellpadding="0" cellspacing="0" width="864" style="width: 804px;">
    <tbody>
        <tr height="81" style=";height:81px" class="firstRow">
            <td height="81" width="103" style="">
                <p>
                    PARA
                </p>
            </td>
            <td width="761" style="">
                <p>
                    该段的必须从小段边界开始。即段的起始地址最低4位必须为0，应为xxxx0H。
                </p>
            </td>
        </tr>
        <tr height="81" style=";height:81px">
            <td height="81" width="103" style="">
                <p>
                    BYTE
                </p>
            </td>
            <td width="761" style="">
                <p>
                    该段可以从任何地址开始。
                </p>
            </td>
        </tr>
        <tr height="81" style=";height:81px">
            <td height="81" width="103" style="">
                <p>
                    WORD
                </p>
            </td>
            <td width="761" style="">
                <p>
                    该段必须从字的边界地址开始，即段的起始地址必须为偶数。
                </p>
            </td>
        </tr>
        <tr height="81" style=";height:81px">
            <td height="81" width="103" style="">
                <p>
                    PAGE
                </p>
            </td>
            <td width="761" style="">
                <p>
                    该段必须从页的边界地址开始，即段的起始地址最低8位必须为00，应为xxx00H。
                </p>
            </td>
        </tr>
    </tbody>
</table>

<p><strong>组合类型</strong>（combine_type）说明程序连接是段合并方法。</p>
<table cellpadding="0" cellspacing="0" width="831" style="width: 804px;">
    <tbody>
        <tr height="61" style=";height:61px" class="firstRow">
            <td height="61" width="131" style="">
                <p>
                    PRIVATE
                </p>
            </td>
            <td width="700" style="">
                <p>
                    私有段，在连接时将不与其他模块中的同名分段合并。组合类型的默认项。
                </p>
            </td>
        </tr>
        <tr height="64" style=";height:64px">
            <td height="64" width="131" style="">
                <p>
                    PUBLIC
                </p>
            </td>
            <td width="700" style="">
                <p>
                    连接时，对于不同程序模块中逻辑段，如果具有相同的类别名，就把这些段顺序连接成为一个逻辑段转入内存。
                </p>
            </td>
        </tr>
        <tr height="112" style=";height:112px">
            <td height="112" width="131" style="">
                <p>
                    COMMON
                </p>
            </td>
            <td width="700" style="">
                <p>
                    连接时，对于不同程序逻辑段，如果具有相同的类别名，则都从同一个地址开始装入，因而各个逻辑段将发生重叠。最后，连接以后的段的长度等于原来的逻辑段的长度，重叠部分的内容是最后一个逻辑段的内容。
                </p>
            </td>
        </tr>
        <tr height="64" style=";height:64px">
            <td height="64" width="131" style="">
                <p>
                    STACK
                </p>
            </td>
            <td width="700" style="">
                <p>
                    本段是堆栈的一部分，连接程序将所有STACK段按照与PUBLIC段的同样方式进行合并。这是堆栈段必须具有的段组合。
                </p>
            </td>
        </tr>
        <tr height="37" style=";height:37px">
            <td height="37" width="131" style="">
                <p>
                    AT表达式
                </p>
            </td>
            <td width="700" style="">
                <p>
                    使段地址时表达式所计算出来的16位值。但它不能用来指定代码段。
                </p>
            </td>
        </tr>
        <tr height="60" style=";height:60px">
            <td height="60" width="131" style="">
                <p>
                    MEMORY
                </p>
            </td>
            <td width="700" style="">
                <p>
                    与PUBLIC相同。
                </p>
            </td>
        </tr>
    </tbody>
</table>

<p><strong>类别</strong>（’class’）在引号中给出连接时组成段的类型名。当连接程序组织段时，将所有的同类别段相邻分配，段类别可以是任意名称，但<strong>必须位于单引号中</strong>。</p>
<h4 id="ASSUME伪指令"><a href="#ASSUME伪指令" class="headerlink" title="ASSUME伪指令"></a>ASSUME伪指令</h4><p>指令格式：<code>ASSUME  段寄存器名：段名[,段寄存器名：段名[,...]]</code></p>
<p>对于8086&#x2F;8088 CPU而言，汇编过程中，ASSUME伪指令只是设定了段寄存器（CS、DS、SS和ES）应指向哪一个程序段，并没有给各个段寄存器装入实际值（CS除外）。因此，必须在程序中安排为段寄存器赋值的指令。段名必须与SEGMENT定义的相对应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA    SEGMENT   ; 数据段</span><br><span class="line">           </span><br><span class="line">DATA    ENDS</span><br><span class="line">......</span><br><span class="line">STACK   SEGMENT PARA STACK′STACK′；堆栈段</span><br><span class="line"></span><br><span class="line">STACK   ENDS</span><br><span class="line">......</span><br><span class="line">CODE    SEGMENT   ; 代码段</span><br><span class="line">   </span><br><span class="line">CODE    ENDS</span><br></pre></td></tr></table></figure>

<h3 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h3><p>数据定义伪指令通常用来定义一个变量的类型，并将所需要的数据放入指定的存储单元中，也可以只给变量分配存储单元，而不赋予特定的值。<br>常用的数据定义伪指令有DB、DW、DD、DQ和DT。配合定义数据伪指令的重复操作符DUP（duplication operator）伪指令。</p>
<h4 id="定义字节变量伪指令DB"><a href="#定义字节变量伪指令DB" class="headerlink" title="定义字节变量伪指令DB"></a>定义字节变量伪指令DB</h4><p>DB（Define Byte）用于定义变量的类型为字节变量BYTE，并给变量分配字节或字节串，DB伪指令后面的操作数每个占用一个字节</p>
<h4 id="定义字变量伪指令DW"><a href="#定义字变量伪指令DW" class="headerlink" title="定义字变量伪指令DW"></a>定义字变量伪指令DW</h4><p>DW（Define Word）用于定义变量的类型为字变量WORD，并给变量分配字或字串，DW伪指令后面的操作数每个占用1个字，即2个字节。在内存中存放时，低位字节存放在低地址中，高位字节存放在高地址中。</p>
<h4 id="定义双字变量伪指令DD"><a href="#定义双字变量伪指令DD" class="headerlink" title="定义双字变量伪指令DD"></a>定义双字变量伪指令DD</h4><p>DD（Define Double word）用于定义变量的类型为双字变量，DD伪指令后面的操作数每个占用2个字，即4个字节。在内存中存放时，低位字节存放在低地址中，高位字节存放在高地址中。</p>
<h4 id="定义四字变量伪指令DQ"><a href="#定义四字变量伪指令DQ" class="headerlink" title="定义四字变量伪指令DQ"></a>定义四字变量伪指令DQ</h4><p>DQ（Define Quadruple word）用于定义变量的类型为四字变量，DQ伪指令后面的操作数每个占用4个字，即8个字节。在内存中存放时，低位字节存放在低地址中，高位字节存放在高地址中。</p>
<h4 id="定义十字节变量伪指令DT"><a href="#定义十字节变量伪指令DT" class="headerlink" title="定义十字节变量伪指令DT"></a>定义十字节变量伪指令DT</h4><p>DT（Define Ten byte）用于定义变量的类型为十字节，DT伪指令后面的操作数每个占用10个字节。一般用于存储压缩的BCD码。</p>
<p>数据定义伪指令后面的操作数可以是常数、表达式或字符串，但每项操作数的值不能超过由伪指令所定义的数据类型限定的范围。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA  SEGMENT                 ；定义数据段开始</span><br><span class="line">B1    DB  10H，30H            ；存入两个字节10H，30H</span><br><span class="line">B2    DB  2*3+5               ；存入表达式的值0BH</span><br><span class="line">S1    DB  ‘HELLO’             ；存入5个字符，每个字符按ASCII码存入</span><br><span class="line">W1    DW  2000H，3000H        ；存入两个字2000H，3000H</span><br><span class="line">W2    DD   12345678H          ；存入双字（5678H，1234H）</span><br><span class="line">W3    DQ   1234567887654321H  ；存入四字（4321H，8765H，5678H，  1234H）</span><br><span class="line">DATA  ENDS                    ；数据段结束</span><br></pre></td></tr></table></figure>

<h4 id="DUP（duplication-operator）用于重复某个（或某些）操作数。"><a href="#DUP（duplication-operator）用于重复某个（或某些）操作数。" class="headerlink" title="DUP（duplication operator）用于重复某个（或某些）操作数。"></a>DUP（duplication operator）用于重复某个（或某些）操作数。</h4><p><code>[变量名] DB/DW/DD/DQ/DT〈表达式1〉 DUP〈表达式2〉</code><br>〈表达式1〉为重复次数，〈表达式2〉为重复的内容.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEM1 DB 3  DUP (4,5);从MEM1地址单元开始存放三组“04H，05H”共6个地址单元</span><br><span class="line">MEM2 DW 30 DUP(?)   ;从MEM2地址单元开始保留30个字共60个地址单元</span><br><span class="line">MEM3 DB 10 DUP(1,2,3 DUP(3),4) ;从MEM3地址单元开始存放十组“01，02，03，03，03，04”，共占用60个地址单元。</span><br></pre></td></tr></table></figure>
<h3 id="符号定义伪指令"><a href="#符号定义伪指令" class="headerlink" title="符号定义伪指令"></a>符号定义伪指令</h3><p>符号定义伪指令的用途是给一个符号重新命名，或定义新的类型属性等。</p>
<h4 id="EQU伪指令"><a href="#EQU伪指令" class="headerlink" title="EQU伪指令"></a>EQU伪指令</h4><p>指令格式：<code>名字  EQU  表达式</code><br>EQU伪指令的作用是将表达式的值赋给一个名字，以后可以用这个名字来代替上述表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUTN   EQU  200            ;COUNT代替常数200</span><br><span class="line">VAL     EQU  ASCII_TABLE    ;VAL代替变量ASSCII_TABLE</span><br><span class="line">SUM     EQU  3*2            ;SUM代替数值表达式：3*2</span><br><span class="line">ADDR    EQU  [BP+8]         ;ADDR代替地址表达式：[BP+8]</span><br><span class="line">C       EQU  CX             ;C代替寄存器CX</span><br><span class="line">M       EQU  MOV            ;M代替指令助记符MOV</span><br></pre></td></tr></table></figure>

<h4 id="x3D-（等号）伪指令"><a href="#x3D-（等号）伪指令" class="headerlink" title="&#x3D;（等号）伪指令"></a>&#x3D;（等号）伪指令</h4><p>“&#x3D;”（等号）伪指令的功能与EQU伪指令基本相同，<strong>主要区别在于它可以对同一个名字重复定义，而EQU不能。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUTN  EQU  200     ;正确，COUNT代替常数200</span><br><span class="line">COUTN  EQU  300     ;错误，COUNT不能再次定义</span><br><span class="line">COUTN  = 200        ;正确，COUNT代替常数200</span><br><span class="line">COUTN  = 300        ;正确，COUNT可以重复定义，即COUNT代替常数300</span><br></pre></td></tr></table></figure>
<h3 id="地址计数器-和ORG伪指令"><a href="#地址计数器-和ORG伪指令" class="headerlink" title="地址计数器$和ORG伪指令"></a>地址计数器$和ORG伪指令</h3><h4 id="地址计数器"><a href="#地址计数器" class="headerlink" title="地址计数器$"></a>地址计数器$</h4><p>地址计数器的值可用$来表示，汇编语言允许用户直接使用$来引用地址计数器的值</p>
<h4 id="ORG伪指令"><a href="#ORG伪指令" class="headerlink" title="ORG伪指令"></a>ORG伪指令</h4><p>ORG是起始位置设置伪指令，用来设置当前地址计数器的值。<br>指令格式：<code>ORG  数值表达式</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA    SEGMENT                     ;定义数据段开始</span><br><span class="line">        ORG   0010H                 ;预置VAR1的偏移量为00010H</span><br><span class="line">        VAR1  DB 20H,30H,40H        ;VAR1的初始化数据</span><br><span class="line">        ORG   $+13                  ;预置VAR2的偏移量为00020H</span><br><span class="line">        VAR2  DW  5678H             ;VAR2的初始化数据</span><br><span class="line">DATA    ENDS                        ;数据段结束</span><br></pre></td></tr></table></figure>

<h1 id="BIOS和DOS中断"><a href="#BIOS和DOS中断" class="headerlink" title="BIOS和DOS中断"></a>BIOS和DOS中断</h1><p>基本输入输出系统（Basic Input&#x2F;Output System，BIOS）给PC系列的不同微处理器提供了兼容的系统加电自检、引导装入、主要I&#x2F;O设备的处理程序以及接口控制等功能模块来处理所有的系统中断。使用BIOS功能调用，程序员不必了解硬件的具体细节，可直接使用指令设置参数，调用BIOS示例程序，所以利用BIOS功能调用编写的程序简洁，可读性好，而且易于移植。</p>
<p>磁盘操作系统（Disk Operating System，DOS）是PC机上最重要的操作系统，它是由软盘或硬盘提供的。它的两个DOS模块<code>IBMBIO.COM</code>和<code>IBMDOS.COM</code>使BIOS使用起来更方便。</p>
<p><code>IBMBIO.COM</code>是输入输出设备处理程序，它提供了DOS到ROM和BIOS的低级接口，完成将数据从外设读入内存，或把数据从内存写到外设去工作。 <code>IBMDOS.COM</code>包含一个文件管理程序和一些处理程序，在DOS下运行的程序可以调用这些处理程序。</p>
<p><strong>DOS功能与BIOS功能都是通过软件中断调用。在中断调用前需要把功能号装入AH寄存器，把子功能号装入AL寄存器，除此之外，通常还需要在CPU寄存器中提供专门的调用参数。</strong></p>
<h2 id="BIOS和DOS的中断类型"><a href="#BIOS和DOS的中断类型" class="headerlink" title="BIOS和DOS的中断类型"></a>BIOS和DOS的中断类型</h2><p>不同微机系列的BIOS和DOS的中断类型各有差异。下面给出的是IBM PC系统主要的BIOS中断类型和DOS中断类型</p>
<table cellpadding="0" cellspacing="0" width="880" style="width: 804px;">
    <tbody>
        <tr height="43" style=";height:43px" class="firstRow">
            <td height="43" width="159" style="">
                <p>
                    CPU中断类型
                </p>
            </td>
            <td width="229" style="">
                <p>
                    8259中断类型
                </p>
            </td>
            <td width="193" style="">
                <p>
                    BIOS中断类型
                </p>
            </td>
            <td width="299" style="">
                <p>
                    用户应用程序和数据表指针
                </p>
            </td>
        </tr>
        <tr height="43" style=";height:43px">
            <td rowspan="4" height="365" width="159" style="">
                <p>
                    0 &nbsp; 除法错
                </p>
                <p>
                    1 &nbsp; 单步
                </p>
                <p>
                    2 &nbsp; 非屏蔽中断
                </p>
                <p>
                    3 &nbsp; 断点
                </p>
                <p>
                    4 &nbsp; 溢出
                </p>
                <p>
                    5 &nbsp; 打印屏幕
                </p>
                <p>
                    6 &nbsp; 保留
                </p>
                <p>
                    7 &nbsp; 保留
                </p>
            </td>
            <td rowspan="4" width="229" style="">
                <p>
                    8 &nbsp; 系统定时器(IRQ0)
                </p>
                <p>
                    9 &nbsp; 键盘(IRQ1)
                </p>
                <p>
                    A &nbsp; 彩色/图形接口(IRQ2)
                </p>
                <p>
                    B &nbsp; COM2控制器(IRQ3)
                </p>
                <p>
                    C &nbsp; COM1控制器(IRQ4)
                </p>
                <p>
                    D &nbsp; LPT2控制器(IRQ4)
                </p>
                <p>
                    E &nbsp; 磁盘控制器(IRQ4)
                </p>
                <p>
                    F &nbsp; LTP1控制器(IRQ4)
                </p>
            </td>
            <td rowspan="4" width="193" style="">
                <p>
                    10 &nbsp; 显示器I/O
                </p>
                <p>
                    11 &nbsp; 取设备信息
                </p>
                <p>
                    12 &nbsp; 取内存信息
                </p>
                <p>
                    13 &nbsp; 磁盘I/O
                </p>
                <p>
                    14 &nbsp; RS-232串口I/O
                </p>
                <p>
                    15 &nbsp; 磁盘I/O
                </p>
                <p>
                    16 键盘I/O
                </p>
                <p>
                    17打印机I/O
                </p>
                <p>
                    18 &nbsp; ROM&nbsp; BASIC
                </p>
                <p>
                    19 &nbsp; 引导装入程序
                </p>
                <p>
                    1A &nbsp; 时钟
                </p>
                <p>
                    40 &nbsp; 软盘BIOS
                </p>
            </td>
            <td width="299" style="">
                <p>
                    用户应用程序
                </p>
            </td>
        </tr>
        <tr height="100" style=";height:100px">
            <td height="100" width="299" style="">
                <p>
                    1B &nbsp; 键盘终止地址(Ctrl+Break)
                </p>
                <p>
                    4A &nbsp; 报警（用户闹钟）
                </p>
                <p>
                    1C &nbsp; 定时器
                </p>
            </td>
        </tr>
        <tr height="43" style=";height:43px">
            <td height="43" width="299" style="">
                <p>
                    数据表指针
                </p>
            </td>
        </tr>
        <tr height="178" style=";height:178px">
            <td height="178" width="299" style="">
                <p>
                    1D &nbsp; 显示器参数表
                </p>
                <p>
                    1E &nbsp; 软盘参数表
                </p>
                <p>
                    1F &nbsp; 图形字符扩展码
                </p>
                <p>
                    41 &nbsp; 0#硬盘参数表
                </p>
                <p>
                    46 &nbsp; 1#硬盘参数表
                </p>
                <p>
                    49 &nbsp; 指向键盘增强服务变换表
                </p>
            </td>
        </tr>
    </tbody>
</table>

<blockquote>
<p>BIOS中断</p>
</blockquote>
<table cellpadding="0" cellspacing="0" width="872" style="width: 804px;">
    <tbody>
        <tr class="firstRow">
            <td width="219" style="">
                <p>
                    功能调用号
                </p>
            </td>
            <td width="219" style="">
                <p>
                    功能说明
                </p>
            </td>
            <td width="219" style="">
                <p>
                    功能调用号
                </p>
            </td>
            <td width="219" style="">
                <p>
                    功能说明
                </p>
            </td>
        </tr>
        <tr>
            <td width="219" style="">
                <p>
                    20
                </p>
                <p>
                    21
                </p>
                <p>
                    22
                </p>
                <p>
                    23
                </p>
                <p>
                    24
                </p>
                <p>
                    25
                </p>
                <p>
                    26
                </p>
            </td>
            <td width="219" style="">
                <p>
                    程序终止
                </p>
                <p>
                    功能调用
                </p>
                <p>
                    终止地址
                </p>
                <p>
                    Ctrl+C中断向量
                </p>
                <p>
                    严重错误向量
                </p>
                <p>
                    绝对磁盘读
                </p>
                <p>
                    绝对磁盘写
                </p>
            </td>
            <td width="219" style="">
                <p>
                    27
                </p>
                <p>
                    28
                </p>
                <p>
                    29
                </p>
                <p>
                    2A
                </p>
                <p>
                    2E
                </p>
                <p>
                    2F
                </p>
                <p>
                    30～3F
                </p>
            </td>
            <td width="219" style="">
                <p>
                    结束并驻留内存
                </p>
                <p>
                    键盘忙循环
                </p>
                <p>
                    快速写字符
                </p>
                <p>
                    网络接口
                </p>
                <p>
                    执行命令
                </p>
                <p>
                    多路转换接口
                </p>
                <p>
                    保留给DOS
                </p>
            </td>
        </tr>
    </tbody>
</table>

<blockquote>
<p>DOS中断</p>
</blockquote>
<h2 id="BIOS和DOS功能调用的基本步骤"><a href="#BIOS和DOS功能调用的基本步骤" class="headerlink" title="BIOS和DOS功能调用的基本步骤"></a>BIOS和DOS功能调用的基本步骤</h2><ol>
<li>将调用参数装入指定的寄存器。</li>
<li>如需要功能调用号，把它装入AH。</li>
<li>如需要子功能调用号，把它装入AL。</li>
<li>按中断号调用DOS或BIOS。</li>
<li>检查返回参数是否正确。</li>
</ol>
<h2 id="常见的BIOS和DOS功能调用"><a href="#常见的BIOS和DOS功能调用" class="headerlink" title="常见的BIOS和DOS功能调用"></a>常见的BIOS和DOS功能调用</h2><p>一般来说，实现同样的功能有时既可以用BIOS中断调用，也可以用DOS中断调用。</p>
<h3 id="键盘输入中断调用"><a href="#键盘输入中断调用" class="headerlink" title="键盘输入中断调用"></a>键盘输入中断调用</h3><h4 id="BIOS键盘中断"><a href="#BIOS键盘中断" class="headerlink" title="BIOS键盘中断"></a>BIOS键盘中断</h4><p>类型16H的中断提供了基本的键盘操作，它的中断处理程序包括3个不同的功能，可根据AH寄存器中的功能号来确定</p>
<table cellpadding="0" cellspacing="0" width="864" style="width: 804px;">
    <tbody>
        <tr height="44" style=";height:44px" class="firstRow">
            <td height="44" width="84" style="">
                <p>
                    AH
                </p>
            </td>
            <td width="219" style="">
                <p>
                    功能
                </p>
            </td>
            <td width="561" style="">
                <p>
                    返回参数
                </p>
            </td>
        </tr>
        <tr height="44" style=";height:44px">
            <td height="44" width="84" style="">
                <p>
                    0
                </p>
            </td>
            <td width="219" style="">
                <p>
                    从键盘读一字符
                </p>
            </td>
            <td width="561" style="">
                <p>
                    AL=字符码，AH=扫描码
                </p>
            </td>
        </tr>
        <tr height="44" style=";height:44px">
            <td height="44" width="84" style="">
                <p>
                    1
                </p>
            </td>
            <td width="219" style="">
                <p>
                    读键盘缓冲区的字符
                </p>
            </td>
            <td width="561" style="">
                <p>
                    如ZF=0，AL=字符码，AH=扫描码；如ZF=1，缓冲区空
                </p>
            </td>
        </tr>
        <tr height="44" style=";height:44px">
            <td height="44" width="84" style="">
                <p>
                    2
                </p>
            </td>
            <td width="219" style="">
                <p>
                    取键盘状态字节
                </p>
            </td>
            <td width="561" style="">
                <p>
                    AL=键盘状态字节
                </p>
            </td>
        </tr>
    </tbody>
</table>

<blockquote>
<p>BIOS键盘中断（INT 16H）</p>
</blockquote>
<h4 id="DOS键盘中断"><a href="#DOS键盘中断" class="headerlink" title="DOS键盘中断"></a>DOS键盘中断</h4><p>类型21H的中断提供了DOS键盘操作，它的中断处理程序包括7个不同的功能，分别根据AH寄存器中的功能号来确定</p>
<table cellpadding="0" cellspacing="0" width="864" style="width: 804px;">
    <tbody>
        <tr height="33" style=";height:33px" class="firstRow">
            <td height="33" width="65" style="">
                <p>
                    AH
                </p>
            </td>
            <td width="256" style="">
                <p>
                    功能
                </p>
            </td>
            <td width="256" style="">
                <p>
                    调用参数
                </p>
            </td>
            <td width="288" style="">
                <p>
                    返回参数
                </p>
            </td>
        </tr>
        <tr height="53" style=";height:53px">
            <td height="53" width="65" style="">
                <p>
                    <strong>1</strong>
                </p>
            </td>
            <td width="256" style="">
                <p>
                    <strong>从键盘输入一字符并回显在屏幕上</strong>
                </p>
            </td>
            <td width="256" style="">
                <p>
                    <strong>无</strong>
                </p>
            </td>
            <td width="288" style="">
                <p>
                    <strong>AL=字符</strong>
                </p>
            </td>
        </tr>
        <tr height="53" style=";height:53px">
            <td height="53" width="65" style="">
                <p>
                    <strong>6</strong>
                </p>
            </td>
            <td width="256" style="">
                <p>
                    <strong>读键盘字符，不回显</strong>
                </p>
            </td>
            <td width="256" style="">
                <p>
                    <strong>DL=0FFH</strong>
                </p>
            </td>
            <td width="288" style="">
                <p>
                    <strong>如ZF=0，AL=字符；如ZF=1，缓冲区空</strong>
                </p>
            </td>
        </tr>
        <tr height="53" style=";height:53px">
            <td height="53" width="65" style="">
                <p>
                    7
                </p>
            </td>
            <td width="256" style="">
                <p>
                    从键盘输入一个字符，不回显
                </p>
            </td>
            <td width="256" style="">
                <p>
                    无
                </p>
            </td>
            <td width="288" style="">
                <p>
                    AL=字符
                </p>
            </td>
        </tr>
        <tr height="53" style=";height:53px">
            <td height="53" width="65" style="">
                <p>
                    8
                </p>
            </td>
            <td width="256" style="">
                <p>
                    从键盘输入一个字符，不回显，检测Ctrl+Break
                </p>
            </td>
            <td width="256" style="">
                <p>
                    无
                </p>
            </td>
            <td width="288" style="">
                <p>
                    AL=字符
                </p>
            </td>
        </tr>
        <tr height="27" style=";height:27px">
            <td height="27" width="65" style="">
                <p>
                    A
                </p>
            </td>
            <td width="256" style="">
                <p>
                    输入字符到缓冲区
                </p>
            </td>
            <td width="256" style="">
                <p>
                    DS：BX=缓冲区首地址
                </p>
            </td>
            <td width="288" style="">
                <p>
                    AL=字符
                </p>
            </td>
        </tr>
        <tr height="53" style=";height:53px">
            <td height="53" width="65" style="">
                <p>
                    B
                </p>
            </td>
            <td width="256" style="">
                <p>
                    读键盘状态
                </p>
            </td>
            <td width="256" style="">
                <p>
                    无
                </p>
            </td>
            <td width="288" style="">
                <p>
                    AL=0FFH，有键入
                </p>
                <p>
                    AL=00，无键入
                </p>
            </td>
        </tr>
        <tr height="69" style=";height:69px">
            <td height="69" width="65" style="">
                <p>
                    C
                </p>
            </td>
            <td width="256" style="">
                <p>
                    清除键盘缓冲区，并调用一种键盘功能
                </p>
            </td>
            <td width="256" style="" class="selectTdClass">
                <p>
                    AL=键盘功能号
                </p>
                <p>
                    （1，6，7，8或A）
                </p>
            </td>
            <td width="288" style="" class="selectTdClass"></td>
        </tr>
    </tbody>
</table>

<blockquote>
<p>DOS键盘中断（INT 21H）</p>
</blockquote>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>1号系统功能调用─从键盘输入一字符并显示在屏幕上</strong></p>
<p>此调用的功能是系统扫描键盘并等待输入一个字符，有键按下时，先检查是否是Ctrl+Break键，若是则退出；否则将字符的键值（ASCII码）送入寄存器AL中，并在屏幕上显示该字符。此调用没有入口参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH,1   ;1为功能号</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>

<p><strong>6号系统功能调用─读键盘字符</strong><br>此调用的功能是从键盘输入一个字符，或输出一个字符到屏幕。<br>如果<strong>（DL）＝0FFH，表示是从键盘输入字符</strong>。<br>当标志ZF&#x3D;0时，表示有键按下，将字符的ASCII码送入寄存器AL。<br>当标志ZF&#x3D;1时，表示无键按下，寄存器AL中不是键入字符ASCII码。<br>如果<strong>（DL）≠0FFH，表示输出一个字符到屏幕</strong>。此时DL寄存器中内容就是输出字符的ASCII码。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  DL，0FFH</span><br><span class="line">MOV  AH，6；把键盘输入的一个字符送入AL中</span><br><span class="line">INT  2lH</span><br><span class="line">MOV  DL′？′</span><br><span class="line">MOV  AH，6；将DL中的字符“？”送屏幕显示</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure>

<h3 id="显示器输出中断调用"><a href="#显示器输出中断调用" class="headerlink" title="显示器输出中断调用"></a>显示器输出中断调用</h3><p>DOS显示中断的中断处理程序包括3个不同的功能，分别根据AH寄存器中的功能号来确定。</p>
<table cellpadding="0" cellspacing="0" width="848" style="width: 804px;">
    <tbody>
        <tr height="60" style=";height:60px" class="firstRow">
            <td height="60" width="84" style="">
                <p>
                    AH
                </p>
            </td>
            <td width="201" style="">
                <p>
                    功能
                </p>
            </td>
            <td width="401" style="">
                <p>
                    调用参数
                </p>
            </td>
            <td width="163" style="">
                <p>
                    返回参数
                </p>
            </td>
        </tr>
        <tr height="97" style=";height:97px">
            <td height="97" width="84" style="">
                <p>
                    2
                </p>
            </td>
            <td width="201" style="">
                <p>
                    显示一个字符（检验Ctrl+Break）
                </p>
            </td>
            <td width="401" style="">
                <p>
                    DL=输出字符
                </p>
            </td>
            <td width="163" style="">
                <p>
                    无
                </p>
            </td>
        </tr>
        <tr height="60" style=";height:60px">
            <td rowspan="2" height="119" width="84" style="">
                <p>
                    6
                </p>
            </td>
            <td rowspan="2" width="201" style="">
                <p>
                    显示一个字符（不检验Ctrl+Break）
                </p>
            </td>
            <td width="401" style="">
                <p>
                    DL=0FF（输入）
                </p>
            </td>
            <td width="163" style="">
                <p>
                    AL=输入字符
                </p>
            </td>
        </tr>
        <tr height="59" style=";height:59px">
            <td height="59" width="401" style="">
                <p>
                    DL=字符（输出）
                </p>
            </td>
            <td width="163" style="">
                <p>
                    无
                </p>
            </td>
        </tr>
        <tr height="67" style=";height:67px">
            <td height="67" width="84" style="">
                <p>
                    9
                </p>
            </td>
            <td width="201" style="">
                <p>
                    显示字符串
                </p>
            </td>
            <td width="401" style="">
                <p>
                    DS：DX=串地址，字符串以‘$’结尾
                </p>
            </td>
            <td width="163" style="">
                <p>
                    无
                </p>
            </td>
        </tr>
    </tbody>
</table>

<p><strong>2号系统功能调用─显示一个字符（检验Ctrl+Break）</strong></p>
<p>此调用的功能是向输出设备输出一个字符码，此调用的入口参数是输出字符的ASCII码，入口参数需送入寄存器DL，没有出口参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DL,&#x27;A&#x27;     ; “A”为要求输出字符的ASCII码 </span><br><span class="line">MOV AH,2       ; 2为功能号</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>
<p>调用结果是将DL寄存器中字符‘A’通过屏幕显示（或打印机）输出</p>
<p><strong>9号系统功能调用—显示字符串</strong></p>
<p>它要求被显示输出的字符必须以“$” 字符作为结尾符。要显示输出的信息一般定义在数据段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MESSAGE DB ‘The sort operation is finished’,‘$’</span><br><span class="line">MOV AH,9</span><br><span class="line">MOV DX,SEG MESSAGE</span><br><span class="line">MOV DS,DX</span><br><span class="line">MOV DX,OFFSET MESSAGE</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>

<h1 id="子程序结构"><a href="#子程序结构" class="headerlink" title="子程序结构"></a>子程序结构</h1><p>子程序又称为过程，它相当于高级语言中的过程和函数。</p>
<h2 id="子程序的结构形式"><a href="#子程序的结构形式" class="headerlink" title="子程序的结构形式"></a>子程序的结构形式</h2><p>子程序的基本结构包括以下几部分：</p>
<ol>
<li>子程序说明。</li>
<li>保护现场和恢复现场。</li>
<li>子程序体。</li>
<li>子程序返回。</li>
</ol>
<h2 id="子程序的定义"><a href="#子程序的定义" class="headerlink" title="子程序的定义"></a>子程序的定义</h2><p>子程序又称为过程（procedure），过程要用过程定义伪指令进行定义。<br>指令格式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过程名  PROC [NEAR] 或 [FAR]</span><br><span class="line">        ...</span><br><span class="line">        （子程序体）</span><br><span class="line">        ...</span><br><span class="line">过程名  ENDP</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ol>
<li>PROC和ENDP必须成对使用</li>
<li>过程名是自定义符，可以作为标号被指令CALL调用</li>
<li>过程由RET指令返回，返回调用程序的操作与过程的属性有关。NEAR型过程属于段内调用，则RET是段内返回；FAR型过程属于段间调用，RET是段间返回。系统设定的缺省类型为NEAR。</li>
</ol>
<p>调用程序和过程在同一个代码段，属于近调用，程序形式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN    PROC  FAR        ; MAIN为调用程序</span><br><span class="line">        ...</span><br><span class="line">        CALL  DISPLAY</span><br><span class="line">        ....</span><br><span class="line">        RET</span><br><span class="line">MAIN    ENDP</span><br><span class="line">DISPLAY PROC  NEAR       ; 子程序为NEAR过程</span><br><span class="line">        PUSH  AX</span><br><span class="line">        PUSH  BX</span><br><span class="line">        ...</span><br><span class="line">        POP   BX</span><br><span class="line">        POP   AX</span><br><span class="line">        RET</span><br><span class="line">DISPLAY ENDP</span><br></pre></td></tr></table></figure>
<p>这里的MAIN和DISPLAY分别为调用程序和子程序的名字。因调用程序和子程序在同一个代码段，所以DISPLAY选择了NEAR属性。这样，但MAIN调用DISPLAY保护返回地址时，只需保护IP指令就可以了。本例也可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN    PROC  FAR         ; MAIN为调用程序</span><br><span class="line">        ...</span><br><span class="line">        CALL  DISPLAY</span><br><span class="line">        ...</span><br><span class="line">        RET</span><br><span class="line">DISPLAY PROC  NEAR        ; 子程序为为NEAR过程</span><br><span class="line">        PUSH  AX </span><br><span class="line">        PUSH  BX</span><br><span class="line">        ...</span><br><span class="line">        POP   BX</span><br><span class="line">        POP   AX</span><br><span class="line">        RET</span><br><span class="line">DISPLAY ENDP</span><br><span class="line">MAIN    ENDP</span><br></pre></td></tr></table></figure>
<p>也就是说，过程定义可以嵌套，一个过程定义可以包括多个过程定义。</p>
<p>调用程序和过程不在同一个代码段，属于远调用，程序形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE1  SEGMENT</span><br><span class="line">        ...</span><br><span class="line">         CALL  DISPLAY</span><br><span class="line">        ...</span><br><span class="line">DISPLAY PROC  FAR        ；子程序为FAR过程</span><br><span class="line">        PUSH  AX</span><br><span class="line">        PUSH  BX</span><br><span class="line">        ...</span><br><span class="line">        POP  BX</span><br><span class="line">        POP  AX</span><br><span class="line">        RET</span><br><span class="line">DISPLAY ENDP</span><br><span class="line">        ...</span><br><span class="line">CODE1   ENDS</span><br><span class="line">CODE2   SEGMENT</span><br><span class="line">        ...</span><br><span class="line">        CALL  DISPLAY</span><br><span class="line">        ...</span><br><span class="line">CODE2   ENDS</span><br></pre></td></tr></table></figure>

<h2 id="子程序的参数传送"><a href="#子程序的参数传送" class="headerlink" title="子程序的参数传送"></a>子程序的参数传送</h2><p>调用程序在调用子程序时，经常需要传送一些参数给子程序；子程序运行完成后也经常要回送一些信息给调用程序。这种调用程序和子程序之间的信息传送称之为参数传送（或称变量传送或过程通信）。参数传送方式主要分为以下三种。</p>
<ol>
<li>通过寄存器传送参数。</li>
<li>通过堆栈传送参数。</li>
<li>通过存储器传送参数。</li>
</ol>
<blockquote>
<p> 啊，第三章真的好长，知识点也很多，一章直接入门编程语言，以后还是得多看</p>
</blockquote>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><blockquote>
<ol>
<li>汇编语言源程序经汇编、链接后生成 <code>EXE</code> 文件。</li>
<li>8086&#x2F;8088汇编语言中伪指令的定义如下：VAR DB 2DUP(1,2,3DUP(3),2DUP(1,0)) , 则在VAR存储区前10个单元的数据是 <code>1，2，3，3，3，1，0，1，0，1 </code>。</li>
<li>微处理器8086的一个段的最大范围是 <code>64</code> KB。</li>
<li>指令AND AX,0 将累加器AX的内容  <code>清零</code>   。</li>
<li>逻辑移位指令SHL用于 <code>无符号数乘2</code>  。</li>
<li>设（SS）&#x3D;2000H, (SP)&#x3D;0100H, (AX)&#x3D;2107H, 执行指令PUSH AX后，存放数据21H的物理地址为 <code>200FFH</code> 。</li>
</ol>
</blockquote>
<h1 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h1><p><strong>名称解释：操作数，操作码，立即数，寄存器操作数，储存器操作数，汇编，汇编程序，汇编程序语言，伪指令，中断。</strong></p>
<p>答：操作数：操作数指出指令执行的操作所需要数据的来源。操作码：用来表示该指令应进行什么性质的操作。立即数：通常把在立即寻址方式指令中给出的数称为立即数。寄存器操作数：表示某一个寄存器，操作数本身存放于寄存器中，在指令中只是给出了几个位的代码来表示它具体存放在哪个寄存器中。储存器操作数：和寄存器操作数差不多，操作数本身放在储存器中。汇编：汇编指将汇编语言源程序转换成对应的机器语言程序。  汇编程序：指把汇编语言书写的程序翻译成与之等价的机器语言程序的翻译程序。汇编程序语言：是一种面向CPU指令系统的程序设计语言。伪指令：是控制汇编过程的命令，又称为汇编控制命令。中断：指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<p><strong>请说明下列指令是否正确，并指出错误原因。</strong></p>
<ol>
<li>MOV [2100],[2200H]，错误，MOV指令的两个操作数必须有一个为寄存器</li>
<li>MOV DH,0001H，错误，两个操作数的位数不一样</li>
<li>MOV CX,50H[BX+BP]，错误，不允许同时使用BX，BP</li>
<li>MOV IP,2456H，错误，IP不能作为目标操作数</li>
<li>PUSH DL，错误，DL为一个字节，不能进栈</li>
<li>MOV CS,AX，错误，CX只能向通用寄存器传，不能反转</li>
<li>MOV 3000H,BX，错误，立即数不能作为目标操作数</li>
<li>MOV ES,DS，错误，不允许在两个段寄存器之间传值</li>
<li>IN AX,256，错误，256不在00H~FFH范围之内</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与接口技术笔记（4）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<p>这章内容讲可编程并行接口8255A</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>8255A是Intel公司生产的通用可编程并行接口芯片,8255A采用40脚双列直插封装，单一+5V电源，全部输入&#x2F;输出与TTL电平兼容。</p>
<p>它有三个输入&#x2F;输出端口：端口A、端口B、端口C。每个端口都可通过编程设定为输入端口或输出端口，但有各自不同的方式和特点。<strong>端口C可作为一个独立的端口使用，但通常是配合端口A和端口B的工作，为这两个端口的输入&#x2F;输出提供控制联络信号。</strong></p>
<h1 id="芯片引脚"><a href="#芯片引脚" class="headerlink" title="芯片引脚"></a>芯片引脚</h1><p>8255A芯片有40根引脚：</p>
<ol>
<li>电源与地线2根：Vcc（26脚）、GND（7脚）。</li>
<li>与外设相连的共24根。<ul>
<li>PA7～PA0：端口A数据信号（8根）。</li>
<li>PB7～PB0：端口B数据信号（8根）。</li>
<li>PC7～PC0：端口C数据信号（8根）。</li>
</ul>
</li>
<li>RESET(35脚)：复位信号,高电平有效。当RESET信号有效时,内部所有寄存器都被清零。同时,3个数据端口被自动设置为输入端口。</li>
<li>D7～D0：三态双向数据线，在8086系统中，采用16位数据总线，D7～D0通常是接在16位数据总线的低8位上。</li>
<li>CS（6脚）：片选信号，低电平有效。该信号来自译码器的输出，只有当CS有效时，读信号RD和写信WR号才对8255A有效。</li>
<li>RD（5脚）：读信号，低电平有效。它控制从8255A读出数据或状态信息。</li>
<li>WR（36脚）：写信号，低电平有效。它控制把数据或控制命令字写入8255A。</li>
<li>A1、A0（8、9脚）：端口选择信号。8255A内部共有4个端口（即寄存器）：3个数据端口（端口A、端口B、端口C）和1个控制端口，当片选信号CS有效时，规定A1、A0为00、01、10、11时，分别选中端口A、端口B、端口C和控制端口。</li>
</ol>
<table>
<thead>
<tr>
<th>A1</th>
<th>A0</th>
<th>RD</th>
<th>WR</th>
<th>CS</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>端口A→数据总线</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>端口B→数据总线</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>端口C→数据总线</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>数据总线→端口A</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>数据总线→端口B</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>数据总线→端口C</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>数据总线→控制字寄存器</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>1</td>
<td>数据总线为三态（高阻）</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>非法状态</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>数据总线为三态（高阻）</td>
</tr>
</tbody></table>
<h1 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h1><p>8255A的内部结构包括四个部分：数据总线缓冲器、读写控制逻辑、A组控制器（包括端口A和端口C的上半部）和B组控制器（包括端口B和端口C的下半部）。 </p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/1.png" class="" title="引脚和内部结构">

<h2 id="A组和B组"><a href="#A组和B组" class="headerlink" title="A组和B组"></a>A组和B组</h2><p><strong>端口A和端口C的高4位（PC7～PC4）构成A组</strong>，由A组控制部件来对它进行控制；<strong>端口B和端口C的低4位（PC3～PC0）构成B组</strong>，由B组控制部件对它进行控制。这两个控制部件各有一个控制单元，接收来自数据总线送来的控制字，并根据控制字确定各端口的工作状态和工作方式。</p>
<h2 id="数据总线缓冲器"><a href="#数据总线缓冲器" class="headerlink" title="数据总线缓冲器"></a>数据总线缓冲器</h2><p>数据总线缓冲器是一个双向三态的8位缓冲器，它与CPU系统数据总线相连，是8255A与CPU之间传输数据的必经之路。<strong>输入数据、输出数据、控制命令字都是通过数据总线缓冲器进行传送的</strong>。</p>
<h2 id="读／写控制逻辑"><a href="#读／写控制逻辑" class="headerlink" title="读／写控制逻辑"></a>读／写控制逻辑</h2><p><strong>读／写控制逻辑接收来自CPU地址总线的信号和控制信号，并发出命令到A组和B组</strong>，把CPU发出的控制命令字或输出的数据通过数据总线缓冲器送到相应的端口，或者把外设的状态或输入的数据从相应的端口通过数据总线缓冲器送到CPU。</p>
<p><strong>在微机80386以上的32位外部数据总线的系统中，则应将8255A的A1端与地址总线的A3相连，将8255A的A0端与地址总线A2相连，并使CPU访问8255A时地址总线的A1、A0两位总是为00。</strong></p>
<h1 id="控制字及状态字"><a href="#控制字及状态字" class="headerlink" title="控制字及状态字"></a>控制字及状态字</h1><p><strong>可编程就是用指令的方法先对芯片进行初始化，设置芯片的端口是处于输入数据状态还是处于输出数据状态，以及每个端口的工作方式。要使8255A工作，必须把工作命令控制字写入8255A的控制字寄存器。</strong></p>
<p>8255A共有两种控制字：</p>
<ul>
<li>工作方式选择控制字，可使8255A的3个数据端口工作在不同的方式。</li>
<li>端口C按位置位&#x2F;复位控制字，可使C端口中的任何一位进行置位或复位。</li>
</ul>
<h2 id="工作方式选择控制字"><a href="#工作方式选择控制字" class="headerlink" title="工作方式选择控制字"></a>工作方式选择控制字</h2><p>8255A的3种基本工作方式：由方式选择控制字来决定。<br>方式0：基本的输入&#x2F;输出方式。<br>方式1：选通的输入&#x2F;输出方式。<br>方式2：双向的传输方式。</p>
<ul>
<li>端口A可以工作于方式0、方式1、方式2共三种工作方式，可以作为输入端口或输出端口。</li>
<li>端口B可以工作于方式0、方式1两种工作方式，可以作为输入端口或输出端口。</li>
<li>端口C分成高4位(PC7～PC4)和低4位(PC3～PC0)，可分别设置成输入端口或输出端口；端口C的高4位与端口A配合组成A组，端口C的低4位与端口B配合组成B组。</li>
<li><strong>D7＝1（特征位），表明是设定工作方式选择控制字；D7＝0为端口C按位置位／复位控制字</strong>。</li>
</ul>
<p>通过对8255A工作方式控制字的设置可将PA、PB和PC 3个端口分别定义为3种不同工作方式的组合，工作方式选择控制字格式及各位含义如图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/2.png" class="" title="8255A的工作方式选择控制字">

<p>在使用8255A芯片前，必须先对其进行初始化。<strong>初始化的程序很简单，只要CPU执行一条输出指令，把控制字写入控制寄存器就可以了</strong>。</p>
<blockquote>
<p>例题： 按下述要求对8255A进行初始化。要求A口设定为输出数据，工作方式为方式0；B口设定为输入数据，工作方式为方式1；C口设定为高四位输入，低四位输出。(地址为200H~203H)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  DX , 203H   ;8255控制口地址送DX</span><br><span class="line">MOV  AL ,8EH     ;写工作方式控制字10001110B</span><br><span class="line">OUT  DX , AL     ;控制字送到控制口</span><br></pre></td></tr></table></figure>

<h2 id="端口C按位置位／复位控制字"><a href="#端口C按位置位／复位控制字" class="headerlink" title="端口C按位置位／复位控制字"></a>端口C按位置位／复位控制字</h2><p>端口C按位置位／复位控制字可实现对端口C的每一位进行控制。置位是使该位为1，复位是使该位为0。</p>
<ul>
<li>D7位是特征位。D7＝1，为工作方式控制字；D7＝0为端口C按位置位／复位控制字。</li>
<li>D6、D5、D4三位无意义，可为任意值。</li>
<li>D3、D2、D1按二进制编码，用来选择对端口C的哪一位进行操作。选择的位将由D0位规定是置位(D0&#x3D;1)还是复位(D0&#x3D;0)。</li>
<li>D0位用来选择对所选定的端口C的哪一位是置位(D0&#x3D;1)还是复位(D0&#x3D;0)。</li>
</ul>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/3.png" class="">

<p><strong>需要注意如下三点</strong>：</p>
<ul>
<li><strong>端口C按位置位／复位控制字，必须写入控制寄存器，而不是写入端口C</strong>。</li>
<li>当C端口被设置为输出时，端口C按位置位／复位控制字，<strong>可以对C口的某一根端口线按位操作</strong>，也就是说，使C口某一根端口线输出高低电平，而不影响其他端口线输出高低电平。</li>
<li>当A端口工作在方式1或方式2，B端口工作在方式1时候，端口C按位置位／复位控制字，可以使内部的“中断允许触发器” 置“1”或置“0”</li>
</ul>
<blockquote>
<p>例题：要求通过8255A芯片C口的PC2位产生一个方脉冲信号。（地址为200H~203H)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    DX,203H         ;控制口地址送DX</span><br><span class="line">AA:    MOV   AL,05H    ;对PC2置位的控制字00000101B</span><br><span class="line">OUT    DX,AL</span><br><span class="line">CALL   DELAY1          ;调用延时程序（省略）</span><br><span class="line">MOV    AL,04H          ;对PC2复位的控制字00000100B</span><br><span class="line">OUT    DX,AL</span><br><span class="line">CALL   DELAY2          ;调用延时程序（省略）</span><br><span class="line">JMP    AA</span><br></pre></td></tr></table></figure>

<h1 id="8255A的工作方式"><a href="#8255A的工作方式" class="headerlink" title="8255A的工作方式"></a>8255A的工作方式</h1><p>8255A有3种工作方式，可以通过编程来进行设置。</p>
<ul>
<li>方式0为简单I&#x2F;O，查询方式，端口A、端口B、端口C均可使用。</li>
<li>方式1为选通I&#x2F;O，中断方式，端口A、端口B可以使用。</li>
<li>方式2为双向I&#x2F;O，中断方式，只有端口A可以使用。</li>
</ul>
<p>工作方式的选择可通过向控制端口写入控制字来实现。在不同的工作方式下，8255A的3个I&#x2F;O端口的排列如图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/4.png" class="">

<h2 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h2><p>方式0也叫基本输入&#x2F;输出方式。一种方式，不需要应答联络信号,端口A、端口B和端口C的高4位及低4位都可以作为输入或输出端口。</p>
<blockquote>
<p>例: 8255A的PB口为开关量输入，PA口为开关量输出，要求能随时将PB口的开关状态通过PA口的发光二极管显示出来，试编写程序。<br>开关状态显示程序清单如下所示。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE    SEGMENT</span><br><span class="line">        ASSUME  CS:CODE </span><br><span class="line">START:</span><br><span class="line">        MOV DX,203H    ;8255A控制口地址</span><br><span class="line">        MOV AL,82H     ;控制字10000010B （PA口输出,PB口输入，方式0）</span><br><span class="line">        OUT DX,AL </span><br><span class="line">BG:     MOV DX,201H    ;PB口地址</span><br><span class="line">        IN  AL,DX      ;读开关状态</span><br><span class="line">        MOV DX,202H    ;PA口地址</span><br><span class="line">        OUT DX,AL      ;输出开关状态</span><br><span class="line">        JMP BG         ;循环</span><br><span class="line">CODE    ENDS</span><br><span class="line">        END START   </span><br></pre></td></tr></table></figure>

<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>方式1也叫选通的输入&#x2F;输方式。</p>
<h3 id="方式1输入"><a href="#方式1输入" class="headerlink" title="方式1输入"></a>方式1输入</h3><p>当端口A和端口B工作于“方式1输入”时，端口A和端口B可分别作为独立的输入端口，必须有端口C配合端口A和端口B工作。<strong>端口C的PC3<del>PC5用作端口A的应答联络线，PC0</del>PC2则用作端口B的应答联络线，PC6和PC7仍可作为基本输入&#x2F;输出方式即方式0，可通过编程设置为输入或输出。</strong></p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/5.png" class="">

<h3 id="方式1输出"><a href="#方式1输出" class="headerlink" title="方式1输出"></a>方式1输出</h3><p>当端口A和端口B工作于方式1输出时，工作方式选择控制字与端口C控制信号的定义如图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/6.png" class="">

<h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>方式2又称双向传输方式，<strong>只有端口A才能工作于方式2。在方式2，外设既可以在8位数据线上往CPU发送数据，又可以从CPU接收数据。</strong><br>当端口A工作于方式2时，端口C的PC­7～PC3用来提供相应的控制和状态信号，配合端口A的工作。此时端口B以及端口C的PC2­～PC­­0­­­则可工作于方式0或方式1，如果端口B工作于方式0时，端口C的PC2～PC0­可用作数据输入&#x2F;输出；如果端口B工作于方式1时，端口C的PC2～PC0­用来为端口B提供控制和状态信号。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/7.png" class="">

<blockquote>
<p>方式2是一种双向传输工作方式。如果一个并行外部设备既可以作为输入设备，又可以作为输出设备，并且输入输出动作不会同时进行，那么，将这个外部设备的8255A的端口A相连，并让它工作于方式2就很合适。例如，软盘系统就是这样一种外设。</p>
</blockquote>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>8255A能实现双向传送功能的工作方式为 <code>方式2</code> ？</li>
<li>8255A在方式0工作时，端口A、B和C的输入&#x2F;输出可以有 <code>16</code> 种组合。</li>
<li>在8255A中，可以进行按位置位&#x2F;复位的端口是 <code>端口C</code> 。</li>
<li>8255A控制字的最高位D7&#x3D; <code>1</code> 时，表示设置工作方式选择控制字。</li>
</ol>
<h1 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h1><p><strong>8255A有哪几种工作方式？有何差别？</strong></p>
<p>答：8255A有三种工作方式：</p>
<ol>
<li>方式0为简单I&#x2F;O，查询方式</li>
<li>方式1为选通I&#x2F;O，中断方式</li>
<li>方式2为双向I&#x2F;O，中断方式</li>
</ol>
<p>差别：方式0不需要应答联络信号，端口A，B，C均可使用；方式1的端口A、B仍作为两个独立的8位I&#x2F;O通道可单独连接外设，而端口C则需要有6位（两个3位）分别作为A、B口的应答联络线，其余2位仍可作为基本I&#x2F;O即方式0；方式2又称为双向传输方式，只有端口A才能工作与方式2，外设既可以往CPU发送数据，又可以从CPU接受数据，即该外设可兼做输入和输出设备</p>
<p><strong>若8255A的端口A定义为方式0、输入，端口B定义为方式1、输出，端口C的上半部定义为方式0、输出，试编写初始化程序（端口地址为200H~203H）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV     DX,203H   ; 8255控制口地址送DX</span><br><span class="line">MOV     AL,94H    ; 写工作方式控制字： 1001 0400B</span><br><span class="line">OUT     DX,AL     ; 控制字送到控制口</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与接口技术笔记（2）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>继续记录课本第3章，关于指令的知识点</p>
<span id="more"></span>

<h1 id="指令格式和寻址方式"><a href="#指令格式和寻址方式" class="headerlink" title="指令格式和寻址方式"></a>指令格式和寻址方式</h1><p>通常一条指令包括一个或两个操作数，双操作数分别称为源操作数（SRC）和目的操作数（DST）</p>
<h2 id="8086、8088的寻址方式"><a href="#8086、8088的寻址方式" class="headerlink" title="8086、8088的寻址方式"></a>8086、8088的寻址方式</h2><ol>
<li>操作数在指令中，即指令中的操作数部分就是操作数本身，这种叫<strong>立即操作数</strong></li>
<li>操作数在CPU内部的某个寄存器中，这时操作数是CPU内部寄存器的一个编码</li>
<li>操作数在内存区中，这是指令的操作数部分包含操作数所在的内存地址</li>
</ol>
<h3 id="立即数寻址方式"><a href="#立即数寻址方式" class="headerlink" title="立即数寻址方式"></a>立即数寻址方式</h3><p>立即数放在指令中，立即数可以是8位或者16位，可以用二进制、八进制、十进制以及十六进制数表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     al,10           ;(al)&lt;-立即数10</span><br><span class="line">mov     al,00100101b    ;(al)&lt;-立即数00100101b</span><br><span class="line">mov     al,0ah          ;(al)&lt;-立即数0ah</span><br><span class="line">mov     ah,58h          ;(ah)&lt;-立即数58h</span><br><span class="line">mov     bx,1234h        ;(bx)&lt;-立即数1234h</span><br></pre></td></tr></table></figure>
<p>上面的12H放BH，34H放BL</p>
<h3 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h3><p>寄存器寻址方式的操作数就存放在指令规定的寄存器中，寄存器的名字在指令中指出。对于16位操作数，寄存器可以有AX，BX，CX，DX，SI，DI，SP，BP；对于8位操作数，寄存器可以有AH，AL，BH，BL，CH，CL，DH，DL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     al,cx           ;(AX)&lt;-(cx)</span><br><span class="line">INC     al              ;(al)&lt;-(al)+1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两种要注意操作对象的位数是否匹配，下面情况都是错的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     al,1234h        ;al是8位，1234h是16位</span><br><span class="line">mov     al,dx           ;al是8位，dx是16位</span><br></pre></td></tr></table></figure>

<h3 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h3><p>操作数在储存器中，通过有效地址取得操作数，有效地址是一个16位二进制数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     ah,[1234h]      ;将DS段中1234H单元内容送AH</span><br><span class="line">mov     ah,value        ;将DS段value单元内容送ah</span><br><span class="line">mov     ax,[2100h]      ;将DS段2100h单元内容送al，2101h送ah</span><br><span class="line">mov     bx,es:[2000h]   ;段超越，操作数在附加段，即物理地址=(es)*16+2000H</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再提一次上一节内容，物理地址&#x3D;段地址*16（16进制段地址左移一位）+有效地址 </p>
</blockquote>
<h3 id="寄存器相对寻址方式"><a href="#寄存器相对寻址方式" class="headerlink" title="寄存器相对寻址方式"></a>寄存器相对寻址方式</h3><p>寄存器相对寻址方式的操作数有效地址是一个基址寄存器（BX，BP）或变址寄存器（SI，DI）的内容+指令中给定的8位或16位位移量，即有效地址由两种分量组成。</p>
<p>以SI、DI、BX，间接寻址，则通常操作数在现行数据段DS区域中，物理地址计算方法为：</p>
<ul>
<li>物理地址&#x3D;16 X (DS) + SI&#x2F;DI&#x2F;BX</li>
</ul>
<p>如果使用寄存器BP时，操作数所在存储单元的段地址在堆栈寄存器SS中，物理地址计算方法为：</p>
<ul>
<li>物理地址&#x3D;16 X (SS) + BP</li>
</ul>
<p>例如：(DS)&#x3D;3000H，(SI)&#x3D;2000H，指令 <code>mov ax,[si]</code> ，物理地址&#x3D;(DS)*16+2000H&#x3D;32000H</p>
<p>指令的执行结果就是将32000H和32001H单元的内容送入寄存器AX中。当然BP也可以和其他的段寄存器相加形成物理地址，如<code>mov ax,ds:[si]</code></p>
<h3 id="寄存器相对寻址方式-1"><a href="#寄存器相对寻址方式-1" class="headerlink" title="寄存器相对寻址方式"></a>寄存器相对寻址方式</h3><p>寄存器相对寻址方式的操作数有效地址是一个基址寄存器（BX，BP）或变址寄存器（SI，DI）的内容+指令中给定的8位或16位位移量，即有效地址由两种分量组成。一般情况下，如果指令中的寄存器是BX，SI，DI，则对应的段地址默认是DS，如果是BP，则对应的段地址默认是SS。同样的，寄存器相对寻址方式也允许段超越。其中位移量可以是一个8位或者16位的立即数，也可以是符号地址。</p>
<p>例如：(DS)&#x3D;2000H,(SI)&#x3D;1000H,ARRAY&#x3D;2000H(16位位移量)，指令：<code>mov bx,array[si]</code>或者<code>mov bx,[array+si]</code></p>
<p>有效地址&#x3D;(si)+(array)&#x3D;1000h+2000h&#x3D;3000h，物理地址&#x3D;20000H+3000H&#x3D;23000H</p>
<h3 id="基址变址寻址方式"><a href="#基址变址寻址方式" class="headerlink" title="基址变址寻址方式"></a>基址变址寻址方式</h3><p>基址变址寻址方式的操作数有效地址是一个基址寄存器（BX，BP）和一个变址寄存器（SI，DI）的内容之和，即有效地址由两种分量组成。<strong>不允许同时使用BX和BP或者SI和DI。</strong></p>
<p>当使用BX时段寄存器为DS，当使用寄存器BP时，段寄存器为SS，所以物理地址为：</p>
<ul>
<li>物理地址&#x3D;16*(DS)+(BX)+(SI&#x2F;DI)</li>
<li>物理地址&#x3D;16*(SS)+(BP)+(SI&#x2F;DI)</li>
</ul>
<p>同样可以跨越段，如：<code>mov ax,es:[bx+di]</code></p>
<h3 id="基址变址相对寻址方式"><a href="#基址变址相对寻址方式" class="headerlink" title="基址变址相对寻址方式"></a>基址变址相对寻址方式</h3><p>基址变址相对寻址方式的操作数有效地址是一个基址寄存器与一个变址寄存器的内容和指令中给定的8位或16位位移量之和，即有效地址由三种分量组成。</p>
<p>有效地址为：EA&#x3D;(BX)&#x2F;(BP) + (SI)&#x2F;(DI) + DISP8&#x2F;DISP16</p>
<p>所以物理地址为：</p>
<ul>
<li>物理地址&#x3D;16*(DS)+(BX)+(SI&#x2F;DI)+DISP8&#x2F;DISP16</li>
<li>物理地址&#x3D;16*(SS)+(BP)+(SI&#x2F;DI)+DISP8&#x2F;DISP16</li>
</ul>
<p>如指令<code>mov ax,data[bx][si]</code>或者<code>mov ax,data[bx+si]</code>或者&#96;mov ax,[data+bx+si]</p>
<p><strong>同样是不允许同时使用BX和BP或者SI和DI。</strong></p>
<h3 id="转移地址有关的寻址方式"><a href="#转移地址有关的寻址方式" class="headerlink" title="转移地址有关的寻址方式"></a>转移地址有关的寻址方式</h3><p>控制转移指令在段内、段间转移时，使用直接（相对）寻址或间接寻址方式</p>
<h1 id="数据传送类指令和串操作类指令"><a href="#数据传送类指令和串操作类指令" class="headerlink" title="数据传送类指令和串操作类指令"></a>数据传送类指令和串操作类指令</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>8086、8088指令系统共有117条基本命令，按照功能分为6类：</p>
<ol>
<li>数据传输类</li>
<li>算术</li>
<li>逻辑移位</li>
<li>串操作</li>
<li>控制转移</li>
<li>处理机控制类</li>
</ol>
<h2 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h2><p>包括传送指令MOV（move）、进栈指令PUSH（push onto the satack）、出栈指令POP（pop from the stack）和交换指令XCHG（exchange）</p>
<h3 id="MOV传送指令"><a href="#MOV传送指令" class="headerlink" title="MOV传送指令"></a>MOV传送指令</h3><p>指令格式：<code>MOV DST,SRC</code>，DST&lt;-SRC</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/1.jpg" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/2.jpg" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/3.jpg" class="">

<p><strong>下面是错误示范</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov  1234h,ax       ;立即数不能做目标操作数</span><br><span class="line">mov  cs,ax          ;cs不能用于目标操作数</span><br><span class="line">mov  ip,ax          ;IP不能用于目标操作数</span><br><span class="line">mov  ds,1234h       ;立即数不能直接送段寄存器</span><br><span class="line">mov  al,bx          ;源操作数与目标操作数的位数必须一致</span><br><span class="line">mov  buf1,buf2      ;不能在两个储存器单元之间传送数据</span><br><span class="line">mov  ds,es          ;不能在两个段寄存器单元之间传送数据</span><br></pre></td></tr></table></figure>

<h3 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h3><p>PUSH进栈指令：把一个字的操作数从源地址压进堆栈中<br><br>POP出栈指令：把一个字的操作数从栈中弹出到目的操作数</p>
<p>PUSH指令格式：<code>PUSH SRC</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令执行操作： (SP) &lt;- (SP) - 2</span><br><span class="line">              ((SP)+1,(SP)) &lt;- SRC</span><br></pre></td></tr></table></figure>

<p>POP指令操作: <code>POP DST</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令执行操作：  (DST) &lt;- ((SP)+1,(SP))</span><br><span class="line">               (SP) &lt;- (SP) + 2</span><br></pre></td></tr></table></figure>

<p>例如：已知SP&#x3D;1000H，AX&#x3D;1122H，BX&#x3D;3344H，程序如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH AX</span><br><span class="line">PUSH BX</span><br><span class="line">POP  BX</span><br><span class="line">POP  AX</span><br></pre></td></tr></table></figure>

<p>两次PUSH流程图如下：</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/1.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/2.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/3.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/4.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/5.png" class="">
<p>两次POP流程图如下：</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/6.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/7.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/8.png" class="">
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/9.png" class="">

<p><strong>错误写法！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH AL     ; 字节不能进栈</span><br><span class="line">PUSH 1000H  ; 立即数不能进栈</span><br><span class="line">POP  AL     ; 字节不能作为出栈对象</span><br><span class="line">POP  CS     ; CS不能作为出栈对象（但是可以进栈）</span><br><span class="line">POP  123H   ; 立即数不能作为出栈对象</span><br></pre></td></tr></table></figure>

<h3 id="XCHG交换指令"><a href="#XCHG交换指令" class="headerlink" title="XCHG交换指令"></a>XCHG交换指令</h3><p>XCHG（exchange）指令可以将源操作数和目的操作数的内容进行交换，可以交换字或者字节</p>
<p>指令格式：XCHG obj1,obj2</p>
<p><strong>错误写法！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XCHG    AL,BX       ; 字节和字不能交换</span><br><span class="line">XCHG    AX,1000H    ; 寄存器与立即数不能交换</span><br><span class="line">XCHG    DS,SS       ; 段寄存器之间不能交换</span><br><span class="line">XCHG    CS,IP       ; CS和IP不能交换</span><br></pre></td></tr></table></figure>

<h2 id="累加器专用传送指令"><a href="#累加器专用传送指令" class="headerlink" title="累加器专用传送指令"></a>累加器专用传送指令</h2><p>累加器专用传送指令包括：IN（input）输入指令、OUT（output）输出指令、XLAT（translate）查表。</p>
<h3 id="IN-x2F-OUT指令"><a href="#IN-x2F-OUT指令" class="headerlink" title="IN&#x2F;OUT指令"></a>IN&#x2F;OUT指令</h3><p>8086、8088采用I&#x2F;O与储存器是单独编址的，因此访问I&#x2F;O端口只能用IN&#x2F;OUT两条指令，IN&#x2F;OUT指令分为长格式和短格式。<strong>长格式指令代码为2个字节，第二字节用PORT表示端口号，端口范围是00~FFH</strong>。<strong>短格式指令代码为1个字节，指定的端口范围是0000~FFFFH</strong>。</p>
<blockquote>
<p>IN指令实现输入端口到CPU的数据传输</p>
</blockquote>
<p>长格式：<br>IN  AL,PORT(字节) —-  (AL)&lt;-(Port)(字节)<br>IN  AX,PORT(字)   —-  (AX)&lt;-(Port+1,Port)(字节)</p>
<p>短格式：<br>IN  AL,DX(字节)   —-  (AL)&lt;-((DX))(字节)<br>IN  AX,DX(字)     —-  (AX)&lt;-((DX)+1,(DX))(字)</p>
<blockquote>
<p>OUT指令实现CPU到输出端口的数据传输</p>
</blockquote>
<p>长格式：<br>OUT  PORT,AL(字节) —-  (Port)&lt;-(AL)(字节)<br>OUT  PORT,AX(字)   —-  (Port+1,Port+1)&lt;-(AX)(字)</p>
<p>短格式：<br>IN  DX,AL(字节)   —-  ((DX))&lt;-(AL)(字节)<br>IN  DX,AX(字)     —-  ((DX)+1,(DX))&lt;-(AX)(字)</p>
<blockquote>
<p>例如： （a）从60H端口输入一个字节数据（b）向61H输出一个字节数据32H（c）从2160H端口输入一个字节数据（d）向2161H端口输入一个字节数据64H</p>
</blockquote>
<p>（a）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法1：</span><br><span class="line">IN      AL,60H</span><br><span class="line">方法2：</span><br><span class="line">MOV     DX,60H</span><br><span class="line">IN      AL,DX</span><br></pre></td></tr></table></figure>
<p>(b)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法1：</span><br><span class="line">MOV     AL,32H</span><br><span class="line">OUT     61H,AL</span><br><span class="line">方法2：</span><br><span class="line">MOV     AL,32H</span><br><span class="line">MOV     DX,61H</span><br><span class="line">OUT     DX,AL</span><br></pre></td></tr></table></figure>
<p>(c)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV     DX,2160H</span><br><span class="line">IN      AL,DX</span><br></pre></td></tr></table></figure>
<p>(d)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV     DX,2161H</span><br><span class="line">MOV     AL,64H</span><br><span class="line">OUT     DX,AL</span><br></pre></td></tr></table></figure>

<h3 id="XLAT查表指令"><a href="#XLAT查表指令" class="headerlink" title="XLAT查表指令"></a>XLAT查表指令</h3><p>好像没啥用，先不写了</p>
<h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p>包括：LEA(load effective address)有效地址送寄存器、LDS(load DS with pointer)指针送寄存器和DS、LES(load ES with pointer)指针送寄存器和ES</p>
<p>这组指令的功能是完成把地址送到指定通用寄存器(REG)中。<strong>REG 不能为段寄存器，SRC 必须为存储器寻址方式。</strong></p>
<h4 id="LEA-有效地址送寄存器"><a href="#LEA-有效地址送寄存器" class="headerlink" title="LEA 有效地址送寄存器"></a>LEA 有效地址送寄存器</h4><p>指令格式： LEA   REG，SRC   相当于： （REG）←SRC</p>
<p>指令把源操作数（存储器）有效地址送到指定16位通用寄存器中，REG 不能为段寄存器。源操作数可使用除立即数和寄存器外任一种存储器寻址方式</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEA     AX，[5678H]     ;（AX）← 5678H</span><br><span class="line">与</span><br><span class="line">MOV     AX，5678H</span><br><span class="line">等价</span><br></pre></td></tr></table></figure>

<h4 id="LDS-指针送寄存器和DS"><a href="#LDS-指针送寄存器和DS" class="headerlink" title="LDS 指针送寄存器和DS"></a>LDS 指针送寄存器和DS</h4><p>指令格式：LDS  REG，SRC</p>
<p>执行的操作：（REG）←（SRC）、（DS）←（SRC+2）</p>
<p>把源操作数（双字存储器）的低字送入16位通用寄存器中，高字送入DS中</p>
<h4 id="LES-指针送寄存器和ES"><a href="#LES-指针送寄存器和ES" class="headerlink" title="LES 指针送寄存器和ES"></a>LES 指针送寄存器和ES</h4><p>指令格式： LES  REG，SRC</p>
<p>执行的操作：（REG）←（SRC）、（ES）←（SRC+2）</p>
<p>把源操作数（双字存储器）中的低字送入16位通用寄存器中，高字送入ES中</p>
<blockquote>
<p>如：已知：（DS）&#x3D;8000H ,（81480H）&#x3D;33CCH ,（81482H）&#x3D;2468H。指令：LDS  SI，[1480H]</p>
</blockquote>
<p>物理地址&#x3D;16×（DS）+1480H&#x3D;81480H。<br>指令执行结果：（SI）&#x3D;33CCH，（DS）&#x3D;2468H</p>
<h3 id="符号扩展指令"><a href="#符号扩展指令" class="headerlink" title="符号扩展指令"></a>符号扩展指令</h3><p>符号扩展指令包括：CBW（convert byte to word）字节扩展为字、CWD（convert word to double word）字扩展为双字。</p>
<h4 id="CBW-字节转换为字指令"><a href="#CBW-字节转换为字指令" class="headerlink" title="CBW 字节转换为字指令"></a>CBW 字节转换为字指令</h4><p>指令格式：CBW</p>
<p>执行的操作：将AL中的8位带符号数扩展为16位并送入AX中，也就是将AL的最高位送入AH的所有各位，即如果（AL）的最高有效位为0，则（AH）&#x3D;00H；如果（AL）的最高有效位为1，则（AH）&#x3D;0FFH。</p>
<h4 id="CWD-字转换为双字指令"><a href="#CWD-字转换为双字指令" class="headerlink" title="CWD 字转换为双字指令"></a>CWD 字转换为双字指令</h4><p>指令格式：CWD</p>
<p>执行的操作：AX的内容符号扩展到DX，形成DX：AX中的双字。即如果（AX）的最高有效位为0，则（DX）&#x3D;0000H；如果（AX）的最高有效位为1，则（DX）&#x3D;0FFFFH。</p>
<blockquote>
<p>例子:已知：（AX）&#x3D; 0BA45H</p>
</blockquote>
<pre><code>指令：CBW      ；（AX）=0045H
指令：CWD      ；（DX）=0FFFFH  （AX）=0BA45H
</code></pre>
<h2 id="串操作类指令"><a href="#串操作类指令" class="headerlink" title="串操作类指令"></a>串操作类指令</h2><p>串操作类指令包括：MOVS（move string）串传送、CMPS（compare string）串比较等，与串操作基本指令配合使用的前缀有：REP（repeat）重复、REPE&#x2F;REPZ（repeat while equal &#x2F; zero）相等&#x2F;为零重复、REPNE&#x2F;REPNZ（repeat while not equal &#x2F; not zero）不相等&#x2F;不为零重复。</p>
<h3 id="MOVS-串传送指令"><a href="#MOVS-串传送指令" class="headerlink" title="MOVS 串传送指令"></a>MOVS 串传送指令</h3><p>指令格式：MOVSB </p>
<p>执行的操作：</p>
<ul>
<li>当DF&#x3D;0时，则（（DI））←（（SI））、（SI）←（SI）+1，（DI）←（DI）+1</li>
<li>当DF&#x3D;1时，则（（DI））←（（SI））、（SI）←（SI）-1，（DI）←（DI）-1</li>
</ul>
<p>指令格式：MOVSW </p>
<p>执行的操作：字操作，</p>
<ul>
<li>当DF&#x3D;0时，则（（DI））←（（SI））、（SI）←（SI）+2，（DI）←（DI）+2</li>
<li>当 DF&#x3D;1时，则（（DI））←（（SI））、（SI）←（SI）-2，（DI）←（DI-2）</li>
</ul>
<p><strong>串传送指令的功能是将位于DS段以SI为指针的源串中的一个字节（或字）存储单元中的数据传送至ES段以DI为指针的目的地址中去</strong>，并自动修改指针，使之指向下一个字节（或字）存储单元。</p>
<p>当DF&#x3D;0时，（SI）和（DI）增量；当DF&#x3D;1时，（SI）和（DI）减量。指令不影响状态标志位。</p>
<h3 id="CMPS-串比较指令"><a href="#CMPS-串比较指令" class="headerlink" title="CMPS  串比较指令"></a>CMPS  串比较指令</h3><p>指令格式：CMPSB </p>
<p>执行的操作：字节操作，（（SI））-（（DI）），（SI）←（SI）±1，（DI）←（DI）±1</p>
<p>指令格式：CMPSW<br>执行的操作：字操作，（（SI））-（（DI）），（SI）←（SI）±2，（DI）←（DI）±2</p>
<p><strong>串比较指令的功能是把位于DS段由SI指定的字节数据或字数据与ES段由DI指定的字节数据或字数据进行比较，结果不保存，但影响状态标志位</strong>。当DF&#x3D;0时，（SI）和（DI）增量；当DF&#x3D;1时，（SI）和（DI）减量。</p>
<h3 id="REP重复"><a href="#REP重复" class="headerlink" title="REP重复"></a>REP重复</h3><p>指令格式：REP</p>
<p>执行的操作：</p>
<ul>
<li>当（CX）&#x3D;0退出重复；</li>
<li>当（CX）≠0，（CX）←（CX）-1，执行其后串操作指令。</li>
</ul>
<p>每执行一次串指令（CX）－1，直到（CX）&#x3D;0，重复执行结束。REP前缀用在MOVS指令前，流程图在下面</p>
<h3 id="REPE-x2F-REPZ相等-x2F-为零重复指令"><a href="#REPE-x2F-REPZ相等-x2F-为零重复指令" class="headerlink" title="REPE&#x2F;REPZ相等&#x2F;为零重复指令"></a>REPE&#x2F;REPZ相等&#x2F;为零重复指令</h3><p>指令格式：REPE&#x2F;REPZ</p>
<p>执行的操作：</p>
<ul>
<li>当（CX）&#x3D;0或零标志ZF&#x3D;0退出重复</li>
<li>否则（CX）←（CX）-1执行其后串操作指令</li>
</ul>
<p>该指令功能是每执行一次串指令（CX）－1，并判断ZF标志是否为0，只要（CX）&#x3D;0或ZF&#x3D;0，退出重复。该指令一般用在CMPS指令前，流程图如下</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/10.png" class="">

<h3 id="REPNE-x2F-REPNZ不相等-x2F-不为零重复指令"><a href="#REPNE-x2F-REPNZ不相等-x2F-不为零重复指令" class="headerlink" title="REPNE&#x2F;REPNZ不相等&#x2F;不为零重复指令"></a>REPNE&#x2F;REPNZ不相等&#x2F;不为零重复指令</h3><p>指令格式：REPNE&#x2F;REPNZ</p>
<p>执行的操作：当（CX）&#x3D;0或零标志ZF&#x3D;1退出重复，否则（CX）←（CX）-1执行其后串操作指令。</p>
<p>该指令功能是每执行一次串指令（CX）－1，并判断ZF标志是否为1，只要（CX）&#x3D;0或ZF&#x3D;1，则退出重复。<strong>该指令一般用在CMPS指令前。</strong></p>
<blockquote>
<ul>
<li>重复前缀指令不能单独使用，其后必须紧跟串操作指令，控制串操作指令重复执行。其执行过程相当于一个循环程序的运行，如下图所示。在每次重复之后，地址指针SI和DI都被修改，但指令指针IP仍保持指向带有前缀的串操作指令的地址。</li>
<li>重复执行次数由数据串长度决定，数据串长度应预置在寄存器CX中。</li>
<li>执行重复前缀指令不影响标志位。</li>
</ul>
</blockquote>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/11.png" class="">

<blockquote>
<p>例题1：在数据段中有一个字符串，其长度为20，要求把他们转送到附加段的一个缓冲区中。程序代码如下所示：</p>
</blockquote>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/12.png" class="">

<p>(CLD：使DF复位到0)</p>
<blockquote>
<p>例题2：把附加段中10个字节的缓冲器置30H，</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法1：</span><br><span class="line">lea     di,mess2</span><br><span class="line">mov     al,30H</span><br><span class="line">mov     cx,10</span><br><span class="line">cld </span><br><span class="line">rep     stosb</span><br><span class="line">方法2：</span><br><span class="line">lea     di,mess2</span><br><span class="line">mov     ax,3030H</span><br><span class="line">mov     cx,5</span><br><span class="line">cld</span><br><span class="line">rep     stosw</span><br></pre></td></tr></table></figure>

<h1 id="算术运算指令与位操作指令"><a href="#算术运算指令与位操作指令" class="headerlink" title="算术运算指令与位操作指令"></a>算术运算指令与位操作指令</h1><h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><p>算术指令分为加法指令，减法指令，乘法指令，除法指令和十进制调整指令。 </p>
<h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><p>加法指令包括：ADD（add）加法、ADC（add with carry）带进位加法、INC（increment）加1</p>
<h4 id="ADD加法指令"><a href="#ADD加法指令" class="headerlink" title="ADD加法指令"></a>ADD加法指令</h4><p>指令格式：ADD  DST，SRC  — （DST）←（SRC）+（DST）</p>
<p>将源操作数与目的操作数相加，结果存放于目的操作数。要求源操作数和目的操作数同时为带符号的数或无符号数，且长度相等。  </p>
<h4 id="ADC带进位加法指令"><a href="#ADC带进位加法指令" class="headerlink" title="ADC带进位加法指令"></a>ADC带进位加法指令</h4><p>指令格式：ADC   DST， SRC  —  （DST）←（SRC）+（DST）+CF</p>
<p>将源操作数与目的操作数以及进位标志位CF的值相加，并将结果存放于目的操作数</p>
<h4 id="INC加1指令"><a href="#INC加1指令" class="headerlink" title="INC加1指令"></a>INC加1指令</h4><p>指令格式：  INC   OPR  —  （OPR）←（OPR）+1</p>
<blockquote>
<p>注意：这三条指令运算结果将影响状态标志位，但是INC指令不影响标志CF。 </p>
</blockquote>
<h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><p>减法指令包括：SUB（subtract）减法、DEC（decrement）减1、NEG（negate）求补、CMP（compare）比较</p>
<h4 id="SUB-减法指令"><a href="#SUB-减法指令" class="headerlink" title="SUB 减法指令"></a>SUB 减法指令</h4><p>指令格式为：SUB  DST，SRC  —  （DST）←（DST） -（SRC）</p>
<p>将目的操作数减去源操作数，结果存放于目的操作数。</p>
<h4 id="DEC-减1指令"><a href="#DEC-减1指令" class="headerlink" title="DEC 减1指令"></a>DEC 减1指令</h4><p>指令格式为：DEC  OPR  —  （OPR）←（OPR）-1</p>
<p>对指定操作数减1。DEC指令不影响进位标志。</p>
<h4 id="NEG求补指令"><a href="#NEG求补指令" class="headerlink" title="NEG求补指令"></a>NEG求补指令</h4><p>NEG  OPR</p>
<p>对指定操作数求补运算。亦即把操作数按位求反后末位加1，因而执行的操作也可表示为：<br><strong>（OPR）← 0FFFFH -（OPR）+1</strong></p>
<h4 id="CMP比较指令"><a href="#CMP比较指令" class="headerlink" title="CMP比较指令"></a>CMP比较指令</h4><p>指令格式为：CMP  OPR1，OPR2</p>
<p>将目的操作数减去源操作数，结果不予保存。只是根据结果的状态设置状态标志位。<br>（一般和后面的转移指令连用）</p>
<h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><p>乘法指令包括：MUL（unsigned multiple）无符号数乘法、IMUL（signed multiple）带符号数乘法</p>
<h4 id="MUL无符号数乘法指令"><a href="#MUL无符号数乘法指令" class="headerlink" title="MUL无符号数乘法指令"></a>MUL无符号数乘法指令</h4><p>指令格式为： MUL  SRC<br>执行的操作：</p>
<ul>
<li>8位数乘法  （AX） &lt;- （AL） ×（SRC） </li>
<li>16位数乘法 （DX，AX） &lt;- （AX）× （SRC）</li>
</ul>
<p>注意： </p>
<ul>
<li>进行字节运算时，目的操作数必须是累加器AL，乘积在寄存器AX中；进行字运算时，目的操作数必须是累加器AX，乘积在寄存器DX(高16位)、AX（低16位）中 。源操作数不允许使用立即数寻址方式。</li>
<li>乘法指令运算结果只影响状态标志CF、OF，对其他状态标志位无影响</li>
</ul>
<h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><p>除法指令包括：DIV（unsigned divide）无符号数除法、IDIV（signed divide）带符号数除法。</p>
<h4 id="DIV无符号数除法指令"><a href="#DIV无符号数除法指令" class="headerlink" title="DIV无符号数除法指令"></a>DIV无符号数除法指令</h4><p>指令格式为： DIV  SRC</p>
<p>字节操作数：16位被除数在AX中，8位除数位源操作数，结果的8位商在AL中，8位余数在AH中。表示为： </p>
<ul>
<li>（AL） &lt;- （AX） ÷ （SRC）的商</li>
<li>（AH） &lt;- （AX） ÷ （SRC）的余数</li>
</ul>
<p>操作数：32位被除数在DX，AX中，16位除数位源操作数，结果的16位商在AX中，16位余数在DX中。表示为：</p>
<ul>
<li>（AX） &lt;- （DX，AX） ÷ （SRC）的商</li>
<li>（DX） &lt;- （DX，AX） ÷ （SRC）的余数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设（AX）=0400H，（BL）=0B4H。即（AX）为无符号数的1024D；（BL）为无符号数的180D。</span><br><span class="line">执行如下指令：</span><br><span class="line">MOV  AX，0400H	；AX=400H=1024</span><br><span class="line">MOV  BL，0B4H	；BL=B4H=180</span><br><span class="line">DIV  BL	；商AL＝05H＝5，余数AH＝7CH＝124</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>逻辑运算指令包括：AND（and）逻辑与、OR（or）逻辑或、NOT（not）逻辑非、XOR（exclusive or）异或、TEST（test）测试。逻辑指令对字节或字数据进行按位的操作。</p>
<h4 id="AND逻辑与指令"><a href="#AND逻辑与指令" class="headerlink" title="AND逻辑与指令"></a>AND逻辑与指令</h4><p>指令格式：AND  DST，SRC  —  （DST） &lt;- （DST）∧（SRC）</p>
<p>AND指令执行按位逻辑与操作。为双操作数指令，两个操作数宽度必须相等，即同为字节或字，执行结果存入DST中。</p>
<h4 id="OR-逻辑或指令"><a href="#OR-逻辑或指令" class="headerlink" title="OR 逻辑或指令"></a>OR 逻辑或指令</h4><p>指令格式：OR  DST，SRC  —  （DST）&lt;-（DST）∨（SRC）</p>
<p>OR指令执行按位逻辑或操作。它们均为双操作数指令，两个操作数宽度必须相等，即同为字节或字，执行结果存入DST中并且是按位进行。</p>
<blockquote>
<p>要求屏蔽寄存器AH的高四位，保留其低四位的数据:  <code>AND  AH，0FH</code></p>
</blockquote>
<blockquote>
<p>要求把寄存器AH的高四位置1，保留其低四位的数据: <code>OR   AH，F0H</code></p>
</blockquote>
<h4 id="NOT-逻辑非指令"><a href="#NOT-逻辑非指令" class="headerlink" title="NOT 逻辑非指令"></a>NOT 逻辑非指令</h4><p>指令格式：NOT  OPR</p>
<h4 id="XOR-逻辑异或指令"><a href="#XOR-逻辑异或指令" class="headerlink" title="XOR 逻辑异或指令"></a>XOR 逻辑异或指令</h4><p>指令格式：XOR  DST，SRC  —  （DST）&lt;-（DST）⊕（SRC）</p>
<h4 id="TEST-测试指令"><a href="#TEST-测试指令" class="headerlink" title="TEST 测试指令"></a>TEST 测试指令</h4><p>指令格式：TEST  OPR1，OPR2  —  （OPR1）∧（OPR2）</p>
<p>对两个操作数指定的内容进行与操作， 但不保留结果，只是根据结果状态，对标志位进行置位</p>
<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>移位指令包括：</p>
<ul>
<li>SHL（shift logical left）逻辑左移，下图a</li>
<li>SAL（shift arithmetic left）算术左移，下图a</li>
<li>SHR（shift logical right）逻辑右移，下图b</li>
<li>SAR（shift arithmetic right）算术右移，下图c</li>
<li>ROL（rotate left）循环左移，下图d</li>
<li>ROR（rotate right）循环右移，下图e</li>
<li>RCL（rotate left through carry）带进位循环左移，下图f</li>
<li>RCR（rotate right through carry）带进位循环右移，下图g</li>
</ul>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/13.png" class="">

<p>指令格式都是：<code>指令 目标操作数,移位位数</code></p>
<p><strong>逻辑左移一位最低位补零，最高位移入CF，可用于无符号数乘2操作；逻辑右移指令右移一位最高位补零，移出位进入CF，可用于无符号数除2操作。</strong></p>
<h1 id="控制转移指令与处理器控制指令"><a href="#控制转移指令与处理器控制指令" class="headerlink" title="控制转移指令与处理器控制指令"></a>控制转移指令与处理器控制指令</h1><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><p>控制转移指令分为无条件转移指令，条件转移指令，循环指令，子程序指令和中断指令。</p>
<h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>无条件地转移到指令指定的地址去执行该地址开始的指令。</p>
<p>转移可以分成两类：段内转移和段间转移。</p>
<p>段内转移是指在同一段的范围内进行转移，此时只需修改IP寄存器的内容，即用新的转移目标地址代替原有的IP的值就可达到转移目的。</p>
<p>段间转移则是要转到另一个段去执行程序，此时需要修改IP和CS寄存器的值，才能达到转移目的，因此段间转移的目标地址由新的段地址和偏移地址组成。</p>
<h4 id="段内直接短转移"><a href="#段内直接短转移" class="headerlink" title="段内直接短转移"></a>段内直接短转移</h4><p>指令格式：<code>JMP  SHORT OPR</code>  —  （IP）←（IP） + 8位位移量(由目标地址OPR确定的)</p>
<p>位移量需要满足向前或向后转移的需要，因此它是一个带符号的数，也就是说这种转移格式只允许在-128～+127字节的范围内转移。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP  SHORT NEXT</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">NEXT：MOV  AL，‘A’</span><br><span class="line">……</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>假设JMP指令地址为0100H，NEXT的地址为011AH，当前IP 的值为0102H，所以JMP指令的偏移量为18H，目的地址为（IP）011AH。</p>
<h4 id="段内直接近转移"><a href="#段内直接近转移" class="headerlink" title="段内直接近转移"></a>段内直接近转移</h4><p>指令格式：JMP  NEAR PTR OPR  —  （IP）←（IP） + 16位位移量</p>
<blockquote>
<p>段内直接短转移和段内直接近转移的属性运算符在书写指令时往往不给出，而是直接写成JMP OPR。而到底是8位还是16位需要由汇编程序在汇编过程中，根据标号处的地址与JMP指令所在地址进行计算得到。</p>
</blockquote>
<h4 id="段内间接近转移"><a href="#段内间接近转移" class="headerlink" title="段内间接近转移"></a>段内间接近转移</h4><p>指令格式：JMP  WORD PTR OPR — （IP）←（EA）</p>
<p>其中有些地址EA值由OPR的寻址方式确定。它可以使用除立即数方式以外的任一种寻址方式。</p>
<ul>
<li>JMP  BX：若执行指令前，（BX）&#x3D;0120H，（IP）&#x3D;0012H，则执行指令后，（IP）&#x3D;0120H。</li>
<li>JMP  WORD  PTR[BX]：若执行指令前，（BX）&#x3D;0120H，（IP）&#x3D;0012H，（DS）&#x3D;3000H，（30120H）&#x3D;80H，（30121H）&#x3D;00H，目标地址为存储器寻址。首先计算偏移地址EA&#x3D;（BX）&#x3D;0120H，<br>物理地址&#x3D;DS×16H+EA&#x3D;30120H。所以执行指令后，（IP）&#x3D;0080H。</li>
</ul>
<h4 id="段间直接远转移"><a href="#段间直接远转移" class="headerlink" title="段间直接远转移"></a>段间直接远转移</h4><p>指令格式：JMP  FAR PTR OPR</p>
<p>执行的操作：</p>
<ol>
<li>（IP）←OPR的段内偏移地址</li>
<li>（CS）←OPR所在段的段地址</li>
</ol>
<h4 id="段间间接远转移"><a href="#段间间接远转移" class="headerlink" title="段间间接远转移"></a>段间间接远转移</h4><p>指令格式：JMP  DWORD  PTR OPR<br>执行的操作：</p>
<ol>
<li>（IP）←（EA）</li>
<li>（CS）←（EA+2）</li>
</ol>
<p>其中EA由OPR的寻址方式确定，它可以使用除立即数及寄存器方式以外的任何存储器寻址方式，根据寻址方式求出EA后，把指定存储单元的字内容送IP寄存器，并把下一个字的内容送到CS寄存器，这样就实现了段间跳转。</p>
<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><ol>
<li>JZ（或JE）（jump if zero，or equal）结果为零（或相等）则转移。测试条件：ZF&#x3D;1</li>
<li>JNZ（或JNE）（jump if not zero，or not equal）结果不为零（或不相等）则转移。测试条件：ZF&#x3D;0</li>
<li>JS（jump if sign）结果为负则转移。测试条件：SF&#x3D;1</li>
<li>JNS（jump if not sign）结果为正则转移。测试条件：SF&#x3D;0</li>
<li>JO（jump if overflow）结果溢出则转移。测试条件：OF&#x3D;1</li>
<li>JNO（jump if not overflow）结果不溢出则转移。测试条件：OF&#x3D;0</li>
<li>JP（JPE）（jump if parity，or parity even）奇偶位为1则转移。测试条件：PF&#x3D;1</li>
<li>JNP（JPO）（jump if not parity，or parity odd）奇偶位为0则转移。测试条件：PF&#x3D;0</li>
<li>JB（或JNAE，或JC）（jump if below，or not above or equal，or carry）低于，或者不高于或不等于，或进位为1则转移。测试条件：CF&#x3D;1</li>
<li>JNB（或JAE，或JNC）（jump if not below，or above or equal，or not carry）不低于，或者高于或等于，或进位为零则转移。测试条件：CF&#x3D;0</li>
</ol>
<p>最后两条指令在这一组指令中可以看作JC和JNC，它们只用CF的值来判别是否转移。</p>
<p>比较两个数大小的转移指令的现行指令都是CMP。小结：</p>
<table data-sort="sortDisabled">
    <tbody>
        <tr class="firstRow">
            <td width="143" valign="top" rowspan="2" colspan="1" style="word-break: break-all;">
                <p>
                    比较情况
                </p>
            </td>
            <td valign="top" rowspan="1" colspan="2" style="word-break: break-all;">
                <p>
                    无符号数
                </p>
            </td>
            <td valign="top" rowspan="1" colspan="2" style="word-break: break-all;">
                <p>
                    带符号数
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    指令助记符
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    满足条件
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    指令助记符
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    满足条件
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&lt;B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JB/JNAE/JC
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=1
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JL/JNGE
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=1且ZF=0
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&lt;=B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JBE/JNA
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=1或ZF=1
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JLE/JNG
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=1或ZF=1
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&gt;B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JA/JNBE
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=0且ZF=0
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JG/JNLE
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=0且ZF=0
                </p>
            </td>
        </tr>
        <tr>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    A&gt;=B
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JAE/JNB
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    CF=0或ZF=1
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    JGE/JNL
                </p>
            </td>
            <td width="143" valign="top" style="word-break: break-all;">
                <p>
                    SF⊕OF=0或ZF=0
                </p>
            </td>
        </tr>
    </tbody>
</table>

<h4 id="测试CX的值为0则转移"><a href="#测试CX的值为0则转移" class="headerlink" title="测试CX的值为0则转移"></a>测试CX的值为0则转移</h4><p>指令格式：JCXZ  OPR，测试条件：（CX）&#x3D;0</p>
<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><p>循环指令包括：LOOP（loop）循环、LOOPZ&#x2F;LOOPE（loop while zero，or equal）当为零或相等时循环、LOOPNZ&#x2F;LOOPNE（loop while nonzero，or not equal）当不为零或不相等时循环。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/13.png" class="" title="流程图">

<h4 id="LOOP循环指令"><a href="#LOOP循环指令" class="headerlink" title="LOOP循环指令"></a>LOOP循环指令</h4><p>指令格式：LOOP  OPR</p>
<p>执行操作及测试条件：CX←CX-1,若 <strong>（CX）≠0转移，（CX）&#x3D;0退出循环</strong> 。</p>
<h4 id="LOOPZ（或LOOPE）当为零或相等时循环指令"><a href="#LOOPZ（或LOOPE）当为零或相等时循环指令" class="headerlink" title="LOOPZ（或LOOPE）当为零或相等时循环指令"></a>LOOPZ（或LOOPE）当为零或相等时循环指令</h4><p>指令格式：LOOPZ（或LOOPE）  OPR</p>
<p>执行操作及测试条件：CX←CX-1,<strong>若（CX）≠0且ZF&#x3D;1循环，若ZF&#x3D;0或（CX）&#x3D;0退出循环</strong>。</p>
<h4 id="LOOPNZ（或LOOPNE）当不为零或不相等时循环指令"><a href="#LOOPNZ（或LOOPNE）当不为零或不相等时循环指令" class="headerlink" title="LOOPNZ（或LOOPNE）当不为零或不相等时循环指令"></a>LOOPNZ（或LOOPNE）当不为零或不相等时循环指令</h4><p>指令格式：LOOPZ（或LOOPE）  OPR</p>
<p>执行操作及测试条件：CX←CX-1, <strong>若（CX）≠0且ZF&#x3D;0循环，若ZF&#x3D;1或（CX）&#x3D;0退出循环</strong>。</p>
<blockquote>
<p>注意：使用循环控制指令之前，必须在寄存器CX（作为计数器）中预置循环次数的初值。</p>
</blockquote>
<h3 id="子程序指令"><a href="#子程序指令" class="headerlink" title="子程序指令"></a>子程序指令</h3><p>子程序指令包括：CALL（call）调用、RET（return）返回。</p>
<p>段内调用指令和返回指令应用原理简述如下。<br>主程序为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000H	MOV	SP，0200H</span><br><span class="line">     </span><br><span class="line">1050H	CALL	2100H</span><br><span class="line">1053H</span><br><span class="line">1A00H	HLT</span><br></pre></td></tr></table></figure>
<p>子程序为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2100H	XOR	AL，AL</span><br><span class="line">21B0H	RET</span><br></pre></td></tr></table></figure>
<p>说明：主程序中，1053H为返回地址，2100H为子程序入口地址。主程序执行时，指令“CALL 2100H”将返回地址1053H压入堆栈，同时将2100H送给指针IP，程序转向子程序执行。子程序执行后，RET指令将保存在堆栈中的1053H送入指针IP，保证主程序的连续执行。</p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>中断指令包括：INT（interrupt）中断、INTO（interrupt if overflow）如溢出则中断、IRET（return from interrupt）从中断返回。</p>
<h4 id="INT-中断指令"><a href="#INT-中断指令" class="headerlink" title="INT 中断指令"></a>INT 中断指令</h4><p>指令格式：INT  TYPE 或 INT</p>
<p>INT TYPE指令为两字节指令，中断类型号TYPE占有一个字节，TYPE它可以是常数或常量表达式，其值必须在0～255范围内,代表256级中断。每个中断类型号都对应一个4字节的中断矢量，中断矢量是指中断服务程序的入口地址。</p>
<h2 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h2><p>处理器控制指令可以分为标志位处理指令和其他处理器控制指令。</p>
<h3 id="标志位处理指令"><a href="#标志位处理指令" class="headerlink" title="标志位处理指令"></a>标志位处理指令</h3><p>标志位处理指令包括：</p>
<ul>
<li>CLC（Clear carry）进位位置0。执行的操作：CF←0</li>
<li>CMC（Complement carry）进位位求反。执行的操作：CF← CF</li>
<li>STC（Set carry）进位位置1。执行的操作：CF←1</li>
<li>CLD（Clear direction）方向标志置0。执行的操作：DF←0</li>
<li>STD（Set direction）方向标志置1。执行的操作：DF←1</li>
<li>CLI（Clear interrupt）中断标志置0。执行的操作：IF←0</li>
<li>STI（Set interrupt） 中断标志置1。</li>
</ul>
<p>这组指令只影响本指令指定的标志，不影响其他标志位。执行的操作：IF←1</p>
<h3 id="其他处理器控制指令"><a href="#其他处理器控制指令" class="headerlink" title="其他处理器控制指令"></a>其他处理器控制指令</h3><p>8086&#x2F;8088用于CPU最大模式时，需要处理主机和协处理器及多处理器之间的同步关系。其他处理器控制指令包括：NOP（no opreation）空操作、HLT（halt）停机、WAIT（wait）等待、ESC（escape）换码、LOCK（lock）封锁，这些指令可以控制处理机状态。它们都不影响状态标志。</p>
<ol>
<li>NOP 空操作指令。<br>指令格式：NOP。<br>此指令为单字节指令，不执行任何操作，只起到占用存储器空间和时间延迟的作用。</li>
<li>HLT停机指令。<br>指令格式：HLT。<br>此指令可暂停计算机工作，使处理器处于停机状态，用于等待一次外部中断的产生，中断结束后，继续执行下面的程序。</li>
<li>WAIT等待指令。<br>指令格式：WAIT。<br>此指令使处理器处于等待状态，也可以用来等待外部中断发生，但中断结束后仍返回WAIT指令继续等待。本指令不允许使用立即数和寄存器寻址方式。</li>
<li>ESC换码指令。<br>指令格式：ESC  mem。<br>此指令执行时，协处理器监视系统总线，并能将mem指定内存单元的内容（指令或操作数）送到数据总线上。</li>
<li>LOCK封锁指令。<br>指令格式：LOCK。<br>用于维持总线的锁存信号，直到后续指令执行完毕。</li>
</ol>
<h1 id="指令系统小结表"><a href="#指令系统小结表" class="headerlink" title="指令系统小结表"></a>指令系统小结表</h1><table cellpadding="0" cellspacing="0" width="864" style="width: 804px;">
    <tbody>
        <tr height="31" style=";height:31px" class="firstRow">
            <td height="31" width="103" style="">
                <p>
                    指令类
                </p>
            </td>
            <td width="164" style="">
                <p>
                    指令名称
                </p>
            </td>
            <td width="597" style="">
                <p>
                    指令助记符
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="4" height="122" width="103" style="">
                <p>
                    数据传送
                </p>
            </td>
            <td width="164" style="">
                <p>
                    数据传送
                </p>
            </td>
            <td width="597" style="">
                <p>
                    MOV、LEA、LDS、LES、LAHF、SAHF
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    堆栈操作
                </p>
            </td>
            <td width="597" style="">
                <p>
                    PUSH、POP、PUSHF、POPF
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    数据交换
                </p>
            </td>
            <td width="597" style="">
                <p>
                    XCHG、XLAT
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    输入输出
                </p>
            </td>
            <td width="597" style="">
                <p>
                    IN、OUT
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="6" height="183" width="103" style="">
                <p>
                    算术运算
                </p>
            </td>
            <td width="164" style="">
                <p>
                    加法
                </p>
            </td>
            <td width="597" style="">
                <p>
                    ADD、ADC、INC
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    减法；比较
                </p>
            </td>
            <td width="597" style="">
                <p>
                    SUB、SBB、DEC、NEG；CMP
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    乘法
                </p>
            </td>
            <td width="597" style="">
                <p>
                    MUL、IMUL
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    除法
                </p>
            </td>
            <td width="597" style="">
                <p>
                    DIV、IDIV
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    扩展
                </p>
            </td>
            <td width="597" style="">
                <p>
                    CBW、CWD
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="164" style="">
                <p>
                    十进制调整
                </p>
            </td>
            <td width="597" style="">
                <p>
                    AAA、AAS、DAA、DAS、AAM、AAD
                </p>
            </td>
        </tr>
    </tbody>
</table>

<table cellpadding="0" cellspacing="0" width="896" style="width: 804px;">
    <tbody>
        <tr height="31" style=";height:31px" class="firstRow">
            <td rowspan="3" height="94" width="105" style="">
                <p>
                    位操作
                </p>
            </td>
            <td width="171" style="">
                <p>
                    逻辑运算
                </p>
            </td>
            <td width="620" style="">
                <p>
                    AND、OR、NOT、XOR、TEST
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    移位运算
                </p>
            </td>
            <td width="620" style="">
                <p>
                    SAL、SAR、SHL、SHR
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    循环移位
                </p>
            </td>
            <td width="620" style="">
                <p>
                    ROL、ROR、RCL、RCR
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="5" height="157" width="105" style="">
                <p>
                    串操作
                </p>
            </td>
            <td width="171" style="">
                <p>
                    串传送
                </p>
            </td>
            <td width="620" style="">
                <p>
                    MOVS、MOVSB、MOVSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串存取
                </p>
            </td>
            <td width="620" style="">
                <p>
                    STOS、STOSB、STOSW、LODS、LODSB、LODSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串比较
                </p>
            </td>
            <td width="620" style="">
                <p>
                    CMPS、CMPSB、CMPSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串搜索
                </p>
            </td>
            <td width="620" style="">
                <p>
                    SCAS、SCASB、SCASW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    串输入输出
                </p>
            </td>
            <td width="620" style="">
                <p>
                    INS、INSB、INSW、OUTS、OUTSB、OUTSW
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="4" height="164" width="105" style="">
                <p>
                    程序控制
                </p>
            </td>
            <td width="171" style="">
                <p>
                    调用
                </p>
            </td>
            <td width="620" style="">
                <p>
                    CALL、RET
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    中断
                </p>
            </td>
            <td width="620" style="">
                <p>
                    INT、INTO、IRET
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    重复操作
                </p>
            </td>
            <td width="620" style="">
                <p>
                    LOOP、LOOPE/LOOPZ、LOOPNE/LOOPNZ、JCXZ
                </p>
            </td>
        </tr>
        <tr height="70" style=";height:70px">
            <td height="70" width="171" style="">
                <p>
                    跳转
                </p>
            </td>
            <td width="620" style="">
                <p>
                    JA/JNBE、JAE/JNB、JB/JNAE、JBE/JNA、JG/JNLE、JE/JZ、JNE/JNZ、JGE/JNL、JL/JNGE、JNC、JC、JNS、JS、JP/JPE、JNP/JPO、JNO、JO
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="2" height="63" width="105" style="">
                <p>
                    处理器控制
                </p>
            </td>
            <td width="171" style="">
                <p>
                    清除标志
                </p>
            </td>
            <td width="620" style="">
                <p>
                    CLC、STC、CMC、CLD、STD、CLI、STI
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    时序控制
                </p>
            </td>
            <td width="620" style="">
                <p>
                    NOP、WAIT、HLT、ESC
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td rowspan="3" height="94" width="105" style="">
                <p>
                    前缀操作
                </p>
            </td>
            <td width="171" style="">
                <p>
                    重复前缀
                </p>
            </td>
            <td width="620" style="">
                <p>
                    REP、REPZ/REPE、REPNZ/REPNE
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    段前缀
                </p>
            </td>
            <td width="620" style="">
                <p>
                    ES：、DS：、CS：、SS：
                </p>
            </td>
        </tr>
        <tr height="31" style=";height:31px">
            <td height="31" width="171" style="">
                <p>
                    总线封锁前缀
                </p>
            </td>
            <td width="620" style="">
                <p>
                    LOCK
                </p>
            </td>
        </tr>
    </tbody>
</table>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>微机与接口技术笔记（5）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<p>这章内容讲可编程定时器&#x2F;计数器8253</p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在计算机系统中使用的定时器&#x2F;计数器归纳起来主要有三大类：<strong>软件定时器&#x2F;计数器、硬件定时&#x2F;计数器和可编程定时器&#x2F;计数器。</strong></p>
<h2 id="软件定时器-x2F-计数器"><a href="#软件定时器-x2F-计数器" class="headerlink" title="软件定时器&#x2F;计数器"></a>软件定时器&#x2F;计数器</h2><p>软件定时器&#x2F;计数器是实现系统定时控制或延时控制的最简单的方法。在计算机中CPU每执行一条指令所占用的周期（T状态）数是确定的，<strong>用汇编语言编写一段具有固定延时时间的循环程序，将该程序的每条指令的T状态数加起来，乘以系统的时钟周期，就是该程序执行一遍所需的延时时间。</strong> 设计者可选择不同的指令条数和不同的循环次数来实现不同的时间延迟。</p>
<h2 id="硬件定时器-x2F-计数器"><a href="#硬件定时器-x2F-计数器" class="headerlink" title="硬件定时器&#x2F;计数器"></a>硬件定时器&#x2F;计数器</h2><p>硬件定时器&#x2F;计数器是指由硬件电路来实现的定时与计数。对于<strong>较长时间的定时</strong>一般用硬件电路来完成，采用硬件定时&#x2F;计数器它的<strong>成本低，使用方便</strong>。 </p>
<h2 id="可编程定时器-x2F-计数器"><a href="#可编程定时器-x2F-计数器" class="headerlink" title="可编程定时器&#x2F;计数器"></a>可编程定时器&#x2F;计数器</h2><p>可编程定时器&#x2F;计数器，是一种软硬件结合的定时器&#x2F;计数器，将定时器&#x2F;计数器电路做成通用的定时器&#x2F;计数器并集成到一个芯片上，定时器&#x2F;计数器工作方式又可由软件来控制选择。<strong>这种定时器&#x2F;计数器芯片可直接对系统时钟进行计数，通过写入不同的计数初值，可方便地改变定时与计数时间，在定时期间不占用CPU资源，更不需要CPU管理</strong>。Intel公司生产的8253就是这样的可编程定时器&#x2F;计数器芯片。</p>
<h1 id="8253的主要功能"><a href="#8253的主要功能" class="headerlink" title="8253的主要功能"></a>8253的主要功能</h1><p>8253具有三个独立的功能完全相同的16位减法计数器，24脚DIP封装，由单一的+5V电源供电。主要功能如下</p>
<ol>
<li>每片8253上有三个独立的16位减法计数器，最大计数范围为0～65535。</li>
<li>每个计数器都可按二进制或二—十进制计数(BCD:用4位二进制数来表示1位十进制数中的0~9这10个数码)。</li>
<li>每个计数器都有六种不同的工作方式，都可以通过程序设置和改变。</li>
<li>每个计数器计数脉冲的频率最高可达2 MHz。</li>
<li>全部输入&#x2F;输出与TTL电平兼容。</li>
</ol>
<p>8253的读、写操作，<strong>对系统时钟没有特殊要求</strong>，因此可以应用于任何一种微机系统中，可作为可编程<strong>定时器、计数器还可以作分频器、方波发生器以及单脉冲发生器等</strong>。</p>
<h1 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h1><p>8253引脚如图。8253芯片有24根引脚，没有复位信号RESET引脚。 </p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/1.png" class="" title="引脚图">

<p>各引脚信号定义如下：</p>
<ul>
<li>CS（21脚）：片选信号，输入，低电平有效。它与译码器输出信号相连接，当为低电平时，8253芯片被CPU选中。</li>
<li>A1（20脚）、A0（19脚）：输入信号，用来对3个计数器和控制寄存器进行寻址，与CPU的系统地址线相连。当A1、A0为00、01、10、11时分别表示对计数器0、计数器1、计数器2和控制寄存器的访问。<br>当CPU为8位数据总线时，8253的A1、A0可与地址总线的A1、A0相连；当CPU为16位数据总线时，8253的A1、A0引脚分别与地址总线的A2、A1相连。</li>
<li>WR（23脚）：写引脚，输入，低电平有效。用于控制CPU对8253的写操作,此引脚与CPU系统控制总线的相连。</li>
<li>RD (22脚)：读引脚，输入，低电平有效，用于控制CPU对8253的读操作，此引脚与CPU系统控制总线的相连。</li>
</ul>
<p>8253读&#x2F;写逻辑信号组合功能及地址分配如表:</p>
<table>
<thead>
<tr>
<th>CS</th>
<th>WR</th>
<th>RD</th>
<th>A1</th>
<th>A2</th>
<th>操作功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>初值写入计数器0的初值寄存器CR0里</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>初值写入计数器0的初值寄存器CR1里</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>初值写入计数器0的初值寄存器CR2里</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>写控制字寄存器</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>读计数器0输出锁存器OL0的内容</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>读计数器0输出锁存器OL1的内容</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>读计数器0输出锁存器OL2的内容</td>
</tr>
</tbody></table>
<p><strong>CLK0～2</strong>：时钟，输入。CLK时钟信号用于控制计数器的减1操作，CLK可以是系统时钟脉冲，也可以由系统时钟分频或者是其他脉冲源提供，输入的时钟频率在1MHz～2MHz范围内。</p>
<p><strong>GATE0～2</strong>：门控信号，输入，由外部信号通过GATE端控制计数器的启动计数和停止计数的操作。</p>
<p><strong>OUT0～2</strong>：时间到或计数结束输出引脚。当计数器计数到0时，在OUT引脚有输出。在不同的模式下，可输出不同电平的信号。</p>
<h1 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h1><p>8253的内部结构由数据总线缓冲器、读／写逻辑电路、控制字寄存器和三个计数通道所组成。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/2.png" class="" title="内部结构">

<h2 id="数据总线缓冲器"><a href="#数据总线缓冲器" class="headerlink" title="数据总线缓冲器"></a>数据总线缓冲器</h2><p>数据总线缓冲器是8位、双向、三态的缓冲器，通过8根数据线D0～D7接收CPU向控制寄存器写入的控制字，向计数器写入的计数初值,也可把计数器的当前计数值读入CPU。</p>
<h2 id="读／写逻辑电路"><a href="#读／写逻辑电路" class="headerlink" title="读／写逻辑电路"></a>读／写逻辑电路</h2><p>读／写控制逻辑电路从系统总线接收输入信号，经过译码，产生对8253各部分的控制信息。</p>
<h2 id="控制字寄存器"><a href="#控制字寄存器" class="headerlink" title="控制字寄存器"></a>控制字寄存器</h2><p>当地址信号A1和A0都为1时，访问控制字寄存器。控制字寄存器接收从CPU发来的控制字，控制字决定了8253的工作方式、计数方式以及使用哪个计数器等。<strong>控制字寄存器只能写入不能读出</strong>。 </p>
<h2 id="计数通道"><a href="#计数通道" class="headerlink" title="计数通道"></a>计数通道</h2><p>8253有3个相互独立的同样的计数电路，分别称作<strong>计数器0、计数器1和计数器2</strong>。</p>
<p>每个计数器包含一个8位的<strong>控制寄存器</strong>(控制单元)，它存放计数器的工作方式控制字；一个16位的<strong>初值寄存器CR</strong>(时间常数寄存器)，8253工作之前要对它设置初值；一个16位计数<strong>执行单元CE</strong>，它接收计数初值寄存器CR送来的内容，并对该内容执行减1操作；一个16位<strong>输出锁存器OL</strong>，它锁存CE的内容，使CPU能从输出锁存器内读出一个稳定的计数值。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/3.png" class="" title="计数器的内部结构">

<h1 id="8253的控制字和读写操作"><a href="#8253的控制字和读写操作" class="headerlink" title="8253的控制字和读写操作"></a>8253的控制字和读写操作</h1><h2 id="8253的控制字"><a href="#8253的控制字" class="headerlink" title="8253的控制字"></a>8253的控制字</h2><p>8253的控制字主要用于：<br><strong>选择哪个计数器通道工作，决定用8位的计数值或是用16位的计数值，按二进制计数或按十进制计数(BCD码)，工作在那种方式</strong>。 </p>
<p>8253是由主机编程设定的，通过把一个8位的控制字写<br>入8253的控制字寄存器，使8253按照某种给定的方式工作。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/4.png" class="" title="控制字（重点要记）">

<p>8253控制字各位的详细意义如下：</p>
<ol>
<li>SC1、SC0用于选择工作的计数器。<ul>
<li>SC1SC0＝00：选择<strong>计数器0</strong>工作。</li>
<li>SC1SC0＝01：选择<strong>计数器1</strong>工作。</li>
<li>SC1SC0＝10：选择<strong>计数器2</strong>工作。  </li>
<li>SC1SC0＝11：无效。</li>
</ul>
</li>
<li>RW1、RW0 用于选择读写格式。<ul>
<li>RW1RW0＝00：计数器锁存命令，把写本命令时的当前计数值锁存到输出锁存器OL中，以供CPU读   取。</li>
<li>RW1RW0＝01：8位计数，只读&#x2F;写计数器低位字节，高位字节自动为0。</li>
<li>RW1RW0 ＝10：16位计数，只读&#x2F;写计数器高位字节，低位字节自动为0。</li>
<li>RW1RW0 ＝11：16位计数，先读&#x2F;写计数器低位字节，后读&#x2F;写计数器高位字节。</li>
</ul>
</li>
<li>M2、M1、M0用于选择工作方式。<ul>
<li>M2M1M0＝000： 使计数器工作于方式0。</li>
<li>M2M1M0 ＝001：使计数器工作于方式1。</li>
<li>M2M1M0 ＝010：使计数器工作于方式2。</li>
<li>M2M1M0 ＝011：使计数器工作于方式3。</li>
<li>M2M1M0 ＝100：使计数器工作于方式4。</li>
<li>M2M1M0 ＝101：使计数器工作于方式5。</li>
</ul>
</li>
<li>BCD计数方式选择<ul>
<li>当BCD位＝0时，则计数器按二进制计数，其计数范围是16位二进制数，最大计数值为216&#x3D;65536（对应计数初值为0000H）；</li>
<li>当BCD位＝1时，则计数器按十进制(BCD码)计数，其计数范围是四位十进制数，最大计数值为104&#x3D;10000，对应计数初值为0000。</li>
</ul>
</li>
</ol>
<h2 id="在赋初值时需要注意两点"><a href="#在赋初值时需要注意两点" class="headerlink" title="在赋初值时需要注意两点"></a>在赋初值时需要注意两点</h2><h3 id="当采用二进制计数时"><a href="#当采用二进制计数时" class="headerlink" title="当采用二进制计数时"></a>当采用二进制计数时</h3><p>如果初值N是8位二进制计数（计数值≤256），则在8253初始化编程的传送指令“MOV AL,N”中，立即数“N”可以写成任何进制数的形式；<br>如果初值N是16位二进制计数（计数值≤65536），<strong>一种方法是先把计算得到的十进制计数初值N转换成4位十六进制，然后分两次写入8253的指定端口，另一种方法是先把该十进制计数初值N直接传给AX, 然后分两次写入8253的指定端口</strong>。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AX, N    ;N是16位二进制计数</span><br><span class="line">OUT  Port, AL ;先写低8位（Port为端口号）</span><br><span class="line">MOV  AL, AH   ;高8位送低8位</span><br><span class="line">OUT  Port, AL ;后写高8位</span><br></pre></td></tr></table></figure>

<h3 id="采用十进制（BCD码）计数时"><a href="#采用十进制（BCD码）计数时" class="headerlink" title="采用十进制（BCD码）计数时"></a>采用十进制（BCD码）计数时</h3><p>必须在8253初始化编程中把计算得到的十进制计数初值N加上后缀H,这样才能在传送指令执行后能够在AL(或AX)中得到十进制数N的BCD码表示形式，例如N&#x3D;30</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL,30H</span><br><span class="line">OUT Port，AL</span><br></pre></td></tr></table></figure>
<p>如果初值N&#x3D;2567,则需要分两次写入，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,2567H    </span><br><span class="line">OUT Port,AL  ;先写低8位（Port为端口号）</span><br><span class="line">MOV AL,AH    ;高8位送低8位</span><br><span class="line">OUT Port,AL  ;后写高8位</span><br></pre></td></tr></table></figure>
<p>也可以按如下方法两次写入，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL,67H    </span><br><span class="line">OUT Port,AL  ;先写低8位（Port为端口号）</span><br><span class="line">MOV AL,25H   ;高8位送低8位</span><br><span class="line">OUT Port,AL  ;后写高8位</span><br></pre></td></tr></table></figure>
<h2 id="8253的初始化编程（写操作）"><a href="#8253的初始化编程（写操作）" class="headerlink" title="8253的初始化编程（写操作）"></a>8253的初始化编程（写操作）</h2><p>8253没有复位信号，加电开机后，其工作方式是不确定的。因此需要对8253进行初始化，初始化步骤如下所示。</p>
<ol>
<li>根据题目要求设计写出8253的控制字。</li>
<li>将控制字写入计数器的控制寄存器中。</li>
<li>写入定时或计数的初值。这里要注意的是如果计<br>数值为16位，则要CPU执行两次输出指令完成初值<br>的设置，即先写低字节，再写高字节。</li>
</ol>
<blockquote>
<p>设8253的片选信号接200H～207H,使用计数器1，工作于方式3（方波发生器）, 二进制计数,计数初值为3000H,请编写初始化程序。</p>
</blockquote>
<p>解：方法1：16位计数，先写低8位，后写高8位。根据题目写出控制字为01110110B(76H)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   DX,203H    ;8253控制寄存器</span><br><span class="line">MOV   AL,76H     ;二进制计数、方式3、先写低8 位、后写高8位、计数器1</span><br><span class="line">OUT   DX,AL      ;控制字写入控制字寄存器</span><br><span class="line">MOV   DX,201H    ;计数器1</span><br><span class="line">MOV   AL,00H     ;计数初值低8位</span><br><span class="line">OUT   DX,AL	     ;计数初值低8位写入计数器1</span><br><span class="line">MOV   AL,30H     ;计数初值高8位</span><br><span class="line">OUT   DX,AL	     ;计数初值高8位写入计数器1</span><br></pre></td></tr></table></figure>
<p>方法2：  16位计数，只写高8位，低8位自动为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   DX,203H    ;8253控制寄存器</span><br><span class="line">MOV   AL, 66H    ;控制字01100110B</span><br><span class="line">OUT   DX, AL	 ;控制字写入控制字寄存器</span><br><span class="line">MOV   DX,201H    ;计数器1</span><br><span class="line">MOV   AL,30H     ;计数初值高8位</span><br><span class="line">OUT   DX, AL     ;计数初值高8位写入计数器1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设8253的端口地址为208H～20FH，使用计数器0，工作于方式4，二进制计数；使用计数器2，工作于方式5，十进制计数。计数器0和计数器2的计数初值都等于十进制数值512(0200H)，请编写初始化程序。</p>
</blockquote>
<p>解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AL,38H	;控制字00111000B,二进制计数、方式4、计数器0、先写低8位、后写高8位</span><br><span class="line">MOV   DX,20BH	;控制字寄存器端口地址</span><br><span class="line">OUT   DX,AL     ;控制字写入控制字寄存器</span><br><span class="line">MOV   DX,208H	;计数器0端口地址</span><br><span class="line">MOV   AL,00H	;计数初值低8位               </span><br><span class="line">OUT   DX,AL  	;计数初值低8位写入计数器0</span><br><span class="line">MOV   AL,02H	;计数初值高8位</span><br><span class="line">OUT   DX,AL 	;计数初值高8位写入计数器0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AL,0BBH	;控制字10111011B，BCD、方式5、计数器2、先写低8位、后写高8位</span><br><span class="line">MOV   DX,20BH	;控制字寄存器端口地址</span><br><span class="line">OUT   DX,AL	    ;控制字写入控制字寄存器</span><br><span class="line">MOV   DX,20AH   ;计数器2端口地址</span><br><span class="line">MOV   AL,12H	;计数初值低8位</span><br><span class="line">OUT   DX,AL     ;计数初值低8位写入计数器2</span><br><span class="line">MOV   AL,05H	;计数初值高8位</span><br><span class="line">OUT   DX,AL	    ;计数初值高8位写入计数器2</span><br></pre></td></tr></table></figure>

<h2 id="8253当前计数值的读取（读操作）"><a href="#8253当前计数值的读取（读操作）" class="headerlink" title="8253当前计数值的读取（读操作）"></a>8253当前计数值的读取（读操作）</h2><p>为了对计数器的计数值进行实时检测，需将计数器中的计数值读回CPU。编程顺序如下。</p>
<ol>
<li>输出锁存器锁存或停止计数，以保证当前计数值读出稳定。</li>
<li>读输出锁存器的读数。</li>
</ol>
<p><strong>当前的计数值读取：</strong><br>一种方法是把当前计数值输出锁存器锁存，输出锁存器锁存是通过写入控制字，使D5、D4分别为0，使当前的计数值不受计数执行单元的变化而变化，保证CPU从锁存器读出一个稳定的计数值。此时计数执行单元作减1操作，计数过程不停止。另一种方法是通过GATE门控信号发一低电平信号，使计数执行单元不作减1操作，计数过程停止。</p>
<p>读输出锁存器的值，也有读8位和读16位的问题，若是读16位的数据，需分两次读出，先读低字节，再读高字节，即执行两次输入指令。</p>
<blockquote>
<p>设8253的端口地址为208H～20FH，请编写程序读取计数器2的当前计数值。（ 20BH：控制字寄存器端口地址，20AH：计数器2端口地址）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL,80H     ;计数器2的锁存命令 （10000000B） </span><br><span class="line">MOV  DX,20BH    ;控制字寄存器端口地址</span><br><span class="line">OUT  DX,AL	    ;计数器2的锁存命令写入控制字寄存器</span><br><span class="line">MOV  DX,20AH    ;计数器2端口地址</span><br><span class="line">IN   AL,DX	    ;读取计数初值低8位 </span><br><span class="line">MOV  BL,AL	    ;计数初值低8位存入BL</span><br><span class="line">IN   AL,DX	    ;读取计数初值高8位</span><br><span class="line">MOV  BH,AL	    ;计数初值高8位存入BH</span><br></pre></td></tr></table></figure>

<h1 id="8253的工作方式"><a href="#8253的工作方式" class="headerlink" title="8253的工作方式"></a>8253的工作方式</h1><p>8253的工作方式有6种，不论哪种工作方式，都遵守如下几条基本原则。</p>
<ol>
<li><strong>控制字写入计数器时，所有的控制逻辑电路立即复位，输出端OUT进入初始状态</strong>。该初始状态与工作方式有关，设置成方式0时，OUT的初始状态为低电平，设置成其他工作方式，OUT的初始状态为高电平。</li>
<li><strong>初始值写入初值计数器CR以后，要经过一个时钟脉冲的上升沿和下降沿，将初值送入计数执行单元，计数执行单元从下一个时钟开始进行计数。</strong></li>
<li><strong>通常，在时钟脉冲CLK的上升沿对门控信号GATE进行采样，各计数器的门控信号的触发方式与工作方式有关</strong>。在方式0、方式4中，门控信号为电平触发；方式1、方式5中，门控信号为上升沿触发；方式2、方式3中，即可用电平触发，也可用上升沿触发。</li>
<li>在时钟脉冲的下降沿计数器进行计数。</li>
</ol>
<h2 id="方式0-——-计数到零产生中断请求"><a href="#方式0-——-计数到零产生中断请求" class="headerlink" title="方式0 —— 计数到零产生中断请求"></a>方式0 —— 计数到零产生中断请求</h2><p>在方式0下，可利用OUT的上升沿作为中断请求信号。门控信号决定计数的启&#x2F;停，影响是否暂停减一。装入初值决定计数过程重新开始，改变计算值是立即有效的，计数过程时序图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/5.png" class="" title="方式0计数过程时序图">

<h2 id="方式1-——-可重触发的单稳态触发器"><a href="#方式1-——-可重触发的单稳态触发器" class="headerlink" title="方式1 —— 可重触发的单稳态触发器"></a>方式1 —— 可重触发的单稳态触发器</h2><p>方式1是在GATE门控信号的作用下才开始计数，计数过程时序所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/6.png" class="" title="方式1计数过程时序图">

<h2 id="方式2-——-分频器"><a href="#方式2-——-分频器" class="headerlink" title="方式2 —— 分频器"></a>方式2 —— 分频器</h2><p>在方式2下，用门控信号达到同步计数的目的，方式2计数过程时序如图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/7.png" class="" title="方式2计数过程时序图">

<h2 id="方式3-——-方波发生器"><a href="#方式3-——-方波发生器" class="headerlink" title="方式3 —— 方波发生器"></a>方式3 —— 方波发生器</h2><p>方式3和方式2的工作过程类似，两者的主要区别是输出的脉冲<br>宽度不同，方式3计数过程时序图如图所示。GATE&#x3D;1,允许计数，GATE&#x3D;0,禁止计数。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/8.png" class="" title="方式3计数过程时序图">
<blockquote>
<p>简单来说就是没有0值，1下一个计数会自动重新装载初值，计数为偶数时前半部分out为高电平，后半部分为低电平，奇数时高电平多一个计数值。</p>
</blockquote>
<h2 id="方式4-——-软件触发选通方式"><a href="#方式4-——-软件触发选通方式" class="headerlink" title="方式4 —— 软件触发选通方式"></a>方式4 —— 软件触发选通方式</h2><p>方式4为软件触发选通方式，其计数过程时序图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/9.png" class="" title="方式4计数过程时序图">

<h2 id="方式5-——-硬件触发选通方式"><a href="#方式5-——-硬件触发选通方式" class="headerlink" title="方式5 —— 硬件触发选通方式"></a>方式5 —— 硬件触发选通方式</h2><p>方式5为硬件触发选通方式，完全由GATE端引入的触发信号控制定时和计数，其计数过程时序图所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/10.png" class="" title="方式5计数过程时序图">

<h1 id="六种工作方式小结"><a href="#六种工作方式小结" class="headerlink" title="六种工作方式小结"></a>六种工作方式小结</h1><p>通过对上面的6种工作方式的分析，可以看出门控信号和写入新的初值会影响计数过程的进行，不同的工作方式，会得到不同的输出波形。在8253的应用中，必须正确使用门控信号和写入新的初值这种触发方式，才能保证各计数器的正常操作；必须了解输出波形的形态，才能正确应用到各种控制场合。为此，把6种工作方式作如下小结。</p>
<h2 id="OUT的输出波形"><a href="#OUT的输出波形" class="headerlink" title="OUT的输出波形"></a>OUT的输出波形</h2><p>在六种工作方式中，只有方式0在写入控制字后OUT输出为低电平，其他五种方式OUT输出都为高电平。方式2、方式4和方式5都是输出宽度为一个CLK周期的负脉冲，输出波形都相同，但方式2是连续工作的，方式4是由软件触发的，方式5是由硬件门控脉冲触发的。计数初值N与输出波形的关系见表。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/11.png" class="" title="计数初值N与输出波形的关系">

<h2 id="GATE门控信号的作用"><a href="#GATE门控信号的作用" class="headerlink" title="GATE门控信号的作用"></a>GATE门控信号的作用</h2><p>一般情况下，GATE信号为低电平时禁止计数，为高电平时允许计数，方式1和方式5则需要有由低变高的上升沿触发脉冲来启动计数。GATE信号对各种工作方式的影响如表所示。 </p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/12.png" class="" title="GATE信号作用">

<h2 id="计数初值的设置"><a href="#计数初值的设置" class="headerlink" title="计数初值的设置"></a>计数初值的设置</h2><p>任何一种工作方式，只有在写入计数初值后才能开始计数。门控信号GATE保持为高电平，方式0、方式2、方式3和方式4在写入计数初值后，计数过程就开始了；而方式1和方式5需要有外部GATE触发，才能开始计数。 </p>
<h2 id="计数过程中改变计数值的影响"><a href="#计数过程中改变计数值的影响" class="headerlink" title="计数过程中改变计数值的影响"></a>计数过程中改变计数值的影响</h2><p>8253在计数过程中写入新的计数初值，对计数过程的影响见表所示。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/13.png" class="" title="对计数过程的影响表">

<h1 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h1><ol>
<li>设8253计数器的时钟输入频率为1.91MHz，为产生25kHz的方波输出信号，应向计数器装入的计数初值为<strong>76</strong>。</li>
<li>在异步通信时，完整的一帧信息一般包括4个部分，传送过程中，它们的正确顺序是   <strong>起始位、数据位、校验位、停止位</strong>    。</li>
<li>在异步串行通信中，使用波特率来表示数据的传送速率，它是指<br><strong>每秒钟传送的二进制数。</strong></li>
<li>全双工和半双工通信的区别时什么？<br>全双工和半双工通信，双方既是发送器又是接收器。两者的区别在于全双工可以同时发送和接收。半双工不能同时双向传输，只能分时进行。</li>
<li>同步传输方式和异步传输方式的特点各是什么？<br>同步传输方式中发送方和接收方的时钟是统一的，字符与字符间的传输是同步无间隔的。异步传输方式并不要求发送方和接收方的时钟完全一样，字符与字符间的传输时异步的。</li>
<li>RS-232C接口的信号电平采用什么逻辑？逻辑“1”和“0”电平各为多少？<br>RS-232C接口的信号电平采用负逻辑。将-15V<del>-5V规定为逻辑“1”，+5V</del>+15V 规定为“0”。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微机</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发之Jetpack：LiveData</title>
    <url>/%E5%AE%89%E5%8D%93/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B9%8BJetpack%EF%BC%9ALiveData/</url>
    <content><![CDATA[<p>与ViewModel的关系：在ViewModel中的数据发生变化时通知页面</p>
<p>LiveData的优势：</p>
<ul>
<li>确保界面符合数据状态</li>
<li>不会发生内存泄漏</li>
<li>不会因Activity停止而导致崩溃</li>
<li>不再需要手动处理生命周期</li>
<li>数据始终保存最新状态</li>
<li>适当的配置更新</li>
<li>共享资源</li>
</ul>
<span id="more"></span>

<h1 id="LiveData的基本使用"><a href="#LiveData的基本使用" class="headerlink" title="LiveData的基本使用"></a>LiveData的基本使用</h1><p>基本用法就是创建一个ViewModel，然后使用observer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MutableLiveData&lt;String&gt; mLiveData = mTestViewModel.getLiveData();</span><br><span class="line">mLiveData.observe(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> String s)</span> &#123;</span><br><span class="line">       <span class="comment">//更新UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><p>还是直接上代码：<br>布局xml，使用TextView显示读秒：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyViewModel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.livedata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.MutableLiveData;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title function_">getCurrentSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentSecond == <span class="literal">null</span>) &#123;</span><br><span class="line">            currentSecond = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line">            currentSecond.setValue(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; currentSecond;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>activity.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.livedata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> MyViewModel myViewModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        myViewModel = <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>.AndroidViewModelFactory(getApplication())).get(MyViewModel.class);</span><br><span class="line">        textView.setText(String.valueOf(myViewModel.getCurrentSecond().getValue()));</span><br><span class="line"></span><br><span class="line">        myViewModel.getCurrentSecond().observe(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">                textView.setText(String.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        startTimer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startTimer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Timer</span>().schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 非UI线程用postValue改变VIewModel，UI线程用setValue</span></span><br><span class="line">                myViewModel.getCurrentSecond().postValue(myViewModel.getCurrentSecond().getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="ViewModel-LiveData实现Fragment间通信"><a href="#ViewModel-LiveData实现Fragment间通信" class="headerlink" title="ViewModel+LiveData实现Fragment间通信"></a>ViewModel+LiveData实现Fragment间通信</h1><p>需求：有两个fragment，里面都是一个SeekBar，然后让两个SeekBar的process保存一致。<br>先创建两个fragment</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">SeekBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/seekBar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:min</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:max</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二个fragment叫SecondFragment<br>添加到activity：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragmentContainerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.livedata.FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintGuide_percent</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragmentContainerView2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.livedata.SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/guideline3&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样创建ViewModel：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.livedata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.MutableLiveData;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; progress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;Integer&gt; <span class="title function_">getProgress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (progress == <span class="literal">null</span>) &#123;</span><br><span class="line">            progress = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line">            progress.setValue(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> progress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fragment的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.livedata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer;</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.SeekBar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span><br><span class="line"><span class="params">                             Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment_first, container, <span class="literal">false</span>);        <span class="comment">// 第二个fragment这改成fragment_second</span></span><br><span class="line">        <span class="type">SeekBar</span> <span class="variable">seekBar</span> <span class="operator">=</span> root.findViewById(R.id.seekBar);</span><br><span class="line">        <span class="type">MyViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(getActivity(), <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>.AndroidViewModelFactory(getActivity().getApplication())).get(MyViewModel.class);</span><br><span class="line">        viewModel.getProgress().observe(getActivity(), <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                seekBar.setProgress(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        seekBar.setOnSeekBarChangeListener(<span class="keyword">new</span> <span class="title class_">SeekBar</span>.OnSeekBarChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="type">int</span> progress, <span class="type">boolean</span> fromUser)</span> &#123;</span><br><span class="line">                viewModel.getProgress().setValue(progress);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个Fragment也上面的基本一致（名字进行修改）<br>activity的java文件保持默认。</p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>安卓</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理笔记（1）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>操作系统原理第一第二章知识点总结</p>
<span id="more"></span>

<h1 id="一、操作系统引论"><a href="#一、操作系统引论" class="headerlink" title="一、操作系统引论"></a>一、操作系统引论</h1><h2 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>方便性</li>
<li>有效性<ul>
<li>提高系统资源利用率</li>
<li>提高系统吞吐量</li>
</ul>
</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>OS作为用户与计算机硬件系统之间的接口<ul>
<li>命令方式</li>
<li>系统调用方式</li>
<li>图标–窗口方式</li>
</ul>
</li>
<li>OS作为计算机系统资源的管理者</li>
<li>OS实现了对计算机资源的抽象</li>
</ul>
<h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><h3 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h3><ul>
<li>人工操作方式<ul>
<li>用户独占全机</li>
<li>CPU等待人工操作</li>
</ul>
</li>
</ul>
<p>人工操作方式严重降低了计算机资源的利用率</p>
<ul>
<li>脱机输入&#x2F;输出(Off–Line I&#x2F;O)方式<ul>
<li>减少了CPU的空闲时间</li>
<li>提高了I&#x2F;O速度</li>
</ul>
</li>
</ul>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ol>
<li>资源利用率高</li>
<li>系统吞吐量大</li>
<li>平均周转时间长</li>
<li>无交互能力</li>
</ol>
<p><strong>宏观并行，微观串行</strong></p>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>特征:</p>
<ol>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
</ol>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>特征:</p>
<ol>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
<li>可靠性</li>
</ol>
<h3 id="集群系统–超算-云计算"><a href="#集群系统–超算-云计算" class="headerlink" title="集群系统–超算~云计算"></a>集群系统–超算~云计算</h3><h3 id="微机操作系统的发展"><a href="#微机操作系统的发展" class="headerlink" title="微机操作系统的发展"></a>微机操作系统的发展</h3><h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><h3 id="并发concurrence"><a href="#并发concurrence" class="headerlink" title="并发concurrence"></a>并发concurrence</h3><ul>
<li>区别并行和并发<ul>
<li>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</li>
<li>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</li>
<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>
</ul>
</li>
<li>引入进程<ul>
<li>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</li>
</ul>
</li>
</ul>
<h3 id="共享sharing"><a href="#共享sharing" class="headerlink" title="共享sharing"></a>共享sharing</h3><ol>
<li>互斥共享方式</li>
<li>同时访问方式</li>
</ol>
<p>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件。</p>
<h3 id="虚拟virtual"><a href="#虚拟virtual" class="headerlink" title="虚拟virtual"></a>虚拟virtual</h3><ol>
<li>时分复用技术<ul>
<li>虚拟处理机技术</li>
<li>虚拟设备技术</li>
</ul>
</li>
<li>空分复用技术</li>
</ol>
<h3 id="异步asynchronism"><a href="#异步asynchronism" class="headerlink" title="异步asynchronism"></a>异步asynchronism</h3><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ul>
<li>进程控制</li>
<li>进程同步<ul>
<li>进程互斥方式</li>
<li>进程同步方式(协同)</li>
</ul>
</li>
<li>进程通信</li>
<li>调度<ul>
<li>作业调度</li>
<li>进程调度</li>
</ul>
</li>
</ul>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><ul>
<li>内存分配<ul>
<li>静态分配</li>
<li>动态分配</li>
</ul>
</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理<ul>
<li>设备处理程序又称设备驱动程序</li>
</ul>
</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读写管理和保护<ul>
<li>根据用户的请求从外存中读取或写入数据</li>
<li>防止系统中的文件被非法窃取和破坏。</li>
</ul>
</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li>用户接口<ul>
<li>联机用户接口（CLI）</li>
<li>脱机用户接口</li>
<li>图形用户接口（GUI）</li>
</ul>
</li>
<li>程序接口</li>
</ul>
<h3 id="现代操作系统的新功能"><a href="#现代操作系统的新功能" class="headerlink" title="现代操作系统的新功能"></a>现代操作系统的新功能</h3><ul>
<li>系统安全</li>
<li>网络的功能和服务</li>
<li>支持多媒体</li>
</ul>
<h2 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ul>
<li>无结构操作系统</li>
<li>模块化OS</li>
<li>分层式结构OS</li>
</ul>
<h3 id="微内核os结构"><a href="#微内核os结构" class="headerlink" title="微内核os结构"></a>微内核os结构</h3><ol>
<li>基本概念:<ul>
<li>足够小的内核</li>
<li>客户&#x2F;服务器模式</li>
<li>机制与策勒分离原理</li>
<li>面对对象的程序设计</li>
</ul>
</li>
<li>微内核基本功能:<ul>
<li>进程（线程）管理</li>
<li>低级储存器管理</li>
<li>中断和陷入处理</li>
</ul>
</li>
<li>微内核优点：<ul>
<li>提高了系统可拓展性</li>
<li>增强了系统的可靠性</li>
<li>提供了对分布式系统的支持</li>
<li>融入面向对象技术</li>
</ul>
</li>
</ol>
<h2 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h2><h3 id="试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。"><a href="#试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。" class="headerlink" title="试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。"></a>试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。</h3><p>答：（1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受<br>的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成<br>截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微妙。<br>（2）交互性：实时信息处理系统具有交互性，但人与系统的交互仅限于访问系统中某<br>些特定的专用服务程序。不像分时系统那样能向终端用户提供数据和资源共享等服务。<br>（3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度<br>的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统<br>中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。</p>
<h3 id="OS有哪几大特征？其最基本的特征是什么？"><a href="#OS有哪几大特征？其最基本的特征是什么？" class="headerlink" title="OS有哪几大特征？其最基本的特征是什么？"></a>OS有哪几大特征？其最基本的特征是什么？</h3><p>答：并发性、共享性、虚拟性和异步性四个基本特征；最基本的特征是并发性。</p>
<h3 id="什么是时分复用技术？举例它能提高资源利用率的根本原因是什么。"><a href="#什么是时分复用技术？举例它能提高资源利用率的根本原因是什么。" class="headerlink" title="什么是时分复用技术？举例它能提高资源利用率的根本原因是什么。"></a>什么是时分复用技术？举例它能提高资源利用率的根本原因是什么。</h3><p>答：时分复用包括虚拟处理机技术和虚拟设备技术。其中虚拟处理机可以将一台物理机虚拟成多台逻辑上的处理机，当一个处理空闲时可以去处理其他逻辑处理机。而虚拟设备技术也是类似的在空闲时间去为其他用户服务。<br>提高效率的根本原因是在一个任务流空闲时可以处理其他任务，充分利用空闲时间，避免设备空负载。</p>
<h3 id="在基于微内核结构的OS中，应用了哪些新技术？"><a href="#在基于微内核结构的OS中，应用了哪些新技术？" class="headerlink" title="在基于微内核结构的OS中，应用了哪些新技术？"></a>在基于微内核结构的OS中，应用了哪些新技术？</h3><p>答：微内核的新技术是：面向对象技术，能降低操作系统的复杂性</p>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>1、为什么要发明计算机系统：方便、有效、可扩充、开放。<br>计算机系统作用：做接口、管理资源、资源的抽象。<br>发展计算机系统的动力：提高利用率、更加方便应用 。<br>2、计算机系统发展史<br>（1）无操作系统<br>①人工操作：单用户、CPU和内存长期空闲。<br>②脱机输入&#x2F;输出（OFF-LINE I&#x2F;0）：装好卡片再上机。目的是节约CPU空闲时间、提高I&#x2F;O速度 。<br> （2）单道批处理操作系统<br>描述：有个监督程序将磁带上的作业调入计算机。<br>缺点：I&#x2F;O太慢，CPU太快 。<br> （3）多道批处理操作系统<br>描述：A在I&#x2F;0，B在CPU。<br>优点：肯定提高资源利用率、系统吞吐量变大。<br>缺点：每个程序都要很久才处理完、无交互能力 。<br>未解难题：内存、外存、I&#x2F;O、CPU、作业管理、接口等之间匹配问题。<br> （4）分时系统<br>描述：解决人机交互问题 。<br>优点：终于有人机交互、多用户共享主机 。<br>实际问题：由于多用户，所以要有“多路卡”、作业直接入内存、有个“时间片”调度作业 。<br>特征：多路、独立、及时（用户可接受）、交互 等特点。<br> （5）实时系统<br>描述：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统 。<br>类型：<br>①周期性实时：按周期时间实时；非周期性实时：有开始截止时间和完成截止时间 。<br>②硬实时：工业系统、武器系统；软实时：信息查询系统和多媒体系统。<br>与分时系统比较： 多路、独立、及时（毫秒级）、交互、可靠。<br>（6）微机时代<br>①单用户单任务：8位机的CP&#x2F;M、16位机的MS-DOS 。<br>②单用户多任务：目前的32位系统，如Windows95 。<br>③多用户多任务：UNIX、Solaris、Linux<br>3、操作系统共同特性：<br>（1）并发<br>①并发和并行宏观上一样，<br>并发：单处理机系统，微观上交替运行<br>并行：多处理机系统，微观上同时运行<br>②引入进程<br>进程：在系统中能独立运行并作为资源分配的基本单位，由机器指令、数据和堆栈等组成，能独立运行的活动实体<br>特点：用进程就可以并发执行了<br>（2）共享<br>①互斥共享方式<br>例子：临界资源，打印机、磁带机<br>描述：你要先申请才能获得资源<br>②同时访问方式<br>描述：微观上还是并发<br>例子：多用户磁盘设备<br>条件：系统允许进程并发、系统能有效管理资源<br>（3）虚拟<br>①时分复用技术<br>虚拟处理机技术：分身之术<br>虚拟设备：又是分身之术，骗用户以为有专人服务<br>时分复用：速度：≤1&#x2F;N<br>②空分复用技术<br>描述：将程序、电话线分成若干部分，然后各部分分时进入内存运行<br>空分复用：空间：≤1&#x2F;N<br>（4）异步<br>描述：因为要并发，所以需要一个机制调度进程<br>4、操作系统主要功能<br>（1）处理机管理功能<br>①控制进程<br>描述：要并发，就要进程、要进程，就要管理<br>②进程同步<br>进程互斥方式：临界资源要互斥<br>进程同步方式：合作完成共同任务，同步机构要协调先后次序<br>③进程通信<br>描述：对合作进程而言，需要交换信息。当他们处于同一计算机系统时，通常采用直接通信的方式。<br>例子：输入进程、计算进程、打印进程，需要信息交换<br>④调度<br>作业调度：选择作业、建立进程、分配资源、插入就绪队列<br>进程调度：从就绪队列中选出进程，分配CPU<br>（2）存储器管理功能<br>①内存分配<br>任务：分配空间、减少碎片、追加内存空间<br>方式：静态分配，装入内存时确定，不允许追加、不允许移动；动态分配，允许追加、允许移动<br>②内存保护<br>任务1：每道程序只在自己的内存空间运行，互不干扰<br>任务2：不允许用户程序访问操作系统程序和数据、也不允许用户程序转移到非共享的其他用户程序中执行<br>③地址映射<br>任务：存储器要负责地址映射，在硬件支持下完成<br>④内存扩充<br>描述：用虚拟存储技术，从逻辑上扩充内存容量<br>任务1：请求-调入功能<br>任务2：置换功能<br> （3）设备管理功能<br>任务1：完成用户进程的I&#x2F;O请求：分配I&#x2F;O设备，完成I&#x2F;O操作<br>任务2：提高CPU和I&#x2F;O利用率：提高I&#x2F;O速度，方便用户使用I&#x2F;O设备<br>①缓冲管理<br>描述：在内存中设置缓冲区<br>例子：单缓冲机制、双向同时传送数据的双缓冲机制、多个设备共同使用的公用“缓冲池”机制<br>②设备分配<br>描述：在系统中设置“设备控制表”、“控制器控制表”等数据结构，用于记录设备和控制器等标识符和状态。根据表就知道指定设备当前是否可用、忙碌。分配时，针对不同设备要有不同“分配方式”，对独占设备还要考虑分配后是否安全<br>③设备处理<br>描述：CPU向设备控制器发出I&#x2F;O命令，要求完成I&#x2F;O操作、反之，CPU接收控制器发出的中断请求，并响应.处理<br>（4）文件管理功能<br>描述：管理用户、系统文件，方便使用；保证安全性<br>①文件储存空间管理<br>背景：多用户环境下，用户自己管理文件存储，会困难和低效<br>任务1：为每个文件分配外存空间、提高外存利用率、进而提高存取速度<br>任务2：系统中设置数据结构，记录文件存储空间使用情况，以供分配时参考<br>任务3：分配和回收<br>②目录管理<br>任务1：为每个文件建立目录项，包括文件名、属性、物理位置等，以实现按名存取<br>任务2：实现文件共享。<br>任务3：提供目录查询手段<br>③文件读&#x2F;写管理和保护<br>文件读&#x2F;写管理：根据用户请求，从外存中读取数据，或将数据写入外存<br>文件保护：防止未经核准的用户存取文件、防止冒名顶替存取文件、防止以不正确方式使用文件<br> （5）操作系统与用户之间的接口<br>①用户接口<br>描述：方便用户直接.间接控制自己的作业<br>联机用户接口：等待用户键入命令<br>脱机用户接口：一开始就提供作业说明书，直到作业结束语句<br>图形用户接口：移动鼠标选择菜单项<br>②程序接口<br>描述：旧系统用汇编语言写，所以只有汇编语言的才能直接使用系统调用；如果是高级语言，就用一一对应的库函数<br> （6）现代操作系统的新功能<br>①系统安全<br>描述：确保存储和传送数据的保密性、完整性和系统可用性，要用几种技术<br>技术：认证技术、密码技术、访问控制技术、反病毒技术<br>②网络的功能和服务<br>功能：网络通信、资源管理、应用互操作<br>③支持多媒体<br>功能：接纳控制功能、实时调度、多媒体文件的存储<br>5、OS结构设计<br>（1）传统操作系统结构<br>①无结构操作系统<br>又名：整体系统结构<br>②模块化结构OS<br>基本概念：<br>又名：模块-接口法<br>描述：有模块、子模块、接口<br>模块独立性：<br>标准：内聚性越高，模块独立性越高、耦合度越低，模块独立性越高<br>优点：提高设计正确性.可理解性和可维护性、增强可适应性、加快加速过程<br>缺点：接口难以满足需求、无序<br>③分层式结构OS<br>基本概念：有序分层，自底向上法铺设中间层<br>优点：易保证系统正确性、易扩充和易维护<br>缺点：系统效率降低<br>（2）客户&#x2F;服务器模式(Client&#x2F;Server Model)简介<br>①客户&#x2F;服务器模式的由来、组成和类型<br>组成：客户机、服务器、网络系统<br>②客户&#x2F;服务器之间的交互<br>描述：客户发送请求消息、服务器接收消息、服务器回送消息、客户机接收消息<br>③客户&#x2F;服务器模式的优点<br>描述：数据分布处理和存储、便于集中管理、灵活性和可扩充性、易于改编应用软件<br>（3）面向对象的程序设计<br>①OOP的基本概念<br>描述：抽象，具体事物为对象<br>对象：封装好<br>对象类：创建多个相似对象<br>继承：继承父类，增加部分<br>②OOP的优点<br>描述：“重用”提高产品质量和生产率、使系统具有更好的易修改性和易扩展性、易于保证系统“正确性”和“可靠性”<br>（4）微内核OS结构<br>描述：支持多处理机<br>例子：卡内基·梅隆的Mach OS、Windows 2000&#x2F;XP<br>①基本概念<br>描述：足够小的内核、基于C&#x2F;S模式、应用“机制与策略分离”原理、采用OOP技术<br>②基本功能<br>描述：进程管理、低级存储器管理、中断和陷入处理<br>③优点<br>描述：提高可扩展性、增强可靠性、可移植性强、提供对分布式系统的支持、融入OOP<br>④缺点<br>描述：效率降低  </p>
<h1 id="二、进程的描述与控制"><a href="#二、进程的描述与控制" class="headerlink" title="二、进程的描述与控制"></a>二、进程的描述与控制</h1><h2 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><p>前趋图（Precedence Graph）是指一个有向无循环图，可记为DAG（Directed Acyclic Graph），它用于描述进程之间执行的先后顺序</p>
<h3 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h3><ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h3 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h3><p>特征：</p>
<ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ul>
<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
<h3 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h3><ul>
<li>进程的三种基本状态<ul>
<li>就绪状态ready</li>
<li>执行状态running</li>
<li>阻塞状态block</li>
</ul>
</li>
<li>三种基本状态的转换</li>
<li>创建状态和终止状态<ul>
<li>五种基础状态及转换</li>
</ul>
</li>
<li>注意<ul>
<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>
</ul>
</li>
</ul>
<h3 id="挂起操作和进程状态的转换"><a href="#挂起操作和进程状态的转换" class="headerlink" title="挂起操作和进程状态的转换"></a>挂起操作和进程状态的转换</h3><ul>
<li>挂起操作的目的<ul>
<li>终端用户的需要: 修改、检查进程</li>
<li>父进程的需要：修改、协调子进程</li>
<li>负荷调节的需要：缓和系统中的负荷，保证系统正常运行</li>
<li>操作系统的需要：检查和记录运行中的资源使用情况</li>
</ul>
</li>
<li>挂起原语操作后三个进程状态的转换<ul>
<li>活动就绪Readya-&gt;静止就绪Readys，处于Readys状态的进程不再被调度</li>
<li>活动堵塞Blockeda-&gt;静止堵塞Blockeds，所期待的事件出现后，将会从静止堵塞转为静止就绪</li>
<li>静止就绪-&gt;活动就绪，Readys状态用激活原语Active激活后转变为Readya状态</li>
<li>静止堵塞-&gt;活动堵塞，同样使用Active能让Blockeds转变为Blockeda</li>
</ul>
</li>
</ul>
<h3 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a>进程管理中的数据结构</h3><ul>
<li>进程控制块PCB的作用<ul>
<li>作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步与通</li>
</ul>
</li>
<li>进程控制块的信息<ul>
<li>进程标识符<ul>
<li>外部标识符PID</li>
<li>内部标识符(端口)</li>
</ul>
</li>
<li>处理机状态<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW</li>
<li>用户栈指针</li>
</ul>
</li>
<li>进程调度信息<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>进程调度所需的其他信息</li>
<li>事件</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>程序和数据的地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
<li>进程控制块的组织方式<ul>
<li>线性方式</li>
<li>链接方式</li>
<li>索引方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ul>
<li>两大功能<ul>
<li>支撑功能<ul>
<li>中断管理</li>
<li>时钟管理</li>
<li>原语操作</li>
</ul>
</li>
<li>资源管理功能<ul>
<li>进程管理：进程的调度和分派、创建和撤销、进程同步的原语等</li>
<li>存储器管理：用户空间的逻辑地址转为物理地址、内存分配和回收、内存保护和对换等</li>
<li>设备管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ul>
<li>进程的层次结构<ul>
<li>父进程</li>
<li>子进程</li>
</ul>
</li>
<li>引起创建进程的事件<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
</li>
<li>进程的创建过程<ol>
<li>申请空白PCB</li>
<li>为新进程分配其运行所需的资源</li>
<li>初始化进程块PCB</li>
<li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>
</ol>
</li>
</ul>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ul>
<li>引起进程终止的事件<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
<li>进程的终止过程<ol>
<li>根据被终止进程的标识符，从该进程的PCB读出进程的状态</li>
<li>若被终止进程处于执行状态应立刻终止该进程执行，将调度标志置真，用于该进程重新调度</li>
<li>若该进程还有子孙进程，将所有子孙进程也终止</li>
<li>将被终止的进程所拥有的全部资源归还给父进程或者系统</li>
<li>被终止的进程（PCB）从所在队列或链表中移出，等待其他程序来收集信息</li>
</ol>
</li>
</ul>
<h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><ul>
<li>引起进程阻塞和唤醒的事件<ul>
<li>向系统请求共享资源失败</li>
<li>等待某种操作完成</li>
<li>新数据尚未到达</li>
<li>等待新任务到达</li>
</ul>
</li>
<li>进程阻塞过程(自己阻塞自己)</li>
<li>进程唤醒过程(系统或其他进程唤醒自己)</li>
</ul>
<h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><ul>
<li>suspend</li>
<li>active</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>两种形式的制约关系<ul>
<li>间接相互制约关系：互斥——竞争</li>
<li>直接相互制约关系：同步——协作</li>
</ul>
</li>
<li>临界资源</li>
<li>访问临界资源进程顺序<ol>
<li>进入区enter section</li>
<li>临界区critical section</li>
<li>退出区exit section</li>
<li>剩余区remainder section</li>
</ol>
</li>
<li>同步机制应遵循的规则<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
</ul>
<h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><ul>
<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>
<li>硬件同步机制<ul>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用swap指令实现进程互斥</li>
</ul>
</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul>
<li>整型信号量</li>
<li>记录型信号量<blockquote>
<p>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</p>
</blockquote>
</li>
<li>AND型信号量</li>
<li>信号量集</li>
</ul>
<h3 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h3><ul>
<li>利用信号量进行进程互斥</li>
<li>利用信号量实现前趋关系</li>
</ul>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><ul>
<li>定义：一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。</li>
<li>组成：<ul>
<li>管程名称</li>
<li>局部于管程的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
</ul>
</li>
<li>条件变量</li>
</ul>
<h3 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h3><ul>
<li>生产者–消费者问题</li>
<li>哲学家进餐问题</li>
<li>读者–写者问题</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信是指进程之间的信息交换，又称低级进程通信。<br>OS提高的高级通信工具特点：</p>
<ol>
<li>使用方便</li>
<li>高效地传送大量数据</li>
</ol>
<h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><ul>
<li>共享存储器系统<ul>
<li>基于共享数据结构的通信方式，比如：生产者和消费者。通信效率底下，属于低级通信</li>
<li>基于共享存储区的通信方式，数据形式和位置甚至访问控制由进程负责，属于高级通信</li>
</ul>
</li>
<li>管道通信系统(pipe)</li>
<li>消息传递系统<ul>
<li>直接通信方式，利用OS提供的原语</li>
<li>间接通信方式，通过共享中间实体的方式发送和接收</li>
</ul>
</li>
<li>客服机–服务器系统<ul>
<li>套接字（Socket）</li>
<li>远程方法调用（Remote Procedure Call-RPC）</li>
</ul>
</li>
</ul>
<h3 id="消息传递通信的实现方式"><a href="#消息传递通信的实现方式" class="headerlink" title="消息传递通信的实现方式"></a>消息传递通信的实现方式</h3><ul>
<li>直接消息传递系统<ul>
<li>直接通信原语<ol>
<li>对称寻址方式</li>
<li>非对称寻址方式</li>
</ol>
</li>
<li>消息的格式</li>
<li>进程的同步方式</li>
<li>通信链路<ol>
<li>单向通信链路，只允许进程向接收进程发送信息</li>
<li>双向通信链路</li>
</ol>
</li>
</ul>
</li>
<li>信箱通信<ul>
<li>信箱结构：由信箱头和信箱体组成</li>
<li>信箱的类型：<ul>
<li>私用信箱：进程创建，拥有者可以读信息，其他用户只能发送到该信箱</li>
<li>公用信箱：操作系统创建，提供给系统中核准进程使用</li>
<li>共享信箱：进程创建，可指出共享进程的名字，拥有者和共享者都可以读信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><ul>
<li>线程的引入正是为了减少程序在并发执行时所付出的时空开销，提高OS的并发性</li>
<li>进程的两个基本属性<ul>
<li>一个拥有资源的独立单位，可独立分配系统资源</li>
<li>一个可独立调度和分派的基本单位，PCB</li>
</ul>
</li>
<li>程序并发执行所需付出的时空开销<ul>
<li>创建进程</li>
<li>撤销进程</li>
<li>进程切换</li>
</ul>
</li>
<li>线程——作为调度和分派的基本单位<ul>
<li>进程是系统资源分配的单位，线程是处理器调度的单位</li>
<li>线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应</li>
<li>进程分解为线程还可以有效利用多处理器和多核计算机</li>
</ul>
</li>
</ul>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><ul>
<li>不同点<ul>
<li>调度的基本单位</li>
<li>并发性</li>
</ul>
</li>
<li>相似点<ul>
<li>状态：运行、阻塞、就绪</li>
<li>线程具有一定的生命期</li>
<li>进程可创建线程，一个线程可创建另一个子线程</li>
<li>多个线程并发执行时仍然存在互斥与同步</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul>
<li>线程的实现方式<ul>
<li>内核支持线程KST</li>
<li>用户级线程ULT</li>
<li>组合方式</li>
</ul>
</li>
<li>多线程OS中的进程属性<ul>
<li>进程是一个可拥有资源的基本单位</li>
<li>多个线程可并发执行</li>
<li>进程已不是可执行的实体</li>
</ul>
</li>
<li>线程的状态和线程控制块<ul>
<li>线程运行的三个状态<ul>
<li>执行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
</ul>
</li>
<li>线程控制块TCB</li>
</ul>
</li>
</ul>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="在操作系统中为什么要引入进程概念？它会产生什么样的影响"><a href="#在操作系统中为什么要引入进程概念？它会产生什么样的影响" class="headerlink" title="在操作系统中为什么要引入进程概念？它会产生什么样的影响?"></a>在操作系统中为什么要引入进程概念？它会产生什么样的影响?</h3><p>答：为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程概念。<br>影响: 使程序的并发执行得以实行。</p>
<h3 id="试说明PCB-的作用，为什么说PCB-是进程存在的惟一标志？"><a href="#试说明PCB-的作用，为什么说PCB-是进程存在的惟一标志？" class="headerlink" title="试说明PCB 的作用，为什么说PCB 是进程存在的惟一标志？"></a>试说明PCB 的作用，为什么说PCB 是进程存在的惟一标志？</h3><p>答：PCB 是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。OS是根据PCB对并发执行的进程进行控制和管理的。</p>
<h3 id="为什么要在OS-中引入线程？"><a href="#为什么要在OS-中引入线程？" class="headerlink" title="为什么要在OS 中引入线程？"></a>为什么要在OS 中引入线程？</h3><p>答：在操作系统中引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性，提高CPU的利用率。进程是分配资源的基本单位,而线程则是系统调度的基本单位。</p>
<h3 id="试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。"><a href="#试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。" class="headerlink" title="试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。"></a>试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较。</h3><p>答：<br>（1）调度性。线程在OS 中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。<br>（2）并发性。进程可以并发执行，一个进程的多个线程也可并发执行。<br>（3）拥有资源。进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源，本<br>身基本不拥有系统资源，但可以访问隶属进程的资源。<br>（4）系统开销。操作系统在创建、撤消和切换进程时付出的开销显著大于线程。</p>
<h2 id="简答题-1"><a href="#简答题-1" class="headerlink" title="简答题"></a>简答题</h2><p>1、前趋图与程序执行<br>（1）前趋图与程序执行<br>（一）前趋图<br>描述：前一个做完，才到后一个做、禁止循环  </p>
<p>（1）顺序执行<br>描述：一个跟一个<br>特征：顺序、封闭（独占资源）、可再现  </p>
<p>（3）并发执行<br>描述：互不依赖才能并发执行<br>特征：间断、失去封闭、不可再现  </p>
<p>2、进程的描述<br>（1）进程的定义和特征<br>进程实体：程序段、相关的数据段和PCB<br>定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位<br>特征：动态、并发、独立、异步  </p>
<p>（2）进程的基本状态及转换<br>进程的三基态：就绪（只欠CPU）、执行、阻塞（因故无法继续执行）<br>三态转换：如图<br>新增两态：创建状态、终止状态<br>五态转换：如图  </p>
<p>（3）挂起操作和进程状态的转换<br>挂起原因：终端用户需要、父进程请求、负荷调节、操作系统需要<br>引入挂起后的三态转换：如图<br>引入挂起后的五态转换：如图  </p>
<p>（4）进程管理中的数据结构<br>用于管理控制的数据结构：每个资源、进程都有一个数据结构用于表征实体——资源信息表、进程信息表，包括：标识、描述、状态等和一批指针，通过指针能够链接成队列，便于查找<br>分类：内存表、设备表、文件表、进程表<br>PCB的作用：作为独立运行基本单位的标识、能实现间断运行、提供进程管理所需的信息、实现与其他进程的同步与通信<br>PCB的信息：进程标识符（内外部）、处理机状态、进程调度信息、进程控制信息<br>PCB组织方式：线性方式、链接方式、索引方式  </p>
<p>3、进程控制<br>（1）操作系统内核<br>描述：常驻内存的模块<br>目的：保护软件、提高OS运行效率<br>系统态、管态、内核态：高特权、访问所有寄存器.存储区、传统OS都在系统态运行<br>用户态、目态：低特权、执行指定指令.访问指定寄存器和存储区<br>支撑功能：中断处理、时钟管理、原语操作<br>资源管理功能：进程管理、存储器管理、设备管理  </p>
<p>（2）进程的创建<br>层次结构：UNIX有父子关系，Windows只有控制与被控制关系<br>进程图：描述家庭关系的图<br>引起创建进程的事件：用户登录、作业调度、提供服务（譬如打印）、应用请求<br>进程的创建：申请空白PCB、分配物理.逻辑资源、初始化PCB、如果能插入就绪，就插  </p>
<p>（3）进程的终止<br>引起进程终止的事件：正常结束、异常结束、外界干预<br>进程的终止过程：根据标识符、终止执行.立即调度、子孙终止、资源归还、移出队列  </p>
<p>（4）进程的阻塞与唤醒<br>引起进程阻塞和唤醒的事件：向系统请求共享资源失败、等待某操作完成、新数据尚未到达、等待新任务到达<br>进行阻塞过程：发生上述的某事件，就进入block过程，主动将状态改为阻塞，PCB插入阻塞队列（分类插入），处理机分配给另一就绪进程，切换，并保留被阻塞进程的处理机状态<br>进程唤醒过程：由释放资源的进程调用wakeup原语，即移出阻塞队列，合作&#x2F;相关的进程中安排wakeup  </p>
<p>（5）进程的挂起与激活<br>进程的挂起：活动→静止，进程正在执行，就转向调度程序重新调度<br>进程的激活过程：从外存调入active原语到内存，检查进程现行状态，静止→活动<br>抢占调度策略：静止就绪进程→就绪队列，比较当前进程优先度，有机会立即剥夺当前进程运行  </p>
<p>4、进程同步<br>描述：能够并发、改善利用率、提高吞吐量、但使系统复杂<br>（1）进程同步的基本概念<br>制约关系：间接相互制约关系、直接相互制约关系<br>间接相互制约关系：互斥共享<br>直接相互制约关系：合作共享，异步性要做好<br>临界资源：生产者-消费者问题、<br>临界区、：进入区、临界区、退出区、剩余区<br>同步机制应遵循的规则：空闲让进、忙则等待、有限等待、让权等待  </p>
<p>（2）硬件同步机制<br>关中断：缺点多：滥用关中断.造成严重后果、关中断时间过长、不适用于多CPU系统（因为一个处理器关中断并不能防止进程在其他处理器上执行相同的临界段代码）<br>Test-and-Set：不断测试lock，如果是FALSE，就进入临界区，并lock &#x3D;&#x3D; TRUE；否则测试到TS(s) &#x3D;&#x3D; TRUE<br>Swap指令：一直等，直到key &#x3D;&#x3D; TRUE<br>但以上都不符合“让权等待”原则  </p>
<p>（3）信号量机制<br>整形信号量：S≤0，就一直等，直到释放互斥资源<br>记录型信号量：整形信号量不符合“让权等待”原则。如果有资源，就分配，如果无，就插入阻塞队列；释放资源，如果有等待，就激活<br>AND型信号量：一口气全分配<br>信号量集：有多个信号量（S信号量,至少要t个,每次分配d个）  </p>
<p>（4）信号量的应用<br>利用信号量实现进程互斥：mutex &#x3D; ( -1, 0, 1）&#x3D; （无，一临一阻队， 一临一信队）<br>利用信号量实现前趋关系：需要的信号量被占用了，就这样实现  </p>
<p>（5）管程机制<br>描述：为解决信号量机制分散、容易死锁的问题，发明新同步工具——管程<br>定义：定义一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据<br>组成：管程名称、数据结构的说明、对数据结构进行操作的过程、初始化的语句<br>特性：模块化、抽象数据类型、信息掩蔽<br>管程与进程不同：都有数据结构，一个公.一个私、管程操作同步.初始化.进程顺序执行、管程为解决互斥资源.进程实现并发性、进程调用管程.进程主动.管程被动、管程不能并发.进程能并发、管程是OS的一个资源管理模块.进程有动态性<br>条件变量：增加一个条件变量，万一发生意外，在管程中被挂起或被阻塞，下一个进程都可以继续执行  </p>
<p>5、经典进程的同步问题<br>（1）生产者-消费者问题<br>记录型信号量解决：如果缓冲区空，而且能够获取信号量，就投放产品；如果缓冲区有产品，而且能够获取信号量，就消费<br>AND信号量解决：一口气全分配<br>管程解决：利用管程只有一个进程能够使用的属性  </p>
<p>（2）哲学家进餐问题<br>记录型信号量解决：先拿左.后那右、先放左.后放右<br>解决死锁：最多4人取筷子、先检查.有左右筷子才能取、奇左右.偶右左<br>AND信号量解决：一口气全分配  </p>
<p>（3）读者-写者问题<br>描述：可以多读一、一旦开始写.就不能读或写<br>记录型信号量解决：<br>读操作：等rmutex就是为了改readcount→无人读？看看是否在写.等wmutex→readcount++→自增完成.rmutex还你→读读读→等rmutex为了自减readcount→无人读？可以写了.还你wmutex<br>写操作：等wmutex.即无读无写→写完.还你wmutex<br>利用信号量集机制：<br>读：限制reader个数→如果mx是1.就读→最后释放一个reader个数<br>写：如果mx是1.并且读者数为0.就写→写完释放mx  </p>
<p>6、进程通信<br>（1）进程通信类型<br>共享存储器系统：某些数据结构和共享存储区、管道通信系统、消息传递系统、C-S系统  </p>
<p>（2）消息传递通信的实现方式<br>①直接消息传递系统<br>1）直接通信原语：对称寻址方式、非对称寻址方式<br>2）消息格式：较短的减少系统处理和存储的开销、较长可以方便<br>3）进程同步方式：发塞收塞（进程间紧密同步.无缓冲）、发通收塞（平常状态）、发通收通（发生某事件无法继续运行）、（无发塞收通）<br>4）通信链路：用“建立连接”原语建立通信链路.用完拆、用“发送命令”原语建立链路，还分单向和双向<br>②信箱通信（间接）<br>1）定义：是数据结构.分信箱头和信箱体<br>2）原语：创建和撤销. 发送和接收<br>3）类型：私用、公用（操作系统创建）、共享（进程创建）<br>4）进程之间的关系：一对一、多对一、一对多、多对多  </p>
<p>（3）直接消息传递系统实例<br>消息缓冲队列通信机制中的数据结构：利用数据结构式消息缓冲区、在PCB增加有关通信的数据项<br>原语：设置发送区、申请PCB(B)的缓冲区i、复制到缓冲区、插入消息队列、移出消息队列、复制到接收区、释放缓冲区  </p>
<p>7、线程的基本概念<br>描述：就是为了提高程序并发执行的程度<br>（1）线程的引入<br>进程的两个基本属性：进程是一个可拥有资源的独立单位、进程同时是一个可独立调度和分派的基本单位<br>进程并发执行所需的时空开销：创建进程、撤销进程、进程切换<br>线程——作为调度和分派的基本单位：线程轻装上阵  </p>
<p>（2）线程与进程比较<br>调度的基本单位：线程是调度和分派的基本单位、跨进程，会切换进程<br>并发性：线程的合作.能够并发<br>拥有资源：有TCB.但只是必不可少、保证独立运行的资源<br>独立性：同一进程的不同线程共享进程的内存地址空间和资源<br>系统开销：因为轻装.所以减少开销、提升速度<br>支持多处理机系统：对多线程进程，多个线程可以分配到多个处理机上  </p>
<p>（3）线程的状态和线程控制块<br>线程运行的三个状态：和进程一样<br>线程控制块TCB：标识符、一组寄存器、运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针<br>多线程OS中的进程属性：进程是可拥有资源的基本单位、多个线程可并发执行、进程已不是可执行的实体  </p>
<p>8、线程的实现<br>（1）线程的实现方式<br>内核支持线程KLT：<br>优点：内核调度同一进程多个线程并行执行、一个线程阻塞.其他线程占有处理机、支持小数据结构和堆栈.切换较快开销小、内核本身采用多线程技术.提高系统执行速度和效率<br>用户级线程ULT：<br>优点：无需内核.节省模式切换的开销、调度算法进程专用、与OS无关.甚至可以在操作系统平台实现<br>缺点：一个线程阻塞.同进程的其他线程都会塞、只有一个CPU.只有一个线程能执行、按进程分配.不公平<br>组合方式：<br>多对一模型：优点：开销小、缺点：一塞进程全塞、只有一线程访问内核、多线程不能同时在多个处理机上运行<br>一对一模型：一个用户级线程映射到一个内核支持线程<br>多对多模型：一对一和多对一的结合  </p>
<p>（2）线程的实现<br>内核支持线程的实现：创建线程、保存信息、调度和切换线程、撤销线程、回收资源<br>用户级线程的实现：<br>运行时系统：用于管理和控制线程的函数的集合，这些函数驻留用户空间.并作为用户级线程与内核之间的接口<br>内核控制线程：连接到LWP，连接到LWP的线程才能与内核通信  </p>
<p>（3）线程的创建和终止<br>线程的创建：初始化线程、创建后返回线程标识符<br>线程的终止：终止线程用函数或系统调用终止操作.但有些线程被建立就会一直执行。大多数OS，线程被中止后并不立即释放所占资源，只有“其他线程”执行分离函数才会分离资源，才能被其他线程利用。虽然未释放的资源也可以被其他线程使用，但要有个“等待线程终止”的连接命令作保险.否则一直阻塞  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理笔记（3）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<p>操作系统第五第六章知识点总结</p>
<span id="more"></span>

<h1 id="第五章：虚拟存储器"><a href="#第五章：虚拟存储器" class="headerlink" title="第五章：虚拟存储器"></a>第五章：虚拟存储器</h1><h2 id="虚拟储存器概述"><a href="#虚拟储存器概述" class="headerlink" title="虚拟储存器概述"></a>虚拟储存器概述</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>一次性：指必须一次性全部装入内存，</li>
<li>驻留性：指作业被装入内存后，整个作业都会一直驻留在内存中，不会换出任何部分<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。表现为：</li>
<li>时间局限性<ul>
<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>
</ul>
</li>
<li>空间局限性<ul>
<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p>
<h2 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h2><ul>
<li>多次性<ul>
<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>
</ul>
</li>
<li>对换性<ul>
<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>
</ul>
</li>
<li>虚拟性<ul>
<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>
</ul>
</li>
</ul>
<h2 id="虚拟存储器的实现方式"><a href="#虚拟存储器的实现方式" class="headerlink" title="虚拟存储器的实现方式"></a>虚拟存储器的实现方式</h2><h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><ul>
<li>硬件<ul>
<li>请求页表机制<ul>
<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>
</ul>
</li>
<li>缺页中断机构</li>
<li>地址变换机构（过程图很关键）</li>
</ul>
</li>
</ul>
<h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><ul>
<li>最小物理块数<ul>
<li>即能保证进程正常运行所需的最小物理块数</li>
</ul>
</li>
<li>内存分配策略<ul>
<li>固定分配局部置换：</li>
<li>可变分配全局置换：</li>
<li>可变分配局部置换：</li>
</ul>
</li>
<li>物理块分配算法<ul>
<li>平均分配算法</li>
<li>按比例分配算法</li>
<li>考虑优先权的分配算法</li>
</ul>
</li>
</ul>
<h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><ul>
<li>系统应在何时调入所需页面<ul>
<li>预调页策略（不能实现）</li>
<li>请求调页策略（需要才给）</li>
</ul>
</li>
<li>系统应该从何处调入这些页面<ul>
<li>对换区</li>
<li>文件区</li>
<li>UNIX方式</li>
</ul>
</li>
<li>页面调入过程（重点）</li>
<li>缺页率（出计算题）：f &#x3D; F &#x2F; A<blockquote>
<p>访问页面成功次数为S，访问失败为F，总页面访问次数为A &#x3D; S + F</p>
</blockquote>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><p>需要预知后面进程需要用到的页面，所以不能实现</p>
<h3 id="先进先出页面置换算法（FIFO）"><a href="#先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h3><p>选择在内存中驻留时间最久的页面予以淘汰</p>
<h3 id="最近最久未使用置换算法（LRU）Recently"><a href="#最近最久未使用置换算法（LRU）Recently" class="headerlink" title="最近最久未使用置换算法（LRU）Recently"></a>最近最久未使用置换算法（LRU）Recently</h3><ul>
<li>寄存器支持</li>
<li>特殊的栈结构<h3 id="最少使用置换算法（LFU）Frequently"><a href="#最少使用置换算法（LFU）Frequently" class="headerlink" title="最少使用置换算法（LFU）Frequently"></a>最少使用置换算法（LFU）Frequently</h3><h3 id="clock置换算法（对访问位A的判断）"><a href="#clock置换算法（对访问位A的判断）" class="headerlink" title="clock置换算法（对访问位A的判断）"></a>clock置换算法（对访问位A的判断）</h3></li>
<li>改进型——增加对修改位M思维判断<h3 id="页面缓冲算法（PBA-page-buffering-algorithm）"><a href="#页面缓冲算法（PBA-page-buffering-algorithm）" class="headerlink" title="页面缓冲算法（PBA,page buffering algorithm）"></a>页面缓冲算法（PBA,page buffering algorithm）</h3></li>
<li>空闲页面链表</li>
<li>修改页面链表</li>
</ul>
<h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="抖动的概念"><a href="#抖动的概念" class="headerlink" title="抖动的概念"></a>抖动的概念</h3><p>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</p>
<h3 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h3><ul>
<li>硬件支持<ul>
<li>请求分段的段表机构</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
</ul>
<h2 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h2><h3 id="实现虚拟存储器需要哪几个关键技术？"><a href="#实现虚拟存储器需要哪几个关键技术？" class="headerlink" title="实现虚拟存储器需要哪几个关键技术？"></a>实现虚拟存储器需要哪几个关键技术？</h3><p>（1）在分页请求系统中是在分页的基础上，增加了请求调页功能和页面置换功能所形成的<br>页式虚拟存储系统。允许只装入少数页面的程序（及数据），便启动运行。<br>（2）在请求分段系统中是在分段系统的基础上，增加了请求调段及分段置换功能后形成的<br>段式虚拟存储系统。允许只装入少数段（而非所有段）的用户程序和数据，即可启动运行。</p>
<h3 id="在一个请求分页系统中，采用LRU-页面置换算法时，假如一个作业的页面走向为4-3-2-1-4-3-5-4-3-2-1-5，当分配给该作业的物理块数M分别为3和4时，试计算访问过程中所发生的缺页次数和缺页率-比较所得结果"><a href="#在一个请求分页系统中，采用LRU-页面置换算法时，假如一个作业的页面走向为4-3-2-1-4-3-5-4-3-2-1-5，当分配给该作业的物理块数M分别为3和4时，试计算访问过程中所发生的缺页次数和缺页率-比较所得结果" class="headerlink" title="在一个请求分页系统中，采用LRU 页面置换算法时，假如一个作业的页面走向为4 , 3 , 2 ,1 , 4 , 3 , 5 , 4 ,3 , 2 , 1 ,5，当分配给该作业的物理块数M分别为3和4时，试计算访问过程中所发生的缺页次数和缺页率 ? 比较所得结果?"></a>在一个请求分页系统中，采用LRU 页面置换算法时，假如一个作业的页面走向为4 , 3 , 2 ,1 , 4 , 3 , 5 , 4 ,3 , 2 , 1 ,5，当分配给该作业的物理块数M分别为3和4时，试计算访问过程中所发生的缺页次数和缺页率 ? 比较所得结果?</h3><p>答：当分配给该作业的物理块数M为3时，缺页9次，缺页率: 9&#x2F;12&#x3D;3&#x2F;4；<br>当分配给该作业的物理块数M为4时，缺页10次，缺页率: 10&#x2F;12&#x3D;5&#x2F;6.</p>
<h3 id="页面缓冲算法的主要特点是什么？如何降低页面换进、换出频率的"><a href="#页面缓冲算法的主要特点是什么？如何降低页面换进、换出频率的" class="headerlink" title="页面缓冲算法的主要特点是什么？如何降低页面换进、换出频率的"></a>页面缓冲算法的主要特点是什么？如何降低页面换进、换出频率的</h3><p>主要特点：1显著地降低了页面换进、换出的频率,使磁盘I&#x2F;O的操作次数大为减少,因而减少了页面换进、换出的开销;2正是由于换入换出的开销大幅度减小,才能使其采用一种较简单的置换策略。<br>需要内存中设置了如下两个链表: 一个是空闲页面链表，实际上该链表是一个空闲物理块链表,是系统掌握的空闲物理块,用于分配给频繁发生缺页的进程,以降低该进程的缺页率。当这样的进程需要读入一个页面时,便可利用空闲物理块链表中的第一个物理块来装入该页。当有一个未被修改的页要换出时,实际上并不将它换出到外存,而是把它们所在的物理块挂在空闲链表的末尾。 另一个是修改页面链表，它是由已修改的页面所形成的链表。设置该链表的目的是为了减少已修改页面换出的次数。当进程需要将一个已修改的页面换出时,系统并不立即把它换出到外存上,而是将它所在的物理块挂在修改页面链表的末尾。这样做的目的是:降低将已修该页面写回磁盘的频率,降低将磁盘内容读入内存的频率。</p>
<h2 id="简答题、阐述题"><a href="#简答题、阐述题" class="headerlink" title="简答题、阐述题"></a>简答题、阐述题</h2><p>1、虚拟存储器概述<br>（1）常规存储管理方式的特征和局部性原理<br>①常规存储管理方式的特征<br>传统：一次性、驻留性<br>②局部性原理<br>绝大部分顺序执行、调用进度不超过5、循环结构由少数指令构成.但多次执行、多对数据结构的处理.这些处理局限于很小的部分<br>时间、空间局限性<br>③虚拟存储器的基本工作情况<br>将少数页面或段先装入内存即可运行<br>（2）虚拟存储器的定义和特征<br>①虚拟存储器的定义<br>有请求调入功能和置换功能.能逻辑上对内存内容加以扩充的一种存储器系统<br>②虚拟存储器的特征<br>多次性、对换性、虚拟性<br>（3）虚拟存储器的实现方式<br>①分页请求系统<br>硬件支持：请求分页的页表机制、缺页中断机制、地址变换机制<br>实现请求分页的软件<br>②请求分段系统<br>硬件支持：请求分段的段表机制、缺段中断机构、地址变换机构<br>软件支持  </p>
<p>2、请求分页存储管理方式<br>（1）请求分页中的硬件支持<br>①请求页表机制<br>②缺页中断机构<br>③地址变换机构<br>（2）请求分页中的内存分配<br>①最小物理块数的确定<br>②内存分配策略<br>策略：固定分配局部置换、可变分配全局置换、可变分配局部置换<br>③物理块分配算法<br>算法：平均分配算法、按比例分配算法、考虑优先权的分配算法<br>（3）页面调入策略<br>①何时调入页面<br>预调页策略：手动指出哪些页要调入内存、成功率偏低<br>请求调页策略：一次调入一页.须较大系统开销<br>②从何处调入页面<br>系统拥有足够的对换区空间：进程进行前就把进程相关的文件拷贝到对换区<br>系统缺少足够的对换区空间：未修改过的不到对换区.以后要用再从文件区调入<br>UNIX方式：从文件区入.出到对换区、允许页面共享<br>③页面调入过程<br>？？？<br>④缺页率<br>？？？  </p>
<p>3、页面置换算法<br>抖动：一个进程在运行中把大部分时间都花费在页面置换工作上<br>（1）最佳置换算法和先进先出置换算法<br>①最佳置换算法<br>要知道未来需要哪页.实际上不可能<br>②先进先出页面置换算法<br>剔走最老的页<br>（2）最近最久未使用和最少使用置换算法<br>①最近最久未使用<br>看最近的n个，最老的踢走<br>②LRU置换算法的硬件支持<br>寄存器： 8位寄存器.R7~R0.R值最小的页被踢出<br>栈：最新访问的是栈顶<br>③最少使用置换算法<br>现实使用这个多.一旦访问就在最高位置一<br>（3）Clock置换算法<br>①简单的CLOCK置换算法<br>也叫最近未使用算法.就是有个访问位，1→0→换出<br>②改进型CLOCK置换算法<br>四类：A M &#x3D; 0 0 ~ 1 1<br>第一步：先找 0 0<br>第二步：再找 0 1，并置所有页0 X<br>第三步：再找0 0，最后找0 1，一定找到<br>优点：减少I&#x2F;O<br>缺点：增加系统开销<br>（4）页面缓冲算法<br>①影响页面换进换出效率的若干因素<br>页面置换算法、写回磁盘的频率、读入内存的频率<br>②页面缓冲算法PBA<br>显著降低页面换进、换出频率，减少页面换进换出的开销<br>换入换出的开销大幅减少，才能使用简单的置换策略，如FIFO<br>要在内存中设置：空闲页面链表、修改页面链表<br>（5）访问内存的有效时间<br>如果考虑快表的命中率和缺页率：EAT &#x3D; …….<br>如果仅考虑缺页率：EAT &#x3D;   </p>
<p>4、“抖动”与工作集<br>（1）多道程序度与“抖动”<br>①现象<br>先增后减<br>②原因<br>进程太多，物理块不够分<br>（2）工作集<br>①工作集的基本概念<br>如果可以预知，就可以先调入内存，大大降低缺页率，从而显著提高处理机利用率<br>②工作集的定义<br>引用的集合，类似FIFO<br>（3）“抖动”的预防方法<br>①采取局部置换策略<br>“抖动”影响较小<br>②把工作集算法融入到处理机调度中<br>每个进程在内存的驻留页面是否足够多，如果是就调入新作业、否则增加新物理块<br>③利用L&#x3D;S准则调节缺页率<br>缺页之间的平均时间&#x3D; 平均缺页服务时间<br>④选择暂停的进程<br>先暂停优先级最低的进程、在选择并不重要，但较大的进程</p>
<p>5、请求分段存储管理方式<br>其实也类似于分页，要硬件和软件支持<br>（1）请求分段中的硬件支持<br>①请求段表机制<br>段表项：段名、段长、段基址、存取方式、访问字段A、修改位M、存在位P、增补位、外存始址<br>A、M：改进型CLOCK置换算法<br>P：本段是否调入内存<br>增补位：看是否做过动态增长<br>②缺段中断机制 （图5-12）<br>万一虚段S不在内存中，就阻塞请求进程。如果没有空闲区，就要拼接空闲区或者淘汰实段以形成空闲区<br>之后读入段S，修改段表及内存空区链<br>③地址变换机构<br>就是一个地址变换机构<br>（2）分段的共享和保护<br>①共享段表<br>共享进程计数count、存取控制字段、段号<br>②共享段的分配与回收<br>共享段的分配、共享段的回收<br>③分段保护<br>越界检查、存取控制检查、环保护机构  </p>
<h1 id="第六章：输入输出系统"><a href="#第六章：输入输出系统" class="headerlink" title="第六章：输入输出系统"></a>第六章：输入输出系统</h1><h2 id="I-x2F-O系统的功能，模型和接口"><a href="#I-x2F-O系统的功能，模型和接口" class="headerlink" title="I&#x2F;O系统的功能，模型和接口"></a>I&#x2F;O系统的功能，模型和接口</h2><p>I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。</p>
<h3 id="I-x2F-O系统的基本功能"><a href="#I-x2F-O系统的基本功能" class="headerlink" title="I&#x2F;O系统的基本功能"></a>I&#x2F;O系统的基本功能</h3><ul>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
<li>提高处理机和I&#x2F;O设备的利用率</li>
<li>对I&#x2F;O设备进行控制</li>
<li>确保对设备的正确共享</li>
<li>错误处理</li>
</ul>
<h3 id="I-x2F-O系统的层次结构和模型"><a href="#I-x2F-O系统的层次结构和模型" class="headerlink" title="I&#x2F;O系统的层次结构和模型"></a>I&#x2F;O系统的层次结构和模型</h3><ol>
<li>I&#x2F;O软件的层次结构<ul>
<li>用户层I&#x2F;O软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序（厂家开发）</li>
<li>中断处理程序</li>
<li>硬件</li>
</ul>
</li>
<li>I&#x2F;O系统的分层<ul>
<li>中断处理程序</li>
<li>设备驱动程序</li>
<li>设备独立性软件</li>
</ul>
</li>
</ol>
<h3 id="I-x2F-O系统接口"><a href="#I-x2F-O系统接口" class="headerlink" title="I&#x2F;O系统接口"></a>I&#x2F;O系统接口</h3><ol>
<li>块设备接口<ul>
<li>指以数据块为单位来组织和传送数据信息的设备</li>
<li>典型的块设备是磁盘、光盘</li>
<li>块设备的基本特征<ul>
<li>①传输速率较高，通常每秒钟为几兆位；</li>
<li>②它是可寻址的，即可随机地读&#x2F;写任意一块；</li>
<li>③磁盘设备的I&#x2F;O采用DMA方式。</li>
</ul>
</li>
</ul>
</li>
<li>流设备接口<ul>
<li>又称字符设备指以单个字符为单位来传送数据信息的设备</li>
<li>这类设备一般用于数据的输入和输出，有交互式终端、打印机</li>
<li>字符设备的基本特征<ul>
<li>①传输速率较低；</li>
<li>②不可寻址，即不能指定输入时的源地址或输出时的目标地址；</li>
<li>③字符设备的I&#x2F;O常采用中断驱动方式。</li>
</ul>
</li>
</ul>
</li>
<li>网络通信接口<ul>
<li>提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。</li>
</ul>
</li>
</ol>
<h2 id="I-x2F-O设备和设备控制器"><a href="#I-x2F-O设备和设备控制器" class="headerlink" title="I&#x2F;O设备和设备控制器"></a>I&#x2F;O设备和设备控制器</h2><h3 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><ul>
<li>使用特性分<ul>
<li>存储设备</li>
<li>I&#x2F;O设备</li>
</ul>
</li>
<li>传输速率分<ul>
<li>低速设备（几字节——几百字节）<ul>
<li>典型的设备有键盘、鼠标、语音的输入</li>
</ul>
</li>
<li>中速设备（数千——数万字节）<ul>
<li>典型的设备有行式打印机、激光打印机</li>
</ul>
</li>
<li>高速设备（数十万——千兆字节）<ul>
<li>典型的设备有磁带机、磁盘机、光盘机</li>
</ul>
</li>
</ul>
</li>
<li>设备与控制器之间的接口<ul>
<li>设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。</li>
<li>数据信号：控制器 ←  设备 ←  控制器<ul>
<li>传送数据信号，输入、输出bit</li>
</ul>
</li>
<li>控制信号: 控制器  →  设备<ul>
<li>执行读、写操作的信号</li>
</ul>
</li>
<li>状态信号：设备当前使用状态</li>
</ul>
</li>
</ul>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul>
<li>主要功能：控制一个或多个I&#x2F;O设备，以实现I&#x2F;O设备和计算机之间的数据交换</li>
<li>基本功能<ul>
<li>接收和识别命令<ul>
<li>控制寄存器、命令译码器</li>
</ul>
</li>
<li>数据交换<ul>
<li>实现CPU与控制器，控制器与设备间的数据交换</li>
</ul>
</li>
<li>标识和报告设备的状态</li>
<li>地址识别<ul>
<li>配置地址译码器，识别不同的设备</li>
</ul>
</li>
<li>数据缓冲区</li>
<li>差错控制</li>
</ul>
</li>
<li>设备控制器的组成<ul>
<li>设备控制器与处理机（CPU）的接口<ul>
<li>实现CPU与设备控制器之间的通信</li>
</ul>
</li>
<li>设备控制器与设备的接口<ul>
<li>控制器可连接多个设备</li>
</ul>
</li>
<li>I&#x2F;O逻辑<ul>
<li>实现对设备的控制</li>
<li>CPU利用该逻辑向控制器发送I&#x2F;O命令</li>
<li>命令、地址译码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内存映像I-x2F-O"><a href="#内存映像I-x2F-O" class="headerlink" title="内存映像I&#x2F;O"></a>内存映像I&#x2F;O</h3><p>驱动程序将抽象I&#x2F;O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I&#x2F;O设备的操作</p>
<h3 id="I-x2F-O通道"><a href="#I-x2F-O通道" class="headerlink" title="I&#x2F;O通道"></a>I&#x2F;O通道</h3><ul>
<li>目的：建立独立的I&#x2F;O操作(组织, 管理和结束)，使由CPU处理的I&#x2F;O工作转由通道完成（解放CPU，实现并行）</li>
<li>什么是I&#x2F;O通道？<ul>
<li>是一种特殊的处理机，具有通过执行通道程序完成I&#x2F;O操作的指令</li>
<li>特点：指令单一(局限于与I&#x2F;O操作相关的指令)，与CPU共享内存</li>
</ul>
</li>
<li>基本过程：<ul>
<li>CPU向通道发出I&#x2F;O指令-&gt;通道接收指令-&gt;从内存取出通道程序处理I&#x2F;O-&gt;向CPU发出中断</li>
</ul>
</li>
<li>通道类型<ul>
<li>字节多路通道<ul>
<li>低中速连接子通道时间片轮转方式共享主通道</li>
<li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。</li>
</ul>
</li>
<li>数组选择通道<ul>
<li>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。</li>
</ul>
</li>
<li>数组多路通道<ul>
<li>含有多个非分配型子通道，前两种通道的组合，通道利用率较好</li>
</ul>
</li>
</ul>
</li>
<li>瓶颈问题<ul>
<li>原因;通道不足</li>
<li>解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）</li>
</ul>
</li>
</ul>
<h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li>分类<ul>
<li>中断（外部触发）<ul>
<li>对外部I&#x2F;O设备发出的中断信号的响应</li>
</ul>
</li>
<li>陷入（内部原因：除0）<ul>
<li>由CPU内部事件引起的中断</li>
</ul>
</li>
</ul>
</li>
<li>中断向量表（类比51单片机）<ul>
<li>中断程序的入口地址表</li>
</ul>
</li>
<li>中断优先级<ul>
<li>对紧急程度不同的中断处理方式</li>
</ul>
</li>
<li>对多中断源的处理方式<ul>
<li>屏蔽中断</li>
<li>嵌套中断</li>
</ul>
</li>
</ul>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><ol>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU 的现场并退出中断</li>
</ol>
<h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><ul>
<li>是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程</li>
<li>主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><ol>
<li>接收由I&#x2F;O进程发来的命令和参数， 并将命令中的抽象要求转换为与设备相关的低层操作。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。</li>
</ol>
</li>
<li><ol start="2">
<li>检查用户I&#x2F;O请求的合法性，了解I&#x2F;O设备的状态，传递有关参数，设置设备的工作方式。</li>
</ol>
</li>
<li><ol start="3">
<li>发出I&#x2F;O命令，如果设备空闲，便立即启动I&#x2F;O设备去完成指定的I&#x2F;O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。</li>
</ol>
</li>
<li><ol start="4">
<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li>
</ol>
</li>
</ul>
<h3 id="设备驱动程序的处理过程"><a href="#设备驱动程序的处理过程" class="headerlink" title="设备驱动程序的处理过程"></a>设备驱动程序的处理过程</h3><ul>
<li>将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。</li>
<li>检查I&#x2F;O请求的合理性，比如拒绝从打印机读入数据的操作。</li>
<li>读出和检查设备的状态，确保设备处于就绪态。</li>
<li>传送必要的参数，如传送的字节数，数据在主存的首址等。</li>
<li>工作方式的设置。</li>
<li>启动I&#x2F;O设备，并检查启动是否成功，如成功则将控制返回给I&#x2F;O控制系统，在I&#x2F;O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。</li>
</ul>
<h3 id="对I-x2F-O设备的控制方式"><a href="#对I-x2F-O设备的控制方式" class="headerlink" title="对I&#x2F;O设备的控制方式"></a>对I&#x2F;O设备的控制方式</h3><ul>
<li>I&#x2F;O控制的宗旨<ul>
<li>减少CPU对I&#x2F;O控制的干预</li>
<li>充分利用CPU完成数据处理工作</li>
</ul>
</li>
<li>I&#x2F;O 控制方式<ul>
<li>轮询的可编程I&#x2F;O方式</li>
<li>中断的可编程I&#x2F;O方式</li>
<li>直接储存器访问（DMA）控制方式</li>
<li>I&#x2F;O通道控制方式</li>
</ul>
</li>
</ul>
<h3 id="DMA控制器组成"><a href="#DMA控制器组成" class="headerlink" title="DMA控制器组成"></a>DMA控制器组成</h3><ul>
<li>主机与DMA控制器的接口</li>
<li>DMA控制器与块设备的接口</li>
<li>I&#x2F;O控制逻辑</li>
</ul>
<h2 id="与设备无关的I-x2F-O软件"><a href="#与设备无关的I-x2F-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h2><p>含义： 应用程序所使用的设备，不局限于使用某个具体的物理设备。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>以物理设备名使用设备</li>
<li>引入了逻辑设备名</li>
<li>逻辑设备名称到物理设备名称的转换（易于实现I&#x2F;O重定向）</li>
</ul>
<h3 id="与设备无关的软件"><a href="#与设备无关的软件" class="headerlink" title="与设备无关的软件"></a>与设备无关的软件</h3><ul>
<li>设备驱动程序的统一接口</li>
<li>缓存管理</li>
<li>差错控制</li>
<li>对独立设备的分配与回收</li>
<li>独立于设备的逻辑数据块</li>
</ul>
<h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><ul>
<li>设备控制表DCT</li>
<li>控制器控制表COCT</li>
<li>通道控制表CHCT</li>
<li>显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I&#x2F;O操作的物理条件</li>
<li>系统设备表SDT</li>
<li>逻辑设备表LUT</li>
<li>分配的流程，从资源多的到资源紧张的:LUT-&gt;SDT-&gt;DCT-&gt;COCT-&gt;CHCT</li>
<li>在申请设备的过程中，根据用户请求的I&#x2F;O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。</li>
</ul>
<h2 id="用户层的I-x2F-O软件"><a href="#用户层的I-x2F-O软件" class="headerlink" title="用户层的I&#x2F;O软件"></a>用户层的I&#x2F;O软件</h2><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><ul>
<li>OS向用户提供的所有功能，用户进程都必须通过系统调用来获取</li>
<li>在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API</li>
</ul>
<h3 id="假脱机系统（spooling）"><a href="#假脱机系统（spooling）" class="headerlink" title="假脱机系统（spooling）"></a>假脱机系统（spooling）</h3><ul>
<li>spooling技术是对脱机输入&#x2F;输出系统的模拟</li>
<li>主要组成<ul>
<li>输入&#x2F;输出井</li>
<li>输入&#x2F;输出缓冲区</li>
<li>输入&#x2F;输出进程</li>
<li>井管理程序</li>
</ul>
</li>
<li>特点（体现操作系统的虚拟性）<ul>
<li>提高了I&#x2F;O的速度<ul>
<li>对数据所进行的I&#x2F;O操作，已从对低速设备演变为对输入井或输出井中的数据存取。</li>
</ul>
</li>
<li>将独占设备改造为共享设备<ul>
<li>实际分给用户进程的不是打印设备，而是共享输出井中的存储区域</li>
</ul>
</li>
<li>实现了虚拟设备功能<ul>
<li>将独占设备变成多台独占的虚拟设备。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><h3 id="缓冲的引入（原因）"><a href="#缓冲的引入（原因）" class="headerlink" title="缓冲的引入（原因）"></a>缓冲的引入（原因）</h3><ul>
<li>缓和CPU与I&#x2F;O设备间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>
<li>提高CPU和I&#x2F;O设备之间的并行性</li>
<li>解决数据粒度不匹配的问题</li>
</ul>
<h3 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h3><p>即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)</p>
<h3 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h3><p>即允许CPU连续工作（T不断）</p>
<h3 id="环形缓冲区（专为生产者和消费者打造）"><a href="#环形缓冲区（专为生产者和消费者打造）" class="headerlink" title="环形缓冲区（专为生产者和消费者打造）"></a>环形缓冲区（专为生产者和消费者打造）</h3><ul>
<li>组成<ul>
<li>多个缓冲区</li>
<li>多个指针</li>
</ul>
</li>
<li>使用<ul>
<li>Getbuf过程</li>
<li>Releasebuf过程</li>
</ul>
</li>
<li>同步问题</li>
</ul>
<h3 id="缓冲池-理解为更大的缓冲区"><a href="#缓冲池-理解为更大的缓冲区" class="headerlink" title="缓冲池(理解为更大的缓冲区)"></a>缓冲池(理解为更大的缓冲区)</h3><ul>
<li>组成<ul>
<li>空白缓冲队列（emq）<ul>
<li>由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区</li>
</ul>
</li>
<li>输入队列（inq）<ul>
<li>由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区</li>
</ul>
</li>
<li>输出队列（outq）<ul>
<li>由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲</li>
</ul>
</li>
</ul>
</li>
<li>Getbuf和Putbuf过程<ul>
<li>收容：缓冲池接收外界数据</li>
<li>提取：外界从缓冲池获得数据</li>
</ul>
</li>
<li>缓冲区工作方式（从缓冲区的角度来看）<ul>
<li>收容输入</li>
<li>提取输入</li>
<li>收容输出</li>
<li>提取输出</li>
</ul>
</li>
</ul>
<h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><h3 id="数据的组织和格式"><a href="#数据的组织和格式" class="headerlink" title="数据的组织和格式"></a>数据的组织和格式</h3><h3 id="磁盘的类型"><a href="#磁盘的类型" class="headerlink" title="磁盘的类型"></a>磁盘的类型</h3><ul>
<li>固定头磁盘（贵）</li>
<li>移动头磁盘<h3 id="磁盘访问的时间（关键）"><a href="#磁盘访问的时间（关键）" class="headerlink" title="磁盘访问的时间（关键）"></a>磁盘访问的时间（关键）</h3></li>
<li>寻道时间Ts&#x3D;m*n+s<ul>
<li>s：启动时间，m：移动一条磁道的时间，n：n条磁道</li>
</ul>
</li>
<li>旋转延迟时间Tr</li>
<li>传输时间Tt&#x3D;b&#x2F;rN<ul>
<li>b：每次读写字节数，r：转速，N：一条磁道上的字节数</li>
</ul>
</li>
<li>总时间Ta&#x3D;Ts+1&#x2F;2r+b&#x2F;rN</li>
</ul>
<h3 id="磁盘的调度算法（掌握图表）"><a href="#磁盘的调度算法（掌握图表）" class="headerlink" title="磁盘的调度算法（掌握图表）"></a>磁盘的调度算法（掌握图表）</h3><ul>
<li>先来先服务（FCFS）<ul>
<li>优点：公平，简单</li>
<li>缺点：可能导致某些进程的请求长期得不到满足</li>
</ul>
</li>
<li>最短寻道时间优先（SSTF）<ul>
<li>说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短</li>
</ul>
</li>
<li>扫描算法（SCAN）<ul>
<li>扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向</li>
<li>联想电梯的运行</li>
<li>可防止低优先级进程出现“饥饿”的现象</li>
</ul>
</li>
<li>循环扫描算法（CSCAN）<ul>
<li>算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描</li>
</ul>
</li>
<li>NStepScan算法<ul>
<li>N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。</li>
</ul>
</li>
<li>FSCAN算法<ul>
<li>是Nstepscan算法的简化，将磁盘请求队列分成两个子队列</li>
</ul>
</li>
</ul>
<h2 id="课后题-1"><a href="#课后题-1" class="headerlink" title="课后题"></a>课后题</h2><h3 id="为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？"><a href="#为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？" class="headerlink" title="为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？"></a>为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？</h3><p>答：应该具备以下功能：接收和识别命令、数据交换、标识和报告设备状态、地址识别、数据缓冲、差错控制。</p>
<h3 id="有哪几种I-x2F-O控制方式？各适用于何种场合？"><a href="#有哪几种I-x2F-O控制方式？各适用于何种场合？" class="headerlink" title="有哪几种I&#x2F;O控制方式？各适用于何种场合？"></a>有哪几种I&#x2F;O控制方式？各适用于何种场合？</h3><p>答：一共有四种I&#x2F;O 控制方式。</p>
<ul>
<li>程序I&#x2F;O方式：早期计算机无中断机构，处理机对I&#x2F;O设备的控制采用程序I&#x2F;O方式或称忙等的方式。</li>
<li>中断驱动I&#x2F;O 控制方式：适用于有中断机构的计算机系统中。</li>
<li>直接存储器访问（DMA）I&#x2F;O 控制方式：适用于具有DMA控制器的计算机系统中。</li>
<li>I&#x2F;O 通道控制方式：具有通道程序的计算机系统中。</li>
</ul>
<h3 id="为何要引入设备独立性？如何实现设备独立性？"><a href="#为何要引入设备独立性？如何实现设备独立性？" class="headerlink" title="为何要引入设备独立性？如何实现设备独立性？"></a>为何要引入设备独立性？如何实现设备独立性？</h3><p>答：现代操作系统为了提高系统的可适应性和可拓展性，所以需要实现设备独立性。<br>为了实现设备的独立性，需要引入逻辑设备和物理设备的概念。</p>
<h3 id="何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？"><a href="#何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？" class="headerlink" title="何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？"></a>何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？</h3><p>答：设备虚拟指把独占的设备经过处理后改造成虚拟设备<br>所依赖的关键技术是：将设备分配给多个进程使用，并根据访问顺序对设备进行控制。</p>
<h3 id="在实现后台打印时，SPOOLing-系统应为请求I-x2F-O的进程提供哪些服务？"><a href="#在实现后台打印时，SPOOLing-系统应为请求I-x2F-O的进程提供哪些服务？" class="headerlink" title="在实现后台打印时，SPOOLing 系统应为请求I&#x2F;O的进程提供哪些服务？"></a>在实现后台打印时，SPOOLing 系统应为请求I&#x2F;O的进程提供哪些服务？</h3><p>答：提供以下服务<br>为输出进程申请一块空间，并将要打印的数据发往其中<br>输出进程为用户进程申请空白用户打印表，设置打印要求，将该表挂起到请求打印队列<br>打印机空闲猴从打印队列取首个打印表并根据打印要求送入内存缓存区进行打印。</p>
<h3 id="引入缓冲的主要原因是什么？"><a href="#引入缓冲的主要原因是什么？" class="headerlink" title="引入缓冲的主要原因是什么？"></a>引入缓冲的主要原因是什么？</h3><p>答：主要原因是：匹配CPU和I&#x2F;O之间的速度差、减少对CPU的中断频率、提高CPU和I&#x2F;O设备之间的并行性</p>
<h2 id="简述题"><a href="#简述题" class="headerlink" title="简述题"></a>简述题</h2><p>1、I&#x2F;O系统的功能、模型和接口<br>（1）I&#x2F;O系统的基本功能<br>①隐藏物理设备的细节<br>②与设备的无关性<br>自动安装并寻找驱动程序，即插即用<br>③提高处理机和I&#x2F;O设备的利用率<br>让处理机和I&#x2F;O设备并行操作<br>④对I&#x2F;O设备进行控制<br>这是驱动程序的功能<br>⑤确保对设备的正确共享<br>独占设备：打印机、磁带机<br>共享设备：磁盘<br>⑥错误处理<br>低级能够解决就不向高级报告，请求高级软件解决<br>（2）I&#x2F;O系统的层次结构和模型<br>①I&#x2F;O软件的层次结构<br>用户层I&#x2F;O软件<br>设备独立性软件：映射、保护、分块、缓冲、分配<br>设备驱动程序：设置设备寄存器、检查状态<br>中断处理程序<br>②I&#x2F;O系统中各种模块之间的层次视图<br>I&#x2F;O系统上下接口（图6-2）<br>I&#x2F;O系统的分层：中断处理程序→设备驱动程序→设备独立性软件<br>（3）I&#x2F;O系统接口<br>①块设备接口<br>块设备、隐藏磁盘二维结构、抽象命令映射为低层操作<br>②流设备接口（Unix的）<br>字符设备：效率低、不可寻址<br>get和put操作：有缓冲区<br>in-control指令：互斥方式实现共享<br>③网络通信接口  </p>
<p>2、I&#x2F;O设备和设备控制器<br>（1）I&#x2F;O设备<br>①I&#x2F;O设备的类型<br>按使用特性：存储设备、I&#x2F;O设备（输入输出交互的）<br>按传输速率：低速、中速、高速<br>②设备与控制器之间的接口<br>接口：数据信号线、控制信号线、状态信号线<br>（2）设备控制器<br>①设备控制器的基本功能<br>接收和识别命令、数据交换、标识和报告设备的状态、数据缓冲区、差错控制<br>②设备控制器的组成<br>设备控制器与处理机的接口、设备控制器与设备的接口、I&#x2F;O逻辑<br>（3）内存映像I&#x2F;O<br>①利用特定的I&#x2F;O指令<br>缺点：访问内存和访问设备要两种不同的指令<br>②内存映像I&#x2F;O<br>就是k为界限，0≤k≤n-1，就是内存地址；k≥n，就是寄存器地址。统一了对内存和对控制器的访问方法<br>（4）I&#x2F;O通道<br>①I&#x2F;O通道设备的引入<br>这是一种特殊的处理机，但只局限于I&#x2F;O相关的指令、而且没有自己的内存<br>②通道类型<br>字节多路通道：一个大水喉，多条小水管；一个换头快，一个速率慢<br>数组选择通道：利用率低<br>数组多路通道：甚至可以并行操作<br>③“瓶颈”问题<br>增加通路即可解决  </p>
<p>3、中断机构和中断处理程序<br>（1）中断简介<br>①中断和陷入<br>中断：由外部设备引起，暂停当前程序，执行中断处理程序<br>陷入：CPU内部事件引起的，多是出错故障<br>②中断向量表和中断优先级<br>中断向量表：asm有学<br>中断优先级：现实中有多个中断信号源，要规定不同优先级<br>③对多中断源的处理方式<br>屏蔽中断：顺序执行。优点简单；缺点无视实时中断请求<br>嵌套中断：有个优先级<br>（2）中断处理程序<br>测定是否有未响应中断信号；<br>保护被中断进程的CPU环境；<br>转入相应设备处理程序；<br>中断处理；<br>恢复CPU现场并退出中断  </p>
<p>4、设备驱动程序<br>（1）设备驱动程序概述<br>①设备驱动程序的功能<br>接收命令和参数，并转换为低层操作序列<br>检查I&#x2F;O合法性，了解I&#x2F;O工作状态，传递I&#x2F;O设备操作有关参数，设置设备工作方式<br>及时响应设备控制器发来的中断请求，并根据中断类型，调用响应中断处理程序<br>②设备驱动程序的特点<br>抽象的I&#x2F;O请求转换成具体的I&#x2F;O操作，反映给I&#x2F;O进程<br>和硬件特性紧密相关，终端驱动程序可以只有一个<br>常用控制方式：中断驱动、DMA<br>一部分必须用汇编语言写，很多驱动程序基本部分已经固化在ROM<br>允许可重入<br>③设备处理方式<br>一类设备一个进程<br>一个I&#x2F;O进程负责各类设备的I&#x2F;O操作<br>只为各类设备设置相应的设备驱动程序，供用户或系统进程调用（目前用得最多）<br>（2）设备驱动程序的处理过程<br>①将抽象要求转换为具体要求<br>②对服务请求进行校验<br>譬如要求打印机输入数据<br>③检查设备的状态<br>检测寄存器中的不同位，了解设备的状态<br>④传送必要参数<br>波特率、奇偶校验等等参数<br>⑤启动I&#x2F;O设备<br>了解数据是否到达<br>（3）对I&#x2F;O设备的控制方式<br>①使用轮询的可编程I&#x2F;O方式<br>无限等待，好浪费CPU<br>②使用中断的可编程I&#x2F;O方式<br>百倍提高CPU利用率<br>③直接存储器访问方式<br>至少传送一个数据块，DMA方式提高CPU和I&#x2F;O之间的并行程度<br>④I&#x2F;O通道控制方式<br>使用通道程序完成CPU指定的I&#x2F;O任务  </p>
<p>5、与设备无关的I&#x2F;O软件<br>（1）与设备无关软件的基本概念<br>①以物理设备名使用设备<br>以前应用程序与物理设备直接相关<br>②引入了逻辑设备名<br>通过更换逻辑设备表即可改变显示终端<br>③逻辑设备名称到物理设备名称的转换<br>要搞一张逻辑设备表<br>（2）与设备无关的软件<br>①设备驱动程序的统一接口<br>要有统一接口，同时抽象设备名要映射到适当的驱动程序上<br>②缓冲管理<br>设置缓冲区，缓和CPU和I&#x2F;O设备之间的速度矛盾、提高CPU利用率<br>③差错控制<br>暂时性错误：只有连续多次出错才报告上层，否则由设备驱动程序自己处理<br>持久性错误：要查清发生错误的原因，避免以后再发生错误<br>④对独立设备的分配与回收<br>独占设备要先申请<br>⑤独立于设备的逻辑数据块  </p>
<blockquote>
<p>与设备无关软件功能：设备驱动程序的统一接口、缓冲、错误报告、分配与释放专用设备、提高与设备无关的块大小  </p>
</blockquote>
<p>（3）设备分配<br>①设备分配中的数据结构<br>系统设备表SDT→设备控制表DCT：类型、标识符、状态、设备队列队首指针、重复执行次数、指向控制器表的指针→控制其控制表COCT→通道控制表CHCT<br>②设备分配时应考虑的因素<br>设备固有属性：独占、共享、虚拟设备<br>设备分配算法：FCFS、优先级高优先<br>安全性：安全、不安全<br>③独占设备的分配程序<br>独占设备：分配设备、控制器、通道<br>如果要设备无关地找设备，就要从SDT找DCT，再逐个测试安全性<br>（4）逻辑设备名到物理设备名映射的实现<br>①逻辑设备表LUT<br>逻辑设备名、物理设备名、设备驱动程序的入口地址<br>②逻辑设备表设置问题<br>整个系统一张LUT<br>或每个用户一张LUT  </p>
<p>6、用户层的I&#x2F;O软件<br>（1）系统调用与库函数<br>①系统调用<br>使用系统调用I&#x2F;O设备，用户态→内核态→用户态<br>②库函数<br>库函数与调用程序接在一起<br>（2）假脱机系统<br>①假脱机技术<br>利用专门的外围控制机，先将低速I&#x2F;O设备上的设局传送到高速磁盘上，或相反<br>②SPOOLing的组成<br>输入井和输出井、输入缓冲区和输出缓冲区、输入进程和输出进程、井管理程序<br>③SPOOLing系统的特点<br>提高I&#x2F;O速度、将独占设备改造为共享设备、实现虚拟设备功能<br>④假脱机打印机系统<br>磁盘缓冲区、打印缓冲区、假脱机管理进程和假脱机打印进程<br>⑤守护进程<br>有个假脱机目录，由守望进程按目录文件依次完成各个进程设备的请求，就可以将一个独占设备改为多个进程共享设备  </p>
<p>7、缓冲区管理<br>（1）缓冲的引入<br>①缓和CPU与I&#x2F;O设备间速度不匹配的矛盾<br>速度有差距，都可以设置缓冲区<br>②减少对CPU的中断频率<br>③解决数据粒度不匹配的问题<br>生产者生产的数量和消费者消费的数量差距<br>④提高CPU和I&#x2F;O设备之间的并行性<br>CPU和打印机可以并行工作呢<br>（2）单缓冲区和双缓冲区<br>①单缓冲区<br>缓冲区也会阻塞<br>②双缓冲区<br>CPU执行第一行中的命令时，用户可以继续向第二缓冲区输入下一行数据<br>如果两台电脑只设置但缓冲，就要再设置一个接收缓冲区，一个发送缓冲区<br>（3）环形缓冲区<br>①环形缓冲区的组成<br>空区R，装满的区G，正在使用的现行工作缓冲区C；另外还有多个指针<br>②环形缓冲区的使用<br>Getbuf和Releasebuf<br>③进程之间的同步问题<br>Nexti赶上Nextg：输入速度＞处理速度<br>Nextg赶上Nexti：处理速度＞输入速度<br>（4）缓冲池<br>①缓冲池的组成<br>专为生产者-消费者设置的，包含一个管理数据结构和一组操作函数，管理多个缓冲区<br>包括空白缓冲队列、输入队列、输出队列<br>②Getbuf过程和Putbuf过程<br>设置MS(type)互斥访问缓冲池队列和RS(type)进程同步使用缓冲区<br>③缓冲区的工作方式<br>收容操作、提取输入、收容输出、提取输出  </p>
<p>8、磁盘存储器的性能和调度<br>（1）磁盘性能简述<br>①数据的组织和格式<br>数据组织和格式：磁盘-双面可存储盘片（存储面）-扇区-磁道（柱面）<br>②磁盘的类型<br>固定头磁盘、移动头磁盘<br>③磁盘访问时间<br>（2）早期的磁盘调度算法<br>①先来先服务<br>就是先来的先找，很公平很简单，但平均寻道好长<br>②SSTF最短寻道时间优先<br>选择一个与磁头距离最近的磁道<br>（3）基于扫描的磁盘调度算法<br>①扫描算法SCAN<br>来回<br>②循环扫描算法CSCAN<br>单程<br>③NStepSCAN和FSCAN调度算法<br>N步扫描算法：将磁盘请求队列分成若干长度为N的子队列，再用FCFS依次处理这些子队列<br>FSCAN算法：只分两个队列，一个现在要扫描的，一个是扫描时新冒出来的  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理笔记（2）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>操作系统第三第四章知识点总结</p>
<span id="more"></span>

<h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章:处理机调度与死锁"></a>第三章:处理机调度与死锁</h1><h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol>
<li>高级调度<ul>
<li>称为长程调度或者作业调度，调度对象是作业</li>
</ul>
</li>
<li>低级调度<ul>
<li>称为进程调度或者短程调度</li>
</ul>
</li>
<li>中级调度<ul>
<li>称为内存调度，用于提高内存利用率和系统吞吐量</li>
</ul>
</li>
</ol>
<blockquote>
<p>进程调度的频率最高而且10mms~100ms进行一次进程调度，所以称为短程调度。作业调度周期最长所以称为长程调度。</p>
</blockquote>
<h3 id="处理机调度算法的共同目标"><a href="#处理机调度算法的共同目标" class="headerlink" title="处理机调度算法的共同目标"></a>处理机调度算法的共同目标</h3><ul>
<li>资源利用率:CPU的利用率&#x3D;CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)</li>
<li>公平性</li>
<li>平衡性</li>
<li>策略强制执行</li>
</ul>
<h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3><ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
<h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3><ul>
<li>响应时间快</li>
<li>均衡性</li>
</ul>
<h3 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h3><ul>
<li>截止时间的保证</li>
<li>可预测性</li>
</ul>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><h3 id="批处理中的作业"><a href="#批处理中的作业" class="headerlink" title="批处理中的作业"></a>批处理中的作业</h3><ol>
<li>作业<ul>
<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>
</ul>
</li>
<li>作业步（JobStep）<ul>
<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>
</ul>
</li>
<li>作业控制块（Job Control Block,JCB）<ul>
<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>
</ul>
</li>
<li>作业运行的三个阶段<ol>
<li>收容阶段：把用户提交的作业通过某种输入方式或者SPOOLing系统输入到硬盘，建立JCB，并把它放入作业后备队列</li>
<li>运行阶段：作业被选中后，为它分配必要的资源和建立进程，并放入就绪队列，直到运行结束前，都属于运行状态</li>
<li>完成阶段：当作业运行完成或者发生异常而提前结束，作业会进入完成阶段。系统回收作业的作业控制块和所有资源，并将结果信息输出</li>
</ol>
</li>
</ol>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><p>每次执行作业调度是，需要做出以下决定3</p>
<ul>
<li>接纳多少个作业</li>
<li>接纳哪些作业</li>
</ul>
<h3 id="先来先服务-first–come-first–served，FCFS-调度算法"><a href="#先来先服务-first–come-first–served，FCFS-调度算法" class="headerlink" title="先来先服务(first–come first–served，FCFS)调度算法"></a>先来先服务(first–come first–served，FCFS)调度算法</h3><ul>
<li>比较有利于长作业，而不利于短作业。</li>
<li>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业</li>
</ul>
<h3 id="短作业优先-short-job-first，SJF-的调度算法"><a href="#短作业优先-short-job-first，SJF-的调度算法" class="headerlink" title="短作业优先(short job first，SJF)的调度算法"></a>短作业优先(short job first，SJF)的调度算法</h3><ul>
<li>优点<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统的吞吐量；</li>
</ul>
</li>
<li>缺点<ul>
<li>必须预知作业的运行时间</li>
<li>对长作业非常不利，长作业的周转时间会明显地增长</li>
<li>在采用SJF算法时，人–机无法实现交互</li>
<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法-priority–scheduling-algorithm，PSA"><a href="#优先级调度算法-priority–scheduling-algorithm，PSA" class="headerlink" title="优先级调度算法(priority–scheduling algorithm，PSA)"></a>优先级调度算法(priority–scheduling algorithm，PSA)</h3><p>选择优先级最高的作业装入内存</p>
<h3 id="高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN"><a href="#高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN" class="headerlink" title="高响应比优先调度算法(Highest Response Ratio Next,HRRN)"></a>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</h3><ul>
<li>原理<ul>
<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>
<li>优先权&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间&#x3D;响应时间&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</li>
</ul>
</li>
<li>特点<ul>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>
<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>
<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</li>
</ul>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度的任务、机制和方式"><a href="#进程调度的任务、机制和方式" class="headerlink" title="进程调度的任务、机制和方式"></a>进程调度的任务、机制和方式</h3><ol>
<li>进程调度的任务<ol>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理器分配给进程</li>
</ol>
</li>
<li>进程调度机制<ol>
<li>排队器</li>
<li>分配器</li>
<li>上下文切换器</li>
</ol>
</li>
<li>进程调度方式<ol>
<li>非抢占方式</li>
<li>抢占式<h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3>基于时间片的轮转，让就绪队列上每个进程每次获得一个时间片。<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3></li>
</ol>
</li>
</ol>
<ul>
<li>优先级调度算法类型<ul>
<li>非抢占式</li>
<li>抢占式</li>
</ul>
</li>
<li>优先级类型<ul>
<li>静态优先级</li>
<li>动态优先级</li>
</ul>
</li>
</ul>
<h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><h2 id="实时调度-HRT和SRT任务"><a href="#实时调度-HRT和SRT任务" class="headerlink" title="实时调度(HRT和SRT任务)"></a>实时调度(HRT和SRT任务)</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ul>
<li>提供必要信息<ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强<ul>
<li>∑(Ci&#x2F;Pi)≤1</li>
<li>N个处理机:∑(Ci&#x2F;Pi)≤N</li>
</ul>
</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制<ul>
<li>对中断的快速响应能力</li>
<li>快速的任务分派能力</li>
</ul>
</li>
</ul>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><ul>
<li>非抢占式调度算法<ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ul>
</li>
<li>抢占式调度算法<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法</li>
</ul>
</li>
</ul>
<h3 id="最早截止时间优先EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先EDF(Earliest Deadline First)算法"></a>最早截止时间优先EDF(Earliest Deadline First)算法</h3><ul>
<li>根据任务的开始截至时间来确定任务的优先级<ul>
<li>截至时间越早，优先级越高</li>
</ul>
</li>
<li>非抢占式调度方式用于非周期实时任务</li>
<li>抢占式调度方式用于周期实时任务</li>
</ul>
<h3 id="最低松弛度优先LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先LLF(Least Laxity First)算法"></a>最低松弛度优先LLF(Least Laxity First)算法</h3><ul>
<li>类似EDF</li>
<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>
<li>松弛度例子<ul>
<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>
</ul>
</li>
</ul>
<h3 id="优先级倒置-Priority-inversion-problem"><a href="#优先级倒置-Priority-inversion-problem" class="headerlink" title="优先级倒置(Priority inversion problem)"></a>优先级倒置(Priority inversion problem)</h3><ul>
<li>优先级倒置的形成<ul>
<li>高优先级进程被低优先级进程延迟或阻塞。</li>
</ul>
</li>
<li>优先级倒置的解决方法<ul>
<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>
<li>实用的:建立在动态优先级继承基础上的</li>
</ul>
</li>
</ul>
<h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ul>
<li>可重用性资源<ul>
<li>一个可重用资源只能给一个进程使用</li>
<li>按照顺序：请求资源-&gt;使用资源-&gt;释放资源</li>
<li>每一类可重用资源的单元数目相对固定，</li>
</ul>
</li>
<li>可消耗性资源<ul>
<li>数据，消息等，由生产者进程创建，消费者进程消耗</li>
</ul>
</li>
<li>可抢占性资源<ul>
<li>不引起死锁</li>
<li>CPU，内存</li>
</ul>
</li>
<li>不可抢占性资源<ul>
<li>光驱，打印机<h3 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h3></li>
</ul>
</li>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁<h3 id="死锁的定义，必要条件和处理方法"><a href="#死锁的定义，必要条件和处理方法" class="headerlink" title="死锁的定义，必要条件和处理方法"></a>死锁的定义，必要条件和处理方法</h3></li>
<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件（四个缺一不可）<ul>
<li>互斥条件</li>
<li>请求和保存条件</li>
<li>不可抢占条件</li>
<li>循环等待条件</li>
</ul>
</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</p>
<h3 id="破坏”请求和保存”条件"><a href="#破坏”请求和保存”条件" class="headerlink" title="破坏”请求和保存”条件"></a>破坏”请求和保存”条件</h3><ul>
<li>第一种协议<ul>
<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>
<li>优点:简单，易行，安全</li>
<li>缺点<ul>
<li>资源被严重浪费，严重地恶化了资源的利用率</li>
<li>使进程经常会发生饥饿现象</li>
</ul>
</li>
</ul>
</li>
<li>第二种协议<ul>
<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>
</ul>
</li>
</ul>
<h3 id="破坏”不可抢占”条件"><a href="#破坏”不可抢占”条件" class="headerlink" title="破坏”不可抢占”条件"></a>破坏”不可抢占”条件</h3><p>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</p>
<h3 id="破坏”循环等待”条件"><a href="#破坏”循环等待”条件" class="headerlink" title="破坏”循环等待”条件"></a>破坏”循环等待”条件</h3><ul>
<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>
<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</p>
<h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><ul>
<li>安全状态<ul>
<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>
</ul>
</li>
<li>安全状态之例</li>
<li>由安全状态向不安全状态的转换</li>
</ul>
<h3 id="利用银行家算法避免死锁"><a href="#利用银行家算法避免死锁" class="headerlink" title="利用银行家算法避免死锁"></a>利用银行家算法避免死锁</h3><p>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</p>
<ul>
<li>银行家算法中的数据结构<ul>
<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]&#x3D;k表示系统中第j类资源数为k个。</li>
<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]&#x3D;k表示进程i对j类资源的最大需求数为中k。</li>
<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] &#x3D; k表示进程i已分得j类资源的数目为k个。</li>
<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]&#x3D;k 表示进程i   还需要j类资源k个。Need[i,j]&#x3D;Max[i,j] - Allocation[i,j]</li>
</ul>
</li>
<li>银行家算法</li>
<li>安全性算法</li>
</ul>
<h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><ul>
<li>资源分配图<ul>
<li>简化步骤<ul>
<li>选择一个没有阻塞的进程p</li>
<li>将p移走，包括它的所有请求边和分配边</li>
<li>重复步骤1，2，直至不能继续下去</li>
</ul>
</li>
</ul>
</li>
<li>死锁定理</li>
<li>死锁检测中的数据结构（比如银行家算法）</li>
</ul>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><ul>
<li>抢占资源，从一个或多个进程抢占足够的资源分配给死锁进程</li>
<li>终止(或撤销)进程，直至打破循环</li>
<li>终止进程的方法<ul>
<li>终止所有死锁进程</li>
<li>逐个终止进程<ul>
<li>代价最小<ul>
<li>进程的优先级的大小</li>
<li>进程已执行了多少时间，还需时间</li>
<li>进程在运行中已经使用资源的多少，还需多少资源</li>
<li>进程的性质是交互式还是批处理的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>付出代价最小的死锁解除算法<ul>
<li>使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>
</ul>
</li>
</ul>
<h2 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h2><h3 id="高级调度与低级调度的主要任务是什么？为什么要引入中级调度？"><a href="#高级调度与低级调度的主要任务是什么？为什么要引入中级调度？" class="headerlink" title="高级调度与低级调度的主要任务是什么？为什么要引入中级调度？"></a>高级调度与低级调度的主要任务是什么？为什么要引入中级调度？</h3><p>高级调度的主要任务是根据某种算法，把外存上处于后备队列中的那些作业调入内存。<br>低级调度是根据某种算法决定就绪队列中的进程获得处理机，再把处理器分配给被选中的进程。<br>引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。使那些暂时不能运行的进程不再占用内存资源，将它们调至外存等待，把进程状态改为就绪驻外存状态或挂起状态。</p>
<h3 id="在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？"><a href="#在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？" class="headerlink" title="在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？"></a>在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？</h3><p>批处理系统的调度算法：短作业优先、优先级、高响应比优先、多级反馈队列调度算法<br>分时系统的调度算法：基于时间片的轮转调度<br>实时系统：最早截止时间优先EDF、最低松弛度优先LLF算法</p>
<h3 id="为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？"><a href="#为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？" class="headerlink" title="为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？"></a>为什么在实时系统中，要求系统（尤其是CPU）具有较强的处理能力？</h3><p>实时系统中通常有着多个实时任务。若处理机的处理能力不够强，有可能因为处理机忙不过来而使某些实时任务得不到及时处理，导致发生难以预料的后果。</p>
<h3 id="何谓死锁？产生死锁的原因和必要条件是什么？"><a href="#何谓死锁？产生死锁的原因和必要条件是什么？" class="headerlink" title="何谓死锁？产生死锁的原因和必要条件是什么？"></a>何谓死锁？产生死锁的原因和必要条件是什么？</h3><p>死锁指多个进程同时争夺资源而等待其他进程造成的一种僵局。<br>产生死锁的原因为竞争资源和进程间推进顺序非法。其必要条件是：互斥条件、请求和保持条件、不可抢占条件、循环等待条件。</p>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>1、处理机调度的层次和调度算法的目标<br>描述：作业可能要经历多级处理机调度<br>（1）处理机调度层次<br>①高级调度（长程调度&#x2F;作业调度）<br>对象是作业、决定将外存中处于后备队列的作业调入内存.创建进程和分配资源.并放入就绪队列、主要存在于多道批处理系统，分时和实时系统不设置高级调度<br>②低级调度（进程调度&#x2F;短程调度）<br>对象是进程（&#x2F;内核级线程）、决定就绪队列哪个进程获得处理机、多道批.分时和实时都要配置<br>③中级调度（内存调度）<br>对象是暂时不能运行的进程、把这些进程调到外存.设为挂起状态、一有条件.稍微有空就变为就绪状态<br>★分级按运行频率划分<br>（2）处理机调度算法的目标<br>①共同目标<br>提高资源利用率、公平、平衡、策略强制执行<br>②批处理系统目标<br>处理机利用率高、平均周转时间短、系统吞吐量高<br>③分时系统目标<br>响应时间快、均衡性<br>④实时系统目标<br>截止时间保证、可预测性  </p>
<p>2、作业与作业调度<br>（1）批处理系统中的作业<br>①作业和作业步<br>作业：包括程序.数据和作业说明书、在批处理系统.作业是基本单位从外存调入内存<br>作业步：独立步骤<br>②作业控制块（JCB）<br>包括作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等<br>流程：进入系统→创建JCB→根据类型放到后备队列等待调度→入内存→根据JCB和作业说明书控制→完成→回收资源.撤销JCB<br>③作业运行的三个阶段和三种状态<br>收容阶段-后备状态、运行阶段-运行状态、完成阶段-完成状态<br>（2）作业调度的主要任务<br>也叫：接纳调度<br>考虑：接纳多少作业、接纳哪些作业<br>（3）先来先服务FCFS和短作业优先SJF调度算法<br>①先来先服务<br>就这样.完成或阻塞才分配到其他进程、实际中和其他算法结合使用<br>②短作业优先<br>实际用得多、要预知作业运行时间、长作业、紧迫作业不利、无人机交互<br>（4）优先级调度算法和高响应比优先调度算法<br>①优先级调度算法<br>外部赋予作业优先级<br>②高响应比优先调度算法<br>集SJF.FCFS的优点.兼顾长作业、但要做相应比计算.增加系统开销（Exp.做过类似）  </p>
<p>3、进程调度<br>（1）进程调度的任务、机制和方式<br>①进程调度的任务<br>保存处理机的现场信息、按某种算法选取进程、把处理器分配给进程<br>②进程调度机制<br>排队器：插入就绪队列<br>分配器：从就绪队列取出.分配处理机<br>上下文切换器：保存、装入新的<br>③进程调度方式<br>非抢占方式：只有完成或因某事无法继续运行、I&#x2F;O、执行了原语操作如block，才会引起进程调度<br>优点：简单、开销小、适用大多数批处理系统<br>抢占方式：对分时系统而言.有人机交互、对实时系统而言.能满足任务需求<br>主要原则：优先权原则、短进程优先原则、时间片原则<br>（2）轮转调度算法<br>①轮转法（RR）的基本原理<br>按FCFS策略排成就绪队列，每隔一定时间就产生一次中断<br>②进程切换时机<br>时间片未用完就完成：马上调度队首进程.启动新时间片<br>时间片完还没完成：中断.进程被调到就绪队列队尾<br>③时间片大小的确定<br>太短有利于短进程、太长退化为FCFS算法.要计算平均周转时间（带权周转时间）<br>（3）优先级调度算法<br>①优先级调度算法的类型<br>非抢占式和抢占式<br>②优先级的类型<br>确定优先级的依据：<br>静态优先级：进程类型、进程对资源的需求、用户需求<br>动态优先级：先赋予优先级，随着进程推进或等待时间增加而改变<br>（4）多队列调度算法<br>将一条就绪队列拆分成多条，各有各调度算法<br>（5）多级反馈队列调度算法<br>①调度机制<br>多条就绪队列、队列内使用FCFS算法.一个时间片未完成就放到下一个队列的末尾.最后一个队列用RR方式、按队列优先级调度.前队列空才到本队列运行<br>②调度算法的性能<br>终端型用户、短批处理作业用户、长批处理作业用户<br>（6）基于公平原则调度算法<br>①保证调度算法<br>保证处理机公平分配<br>功能：跟踪进程已经执行的处理时间、该时间除以n、计算实际处理时间和应获得时间之比、比较比率、比率最低的获得处理机<br>②公平分享调度算法<br>考虑多用户  </p>
<p>4、实时调度<br>描述：实时系统有两种实时任务——HRT和SRT<br>（1）实现实时调度的基本条件<br>①提供必要信息<br>就绪时间、开始截止和完成截止时间、处理时间、资源要求、优先级<br>②系统处理能力强<br>（处理时间i&#x2F;周期时间i）总和 ≤ 1. 未考虑任务切换花费的时间还应该留有余地<br>提高系统处理能力的途径：单处理机系统增强处理能力.显著减少每个任务的处理时间、多处理机系统.就变成（处理时间i&#x2F;周期时间i）总和 ≤ N<br>③采用抢占式调度机制<br>执行完关键程序和临界区后，能及时将自己阻塞起来，以释放处理机<br>④具有快速切换机制<br>对中断的快速响应能力、快速的任务分派能力<br>（2）实时调度算法的分类<br>根据任务性质：H&#x2F;S<br>根据调度方式：非抢占式&#x2F;抢占式<br>①非抢占式调度算法<br>轮转、优先调度<br>②抢占式调度算法<br>基于时钟中断的抢占式优先级调度算法：等待时钟中断发生才剥夺当前任务的执行<br>立即抢占优先调度算法：好快好快.只要任务未处于临界区.就立即剥夺当前任务执行<br>（3）最早截止时间优先EDF算法<br>非抢占式调度方式用于非周期实时任务：开始截止时间早的排前<br>抢占式调度方式用于周期实时任务：最早截止时间优先算法<br>（4）最低松弛度优先LLF算法<br>松弛度？？？<br>（5）优先级倒置<br>①优先级倒置的形成<br>②优先级倒置的解决方法<br>继承动态优先级的方法：P3继承P1的优先级.一方面避免P2抢占处理机、另一方面释放mutex资源 </p>
<p>5、死锁概述<br>（1）资源问题<br>指互斥资源、不可被抢占的资源<br>①可重用性资源和消耗性资源<br>可重用性资源：一个只能分配给一个进程使用、顺序为请求.使用.释放、数目相对固定.运行期间不能创建或删除<br>可消耗性资源：在进程运行中树木不断变化.可为0、可以不断创建.放入缓冲区、可以由进程创建.使用并不再返回资源类<br>②可抢占性资源和不可抢占性资源<br>可抢占性资源：可以被其他进程抢占.如CPU和主存<br>不可抢占性资源：一旦分配给进程就不能强制收回.要做到底<br>（2）计算机系统中的死锁<br>①竞争不可抢占性资源引起死锁<br>我要你的，你要我的，形成环路，死锁<br>②竞争可消耗资源引起死锁<br>譬如消息通信机制.先读后写.就会死锁<br>③进程推进顺序不当引起死锁<br>竞争不可抢占性资源引起死锁的翻版.多画了一个图<br>（3）死锁的定义、必要条件和处理方法<br>①死锁的定义<br>这组死锁进程都在等其他进程释放所占资源<br>②产生死锁的必要条件<br>互斥条件：一段时间只被一个进程占用<br>请求和保持条件：进程已经保持至少一个条件.但有提出新资源请求<br>不可抢占条件：只能在进程用完才能释放<br>循环等待条件：存在循环链<br>③处理死锁的方法<br>预防死锁：设置限制条件.破坏产生死锁四个必要条件来预防<br>避免死锁：在资源动态分配时.用防止系统进入不安全状态<br>检测死锁：通过检测机构及时检测死锁.采取适当措施以解脱<br>解除死锁：撤销进程.回收资源.分配给处于阻塞的进程<br>防范逐渐减弱.但资源利用率提高.进程因资源因素而阻塞的频度下降  </p>
<p>6、预防死锁<br>（1）破坏“请求和保持”条件<br>保证：进程请求资源时，不持有不可抢占资源<br>第一种协议：一次性全部申请，从而破坏“请求条件”、缺点是资源被严重浪费.进程饥饿<br>第二种协议：先释放资源.再请求新资源<br>（2）破坏“不可抢占”条件<br>当保持了某些不可抢占资源后.提出新资源请求不得满足.就必须释放已经保持的资源.等需要时再申请<br>缺点：增加周转时间、增加系统开销、降低系统吞吐量<br>（3）破坏“循环等待”条件<br>总有一个进程占据了较高序号的资源.此后它继续申请的资源必然是空闲的  </p>
<p>7、避免死锁<br>（1）系统安全状态<br>①安全状态<br>计算一个资源分配的安全性.如果分配不会导致不安全状态.才可将资源分配给进程<br>②安全状态之例<br>③由安全状态向不安全状态的转换  </p>
<p>（2）利用银行家算法避免死锁<br>①银行家算法中的数据结构<br>Availalbe、Max、Allocation、Need<br>②银行家算法<br>睇wiki“银行家算法”条目<br>声明：Request是请求向量<br>Request ≤ Need, 否则出错<br>Request ≤ Available, 否则P等待<br>系统试探分配资源给P, 并执行Availalbe -&#x3D; Requeset; Allocation+&#x3D; Request; Need -&#x3D; Request  </p>
<p>8、死锁的检测与解除<br>（1）死锁的检测<br>①资源分配图<br>圆圈代表进程、方格代表一类资源、边代表资源分配<br>②死锁的定理<br>简化资源分配图.如果不能完全简化.就会死锁<br>③死锁检测中的数据结构<br>类似于银行家算法？？？  </p>
<p>（2）死锁的解除<br>常用两种方法：抢占资源、终止&#x2F;撤销进程<br>①终止进程的方法<br>终止所有死锁进程：会功亏一篑<br>逐个终止进程：找到代价最小.考虑优先级、已执行时间.还需的时间、已用资源、交互式还是批处理式<br>②付出代价最小的死锁解除算法<br>很不实际  </p>
<h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章:存储器管理"></a>第四章:存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多层结构的存储系统"><a href="#多层结构的存储系统" class="headerlink" title="多层结构的存储系统"></a>多层结构的存储系统</h3><ul>
<li>存储器的多层结构<ul>
<li>CPU寄存器</li>
<li>主存</li>
<li>辅存</li>
</ul>
</li>
<li>可执行存储器<ul>
<li>寄存器和主存的总称</li>
<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>
</ul>
</li>
</ul>
<h3 id="主存储器与寄存器"><a href="#主存储器与寄存器" class="headerlink" title="主存储器与寄存器"></a>主存储器与寄存器</h3><h3 id="高速缓存和磁盘缓存"><a href="#高速缓存和磁盘缓存" class="headerlink" title="高速缓存和磁盘缓存"></a>高速缓存和磁盘缓存</h3><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>编译<ul>
<li>源程序 -&gt; 目标模块（Object modules）——–Compiler<ul>
<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>
</ul>
</li>
</ul>
</li>
<li>链接<ul>
<li>一组目标模块 -&gt; 装入模块 （Load Module）———-Linker<ul>
<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>
</ul>
</li>
</ul>
</li>
<li>装入<ul>
<li>装入模块 -&gt; 内存  ——–Loader<ul>
<li>由装入程序将装入模块装入内存<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3></li>
</ul>
</li>
</ul>
</li>
<li>绝对装入方式<ul>
<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>
</ul>
</li>
<li>可重定位装入方式<ul>
<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>
<li>优点：不需硬件支持，可以装入有限多道程序。</li>
<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>
</ul>
</li>
<li>动态运行时的装入方式<ul>
<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>
<li>优点：<ul>
<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>
<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>
</ul>
</li>
<li>缺点：需要硬件支持，OS实现较复杂。</li>
<li>它是虚拟存储的基础。</li>
</ul>
</li>
</ul>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ul>
<li>静态链接(Static Linking)方式(lib)</li>
<li>装入时动态链接(Load-time Dynamic Linking)</li>
<li>运行时动态链接(Runtime Dynamic Linking)(dll)</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="单一连续分配-DOS"><a href="#单一连续分配-DOS" class="headerlink" title="单一连续分配(DOS)"></a>单一连续分配(DOS)</h3><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>最早出现的方法，会浪费很多空间，划分分区方法</p>
<ul>
<li>分区大小相等：缺乏灵活性，程序小浪费空间，程序大于分区导致无法运行。只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>
<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>
<li>优点：无外碎片、易实现、开销小。</li>
<li>缺点：<ul>
<li>存在内碎片，造成浪费</li>
<li>分区总数固定，限制了并发执行的程序数目。</li>
<li>通用Os很少采用，部分控制系统中采用</li>
</ul>
</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul>
<li>分区分配操作<ul>
<li>分配内存</li>
<li>运行完成时回收内存</li>
</ul>
</li>
</ul>
<h4 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h4><ul>
<li>首次适应（firstfit, FF）算法<ul>
<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>
<li>这种方法目的在于减少查找时间。</li>
<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>
</ul>
</li>
<li>循环首次适应（nextfit, NF）算法<ul>
<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>
<li>空闲分区分布得更均匀，查找开销小</li>
<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>
</ul>
</li>
<li>最佳适应（best fit, BF）算法<ul>
<li>找到最合适的，但是大区域的访问次数减少</li>
<li>这种方法能使外碎片尽量小。</li>
<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>
</ul>
</li>
<li>最坏适应（worst fit, WF）算法<ul>
<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>
<li>空闲分区按大小由大到小排序</li>
</ul>
</li>
</ul>
<h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><ul>
<li>快速适应</li>
<li>伙伴系统</li>
<li>哈希算法</li>
</ul>
<h3 id="动态重定向分区分配"><a href="#动态重定向分区分配" class="headerlink" title="动态重定向分区分配"></a>动态重定向分区分配</h3><ul>
<li>紧凑</li>
<li>动态重定位<ul>
<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>
<li>内存地址&#x3D;相对地址+起始地址</li>
</ul>
</li>
<li>动态重定位分区分配算法<ul>
<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>
<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>
</ul>
</li>
<li>优点：没有内碎片。</li>
<li>缺点：外碎片。</li>
</ul>
<blockquote>
<p>基址寄存器：程序的最小物理地址<br>界限寄存器：程序的逻辑地址范围<br>物理地址 &#x3D; 逻辑地址 + 基址<br>内碎片：占用分区之内未被利用的空间<br>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</p>
</blockquote>
<h2 id="对换-了解"><a href="#对换-了解" class="headerlink" title="对换(了解)"></a>对换(了解)</h2><p>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</p>
<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="分页存储管理的基本方式"><a href="#分页存储管理的基本方式" class="headerlink" title="分页存储管理的基本方式"></a>分页存储管理的基本方式</h3><ul>
<li>页面<ul>
<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>
</ul>
</li>
<li>页框（frame）<ul>
<li>内存空间分成与页面相同大小的存储块</li>
</ul>
</li>
<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>
<li>地址结构<ul>
<li>页号P+位移量W(0-31)</li>
</ul>
</li>
<li>页表<ul>
<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>
<li>页表的作用是实现从页面号到物理块号的地址映射</li>
</ul>
</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ul>
<li>基本的地址变换机构<ul>
<li>要访问两次内存</li>
<li>页表大都驻留在内存中</li>
<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>
<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>
</ul>
</li>
<li>具有快表的地址变换机构<ul>
<li>提高了效率，此处会有计算题</li>
<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1&#x2F;2。</li>
<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>
<li>地址变换过程为：<br>  1、CPU给出有效地址<br>  2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。<br>  3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；<br>  4、若快表中未找到对应的页表项，则需再访问内存中的页表<br>  5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>
</ul>
</li>
</ul>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><ul>
<li>主要是有的时候页表太多了，要化简</li>
<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>
<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>
</ul>
<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><ul>
<li><p>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</p>
</li>
<li><p>优点：</p>
<ul>
<li>没有外碎片，每个内碎片不超过页大小。</li>
<li>一个程序不必连续存放。</li>
<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>
</ul>
</li>
<li><p>缺点：程序全部装入内存。</p>
</li>
</ul>
<h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul>
<li>方便编程</li>
<li>信息共享</li>
<li>动态增长</li>
<li>动态链接</li>
</ul>
<p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。<br>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定。</p>
<h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ul>
<li>分段<ul>
<li>格式：段号+段内地址</li>
</ul>
</li>
<li>段表<ul>
<li>段表实现了从逻辑段到物理内存区的映射。</li>
</ul>
</li>
<li>地址变换机构</li>
</ul>
<h3 id="和分页的区别"><a href="#和分页的区别" class="headerlink" title="和分页的区别"></a>和分页的区别</h3><ul>
<li>页是信息的物理单位</li>
<li>页的大小固定且由系统固定</li>
<li>分页的用户程序地址空间是一维的</li>
<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>
<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>
</ul>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>这是分段最重要的优点，分页系统中对程序和数据的共享远不如分段系统方便</p>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ul>
<li>基本原理<ul>
<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>
</ul>
</li>
<li>地址变换过程<ul>
<li>需要三次访问过程</li>
</ul>
</li>
<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</li>
</ul>
<h2 id="课后题-1"><a href="#课后题-1" class="headerlink" title="课后题"></a>课后题</h2><h3 id="可采用哪几种方式将程序装入内存？它们分别适用于何种场合？？"><a href="#可采用哪几种方式将程序装入内存？它们分别适用于何种场合？？" class="headerlink" title="可采用哪几种方式将程序装入内存？它们分别适用于何种场合？？"></a>可采用哪几种方式将程序装入内存？它们分别适用于何种场合？？</h3><p>（1）绝对装入方式，当系统很小，仅能运行单道程序时，能知道程序驻留在内存的什么位置，可采用绝对装入方式<br>（2）可重定向装入方式，适用于多道程序<br>（3）动态运行时装入方式，适用于多道程序环境；不允许程序运行时在内存中移位置。</p>
<h3 id="为什么要引入动态重定位？如何实现？"><a href="#为什么要引入动态重定位？如何实现？" class="headerlink" title="为什么要引入动态重定位？如何实现？"></a>为什么要引入动态重定位？如何实现？</h3><p>因为在程序执行过程中，每当访问指令或数据时，需要将要访问的程序或数据的逻辑地址转换成物理地址，所以引入了动态重定位；<br>具体实现方法是在系统中增加一个重定位寄存器，用来存放程序在内存中的起始地址，程序执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加之和，从而实现动态重定位。</p>
<h3 id="分区存储管理中常用那些分配策略？比较它们的优缺点。"><a href="#分区存储管理中常用那些分配策略？比较它们的优缺点。" class="headerlink" title="分区存储管理中常用那些分配策略？比较它们的优缺点。"></a>分区存储管理中常用那些分配策略？比较它们的优缺点。</h3><p>分区存储管理中的常用分配策略：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。<br>首次适应算法优缺点：保留了高址部分的大空闲区，为后来的大作业分配创造条件；低址部分不断被划分，留下许多难以利用的小空闲区，每次查找都从低址开始增加了系统查找空闲分区的开销。<br>循环首次适应算法优缺点：内存空闲分区分布均匀，减少了查找系统开销；缺乏大空闲分区，导致不能装入大型作业。<br>最佳适应算法优缺点：每次分配给文件的都是最适合该文件大小的分区，内存中留下许多难以利用的碎片空间。<br>最坏适应算法优缺点：剩下空闲区不太小，产生碎片的可能性最小，对中小型文件分配分区操作有利；存储器中缺乏大空闲区，对大型文件分区分配不利。</p>
<h3 id="在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？"><a href="#在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？" class="headerlink" title="在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？"></a>在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？</h3><p>在以进程为单位进行对换时，并非每次都将整个进程换出。因为：<br>(1)从结构上讲，进程由程序段、数据段和进程控制块组成的，其中进程控制块总有部分或全部常驻内存，不被换出。<br>(2)程序段和数据段可能正被若干进程共享，此时它们也不能换出。</p>
<h3 id="在具有快表的段页式存储管理方式中，如何实现地址变换？"><a href="#在具有快表的段页式存储管理方式中，如何实现地址变换？" class="headerlink" title="在具有快表的段页式存储管理方式中，如何实现地址变换？"></a>在具有快表的段页式存储管理方式中，如何实现地址变换？</h3><p>在CPU给出有效地址后，由地址变换机构自动将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号比较，若找到匹配页号，表示要访问的页表项在快表中。可直接从快表读出该页对应物理块号，送到物理地址寄存器中。如快表中没有对应页表项，则再访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页表项存入快表。但若寄存器已满，则OS必须找到合适的页表项换出。</p>
<h2 id="简答题-1"><a href="#简答题-1" class="headerlink" title="简答题"></a>简答题</h2><p>1、存储器的层次结构<br>（1）多层结构的存储器系统<br>CPU寄存器；<br>高速缓存Cache、主存储器RAM、磁盘缓存；<br>固定磁盘、可移动存储介质<br>（2）可执行存储器<br>就是CPU寄存器和主存.访问很快<br>（3）主存储器与寄存器<br>①主存储器<br>又叫主存or内存.相比CPU执行速度.它还是很慢.所以引入寄存器和高速缓存<br>②寄存器<br>完全与CPU协同工作.但好贵<br>（4）高速缓存和磁盘缓存<br>①高速缓存<br>备份主存中较常用的数据.以减少CPU对主存储器的访问次数<br>②磁盘缓存<br>因为磁盘I&#x2F;O速度远低于主存访问速度.所以设置磁盘缓存来暂存频繁使用的一部分磁盘数据和信息  </p>
<p>2、程序的装入和链接<br>用户程序要在OS中运行.要先装入内存.再转换为一个可执行程序：编译、链接、装入<br>（1）程序的装入<br>①绝对装入方式<br>当OS很小.且仅能运行单道程序时.完全有可能知道程序驻留在内存的位置.那么就可以产生绝对地址的目标代码<br>②可重定位装入方式（静态重定位）<br>多道程序下.逻辑地址和物理地址不同.要加上起始地址.但只在进程装入时一次完成.故称为静态重定位.可装到内存任何允许位置<br>③动态运行时的装入方式<br>需要重定位寄存器<br>（2）程序的链接<br>①静态链接方式<br>要解决：对相对地址进行修改（子程序的相对地址）、变换外部调用符号（生成可执行文件后不再拆开.又叫静态链接方式）<br>②装入时动态链接<br>便于修改和更新（各模块分开存放）、便于实现对目标模块的共享（静态每个应用模块必有目标模块的拷贝.无法共享.但动态可以一个目标链接多个应用模块）<br>③运行时动态链接<br>运行时发现没有.就由OS去找这个模块内功加快程序装入过程和节约大量内存空间  </p>
<p>3、连续分配存储管理方式<br>（1）单一连续分配<br>分系统区和用户区.单用户.单任务操作系统<br>（2）固定分区分配<br>划分分区的方法：大小相等（一台计算机控制多台相同冶炼炉）和大小不等<br>内存分配：通常按大小排队.建立分区使用表.如果找不到大小足够的分区.就拒绝分配内存<br>（3）动态分区分配<br>动态分区分配中的数据结构<br>动态分区分配算法：之后介绍4种分配算法和3中索引搜索算法<br>分区分配操作：分配内存、回收内存<br>（4）基于顺序搜索的动态分区分配算法<br>首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法<br>（5）基于索引搜索的动态分区分配算法<br>快速适应算法、伙伴系统、哈希算法<br>（6）动态可重定位分区分配<br>紧凑、动态重定位、动态重定位分区分配算法  </p>
<p>4、对换<br>（1）多道程序环境下的对换技术<br>①对换的引入<br>避免内存全部被阻塞.外存却有很多作业无法进入内存<br>②对换的类型<br>整体对换、页面对换<br>（2）对换空间的管理<br>①对换空间管理的主要目标<br>文件区管理主要目标：提高文件存储空间的利用率.提高对文件的访问速度<br>对换空间管理的主要目标：提高换入换出的速度<br>②对换区空闲盘块管理中的数据结构<br>与内存的相似<br>③对换空间的分配与回收<br>与内存分配和回收雷同<br>（3）进程的换出与换入<br>①进程的换出<br>选择被换出的进程<br>进程换出过程<br>②进程的换入<br>如果发现许多进程运行时缺页且内存紧张.才启动对换程序.将部分进程调至外存<br>如果缺页率明显减少.系统吞吐量已下降.则可以暂停运行对换程序  </p>
<p>5、分页存储管理方式<br>其实分三种：分页、分段、段页式<br>（1）分页存储管理的基本方法<br>①页面和物理块<br>页面：页号<br>页面大小：太小.进程占用较多页面、太多.碎片多、适中.1kB~8kB<br>②地址结构<br>页号：P<br>页内地址（偏移量）：d<br>两个都有公式计算<br>③页表<br>从页号到物理块号的映射<br>（2）地址变换机构<br>①基本的地址变换机构<br>如果发现页号≥页表长度.就引发越界中断；否则页表始址+页号<em>页表项长度&#x3D;物理块号<br>②具有快表的地址变换机构<br>有个快表在高速缓存<br>（3）访问内存的有效时间<br>EAT &#x3D; t +t &#x3D; 2t<br>EAT &#x3D; a</em>λ+(t+λ)(1-a)+t &#x3D; 2t+ λ - t* a<br>（4）两级和多级页表<br>①两级页表<br>②多级页表<br>（5）反置页表<br>①反置页表的引入<br>②地址变换  </p>
<p>6、分段存储管理方式<br>（1）分段存储管理的基本方法<br>①方便编程<br>逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的<br>②信息共享<br>段是信息的逻辑单位。简化共享过程<br>③信息保护<br>就是可以加个标识。不允许读写<br>④动态增长<br>可以解决这个问题<br>⑤动态链接<br>4.2.2<br>（2）分段系统的基本原理<br>①分段<br>每个段有一个段号<br>②段表<br>实现从逻辑段到物理内存区的映射<br>③地址变换机构<br>段表项数目比页表项数目少.其所需的联想存储器相对较少.减少存取数据的时间<br>④分页和分段的主要区别<br>页是信息的物理单位.分页是系统管理上的需要<br>while 段是存储管理方式中的逻辑单位.分段目的在于更好满足用户的需要<br>页大小固定.段大小不固定<br>分页的用户程序地址是一维的.分段是二维的<br>（3）信息共享<br>①分页系统中对程序和数据的共享<br>每个进程都有页表.也都指向相同的物理块号<br>②分段系统中的程序和数据的共享<br>可重入代码是一种不允许任何进程对它进行修改的代码<br>配以局部数据区.把执行中可能改变的部分拷贝到该数据区.这样执行时只需对该数据区中的内容修改即可<br>（4）段页式存储管理方式<br>分段→分页.每段一个段名<br>段号.比较.加法算段表段号→得到页号.(比较).加法算页表页号→得到物理块号.加页内地址→得物理地址  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>无线传感网络复习题</title>
    <url>/%E5%A4%8D%E4%B9%A0%E9%A2%98/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>把老师发的无线传感网络复习题补充完答案</p>
<span id="more"></span>

<h1 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h1><ol>
<li>传感器网络的三个基本要素：<strong>传感器，感知对象，观察者</strong>。</li>
<li>无线通信物理层的主要技术包括：<strong>介质的选择、频段的选择、调制技术和扩频技术</strong>。</li>
<li>无线传感器网络特点：<strong>大规模网络、自组织网络、可靠的网络、动态网络、以数据为中心的网络、应用相关的网络</strong>。</li>
<li>无线传感器网络的关键技术主要包括：<strong>网络拓扑控制、网络协议、时间同步、定位技术、数据融合及管理、网络安全、应用层技术等</strong>。</li>
<li>传感器节点由<strong>传感器模块、处理器模块、嵌入式软件系统、无线通信模块和能量供应模块</strong>四部分组成。</li>
<li>无线传感器网络的组成模块分为：<strong>通信模块、传感模块、计算模块、存储模块和电源模块</strong>。</li>
<li>传感器网络的支撑技术包括：<strong>定位技术、时间同步、数据融合、能量管理、安全机制</strong>。</li>
<li>传感器节点通信模块的工作模式有<strong>发送 、接收和空闲</strong>。</li>
<li>传感器节点的能耗主要集中在<strong>通信</strong>模块。</li>
<li>当前传感器网络应用最广的两种通信协议是：<strong>zigbee、IEEE802.15.4</strong>。</li>
<li>ZigBee 主要界定了网络、安全和应用框架层，通常它的网络层支持三种拓扑结构：<strong>星型(Star)结构、网状（Mesh）结构、簇树型（Cluster Tree）结构</strong>。</li>
<li>根据对传感器数据的操作级别，可将数据融合技术分为以下三类：<strong>特征级融合、数据级融合、决策级融合</strong>。</li>
<li>信道可以从侠义和广义两方面理解，侠义的信道<strong>信号输出的媒质</strong>，分为<strong>有线信道和无线信道</strong>；广义信道<strong>包括除除传输媒质还包括有关的转换器</strong>广义信道按照功能可以分为<strong>模拟信道</strong>和<strong>数字信道</strong>。</li>
<li>任意相邻区域使用无频率交叉的频道是，如：<strong>1、6、11</strong> 频道。</li>
<li>无线传感器网络可以选择的频段有：<strong>868MHZ、915MHZ、2.4GHZ、5GHZ</strong>。</li>
<li>IEEE 802.15.4 标准主要包括：<strong>物理层和 MAC 层的标准</strong>。</li>
<li>传感器网络中常用的测距方法有：<strong>到达时间&#x2F;到达时间差(ToA&#x2F;TDoA)、接收信号强度指示(RSSI)、到达角(AoA)</strong> 。</li>
<li>无线传感器网络的协议栈包括物理层、<strong>数据链路层</strong>、<strong>网络层</strong>、传输层和<strong>应用层</strong>，还包括能量管理、移动管理和任务管理等平台。</li>
<li>无线传感器节点处于<strong>发送状态</strong>、接收状态、侦听状态和<strong>睡眠状态</strong>时单位时间内消耗的能量是依次减少的。</li>
<li>IEEE 802.15.4 标准将无线传感器网络的数据链路层分为两个子层，即<strong>逻辑链路子层LLC</strong> 和<strong>介质访问控制子层MAC</strong>。</li>
<li>Zigbee 的最低两层即物理层和 MAC 层使用<strong>IEEE 802.15.4协议</strong>标准，而网络层和应用层由Zigbee 联盟制定。</li>
<li>无线传感器网络的时间同步方法有很多，按照网络应用的深度可以划分三种：<strong>简单排序</strong>、<strong>相对同步</strong>和<strong>绝对同步</strong>。 </li>
<li>无线传感器网络的时间同步方法有很多，按照时间同步的参考时间可以划分为<strong>内同步</strong>和<strong>外同步</strong>。</li>
<li>无线传感器网络的时间同步方法有很多，根据需要时间同步的不同应用需求以及同步对象的范围不同可以划分为<strong>局部同步</strong>和<strong>全网同步</strong>.</li>
<li>物理层帧由<strong>同步头，物理帧头和PHY负载</strong>构成。</li>
<li>MAC 层有四种不同的帧形式：<strong>信标帧，数据帧，确认帧，命令帧</strong></li>
<li>MAC 帧一般格式由 <strong>MAC帧帧头，MAC帧有效载荷和MAC帧尾</strong> 构成。</li>
<li>典型的时间同步协议有：<strong>DMTS协议，PBS协议和TPSN协议</strong>。 </li>
<li>数据融合的策略可以分为：<strong>应用层数据融合，路由层数据融合和独立的数据融合协议层</strong>.</li>
<li>定位技术分为：<strong>多边定位&#x2F;三边定位和接收信号角度定位</strong>。</li>
<li>按照 OSI 模型，Zigbee 网络分为 4 层，从下向上分别为 <strong>物理层，MAC层，网络层和应用层</strong>。</li>
<li>根据标签的供电方式可以将RFID系统分为<strong>有源标签，无源标签，和半有源标签</strong>；根据工作频率可以分为<strong>低频标签，高频标签，超高频标签和微波标签</strong>。</li>
<li>RFID 系统由<strong>读写器，标签和应用系统</strong>组成。</li>
<li>ISO 标准体系分为 <strong>ISO14443，ISO15693和ISO18000</strong>三种。</li>
<li>EPC Global 体 系 架 构 分 为 <strong>EPC物理对象交换标准，EPC基础设施标准和EPC数据对象交换标准</strong> 三部分。</li>
<li>蜂窝移动通信是采用 <strong>无线组网</strong>方式，在<strong>终端</strong>和<strong>网络设备</strong>之间通过无线信道连接起来，进而实现用户在活动中可以互相通信。</li>
<li>GPRS 是一种以<strong>全球手机系统（GSM）</strong>为基础的数据传输技术，是<strong>GSM</strong>的延续。</li>
<li>WIFI 全称为 Wireless Fidelity，又称<strong>IEEE802.11b</strong>，它的最大优点就是传输速度较高，可以达到11Mb&#x2F;s。</li>
<li>IEEE802.11 标 准 规 范 逻 辑 结 构 包 括 了 <strong>无线局域网的物理层</strong> 和 <strong>媒体访问控制层</strong>。</li>
<li>1997 年完成并公布的 IEEE802.11 标准的最初版本支持三种可选的物理层：<strong>调频序列扩频</strong>，<strong>直接序列扩频</strong>和<strong>红外物理层</strong>。</li>
<li>网关根据应用领域的不同，分类也不同，一般可以分为<strong>协议网关，应用网关和安全网关</strong>。</li>
<li>无线传感器网络网关属于<strong>协议网关</strong>的一种，可以转换不同的协议。</li>
<li>RFID 系统通常由<strong>电子标签、读写器和计算机通信网络</strong>三部分组成。</li>
<li>在 RFID 系统工作的信道中存在有三种事件模型：<strong>①以能量提供为基础的事件模型②以时序方式提供数据交换的事件模型③以数据交换为目的的事件模型</strong></li>
<li>典型的读写器终端一般由<strong>天线、射频模块、逻辑控制模块</strong>三部分构成。</li>
<li>控制系统和应用软件之间的数据交换主要通过读写器的接口来完成。一般读写器的 I&#x2F;O 接口形式主要有：<strong>USB、WLAN、以太网接口、RS-232 串行接口、RS-485 串行接口</strong>。</li>
<li>根据电子标签工作时所需的能量来源，可以将电子标签分为<strong>有源&#x2F;无源标签</strong>。</li>
<li>最常用的差错控制方法有<strong>奇偶校验、循环冗余校验、汉明码</strong>。</li>
<li>RFID 系统按照工作频率分类，可以分为<strong>低频、高频、超高频、微波</strong>四类。</li>
<li>高频 RFID 系统典型的工作频率是<strong>13.56MHz</strong>。</li>
<li>超高频 RFID 系统遵循的通信协议一般是<strong>ISO18000-7、ISO18000-6</strong>。</li>
<li>目前国际上与 RFID 相关的通信标准主要有：<strong>ISO&#x2F;IEC 18000 标准、EPC Global标准。</strong></li>
</ol>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ol>
<li>信标：anchor&#x2F;beacon:信标节点是位置信息已知的节点，。信标节点一般所占比例很小，通常通过手工配置或者配备GPS接收器来获取自身的位置信息。</li>
<li>跳数：两个节点之间间隔的跳段总数，称为这两个节点间的跳数。</li>
<li>无线自组织网络:无线自组织网络是一种独立组网的技术，由一组带有无线收发装置的可移动节点组成临时性多跳自治系统。</li>
<li>无线传感器网络(WSN)：无线传感器网络(Wireless Sensor Networks, WSN)是一种分布式传感网络，它的末梢是可以感知和检查外部世界的传感器。WSN中的传感器通过无线方式通信，因此网络设置灵活，设备位置可以随时更改，还可以跟互联网进行有线或无线方式的连接。通过无线通信方式形成的一个多跳自组织网络。 </li>
<li>基带信号:信源（信息源，也称发送端）发出的没有经过调制（进行频谱搬移和变换）的原始电信号，其特点是频率较低，信号频谱从零频附近开始，具有低通形式。根据原始电信号的特征，基带信号可分为数字基带信号和模拟基带信号（相应地，信源也分为数字信源和模拟信源），其由信源决定。</li>
<li>物理信道：物理信道就是实际的物理介质组成的信道,也是物理电路或无线\红外线等,是个物理概念.比如光纤和电话线等就可以组成物理信道. </li>
<li>逻辑信道：逻辑信道一般是指人为定义的信息传输信道。大致比较多，多是一些编码或分成不同的时隙来传送不同的信息。</li>
<li>路由选择：路由选择是指选择通过互连网络从源节点向目的节点传输信息的通道，而且信息至少通过一个中间节点。</li>
<li>路由协议：（Routing protocol）是一种指定数据包转送方式的网上协议。</li>
<li>超宽带（UWB）： 超宽带技术是一种新型的无线通信技术。它通过对具有很陡上升和下降时间的冲激脉冲进行直接调制，使信号具有GHz量级的带宽。</li>
<li>相对时间同步：节点维持其本地时钟的独立运行，动态获取并储存它与其他节点之间的时钟偏移和和时钟漂移，根据这些信息，实现不同节点本地时间值之间的相互转换，达到时间同步的目的。</li>
<li>绝对时间同步：节点的本地时间参考基准并保持时刻一致，因此除了正常的计时过程对节点本地时间进行修改外，节点本地时间也会被时间同步协议所修改。</li>
<li>时钟偏移：或称时钟偏斜，是指时钟信号到达数字电路各个部分所用时间的差异。对于大多数数字集成电路系统，例如计算机系统，各种信号都是根据系统时间脉冲信号的时钟频率进行同步的，这样这些信号就能在相同的步调上工作。</li>
<li>数据融合：数据融合是将多个传感器和信息源的多份数据和信息相关处理，去除冗余数据，组合出更有效、更符合用户需求的数据的过程。</li>
<li>容错技术：容错技术是容忍并防范局部错误的决策方法。</li>
</ol>
<h1 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h1><p>1、以下哪些选项不是无线传感器网络和移动自组织网络之间的区别？( D )<br>A.无线传感器网络通常比移动自组织网络的规模大（节点多）。 B.移动自组织网络更具移动性。<br>C.移动自组织网络的节点通常比无线传感器网络节点有更强大的存储能力。D.无线传感器网络的设计&#x2F;部署成本比移动自组织网络高。</p>
<p>2、以下哪些选项是无线多媒体传感器网络(WMSN）所需要的？( D)<br>A.由于涉及视频&#x2F;音频数据，因此它们需要更大的存储容量。B.它们需要考虑严格的服务质量。<br>C.它们需要高带宽。D.以上都是。</p>
<p>3、关于无线传感器网络定位的描述，以下哪些选项是正确的？(C))<br>A.无线传感器网络通常使用 CPS 进行定位。B.无线传感器网络能轻易达到小于 0.1 米的定位精度。<br>C.无线传感器网络能够使用三角形原理来定位一个节点。D.无线传感器网络定位并不需要时钟同步。</p>
<p>4、 一个传感器节点包括。( D)<br>A.模拟&#x2F;数字传感器芯片 B.无线收发器<br>C. CPU&#x2F;存储器 D.以上全部选项</p>
<p>5、在一个传感器网络中，节点中的能量主要被消耗在（ C）：<br>A.模拟传感部分 B.CPU 对信号处理的本地计算<br>C.无线多跳通信 D.唤醒&#x2F;睡眠切换</p>
<p>6、关于传感器节点的存储器，下面哪项叙述是不正确的？（C ）<br>A.传感器节点只需要少量的数据存储和程序存储器。<br>B.如果数据需要存储较长时间，那么用闪存替代 SRAM 更加高效。<br>C.程序的执行发生在闪存中，而不是在 SRAM 中。<br>D.目前，SRAM 的容量通常小于 1MB。</p>
<p>7、 传感器节点的无线通信有以下哪些特征？（BC）<br>A.低功耗无线通信在接收状态下比发射状态下消耗更多能量。<br>B.无线通信系统的发射距离取决于几个关键因素，最直接的因素是传输功耗。<br>C.目前市面上大部分射频收发器采用基于 VCO 的无线通信体系结构，能够以各种不同的载波频率通信。<br>D.在调幅（AM）方式下编码和解码最为方便。并且不易受噪声影响。</p>
<p>8、以下哪项不是 TRAMA 协议中的状态？（D）<br>A.睡眠状态 B.接收状态 C．传输状态 D．唤醒状态</p>
<p>9、Z-MAC 协议综合了哪两种传统的 MAC 协议？（ D）<br>A. CDMA 和 TDMA B. FDMA 和 CSMA<br>C. CDMA 和 SDMA D. CSMA 和 TDMA</p>
<p>10、下列路由协议哪些是以数据为中心的路由协议？（）<br>A.谣传路由（Rumor Routing)	B. MCFA	C. SPEED	D. GBR</p>
<blockquote>
<p><strong>题目有问题，书本上的只有：SPIN和DD（定向扩散）协议</strong></p>
</blockquote>
<p>11、下列行为中哪些不是用于数据扩散的？（C）<br>A.洪泛(flooding)B.闲聊(gossiping)<br>C.定向传播(directional propagation)D.以上都不是</p>
<p>12、SPIN 协议没有使用哪些数据分组? （C）<br>A. ADV	B. REQ	C. ACK	D. DATA</p>
<p>13、下列哪一项不属于传输层的任务？（A ）<br>A.源节点到目的节点的可靠传输 B.网络拥塞检侧<br>C.网络拥塞避免 D.缓冲区管理</p>
<p>14、为什么无线传感器网络中不能采用 TCP?（D ）<br>A.TCP 在传感器中使用时开销过高<br>B.在无线传输每一跳中积累错误<br>C.TCP 能耗较大<br>D.A 和 B</p>
<p>15、以下哪个原因会导致传感器数据产生噪声？（D ）<br>A.硬件&#x2F;电路噪声 B.运行环境 C.测量误差 D．以上皆是</p>
<p>16、下列关于传感器网络安全的描述中，哪些项是不正确的？（A ）<br>A.密钥管理包括密钥的生成和分发，它是保证传感器网络安全的重要环节。<br>B.传感器网络安全最重要的目标是要保证传输数据的机密性，其他安全目标是次要的。<br>C.传统网络的安全机制由于其计算开销过大而不适用于资源严格受限的传感器网络。<br>D.传感器网络的安全机制在无线传感器节点内占用较少的存储空间(小于 100K<br>字节)</p>
<p>17、下面不属于无线通信信道的是 （A） 。<br>A.光纤	B.自由空间信道	C.加性噪声信道	D.多径信道</p>
<p>18、下面哪些 MAC 层协议是竞争型协议 （ABD）。<br>A.SMAC 协议	B.TMAC 协议	C.SMACS 协议	D.PMAC 协议</p>
<p>19、下面那些 MAC 层协议是分配型 MAC 协议 （BCD）。<br>A.SMAC 协议	B.SMACS 协议	C.DMAC 协议	D.TRAMA 协议</p>
<p>20、下面哪些协议是以数据为中心的路由协议 （A）。<br>A.DD 协议	B.GAF 协议	C.TTDD 协议	D.SPEED 协议</p>
<p>21、下面哪些协议不是地理位置信息路由协议 （B）。<br>A.GPSR 协议	B.TTDD 协议	C.GAF 协议	D.GEAR 协议</p>
<p>22、下列哪一项是超高频 RFID 系统的工作频率范围？（B）<br>A、&lt;150KHz	B、433.92MHz 和 860～960MHz	C、13.56MHz	D、2.45～5.8GHz</p>
<p>23、ISO18000-3、ISO14443 和 ISO15693 这三项通信协议针对的是哪一类 RFID系统？（B）<br>A、低频系统	B、高频系统	C、超高频系统	D、微波系统</p>
<p>24、是电子标签的一个重要组成部分，它主要负责存储标签内部信息，还负责对标签接收到的信号以及发送出去的信号做一些必要的处理。（B）<br>A、天线	B、电子标签芯片	C、射频接口	D、读写模块</p>
<p>25、电子标签正常工作所需要的能量全部是由阅读器供给的，这一类电子标签称为（B）。<br>A、有源标签	B、无源标签	C、半有源标签	D、半无源标签</p>
<p>26、RFID 卡（C）可分为：主动式标签（TTF）和被动式标签（RTF）。<br>A、按供电方式分	B、按工作频率分	C、按通信方式分	D、按标签芯片分</p>
<p>27、下列物联网相关标准中那一个由中国提出的。（C）<br>A、IEEE802.15.4a	B、IEEE802.15.4b	C、IEEE802.15.4c	D、IEEE802.15.4n</p>
<p>28 、数据采集和感知用于采集物理世界中发生的物理事件和数据，主要（ABCD）。<br>A、传感器B、RFID<br>C、二维码<br>D、多媒体信息采集</p>
<p>29、RFID 标签的分类按标签芯片分（ABD）。<br>A、只读（R&#x2F;O）标签B、CPU 标签<br>C、被动式标签（RTF） D、读写（R&#x2F;W）标签</p>
<p>30、移动通信系统包括（ABCD）。<br>A. 无线电话	B. 无线寻呼	C. 陆地蜂窝移动通信	D. 卫星移动通信</p>
<p>31、GSM 系统中信道的频率间隔是（B）。<br>A．1.23MHz	B. 200kHz<br>C. 400kHz	D. 100kHz</p>
<p>32、移动通信中电波的传播方式主要有（ABC）。<br>A. 直射波	B. 反射波	C.地表面波	D. 水平面波</p>
<p>33、 RFID 属于物联网的哪个层 （A）<br>A 感知层	B 网络层	C 业务层	D 应用层</p>
<h1 id="简述题"><a href="#简述题" class="headerlink" title="简述题"></a>简述题</h1><p>1、简述无线网络介质访问控制方法 CSMA&#x2F;CA 的工作原理<br>CSMA&#x2F;CA 机制:当某个站点（源站点）有数据帧要发送时，检测信道。若信道空闲，且在 DIFS 时间内一直空闲，则发送这个数据帧。发送结束后，源站点等待接收 ACK 确认帧。如果目的站点接收到正确的数据帧，还需要等待 SIFS 时间， 然后向源站点发送 ACK 确认帧。若源站点在规定的时间内接收到 ACK 确认帧，则说明没有发生冲突，这一帧发送成功。否则执行退避算法。</p>
<p>2、为什么无线传感器网络需要时间同步，简述 RBS、TPSN 时间同步算法工作原理？<br>在分布式的无线传感器网络应用中，每个传感器节点都有自己的本地时钟。不同节点的晶体振荡器频率存在偏差，以及湿度和电磁波的干扰等都会造成网络节点之间的运行时间偏差。<br>RBS 同步协议的基本思想是多个节点接收同一个同步信号，然后多个收到同步信号的节点之间进行同步。这种同步算法消除了同步信号发送一方的时间不确定性。这种同步协议的缺点是协议开销大.<br>TPSN 协议采用层次型网络结构，首先将所有节点按照层次结构进行分级，然后每个节点与上一级的一个节点进行时间同步，最终所有节点都与根节点时间同步。</p>
<p>3、无线传感器网络体系结构包括哪些部分，各部分的功能分别是什么？<br>无线传感器网络体系结构包括物理层、数据链路层、网络层、传输层和应用层和能量管理平台、移动管理平台和任务管理平台。这些管理平台使得传感器节点能够按照能源高效的方式协同工作，在节点移动的传感器网络中转发数据，并支持多任务和资源共享。</p>
<blockquote>
<p> 物理层负责载波频率的产生、信号的调制解调和无线收发技术。<br> 数据链路层负责数据成帧、帧校验、媒体接入和差错控制。<br> 网络层负责路由的发现与维护，使得传感器节点可以进行有效的数据通信。<br> 传输层负责数据流的传输控制，保证通信服务的质量。<br> 应用层根据不同应用的具体要求，负责任务调度、数据分发等具体业务。<br> 能量管理平台负责管理传感器节点如何使用能源。在各个协议层都需要节省能源。<br> 移动管理平台负责监测并传输传感器节点的移动信息，维护其到汇聚节点的路由，使得传感器节点能动态跟踪邻居节点的位置。<br>任务管理平台负责平衡和调度监测任务。</p>
</blockquote>
<p>4、无线传感器网络的路由协议有哪些类型？路由协议的设计要求？<br>由协议主要分为四类:基于聚簇的路由协议、以数据为中心路由协议、基于地理位置路由协议和能量感知路由协议。现有的无线传感器网络路由协议设计以节能、延长网络生命周期为主要目的。<br>(1)	<strong>QoS 路由</strong>。目前传感器网络路由协议的研究重点主要集中在能量效率上, 而在未来的研究中可能还需要解决由视频和成像传感器以及实时应用引起的<br>QoS 问题。<br>(2)	<strong>支持移动性</strong>。目前的 WSNs 路由协议对网络的拓扑感知能力和移动性的支持比较差,如何在控制协议开销的前提下,支持快速拓扑感知是一个重要挑战。<br>(3)	<strong>安全路由</strong>。由于 WSNs 的固有特性,其路由协议极易受到安全威胁, 是网络攻击的主要目标, 设计简单、有效、适用于 WSNs 的安全机制是今后努力的方向。<br>(4)	<strong>有效功耗</strong>。WSNs 中数据通信最为耗能,今后尽量通过使用数据融合技术、数据传输中采用过滤机制来减少通信量,并通过让各节点平均消耗能量来保持通信量的负载均衡。<br>(5)	<strong>容错性</strong>。由于 WSNs 节点容易发生故障,应尽量利用节点易获得的网络信息计算路由, 以确保在路由出现故障时能够尽快得到恢复,可采用多路径传输来提高数据传输的可靠性。</p>
<p>5、无线传感器网络的路由协议具有哪些特点？<br>（1）能量优先，（2）基于局部拓扑信息（3）以数据为中心（4）应用相关</p>
<p>6、什么是数据融合技术，它在传感器网络中的作用是什么？<br>数据融合是一种多源信息处理技术，它通过对来自同一目标的多源数据进行优化合成，获得比单一信息源更精确、完整的估计或判决。在传感器网络中的作用在于：节省整个网络的能量，增强所收集数据的准确性，提高数据收集效率。</p>
<p>7、 描述 TDoA 测距机制的工作原理。<br>节点同时发射两种不同传播速度的无线信号，接收节点根据两种信号到达的时间差以及这两种信号的传播速度，计算两个节点之间的距离。假设发射节点同时发射无线射频信号和超声波信号，接收节点记录下这两种信号的到达时间为 T1、T2，无线射频信号和超声波信号的传播速度分别为 c1、c2, 那么两点之间的距离为(T2-T1)<em>S，其中 S&#x3D;c1</em>c2&#x2F;(c1-c2)。</p>
<p>8、什么是无线传感器网络？构成无线传感器网络的三个基本要素是什么？<br>答：无线传感器网络是一种全新的信息获取平台，能够实时监测和采集网络分布区域内各种监测对象的数据，并将这些数据发送至网关节点，以实现范围内目标检测，追踪等。特点是快速展开，抗毁强。<br>三个基本要素是：传感器，感知对象，观察者。</p>
<p>9、无线传感器网络能量浪费的途径有哪些？<br>答：数据采集：终端节点在进行数据采集时，需要耗费节点的能量。数据处理：处理器在进行数据处理的过程中需要耗费能量。数据传输：数据传输需要使用终端RF模块，RF模块是节点能量消耗的主要模块。</p>
<p>10、无线传感器网络的网络拓扑结构有哪几种形式？并说明每一种拓扑结构的特点。<br>答：网络的拓扑结构是指网络中各结点之间互联的构形，不同拓扑结构的网络其信道的访问技术，利用率以及信息的延迟、吞吐量、设备开销各不相同，因此分别适用于不同用途的场合。常用的网络拓扑结构有星形、总线形、环形、网状及层次形几种。<br>星形网：它管理网中所有的通道，所以路径选择技术较简单，但它必须具有很高的可靠性，较强的计算能力，一旦中央交换结点机发生了故障，那么整个网络就无法工作。<br>环形网：整个网络采用同一传输介质，使信息很容易在网络中各工作站之间广播式传输。缺点是一个工作站的故障可能导致整个环路工作瘫痪，此外要在环上增加或删除一个工作站要断开环路，中断网络的正常工作。<br>总线网：使用广播式传输方式，大多数使用竞争的方法来使用网络的传输介质。</p>
<p>11、说明无线传感器网络物理层以及网络层的主要功能？<br>答：（1）物理层的网络互连设备为转发器（Repeater），在物理层间实现透明的二进制比特复制，以补偿信号衰减；<br>网络层的网络互连设备为路由器（Router），提供网络层间的协议转换，在不同的网络之间存储转发分组；<br>（2）网络层为建立网络连接和为上层提供服务,应具备以下主要功能：路由选择和中继；激活,终止网络连接；在一条数据链路上复用多条网络连接,多采取分时复用技术；差错检测与恢复；排序,流量控制；服务选择；网络管理；网络层标准简介。</p>
<p>12、什么是 ISM 无线频段？它有什么特点？<br>答：ISM(Industrial Scientific Medical) Band，是由ITU-R （ITU Radiocommunication Sector，国际通信联盟 无线电通信局）定义的。此频段主要是开放给工业、科学、医学三个主要机构使用，属于Free License，无需授权许可，只需要遵守一定的发射功率(一般低于1W)，并且不要对其它频段造成干扰即可。</p>
<p>13、简要说明在无线通信系统中，反射、绕射和散射这三种影响信号传播的基本机制。<br>答：</p>
<p>14、根据信道的分配方式的不同，无线传感器网络的 MAC 协议可以分为哪几种类型？每一种类型的典型协议有哪些？<br>答：时分复用无竞争接入方式、随机竞争接入方式、竞争与固定分配相结合的接入方式。</p>
<p>15、竞争型、分配型和混合型 MAC 协议各有什么特点？<br>答：基于竞争的MAC协议有以下优点：可根据需要分配信道，所以这种协议能较好的满足节点数量和网络负载的变化。能较好的适应网络拓扑的变化。不需要复杂的时间同步或控制调度算法。分配式的无线传感器网络MAC协议有如下优点：无冲突。无隐蔽终端问题。易于休眠，适合于低功耗网络。</p>
<p>16、基于竞争的 MAC 协议基本思想是什么？<br>答：当结点需要发送数据时，通过竞争方式使用无线信道。如果发送的数据产生了碰撞，就按照某种策略重发数据，直到数据发送成功或放弃发送。</p>
<p>17、S-MAC 协议的基本思想是什么？<br>答：当节点不需要发送数据时，尽可能地让它处于功耗较低的睡眠状态</p>
<p>18、简单分析 TRAMA 协议的特点。<br>答：TRAMA 协议在冲突避免、延时、宽带利用率等方面有较好的性能，但协议需要较大的储存空间来储存多跳邻居信息和分配信息。</p>
<p>19、简述典型的混合型 MAC 协议 ZMAC 协议的基本思想和特点。<br>答：基本思想：ZMAC引入了时间帧的概念，每个时间帧又分为若千个时隙。在ZMAC中，网络部署时每个节点都执行时隙分配的DRAND算法。时隙分配结束后，每个节点都会在时间帧中拥有一个时隙。分配时隙的节点称为该时隙的所有者，时隙所有者在对应的时隙中发送数据的优先级更高。<br>特点：1.ZMAC 协议是种混合型 MAC协议，可以根据网络中的信道 竞争情况来动态调整MAC协议所采用的机制，在CSMA和TDMA机制间进行切换。2.在网络数据量较小时， 竞争者较少， 协议工作在 CSMA机制下:在网络数据量较大时，竞争者较多，ZMAC协议工作在TDMA机制下，使用拓扑信息和时钟信息来改善协议性能。3.ZMAC 协议结合了竞争型MAC协议和分配型MAC协议的特点，能很好地适应网络拓扑的变化并提供均衡的网络性能。</p>
<p>20、简述竞争型 MAC 协议和分配型 MAC 协议的优点。<br>答：基于竞争的MAC协议有以下优点：可根据需要分配信道，所以这种协议能较好的满足节点数量和网络负载的变化。能较好的适应网络拓扑的变化。不需要复杂的时间同步或控制调度算法。<br>分配式的无线传感器网络MAC协议有如下优点：无冲突。无隐蔽终端问题。易于休眠，适合于低功耗网络。</p>
<p>21、RFID 系统主要由哪几部分组成？RFID 工作原理是什么。<br>（1）电子标签、读写器、RFID 中间件、应用系统<br>（2）标签进入磁场后，如果接收到阅读器发出的特殊射频信号，就能凭借感应电流所获得的能量发送出存储在芯片中的产品信息（即 Passive Tag，无源标签或被动标签），或者主动发送某一频率的信号（即 Active Tag，有源标签或主动标签），阅读器读取信息并解码后，送至中央信息系统进行有关数据处理。</p>
<p>21、简述目前主流的近距离无线通信技术。<br>答：蓝牙技术、ZigBee技术、超宽带技术UWB、近场通信技术、Wi-Fi技术等。</p>
<p>22、简述目前主流广域网无线通信技术。<br>答：综合业务数字网，帧中继，异步传输模式，数字数据网</p>
<p>24、简述 ZigBee 与 IEEE802.15.4 标准的联系与区别。<br>IEEE802.15.4协议是国际无线电委员会定义的底层通信协议，而ZIGBEE是在底层协议的基础上，增加了一些应用层，网络层应用信息，起到了扩充细化IEEE802.15.4协议的作用！</p>
<p>25、简述与条形码相比 RFID 技术具有的优点<br>（1）可识别单个非常具体的物体。<br>（2）采用无线电射频，可以隔箱扫描<br>（3）可以同时对多个物体进行读识，可以整箱扫描。<br>（4）存储信息量大 可以重复擦写。<br>（5）易于构成网络应用环境</p>
<p>26、什么是 EPC,EPC 编码有何特点，简述 EPC 的好处<br>（1）EPC 的全称是 Electronic Product Code，中文称为产品电子代码。EPC 的载体是 RFID 电子标签，并借助互联网来实现信息的传递。EPC 旨在为每一件单品建立全球的、开放的标识标准，实现全球范围内对单件产品的跟踪与追溯，从而有效提高供应链管理水平、降低物流成本。EPC 是一个完整的、复杂的、综合的系统。<br>（2）编码容量大、兼容性强、应用广泛、具有合理性、国际性<br>（3）EPC 电子标签技术，可以实现数字化库房管理；并配合使用 EPC 编码，使得库存货品真正实现网络化管理。</p>
<p>27、简述目前研究的 MAC 协议并按竞争型、分配性和混合型方式进行分类说明。<br>答：竞争性：当无线节点需要发送数据时，主动抢占无线信道，当在其通信范围内的其他无线节点需要发送数据时，也会发起对无线信道的抢占，这就需要响应的机制来保证任一时刻在通信区域内只有一个无线节点获得信道的使用权。属于竞争型MAC协议包括：SMAC、TMAC、PMAC协议<br>分配型：分配型MAC协议通常采用TDMA(时分多址)、CDMA(码分多址)、FDMA(频分多址)等技术将一个物理信道分为多个子信道，并将子信道静态或动态地分配给需要通信的节点，避免冲突。属于分配型MAC协议包括：SMACS、TRAMA、DMAC<br>混合型：比较有代表性的混合型MAC协议：ZMAC。ZMAC协议是一种混合型MAC协议，此协议对竞争方式和分配方式进行了组合。采用CSMA机制作为基本方法，在竞争加剧时使用TDMA机制来解决信道冲突问题。</p>
<h1 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h1><p>1、 简述无线传感器网络与物联网的关系<br>物联网的概念比传感器网络概念大一些，无线传感器网络是构成物联网感知层和网络层的一部分，是物联网的重要组成部分。</p>
<p>2、 简述物理层的功能<br>主要功能：在一条物理传输媒体上，实现数据链路实体之间透明地传输各种数据的比特流。<br>物理层的功能包括数据的发送与接收、物理能量信道的检测、射频收发器的激活与关闭、空闲信道评估、链路质量指示和物理层属性参数的获取与设置。这些功能是通过物理层服务访问接口来实现的。</p>
<p>3、 模拟调制的调制方式分为：幅度调制AM、频率调制FM、相位调制PM</p>
<p>4、 数字调制的调制方式分为：ASk幅度调制、FSK频率调制、PSK相位调制</p>
<p>5、 MAC层的功能：支持CSMA&#x2F;CA的工作、PAN的建立和维护、关联和解除关联、信标帧的同步</p>
<p>6、 无线传感器网络路由层根据不同的应用将路由协议分为五类：数据为中心的路由协议、分层结构的路由协议、地理信息的路由协议、可靠的路由协议、按需的路由协议</p>
<blockquote>
<p>数据为中心的路由协议：SPIN、DD<br>分层结构的路由协议:LEACH、PEASIS、TTDD、TEEN、APTEEN<br>地理信息的路由协议：GPSR、GAF、LAR、GEAR<br>可靠的路由协议：SPEED<br>按需的路由协议：DSDV、DSR、AODV</p>
</blockquote>
<p>7、 经典的时间同步协议：DMTS、RBS和TPSN</p>
<blockquote>
<p>DMTS：选择一个节点作为时间主节点广播同步时间<br>RBS：用于同步报文的多个接收者，适用于单跳网络和多跳网络<br>TPSN：提供传感器网络全网范围内节点间的时间同步，引入了双向报文交换协议</p>
</blockquote>
<p>8、 数据融合的定义和要点<br>定义在上面名词解析<br>要点：<br>✧数据融合是多信源、多层次的处理过程，每个层次代表信息的不同抽象程度。<br>✧数据融合过程包括数据检测、 关联、估计与合并。<br>✧数据融合的输出 包括低层次上的状态身份估计和高层次上的总战术态势评估。</p>
<p>9、 无线传感器网络时间同步需要重点解决哪些问题？<br>✧如何设计时间同步协议，使得同步精度尽可能高，即同步误差尽可能得小。<br>✧如何设计满足应用需求的低功耗的时间同步协议，以尽可能地延长网络的生命周期。<br>✧如何设计可扩展性强的时间同步协议或算法，以适应不断扩大的网络规模和由此带来的系统动态性的增强。</p>
<p>10、 常见的Zigbee芯片和协议<br>最常见的Zigbee芯片为CX243X系列、CC253X系列、MC1322X系列<br>三种常见的协议栈：</p>
<ol>
<li>非开源协议栈：Freescale、Microchip解决方案</li>
<li>半开源协议栈：ZStack</li>
<li>开源协议栈：Freakz</li>
</ol>
<p>11、 Zigbee的定义<br>Zigbee是一种近距离、低复杂度、低功耗、低成本的双向无线通讯技术，主要用于距离短、功耗低且传输速率不高的各种电子设备之间进行数据传输的应用</p>
<p>12、 Zigbee的特点<br>低功耗、低成本、大容量、可靠、时延短、灵活的网络拓扑结构</p>
<p>13、 RFID工作原理<br>✧由读写器通过发射天线发送特定频率的射频信号。<br>✧当电子标签进入有效工作区域时产生感应电流，从而获得能量，电子标签被激活，使得电子标签将自身编码信息通过内置的射频天线发送出去。<br>✧读写器的接收天线接收到从标签发送来的调制信号，经天线调节器传送到读写器信号处理模块，经解调和解码后将有效信息送至后台主机系统进行相关的处理。<br>✧读写器的应用系统根据逻辑运算识别该标签的身份，针对不同的设定作出相应的处理和控制，最终发出指令信号控制读写器完成相应的读写操作。</p>
<p>14、 GPRS技术的特点<br>高数数据传输、永远在线、按数据流量计费</p>
<p>15、 简述WIFI接入点的网络成员和结构<br>基本服务单元（BSS）、分配系统、站点、接入点、拓展服务单元</p>
<p>16、 网关的特点和功能<br>特点：<br>✧能耗方面: 具有寿命长，高能效、低成本等特点。<br>✧数据处理方面: 具有数据吞吐量大、计算能力、存储能力要求高等特点。<br>✧在通信距离方面: 网关的传输范围比普通的无线传感器网络节点较远，以保证数据传输到外网的监控中心。<br>功能：<br>✧扫描并选定数据传输的物理信道，分配无线传感器网络内的网络，发送广播同步帧，初始化无线传感器网络设备。<br>✧配合无线传感器网络所采用的MAC算法和理由协议，协助节点完成与邻居节点连接的建立和路由的形成。<br>✧对接收数据进行协议转换。<br>✧对从各个节点接收到的数据的具体应用和需求以及当前的带宽，自适应的启动数据融合算法，降低数据冗余度。<br>✧处理来自监控中心的控制命令。</p>
]]></content>
      <categories>
        <category>复习题</category>
      </categories>
      <tags>
        <tag>复习题</tag>
        <tag>无线传感网络</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网安全导论笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>因为我的课程考试内容只有写出缩写单词的全拼、翻译、名词解释、课后题，所以这里只写这些内容。</p>
<span id="more"></span>

<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><h2 id="第一部分-物联网安全概述"><a href="#第一部分-物联网安全概述" class="headerlink" title="第一部分 物联网安全概述"></a>第一部分 物联网安全概述</h2><p>物联网安全需求分析、安全技术框架、密码与身份认证</p>
<ul>
<li>T2T,H2T,H2H: T&#x3D;&gt;Thing, H&#x3D;&gt;Human</li>
<li>DAS: Direct Attached Storage, 直连存储</li>
<li><strong>NAS</strong>: Network Attached Storage, 网络附加存储</li>
<li>SAN: Storage Area Network, 专用存储区域网络</li>
<li>DCM: Device Connect Manage, 结合互联网</li>
<li><strong>PKI</strong>: Public Key Infrastructure, 公共密钥基础设施&#x2F;公开密钥体系</li>
<li>DOS: Denial of Service, 拒绝服务</li>
<li><strong>DDOS</strong>: Distributed Denial of Service, 分布式拒绝服务</li>
<li>AKA: Authentication and Key Agreement, 认证与密钥协商</li>
<li>AC: Asymmetric Cryptography, 非对称密钥密码体系</li>
<li><strong>CA</strong>: Certificate Authority, 证书颁发机构&#x2F;电子签证机关</li>
<li>DSA: Digital Signature Algorithm, 数字签名算法</li>
<li>DEA: Data Encryption Algorithm, 数据加密算法</li>
<li>SET: Secure Electronic Transaction, 安全电子交易协议</li>
<li>PKG: Private Key Generation, 私钥生成中心</li>
<li><strong>RBAC</strong>: Role-Based Access Control, 基于角色的访问控制</li>
<li>ABAC: Attribute Base Access Control, 基于属性的访问控制</li>
<li><strong>DES</strong>: Data Encryption Standard, 数据加密标准</li>
<li><strong>AES</strong>: Advanced Encryption Standard, 高级加密标准</li>
<li><strong>MD5</strong>: Message Digest Algorithm 5, 信息摘要算法第五版</li>
<li><strong>SHA</strong>: Secure Hash Algorithm, 安全散列算法</li>
<li>IDEA: International Data Encryption Algorithm, 国际数据加密算法</li>
<li>MAC: Message authentication code, 消息认证码</li>
<li>asymmetric cryptography: 非对称密码学</li>
<li>digital signature: 数字签名</li>
<li>sniffer: 数据嗅探&#x2F;窃听</li>
</ul>
<h2 id="第二部分-物联网感知识别层安全"><a href="#第二部分-物联网感知识别层安全" class="headerlink" title="第二部分 物联网感知识别层安全"></a>第二部分 物联网感知识别层安全</h2><p>RFID系统安全与隐私、无线传感器网络安全</p>
<ul>
<li><strong>RFID</strong>: Radio Frequency Identification, 射频识别</li>
<li>MITM: Man-in-the-Middle Attack, 中间人攻击</li>
<li><strong>EPC</strong>: Electronic Product Code, 产品电子代码</li>
</ul>
<h2 id="第三部分-物联网网络构建层安全"><a href="#第三部分-物联网网络构建层安全" class="headerlink" title="第三部分 物联网网络构建层安全"></a>第三部分 物联网网络构建层安全</h2><p>无线通信网络安全、互联网网络安全</p>
<ul>
<li><strong>WLAN</strong>: Wireless Local Area Network, 无线局域网</li>
<li><strong>WAP</strong>: Wireless Application Protocol, 无线应用协议</li>
<li>WML: Wireless Markup Language, 无线标记语言</li>
<li><strong>SSID</strong>: Service Set Identifier, 服务集标识</li>
<li>WEP: Wired Equivalent Privacy, 有线等效保密</li>
<li><strong>UWB</strong>: Ultra Wide Band, 超宽带</li>
<li>IPSec: Internet Protocol Security</li>
<li>IKE: Internet key exchange, 网络密钥交换</li>
<li><strong>SA</strong>: Security Association, 安全联盟</li>
<li><strong>VPN</strong>: Virtual Private Network, 虚拟专用网络</li>
<li><strong>QoS</strong>: Quality of Service, 服务质量</li>
<li>RFC: Request For Comments, 请求注解</li>
<li><strong>SSL</strong>: Secure Sockets Layer, 安全套接字协议</li>
<li><strong>TLS</strong>: Transport Layer Security, 安全传输层协议</li>
<li>WTLS: Wireless Transport Layer Security, 无线传输层协议</li>
<li><strong>SSH</strong>: Secure Shell, 安全外壳协议</li>
</ul>
<h2 id="第四部分-物联网管理服务层安全"><a href="#第四部分-物联网管理服务层安全" class="headerlink" title="第四部分 物联网管理服务层安全"></a>第四部分 物联网管理服务层安全</h2><p>中间件与云计算安全</p>
<ul>
<li><strong>OLTP</strong>: on-line transaction processing, 联机事务处理</li>
<li><strong>OLAP</strong>: On-Line Analytical Processing, 翻译为联机分析处理</li>
<li>ESB: Enterprise Service Bus, 企业服务总线</li>
<li>TPM: Transaction Processing Monitor, 事务处理监控器</li>
<li>DCE: Distributed Computing Environment, 分布式计算环境</li>
<li><strong>RPC</strong>: Remote Procedure Call, 远程过程调用</li>
<li>ORB: Object Request Broker, 对象请求代理</li>
<li><strong>API</strong>: Application Programming Interface, 应用程序接口</li>
<li>SaaS: Software-as-a-Service, 软件即服务</li>
<li>PaaS: Platform as a Service, 平台即服务</li>
<li>IaaS: Infrastructure as a Service, 基础设施即服务</li>
<li><strong>DDBS</strong>: Distributed Database System, 分布式数据库</li>
</ul>
<blockquote>
<p>拓展一下CaaS、FaaS,分别代表Container，Function，容器即服务、函数即服务</p>
</blockquote>
<h2 id="第五部分-互联网综合应用层安全"><a href="#第五部分-互联网综合应用层安全" class="headerlink" title="第五部分 互联网综合应用层安全"></a>第五部分 互联网综合应用层安全</h2><p>信息隐蔽技术、位置信息与隐私保护</p>
<ul>
<li>LSB: Least Significant Bit, 最低有效位&#x2F;最低比特位替换</li>
<li><strong>LBS</strong>: Location Based Services, 基于位置的服务</li>
<li>PPV: Pay-Per-View</li>
<li>VOD: Video on Demand</li>
<li><strong>GSM</strong>: Global System for Mobile Communications, 全球移动通信系统</li>
<li><strong>CDMA</strong>: Code Division Multiple Access, 码分多址</li>
<li>GIS: Geographic Information System, 地理信息系统</li>
<li>PSAP: Public Safety Access Point, 公共安全应答点</li>
<li>AOA: Angle-of-Arrival, 到达角度测距</li>
<li>TDOA: Time Difference of Arrival, 到达时间差</li>
<li>MLC: Mobile Location Centre, 移动定位中心</li>
<li>SMC: Secure Multi-Party Computation, 安全多方计算</li>
</ul>
<h2 id="第六部分-物联网安全标准和安全体系"><a href="#第六部分-物联网安全标准和安全体系" class="headerlink" title="第六部分 物联网安全标准和安全体系"></a>第六部分 物联网安全标准和安全体系</h2><ul>
<li><strong>ISO</strong>: International Organization for Standardization, 国际标准化组织</li>
<li><strong>ITU</strong>: International Telecommunication Union, 国际电信联盟 </li>
<li><strong>IETF</strong>: The Internet Engineering Task Force, 国际互联网工程任务组</li>
<li>CCSA: China Communications Standards Association, 中国通信标准化协会</li>
</ul>
<h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><ol>
<li>数据加密：数据加密是计算机系统对信息进行保护的一种最可靠的方法，它利用密码技术对信息进行交换，实现信息隐蔽，从而保护信息的安全。</li>
<li>数据融合安全：无线传感器网络中有大量的节点, 会产生大量的数据。如何把这些数据进行分类,集合出在网络中传输的有效数据并进行数据身份认证是数据融合安全所要解决的问题。 </li>
<li>对称密钥：（私钥加密）即信息的发送方和接收方用同一个秘钥去加密和解密数据。只有发送方和接收方才知道这一密钥。它的最大优势是加&#x2F;解密速度快，适合于对大数据量进行加密，但密钥管理困难。</li>
<li>非对称密钥：（公钥密钥加密）它需要使用不同的秘钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。</li>
<li>VPN：虚拟专网指依靠ISP和其他NSP（网络服务提供者）在公用网络（如Internet、Frame Relay、ATM）建立专用的数据通信网络的技术。</li>
<li>数字证书：（数字凭证）使用电子手段来证实一个用户的身份和对网络资源的访问权限。数字证书就是一个数字文件，通常由四个部分组成：第一是证书持有人的姓名、地址等关键信息；第二是证书持有人的公开密钥；第三是证书序号、证书的有效期限；第四是发证单位的数字签名。</li>
<li>数字签名：指通过一个单向函数对传送的报文进行处理得到的，是一个用以认证报文来源并核实报文是否发生变化的一个字母数字串。用于提供服务不可否认性的安全机制。</li>
<li>数字水印：是将一些标识信息（即数字水印）直接嵌入数字载体（包括多媒体、文档和软件等）当中，但不影响原载体的使用价值，也不容易被人的知觉系统（如视觉或听觉系统）觉察或注意到。</li>
<li>CA：电子签证机关，是采用PKI公开密钥技术，专门提供网络身份认证服务，负责签发和管理数字证书，且具有权威性和公正性的第三方信任机构，它的作用就像颁发证件的部门，如护照办理机构。</li>
<li>PKI：公钥基础设施，是一种遵循既定标准的密钥管理平台，它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。</li>
<li>隧道技术：隧道技术是VPN的基本技术，类似于点对点连接技术。它在公用网建立一条数据通道（隧道），让数据包通过这条隧道传输。</li>
<li>防火墙：防火墙是由软件和硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实现接入控制策略，阻挡来自外部通过网络对本网络的威胁和入侵。</li>
<li>安全路由：由于传感器网络中许多路由协议相对简单，更易受到攻击，所以常常采用安全路由来增加网络的安全性。</li>
<li>时空匿名：将一个用户的位置通过在时间和空间轴上扩展，变成一个时空区域，达到匿名的效果。</li>
<li>法拉第笼：是一个由金属网或金属薄片制成的容器, 使得某一频段的无线电信号无法穿透，用于静电屏蔽。</li>
<li>身份验证：身份验证是指通过一定的手段完成对用户身份的确认。身份验证的目的是确认当前声称为某种身份的用户确实是所声称的用户。</li>
<li>身份认证：通过检测双方拥有什么或者知道什么来确定同性双方的身份是否合法。</li>
<li>隐蔽信道：在多级安全水平的系统环境中，那些既不是专门设计的也不打算用来传输信息的通信路径。</li>
<li>访问控制：按用户身份及其所归属的某预设的定义组限制用户对某些信息项的访问，或限制对某些控制功能的使用。</li>
<li>污水池攻击：攻击者通过声称自己电源充足、性能可靠且尬笑，使泄密节点在路由算法上对周围节点具有特别的吸引力，吸引周围的节点选择它作为路由路径中的点，引诱该区域几乎所有的数据流通过该泄密节点。</li>
<li>入侵检测系统（IDS）：是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。</li>
<li>DMA：直接存储器访问，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。</li>
<li>Hash函数：散列算法也叫哈希算法，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>
</ol>
<h1 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="概要说明物联网安全的逻辑层次"><a href="#概要说明物联网安全的逻辑层次" class="headerlink" title="概要说明物联网安全的逻辑层次"></a>概要说明物联网安全的逻辑层次</h3><p>底层是用来信息采集的感知识别层，中间层是数据传输的网络构建层，顶层则是包括管理服务层和综合应用层的应用&#x2F;中间件层</p>
<h3 id="物联网面对的特殊安全问题有哪些？"><a href="#物联网面对的特殊安全问题有哪些？" class="headerlink" title="物联网面对的特殊安全问题有哪些？"></a>物联网面对的特殊安全问题有哪些？</h3><ol>
<li>物联网机器&#x2F;感知节点的本地安全问题</li>
<li>感知网络的传输与信息安全问题</li>
<li>核心网络的传输与信息安全问题</li>
<li>物联网业务的安全问题</li>
</ol>
<h3 id="感知识别层可能遇到的安全挑战包括哪几种情况？"><a href="#感知识别层可能遇到的安全挑战包括哪几种情况？" class="headerlink" title="感知识别层可能遇到的安全挑战包括哪几种情况？"></a>感知识别层可能遇到的安全挑战包括哪几种情况？</h3><ol>
<li>网关节点被敌手控制—安全性全部丢失； </li>
<li>普通节点被敌手控制（敌手掌握节点密钥）； </li>
<li>普通节点被敌手捕获（但由于没有得到节点密钥，而没有被控制）； </li>
<li>节点（普通节点或网关节点）受来自于网络的DOS攻击； </li>
<li>接入到物联网的超大量节点的标识、识别、认证和控制问题。</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="电子签证机关（CA）的概念是什么？"><a href="#电子签证机关（CA）的概念是什么？" class="headerlink" title="电子签证机关（CA）的概念是什么？"></a>电子签证机关（CA）的概念是什么？</h3><p>CA是采用PKI（公开密钥体系）公开密钥技术，专门提供网络身份认证服务，负责签发和管理数字证书，且具有权威性和公正性的第三方信任机构。</p>
<h3 id="物联网中的加密机制实施是的主要困难是什么？"><a href="#物联网中的加密机制实施是的主要困难是什么？" class="headerlink" title="物联网中的加密机制实施是的主要困难是什么？"></a>物联网中的加密机制实施是的主要困难是什么？</h3><p>感知层的节点上要运行一个加密&#x2F;解密程序不仅需要存储开销、高速的CPU，而且还要消耗节点的能量</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="什么是非对称加密（即公开密钥系统，简称公钥）？"><a href="#什么是非对称加密（即公开密钥系统，简称公钥）？" class="headerlink" title="什么是非对称加密（即公开密钥系统，简称公钥）？"></a>什么是非对称加密（即公开密钥系统，简称公钥）？</h3><p>非对称密钥密码体系也称公开密钥技术。需要两个密钥：公开密钥和私有密钥，相对于对称密钥密码体系，最大的特点在于加密和解密使用不同的密钥。</p>
<h3 id="简述数字签名的概念及应用"><a href="#简述数字签名的概念及应用" class="headerlink" title="简述数字签名的概念及应用"></a>简述数字签名的概念及应用</h3><p>数字签名是指通过一个单向函数对传送的报文进行处理得到的，是一个用以认证报文来源并核实报文是否发生变化的一个字母数字串。<br>数字签名的作用就是了为了鉴别文件或书信真伪，签名起到认证、生效的作用。</p>
<h3 id="电子ID身份识别主要有哪几种方式？"><a href="#电子ID身份识别主要有哪几种方式？" class="headerlink" title="电子ID身份识别主要有哪几种方式？"></a>电子ID身份识别主要有哪几种方式？</h3><ol>
<li>通行字识别方式   </li>
<li>持证的方式</li>
</ol>
<h3 id="基于零知识证明的识别技术原理是什么？"><a href="#基于零知识证明的识别技术原理是什么？" class="headerlink" title="基于零知识证明的识别技术原理是什么？"></a>基于零知识证明的识别技术原理是什么？</h3><p>零知识证明的基本思想是向别人证明你知道某种事物或具有某种东西，而且别人并不能通过你的证明知道这个事物或这个东西，也就是不泄露你掌握的这些信息。<br>零知识证明是这样一种技术，即当示证者P掌握某些秘密信息，P设法向验证者V证明自己掌握这些信息，验证者V可以验证P是否真的掌握这些秘密信息,但同时P又不想让V也知道那些信息。</p>
<h3 id="物联网密钥管理流程有哪些步骤？"><a href="#物联网密钥管理流程有哪些步骤？" class="headerlink" title="物联网密钥管理流程有哪些步骤？"></a>物联网密钥管理流程有哪些步骤？</h3><p>①密钥生成、②密钥分发、③验证密钥、④更新密钥、⑤密钥存储、⑥备份密钥、⑦密钥有效期、⑧销毁密钥、⑨密钥管理</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="RFID攻击模式有哪几种？"><a href="#RFID攻击模式有哪几种？" class="headerlink" title="RFID攻击模式有哪几种？"></a>RFID攻击模式有哪几种？</h3><p>①窃听、②中间人攻击、③欺骗、重放、和克隆、④拒绝服务攻击、⑤物理破解、⑥篡改信息、⑦RFID病毒 </p>
<h3 id="RFID技术中有哪些隐私问题？其保护措施是什么？"><a href="#RFID技术中有哪些隐私问题？其保护措施是什么？" class="headerlink" title="RFID技术中有哪些隐私问题？其保护措施是什么？"></a>RFID技术中有哪些隐私问题？其保护措施是什么？</h3><p>位置隐私和信息隐私。<br>保护措施：</p>
<ol>
<li>在制定RFID技术标准时就考虑隐私保护问题</li>
<li>在商业零售中RFID标签可自由除去</li>
<li>对识别权力进行限制</li>
<li>电子标签改为可读写式</li>
</ol>
<h3 id="如何使用物理途径来保护RFID标签的安全性？"><a href="#如何使用物理途径来保护RFID标签的安全性？" class="headerlink" title="如何使用物理途径来保护RFID标签的安全性？"></a>如何使用物理途径来保护RFID标签的安全性？</h3><ol>
<li>静电屏蔽  </li>
<li>阻塞标签  </li>
<li>主动干扰   </li>
<li>改变阅读器频率  </li>
<li>Kill命令机制</li>
</ol>
<h3 id="如何采用密码机制解决RFID的安全问题？举两三个例子对RFID安全协议进行说明。"><a href="#如何采用密码机制解决RFID的安全问题？举两三个例子对RFID安全协议进行说明。" class="headerlink" title="如何采用密码机制解决RFID的安全问题？举两三个例子对RFID安全协议进行说明。"></a>如何采用密码机制解决RFID的安全问题？举两三个例子对RFID安全协议进行说明。</h3><p>利用成熟的密码方案和机制来设计和实现符合RFID安全需求的密码协议 </p>
<ol>
<li>哈希锁（Hash-Lock）协议  </li>
<li>随机哈希锁(randomized hash-lock)协议 </li>
<li>Hash链协议</li>
</ol>
<h3 id="RFID认证通信协议"><a href="#RFID认证通信协议" class="headerlink" title="RFID认证通信协议"></a>RFID认证通信协议</h3><p>基于 RFID 认证协议的解决方案着重于设计适合标签执行的(超)轻量级认证协议。这些协议支持伪随机数生成器(PRNG)、单向哈希函数(HASH)、循环冗余校验码(CRC: Cyclic Redundancy Check)和简单比特位运算，如：异或、与、或等操作。</p>
<h3 id="RFID系统通信模型："><a href="#RFID系统通信模型：" class="headerlink" title="RFID系统通信模型："></a>RFID系统通信模型：</h3><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/rfid1.png" class="">

<h3 id="M1卡三重认证"><a href="#M1卡三重认证" class="headerlink" title="M1卡三重认证"></a>M1卡三重认证</h3><p>M+k的三轮认证（三重认证）是保障M1-k安全的重要手段，读卡器M1卡的读写操作必须n过三轮验证，在该程中M1和读卡器相互发送验证信息来验证密钥，并且该过程也同样被加密。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/rfid2.png" class="">

<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="无线传感器网络的攻击形式有哪几种"><a href="#无线传感器网络的攻击形式有哪几种" class="headerlink" title="无线传感器网络的攻击形式有哪几种?"></a>无线传感器网络的攻击形式有哪几种?</h3><ol>
<li>虚假路由信息</li>
<li>选择性的转发</li>
<li>污水池(sinkhole)攻击</li>
<li>Sybil攻击</li>
<li>蠕虫洞(wormholes)攻击</li>
<li>Hello洪泛攻击</li>
<li>选择性转发</li>
<li>DOS攻击</li>
</ol>
<h3 id="绘图描述无线传感器网络安全体系结构"><a href="#绘图描述无线传感器网络安全体系结构" class="headerlink" title="绘图描述无线传感器网络安全体系结构"></a>绘图描述无线传感器网络安全体系结构</h3><img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/wsn1.png" class="">

<h3 id="如何采用安全路由来增加网络的安全性-有哪些常用的方法"><a href="#如何采用安全路由来增加网络的安全性-有哪些常用的方法" class="headerlink" title="如何采用安全路由来增加网络的安全性?有哪些常用的方法?"></a>如何采用安全路由来增加网络的安全性?有哪些常用的方法?</h3><p>安全路由常用方式：</p>
<ol>
<li>网络中加入容侵策略，提高物联网的安全性。</li>
<li>用多径路由选择的方法抵御选择性转发攻击。</li>
<li>在路由设计中加入广播半径限制抵御泛洪攻击。</li>
<li>在路由设计中加入安全等级策略抵御虫洞攻击和陷洞攻击。</li>
</ol>
<h3 id="什么是无线传感器网络中的数据融合安全和数据认证"><a href="#什么是无线传感器网络中的数据融合安全和数据认证" class="headerlink" title="什么是无线传感器网络中的数据融合安全和数据认证?"></a>什么是无线传感器网络中的数据融合安全和数据认证?</h3><p>无线传感器网络中有大量的节点，会产生大量的数据。如何把这些数据进行分类，集合出在网络中传输的有效数据，并进行数据身份认证，是数据融合安全所要解决的问题。<br>数据认证是无线传感器网络安全的基本要求之一。网络中的消息在传输之前都要强制认证，否则敌手能够轻松地将伪造的消息包注人网络，从而耗尽传感器能量，使整个网络瘫痪。</p>
<h3 id="什么是ZigBee信任中心-它能提供哪几种功能"><a href="#什么是ZigBee信任中心-它能提供哪几种功能" class="headerlink" title="什么是ZigBee信任中心?它能提供哪几种功能?"></a>什么是ZigBee信任中心?它能提供哪几种功能?</h3><p>所谓信任中心是在网络中分配安全密钥的一种令人信任的设备,它允许设备加人网络。并分配密钥，因而确保设备之 间端到端的安全性。在采用安全机制的网络中，网络协调者可成为信任中心。信任中心提供3种功能:</p>
<ol>
<li>信任管理。任务是负责对加入网络的设备验证。</li>
<li>网络管理。任务是负责获取和分配网络密钥给设备。</li>
<li>配置管理。任务是确保端到端设备的安全。</li>
</ol>
<h3 id="为了满足安全性需要-ZigBee标准使用哪几种方法来确保安全"><a href="#为了满足安全性需要-ZigBee标准使用哪几种方法来确保安全" class="headerlink" title="为了满足安全性需要,ZigBee标准使用哪几种方法来确保安全?"></a>为了满足安全性需要,ZigBee标准使用哪几种方法来确保安全?</h3><ol>
<li>加密技术：ZigBee使用AES-128加密算法。</li>
<li>鉴权技术：保证信息的原始性，使得信息不被第三方攻击。</li>
<li>完整性保护：</li>
<li>帧序更新：通过设置计数器来保证数据更新，通过使用一个有序编号来避免帧重发攻击。</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="无线通信网络中的不安全因素主要有哪几个方面"><a href="#无线通信网络中的不安全因素主要有哪几个方面" class="headerlink" title="无线通信网络中的不安全因素主要有哪几个方面?"></a>无线通信网络中的不安全因素主要有哪几个方面?</h3><ol>
<li>无线窃听</li>
<li>假冒攻击</li>
<li>信息篡改</li>
<li>服务后抵赖</li>
<li>重传攻击</li>
</ol>
<h3 id="简述WAP应用面临的安全威胁。"><a href="#简述WAP应用面临的安全威胁。" class="headerlink" title="简述WAP应用面临的安全威胁。"></a>简述WAP应用面临的安全威胁。</h3><ol>
<li>假冒</li>
<li>窃听</li>
<li>非授权访问</li>
<li>信息否认</li>
<li>WAP应用模型本身存在的安全漏洞</li>
</ol>
<h3 id="无线网络安全技术的实现措施有哪几种"><a href="#无线网络安全技术的实现措施有哪几种" class="headerlink" title="无线网络安全技术的实现措施有哪几种?"></a>无线网络安全技术的实现措施有哪几种?</h3><ol>
<li>采用128位WEP加密技术，不使用厂商自带的WEP密钥</li>
<li>使用MAC地址过滤策略</li>
<li>禁用SSID广播</li>
<li>采用端口访问技术进行控制，防止非授权的非法接入和访问</li>
<li>对于密度等级高的网络采用VPN进行连接</li>
</ol>
<h3 id="简述UWB面临的信息安全威胁。"><a href="#简述UWB面临的信息安全威胁。" class="headerlink" title="简述UWB面临的信息安全威胁。"></a>简述UWB面临的信息安全威胁。</h3><ol>
<li>拒绝服务攻击</li>
<li>密钥泄露</li>
<li>假冒攻击</li>
<li>路由攻击</li>
</ol>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="网络安全攻击的形式有哪几种"><a href="#网络安全攻击的形式有哪几种" class="headerlink" title="网络安全攻击的形式有哪几种?"></a>网络安全攻击的形式有哪几种?</h3><ol>
<li>中断：以可用性作为攻击目标，它毁坏系统资源，使网络不可使用。</li>
<li>截获：以保密性作为攻击目标，非授权用户通过某种手段获得对系统资源的访问。</li>
<li>篡改：以完整性作为攻击目标，非授权用户不仅获得访问而且对数据进行修改。</li>
<li>伪造：以完整性作为攻击目标，非授权用户将伪造的数据插入到正常传输的数据中。</li>
</ol>
<h3 id="分别简述包过滤防火墙、代理服务器防火墙和状态监视器防火墙的技术原理。"><a href="#分别简述包过滤防火墙、代理服务器防火墙和状态监视器防火墙的技术原理。" class="headerlink" title="分别简述包过滤防火墙、代理服务器防火墙和状态监视器防火墙的技术原理。"></a>分别简述包过滤防火墙、代理服务器防火墙和状态监视器防火墙的技术原理。</h3><ol>
<li>包过滤防火墙：通过在网络中的适当位置对数据包进行过滤，根据检查数据流中每个数据包的源地址、目的地址、所有的TCP端口号和TCP链路状态等要素，然后依据一组预定义的规则，以允许合乎逻辑的数据包通过防火墙进入到内部网络，而将不合乎逻辑的数据包加以删除</li>
<li>代理服务器防火墙：其运行在两个网络之间，当代理服务器接收到用户的请求后，会检查用户请求的站点是否符合公司的要求，如果公司允许用户访问该站点，代理服务器会像一个客户一样去该站点取回所需信息，再转发给客户。</li>
<li>状态监视器防火墙：安全特性较好。采用了一个在网关上执行网络安全策略的软件引擎，称为检测模块。检测模块在不影响网络正常工作的前提下，采用抽取相关数据的方法对网络通信的各层实施检测，抽取部分数据，即状态信息，并动态地保存起来，作为以后指定安全策略的参考。</li>
</ol>
<h3 id="什么是IPSec安全协议-IPSec-协议的特点是什么"><a href="#什么是IPSec安全协议-IPSec-协议的特点是什么" class="headerlink" title="什么是IPSec安全协议? IPSec 协议的特点是什么?"></a>什么是IPSec安全协议? IPSec 协议的特点是什么?</h3><p>IPSec(IP Scourin)是IETF制定的三层隧道加密协议，它为Intemet上传输的数据提供了高质量的、可互操作的、基于密码学的安全保证。特定的通信万之间在IP层通过加密与数据源认证等方式提供了以下的安全服务。</p>
<ol>
<li>数据机密性(confidentiality): IPSec发送方在通过网络传输包前对包进行加密。</li>
<li>数据完整性(data integrity): IPSec 接收方对发送方发送来的包进行认证，以确保数据在传输过程中没有被篡改。</li>
<li>数据来源认证(datalauthentication): IPSec在接收端可以认证发送IPSec报文的发送端是否合法。</li>
<li>防重放(anti replay): IPSec接收方可检测并拒绝接收过时或重复的报文。</li>
</ol>
<h3 id="VPN主要采用哪4项技术来保证安全"><a href="#VPN主要采用哪4项技术来保证安全" class="headerlink" title="VPN主要采用哪4项技术来保证安全?"></a>VPN主要采用哪4项技术来保证安全?</h3><ol>
<li>隧道技术</li>
<li>加解密技术</li>
<li>密钥管理技术</li>
</ol>
<h3 id="为防止黑客攻击，通常可以使用哪几种防范措施"><a href="#为防止黑客攻击，通常可以使用哪几种防范措施" class="headerlink" title="为防止黑客攻击，通常可以使用哪几种防范措施?"></a>为防止黑客攻击，通常可以使用哪几种防范措施?</h3><p>p203</p>
<h2 id="第八章之后"><a href="#第八章之后" class="headerlink" title="第八章之后"></a>第八章之后</h2><h3 id="信息加密和隐藏可以分为哪3种模式？"><a href="#信息加密和隐藏可以分为哪3种模式？" class="headerlink" title="信息加密和隐藏可以分为哪3种模式？"></a>信息加密和隐藏可以分为哪3种模式？</h3><ol>
<li>信息加密模式</li>
<li>信息隐藏模式</li>
<li>信息加密与隐藏模式</li>
</ol>
<h3 id="绘图说明信息隐藏的通用模型。"><a href="#绘图说明信息隐藏的通用模型。" class="headerlink" title="绘图说明信息隐藏的通用模型。"></a>绘图说明信息隐藏的通用模型。</h3><p>被隐藏的信息称为秘密信息，如版权信息、秘密数据和软件序列号等。而用于隐藏秘密信息的公开消息称为载体信息，如视频、图片、音频和文本文件等</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/xxyc1.png" class="">

<h3 id="数据隐写术可以分为哪几类？"><a href="#数据隐写术可以分为哪几类？" class="headerlink" title="数据隐写术可以分为哪几类？"></a>数据隐写术可以分为哪几类？</h3><ol>
<li>替换系统</li>
<li>变换域技术</li>
<li>扩展频谱技术</li>
<li>统计方法</li>
<li>失真技术</li>
<li>载体生成方法</li>
</ol>
<h3 id="数字水印具有哪些特点？主要应用于哪些领域？"><a href="#数字水印具有哪些特点？主要应用于哪些领域？" class="headerlink" title="数字水印具有哪些特点？主要应用于哪些领域？"></a>数字水印具有哪些特点？主要应用于哪些领域？</h3><p>特点：</p>
<ol>
<li>有效性</li>
<li>逼真度</li>
<li>数据容量</li>
<li>盲检测与明检测</li>
<li>虚检率</li>
<li>鲁棒性</li>
<li>安全性</li>
</ol>
<p>应用领域：</p>
<ol>
<li>版权保护</li>
<li>广播监视</li>
<li>操作跟踪</li>
<li>内容认证</li>
<li>访问控制</li>
<li>指纹</li>
<li>内容标志</li>
<li>防伪</li>
</ol>
<h3 id="LBS系统由哪些部分组成？"><a href="#LBS系统由哪些部分组成？" class="headerlink" title="LBS系统由哪些部分组成？"></a>LBS系统由哪些部分组成？</h3><p>一个完整的LBS系统主要由空间定位系统、位置服务中心、通信网络和移动终端等部分组成。</p>
<ol>
<li>移动终端</li>
<li>无线网络</li>
<li>定位平台</li>
<li>提供位置服务的服务器</li>
<li>提供位置服务的应用程序</li>
<li>与位置信息相关的内容</li>
</ol>
<h3 id="简述隐私的定义"><a href="#简述隐私的定义" class="headerlink" title="简述隐私的定义"></a>简述隐私的定义</h3><p>隐私就是个人和机构等实体不愿意被外部世界知晓的消息，在具体应用中，隐私为数据所有者不愿意被披露的敏感消息，包括敏感数据以及数据所表征的特性。通常我们所说的隐私都指敏感数据，如个人的薪资、病人的患病记录、公司的财务信息等。</p>
<h3 id="简要说明侵犯网络隐私权的主要技术手段。"><a href="#简要说明侵犯网络隐私权的主要技术手段。" class="headerlink" title="简要说明侵犯网络隐私权的主要技术手段。"></a>简要说明侵犯网络隐私权的主要技术手段。</h3><ol>
<li>利用在线注册收集隐私消息</li>
<li>利用IP地址跟踪用户的位置或行踪</li>
<li>利用Cookie文件手机用户的隐私信息</li>
<li>利用特洛伊木马病毒窃取隐私信息</li>
<li>利用嵌入式软件手机隐私信息</li>
<li>利用Web Beacon窃取隐私信息</li>
<li>利用篡改网页收集隐私消息</li>
</ol>
<h3 id="说明位置服务与隐私保护的关系。"><a href="#说明位置服务与隐私保护的关系。" class="headerlink" title="说明位置服务与隐私保护的关系。"></a>说明位置服务与隐私保护的关系。</h3><p>隐私保护不是指要保护用户的个人信息不被他人使用，而是指用户对个人信息进行有效控制的权利。位置信息是一种特殊的个人隐私信息，对其进行保护就是要给予所涉及的个人决定和控制自己所处位置的信息何时、如何及在何种程度上被他人获知的权利。</p>
<h3 id="简述LBS中的3种基本的隐私保护方法"><a href="#简述LBS中的3种基本的隐私保护方法" class="headerlink" title="简述LBS中的3种基本的隐私保护方法"></a>简述LBS中的3种基本的隐私保护方法</h3><ol>
<li>假位置：通过制造假位置达到以假乱真的效果。</li>
<li>时空匿名：将一个用户的位置通过在时间和空间轴上扩展，变成一个时空区域，达到	匿名效果。</li>
<li>空间加密：通过对位置加密达到匿名效果。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>物联网</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库与数据挖掘学习笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>一些可能会考是知识点和例题。</p>
<span id="more"></span>

<h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><ul>
<li>数据仓库：数据仓库是一个面向主题的、集成的、相对稳定的、反映历史变化的数据集合，通常用于辅助决策支持。</li>
<li>数据挖掘：数据挖掘就是从大量数据中获取有效的、新颖的、潜在有用的、最终可理解的模式的过程。简单的说，数据挖掘是从大量数据中提取或“挖掘”知识，又被称为数据库中的知识发现。</li>
<li>元数据：元数据是描述数据仓库内数据的结构和建立方法的数据。</li>
<li>操作型数据：操作型数据:通常存储在遍及组织的各种不同的操作型记录系统中(如业务计费系统、供应链系统等)。</li>
<li>调和数据:存储在企业级数据仓库和操作型数据存储中。调和数据是详细的、当前的数据，对所有决策支持应用来说，调和数据是单一的、权威的数据源。</li>
<li>导出数据:存储在各个数据集市中。对终端用户的决策支持应用来说，导出数据是已选择的、格式化了的聚集数据。</li>
<li>当前数据：（保留的最新数据）只反映当前最新值，但现存的最新记录将改变以前记录中的数据，当前数据中不保存以前的记录内容。</li>
<li>周期数据：（保留的历史数据）一旦保存，物理上就不再改变或删除。</li>
<li>元数据：描述数据仓库内数据的结构和建立方法的数据，是描述数据的数据。</li>
<li>技术元数据：技术元数据是数据仓库的设计和管理人员用于开发和管理数据仓库时使用的元数据，包括数据源信息、数据转换的描述等。</li>
<li>业务元数据：业务元数据从单位业务的角度描述数据仓库的元数据，比如业务主体的描述，即业务主体包含的数据、查询及报表等信息。 </li>
<li>数据集市：数据集市是为了特定的应用目的，从数据仓库中独立出来的一部分数据，也称为部门数据或主题数据。</li>
<li>数据挖掘就是从大量数据中获取有效的、新颖的、潜在有用的、最终可理解的模式的过程。</li>
<li>数据ETL：用来实现异构数据源的数据集成，即完成数据的抓取、清洗、转换、加载和索引等调和工作。</li>
<li>数据抽取：从源文件和源数据库中获取相关数据用于填充数据仓库,称为抽取。</li>
<li>数据转换：把数据从业务系统的格式转换成企业数据仓库的数据格式。</li>
<li>E-R：E-R图描述的是主题以及主题之间的联系。</li>
<li>关联：若两个或多个变量的取值之间存在某种规律性，就称为关联。</li>
<li>关联规则(Association Rule)可以表示为一个蕴含式：R: X&#x3D;&gt;Y。R表示:如果项集X在某一交易中出现，则会导致项集Y按照某一概率也会在同一交易中出现，X称为规则的条件，Y称为规则的结果</li>
<li>操作数据存储ODS是一个面向主题的、集成的、企业级的、当前的、详细的、快速更新的数据库，常被用作数据仓库临时区域的数据库</li>
<li>分类：指把数据样本映射到一个事先定义的类中的学习过程，即给定一组输入的属性向量及其对应的类，用基于归纳的学习算法得出分类</li>
<li>决策树学习是以实例为基础的归纳学习算法，从一组无次序、无规则的实例中推理出以决策树表示的分类规则</li>
</ul>
<h1 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h1><h2 id="数据仓库的组成元素主要有哪些？各自的主要作用是什么？"><a href="#数据仓库的组成元素主要有哪些？各自的主要作用是什么？" class="headerlink" title="数据仓库的组成元素主要有哪些？各自的主要作用是什么？"></a>数据仓库的组成元素主要有哪些？各自的主要作用是什么？</h2><ol>
<li>数据仓库数据库：是整个数据仓库环境的核心，是数据信息存放的地方，对于数据提供存取和检索支持。</li>
<li>数据抽取工具：把数据从各种各样的存储环境中提取出来，进行必要的转化、整理，再存放到数据仓库内。</li>
<li>元数据：描述数据仓库内数据的结构和建立方法的数据。</li>
<li>访问工具：为用户访问数据仓库提供的手段。</li>
<li>数据集市：为了特定的应用目的，从数据仓库中独立出来的一部分数据，也称为部门数据或主题数据。</li>
<li>数据仓库管理：数据仓库管理包括安全与权限的管理、数据更新的跟踪、数据质量的检查、元数据的管理与更新等。</li>
<li>信息发布系统：把数据仓库中的数据或其他相关的数据发送给不同的地点或客户。</li>
</ol>
<h2 id="比较分析数据处理中的联机事务处理OLTP和联机分析处理OLAP。"><a href="#比较分析数据处理中的联机事务处理OLTP和联机分析处理OLAP。" class="headerlink" title="比较分析数据处理中的联机事务处理OLTP和联机分析处理OLAP。"></a>比较分析数据处理中的联机事务处理OLTP和联机分析处理OLAP。</h2><table>
<thead>
<tr>
<th>不同的</th>
<th>OLTP</th>
<th>OLAP</th>
</tr>
</thead>
<tbody><tr>
<td>用户</td>
<td>操作人员、低层管理人员</td>
<td>决策人员、高级管理人员</td>
</tr>
<tr>
<td>功能</td>
<td>日常操作型事务处理</td>
<td>分析决策</td>
</tr>
<tr>
<td>数据库设计目标</td>
<td>面向应用</td>
<td>面向主题</td>
</tr>
<tr>
<td>数据特点</td>
<td>当前的、最新的、细节的、二维的与分立的</td>
<td>历史的 、聚集的、多维的.集成的与统一的</td>
</tr>
<tr>
<td>存取规模</td>
<td>通常一次读或写数十条记录</td>
<td>可能读取百万条以上记录</td>
</tr>
<tr>
<td>工作单元</td>
<td>一个事务</td>
<td>一个复杂查询</td>
</tr>
<tr>
<td>用户量</td>
<td>通常是成千上万个用户</td>
<td>可能只有几十个或上百个用户</td>
</tr>
<tr>
<td>数据库大小</td>
<td>通常在GB级(100MB~ 1GB)</td>
<td>通常在TB级(100GB~1TB及以上)</td>
</tr>
</tbody></table>
<p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。<br>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
<h2 id="三层数据仓库结构"><a href="#三层数据仓库结构" class="headerlink" title="三层数据仓库结构"></a>三层数据仓库结构</h2><p>底层：数据仓库的数据库服务器<br>中间层：OLAP服务器<br>前端客户工具层</p>
<h2 id="应用划分聚类算法时的三个要点是什么"><a href="#应用划分聚类算法时的三个要点是什么" class="headerlink" title="应用划分聚类算法时的三个要点是什么?"></a>应用划分聚类算法时的三个要点是什么?</h2><p>选定某种距离作为数据样本间的相似性度量，选择评价聚类性能的准则函数，选择某个初始分类，之后用迭代的方法得到聚类结果，使得评价聚类的准则函数取得最优值。</p>
<h2 id="ETL的目标？"><a href="#ETL的目标？" class="headerlink" title="ETL的目标？"></a>ETL的目标？</h2><p>抽取、转换、加载过程的目的是为决策支持应用提供-一个单一的、权威的数据源。</p>
<h2 id="以关系表构成的多维数据模式？"><a href="#以关系表构成的多维数据模式？" class="headerlink" title="以关系表构成的多维数据模式？"></a>以关系表构成的多维数据模式？</h2><p>星型模式：事实表在中心，周围连接多个维表（每维一个），事实表含有大量数据，没有冗余。<br>雪花模式：是星型模式的变种，其中某些维表是规范化的，因而把数据进一步分解到附加表中，维表中进一步使用其他维表。模式图形成类似于雪花的形状。<br>事实星座模式多个事实表共享维表，这种模式可以看作星型模式的汇集，因此称为星系模式，或者事实星座</p>
<h2 id="数据仓库的设计与实施阶段"><a href="#数据仓库的设计与实施阶段" class="headerlink" title="数据仓库的设计与实施阶段"></a>数据仓库的设计与实施阶段</h2><ol>
<li>数据仓库概念模型的设计</li>
<li>数据仓库逻辑模型的设计</li>
<li>数据仓库物理模型的设计</li>
<li>源数据抽取、清洗、整理与装载设计</li>
<li>数据表达及访问设计</li>
<li>数据仓库维护方案的设计</li>
</ol>
<h2 id="分类过程"><a href="#分类过程" class="headerlink" title="分类过程"></a>分类过程</h2><ul>
<li>获取数据：输入数据、对数据进行量化</li>
<li>预处理：去除噪声数据、对空缺值进行处理、数据集成或者变换</li>
<li>分类器设计：划分数据集、分类器构造、分类器测试</li>
<li>分类决策：对未知类标号的数据样本进行分类</li>
</ul>
<h1 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol>
<li>数据仓库是一个<strong>面向主题的</strong>、集成的、<strong>相对稳定的、反映历史变化</strong>的数据集合。</li>
<li>元数据为访问数据仓库提供了一个信息目录，根据元数据用途的不同可将数据仓库的元数据分为<strong>技术元数据</strong>和<strong>业务元数据</strong>两类</li>
<li>数据事务处理通常分为两大类：<strong>联机事务处理</strong>和<strong>联机分析处理</strong></li>
<li>多维分析是指以“维”形式组织起来的数据采取<strong>切片</strong>、切块、<em>钻取</em>和旋转灯各种分析动作，使用户能从不同角度、不同侧面观测数据仓库中的数据</li>
<li>ROLAP是基于关系型数据库的OLAP实现，而MOLAP是基于<strong>多维数据结构&#x2F;多维数组</strong>组织的OLAP实现的</li>
<li>数据仓库按照其开发过程，其关键环节包括<strong>数据抽取</strong>、数据存储与管理、<strong>数据表现</strong>等</li>
<li>数据仓库系统的体系结构根据应用需求的不同，可以分为一下4种类型：<strong>两层架构</strong>、<strong>独立性数据集市</strong>、<strong>依赖型数据集市和操作型数据存储</strong>和<strong>逻辑型数据集市和实时数据仓库</strong></li>
<li>操作型数据存储实际上是一个集成的、面向主题的、<strong>可更新的、当前值的</strong>、企业级的、详细的数据库，亦称运营数据存储</li>
<li>实时数据库意味着源数据系统、决策支持服务和数据仓库之间以一个<strong>实时</strong>的速度交换数据和业务规则</li>
<li>从应用的角度，数据仓库的发展演变可归纳为5个阶段：<strong>以报表为主、以分析为主、以预测模型为主、以运营导向为主和以实时数据仓库和自动决策为主</strong><ol start="11">
<li><pre><code>什么是数据仓库?数据仓库的特点主要有哪些?
</code></pre>
答∶ <strong>数据仓库就是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，通常用于辅助决策支持。</strong><br>数据仓库的特点包含以下几个方面∶ （1） 面向主题。操作型数据库的数据组织是面向事务处理任务，各个业务系统之间各自分离;而数据仓库中的数据是按照一定的主题域进行组织。主题是一个抽象的概念，是指用户使用数据仓库进行决策时所关心的重点领域，一个主题通常与多个操作型业务系统或外部档案数据相关。 （2）集成的。面向事务处理的操作型数据库通常与某些特定的应用相关，数据库之间相互独立，并且往往是异构的。而数据仓库中的数据是在对原有分散的数据库数据作抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企事业单位一致的全局信息。也就是说存放在数据仓库中的数据应使用一致的命名规则、格式、编码结构和相关特性来定义。 （3）相对稳定的。操作型数据库中的数据通常实时更新，数据根据需要及时发生变化。数据仓库的数据主要供单位决策分析之用，对所涉及的数据操作主要是数据查询和加载，一旦某个数据加载到数据仓库以后，-一般情况下将作为数据档案长期保存，几乎不再做修改和删除操作，也就是说针对数据仓库，通常有大量的查询操作及少量定期的加载（或刷新）操作。 （4）反映历史变化。操作型数据库 （OLTP）主要关心当前某一个时间段内的数据，而数据仓库中的数据通常包含较久远的历史数据，因此总是包括—个时间维，以便可以研究趋势和变化。数据仓库系统通常记录了一个单位从过去某一时点（如开始启用数据仓库系统的时点）到目前的所有时期的信息，通过这些信息，可以对单位的发展历程和未来趋势做出定量分析和预测。</li>
</ol>
</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li>调和数据是存储在<strong>企业级数据仓库</strong>和操作型数据存储中的数据。</li>
<li>抽取、转换、加载过程的目的是为决策支持应用提供一个<strong>单一的</strong>、权威数据源。因此，我们要求ETL过程产生的数据是 <strong>详细的</strong>、历史的、规划化的、可理解的、即时的和质量可控制的。</li>
<li>数据抽取的两个常见类型是静态抽取和增量抽取。静态抽取用于<strong>最初填充数据库</strong>，增量抽取用于进行数据仓库的维护。</li>
<li>粒度的是对数据仓库中数据的综合程度高低的一个衡量。粒度越小，细节程度 <strong>越高</strong>，综合程度 <strong>越低</strong>，回答查询的种类 <strong>越多</strong>。</li>
<li>使用星型模式可以从一定程度上<strong>提高</strong>查询效率。因为星型模式中的数据的组织已经经过 <strong>预处理</strong>，主要数据都在庞大的 <strong>事实表</strong> 中。</li>
<li>维度表一般由主键、分类层次和描述属性组成。对于主键可以选择两种方式∶ 一种是采用<strong>自然键</strong>，另一种是采用<strong>代理键</strong>。</li>
<li>雪花模式是对<strong>星型模式</strong>维表的进一步层次化和规范化来消除冗余的数据。</li>
<li>数据仓库中存在不同综合级别的数据。一般把数据分成4个级别∶<strong>早期细节级、当前细节级、轻度细节级和 高度细节级</strong>。<br>9.什么是数据仓库的三层数据结构?<br>答∶数据是从企业内外部的各业务处理系统（操作型数据）流向企业级数据仓库（EDW）或操作型数据存储区（ODS），在这个过程中，要根据企业（或其他组织）的数据模型和元数据库对数据进行调和处理，形成一个中间数据层，然后再根据分析需求，从调和数据层（EDW、ODS）将数据引入导出数据层，如形成满足各类分析需求的数据集市。</li>
<li>什么是数据仓库的数据ETL过程?<br>答∶数据的ETL过程就是负责将操作型数据转换成调和数据的过程。这两种数据具有明显的区别，因此，数据调和是构建一个数据仓库中最难的和最具技术挑战性的部分。在为企业级数据仓库填充数据的过程中，数据调和可分为两个阶段∶<br>一是企业级数据仓库（EDW）首次创建时的原始加载;二是接下来的定期修改，以保持E DW的当前有效性和扩展性。<br>整个过程由四个步骤组成∶抽取、清洗、转换、加载和索引。事实上，这些步骤可以进行不同的组合，如，可以将数据抽取与清洗组合为一个过程，或者将清洗和转换组合在一起。通常，在清洗过程中发现的拒绝数据信息会关回到源操作型业务系统中，然后将数据在源系统中加以处理，以便在以后重新抽取。</li>
<li>比较分析星型模式、雪花模式和共享星座模式。<br>答：在星型模式中，事实表居中，多个维表呈辐射状分布于四周，并与事实表连接。雪花型模式是星型模式的变种，不同的是将某些维表规范化。它是对星型模式维表的进一步层次化和规范化，从而消除冗余的数据。<br>事实星座结构是多个事实表共享维表，这种模式可以看做是星型模式集，也叫多重事实表或称为星系模式。</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol>
<li>关联规则的经典算法包括<strong>apriori</strong>和<strong>FP-growth</strong>，其中 <strong>FP-growth</strong> 的效率更高。</li>
<li>如果<code>L2 = &#123;a，b&#125;，&#123;a，c&#125;，&#123;a，d&#125;，&#123;b， c&#125;，&#123;b， d&#125;</code> ，则连接产生的C3是什么;经裁剪后的C3是什么？<br>答：连接之后的<code>C3 = &#123;&#123;a，b，c&#125;&#123;a，b，d&#125;，&#123;a，c，d&#125;，&#123;b，c, d&#125;&#125;</code> 再经过裁剪之后的<code>C3 = &#123;&#123;a，b，c&#125;&#123;a，b，d&#125;&#125;</code>。</li>
<li>什么是关联规则?关联规则的分类有哪些?关联规则挖掘的步骤有哪些?<br>答：关联规则挖掘最初由 R.Agrawal等人提出，用来发现超级市场中用户购买的商品之间的隐含关联关系，并用规则的形式表示出来，称为关联规则。<br>关联规则的分类∶<ol>
<li>基于规则中涉及到的数据的维数，关联规则可以分为单维的和多维的。</li>
<li>基于规则中数据的抽象层次，可以分为单层关联规则和多层关联规则。</li>
<li>基于规则中处理的变量的类型不同，关联规则可以分为布尔型和数值型。<br>关联规则挖掘的步骤∶</li>
<li>找出交易数据库中所有大于或等于用户指定的最小支持度的频繁项集;</li>
<li>利用频繁项集生成所需要的关联规则，根据用户设定的最小可信度进行取舍，产生强关联规则。</li>
</ol>
</li>
<li>描述k-means聚类算法的步骤。<ol>
<li>从数据中选择k个对象作为初始聚类中心;</li>
<li>计算每个聚类对象到聚类中心的距离来划分;</li>
<li>再次计算每个聚类中心;</li>
<li>计算标准测度函数，之道达到最大迭代次数，则停止，否则，继续操作。</li>
</ol>
</li>
<li>描述凝聚型层次聚类算法的操作步骤。<ol>
<li>N个初始模式样本自成一类，即建立N类∶G1(0),G2(0),,Gn(0) (G_Group)计算各类之间（即各样本间）的距离（相似性、相关性），得一NN维距离矩阵。”0*”表示初始状态。</li>
<li>假设已求得距离矩阵D（n）（n为逐次聚类合并的次数），找出D（n）中的最小元素，将其对应的两类合并为一类。由此建立新的分类∶G1(n+1),,G2(n+1),</li>
<li>计算合并后新类别之间的距离，得D（n+ 1)。</li>
<li>跳至第二步，重复计算及合并。结束条件∶取距离阈值T，当D（n）的最小分量超过给定值T时，算法停止。所得即为聚类结果。或不设阈值T，一直将全部样本聚成一类为止，输出聚类的分级树。</li>
</ol>
</li>
<li>数据仓库中的数据分为<strong>状态数据</strong>和<strong>事件数据</strong></li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol>
<li>分类的过程包含<strong>获取数据，预处理，分类器设计，分类决策</strong>。</li>
<li>分类器设计阶段包含三个过程: <strong>划分数据集，分类器构造，分类器测试</strong>。</li>
<li>分类问题中常用的评价准则有 <strong>精确度，查全率和查准率，F-measure, 几何均值</strong>。</li>
<li>支持向量机中常用的核函数有 <strong>多项式核函数，径向基核函数，S型核函数</strong>。</li>
<li>什么是分类?分类的应用领域有哪些?<br> 答: 分类是指把数据样本映射到-一个事先定义的类中的学习过程，即给定- -组输入的属性向量及其对应的类，用基于归纳的学习算法得出分类。分 类问题是数据挖掘领域中研究和应用最为广泛的技术之- -，许多分类算法被包含在统计分析工具的软件包中，作为专门的分类工具来使用。分类问题在商业、银行业、医疗诊断、生物学、文本挖掘、因特网筛选等领域都有广泛应用。例如，在银行业中，分类方法可以辅助工作人员将正常信用卡用户和欺诈信用卡用户进行分类，从而采取有效措施减小银行的损失;在医疗诊断中，分类方法可以帮助医疗人员将正常细胞和癌变细胞进行分类,从而及时制定救治方案,挽救病人的生命;在因特网筛选中，分类方法可以协助网络工作人员将正常邮件和垃圾邮件进行分类，从而制定有效的垃圾邮件过滤机制，防止垃圾邮件干扰人们的正常生活。</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol>
<li>聚类分析包括 <strong>连续型，二值离散型，多值离散型，混合类型</strong> 4种类型描述属性的相似度计算方法。</li>
<li>连续型属性的数据样本之间的距离有 <strong>欧氏距离，曼哈顿距离，明考斯基距离</strong>。</li>
<li>划分聚类方法对数据集进行聚类时包含三个要点: </li>
<li>层次聚类方法包括 <strong>凝聚型层次聚类 和 分解型层次聚类</strong> 两种层次聚类方法。</li>
<li>什么是聚类分析?聚类分析的应用领域有哪些?<br> 聚类分析是将物理的或者抽象的数据集合划分为多个类别的过程，聚类之后的每个类别中任意两个数据样本之间具有较高的相似度，而不同类别的数据样本之间具有较低的相似度。聚类分析是数据挖掘应用的主要技术之一，它可以作为一个独立的工具来使用，将未知类标号的数据集划分为多个类别之后，观察每个类别中数据样本的特点，并且对某些特定的类别作进一步的分析。此外，聚类分析还可以作为其他数据挖掘技术(例如分类学习、关联规则挖掘等)的预处理工作。聚类分析在科学数据分析、商业、生物学、医疗诊断、文本挖掘、Web数据挖掘等领域都有广泛应用。在科学数据分析中，比如对于卫星遥感照片，聚类可以将相似的区域归类，有助于研究人员根据具体情况做进一步分析; 在商业领域，聚类可以帮助市场分析人员对客户的基本数据进行分析,发现购买模式不同的客户群，从而协助市场调整销售计划;在生物学方面,聚类可以帮助研究人员按照基因的相似度对动物和植物的种群进行划分，从而获得对种群中固有结构的认识:在医疗诊断中，聚类可以对细胞进行归类，有助于医疗人员发现异常细胞的聚类，从而对病人及时采取措施;在文本挖掘和Web数据挖掘领域中，聚类可以将网站数据按照读者的兴趣度进行划分，从而有助于网站内容的改进。</li>
<li>请描述k-means聚类算法的操作步骤。</li>
</ol>
<h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><ol>
<li>请简述Web挖掘的三个主要类别： <strong>Web内容挖掘、Web结构挖掘和Web使用挖掘</strong>。</li>
<li>请解释衡量信息检索性能的尺度的两个概念:查准率和查全率：<br> 查准率是检索到的文档中的相关文档占全部检索到的文档的百分比，它所衡量的是检索系统的准确性。查全率是被检索出的文档中的相关文档占全部相关文档的百分比，它所衡量的是检索系统的全面性。 </li>
<li>简述Web使用挖掘的路径分析手段的工作原理,举例说明它的分析结果怎样帮助优化站点的结构。<br> 路径分析可用于发现Web站点中最经常被访问的路径，从而调整站点的结构。例如，某个网站的主页A中有一个链接指向了网页B,而网页B中有一个链接指向了网页C。经过Web路径挖掘发现，凡是从主页开始访问并链接到网页B的用户，大都最后链接到了网页C.根据发现的这条规律，可以在主页中增加-一个链接C,这样可以方便大多数用户的使用。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据仓库</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理笔记（4）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<p>操作系统第六七八章知识点总结</p>
<span id="more"></span>

<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h2><h3 id="数据项、记录和文件"><a href="#数据项、记录和文件" class="headerlink" title="数据项、记录和文件"></a>数据项、记录和文件</h3><ul>
<li>数据项  <ul>
<li>基本数据项：描述以对象某种属性的字符集，如学号、姓名、年龄这些不能再细分的  </li>
<li>组合数据项：若干个基本数据项组成的，就是还可以细分的</li>
</ul>
</li>
<li>记录  <ul>
<li>描述一个对象在某方面的属性，注意要有关键字key，方便查找</li>
</ul>
</li>
<li>文件  <ul>
<li>多条记录组成文件</li>
</ul>
</li>
</ul>
<p>文件属性：类型、长度、物理位置、建立时间（即最后一次修改时间）  </p>
<h3 id="文件名和类型"><a href="#文件名和类型" class="headerlink" title="文件名和类型"></a>文件名和类型</h3><ul>
<li>文件名和拓展名   </li>
<li>文件类型  <ul>
<li>按用途分：系统文件、用户文件、库文件  </li>
<li>按文件数据形式：源文件、目标文件、可执行文件  </li>
<li>按存取控制属性：只执行文件、只读文件、读写文件  </li>
<li>按组织形式和处理方式分类：普通文件、目录文件、特殊文件</li>
</ul>
</li>
</ul>
<h3 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h3><ul>
<li>对象及其属性  <ul>
<li>管理对象：文件、目录、磁盘存储空间</li>
</ul>
</li>
<li>对对象操纵和管理的软件集合  <ul>
<li>I&#x2F;O控制层、基本文件系统层、基本I&#x2F;O管理程序、逻辑文件系统</li>
</ul>
</li>
<li>文件系统的接口  <ul>
<li>命令接口、程序接口</li>
</ul>
</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>最基本的文件操作  <ul>
<li>创建、删除、读、写、设置读写位置</li>
</ul>
</li>
<li>文件的“打开”和“关闭”操作  </li>
<li>其他文件操作  <ul>
<li>设置和获得文件的属性、查询文件状态</li>
</ul>
</li>
</ul>
<p>有关目录的，就是创建、删除、改变当前目录等  </p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><h3 id="文件逻辑结构的类型"><a href="#文件逻辑结构的类型" class="headerlink" title="文件逻辑结构的类型"></a>文件逻辑结构的类型</h3><p>有结构文件：记录式文件<br>无结构文件：流式文件  </p>
<ul>
<li>按文件是否有结构分类  <ul>
<li>有结构文件（如数据库）：定长记录、变长记录  </li>
<li>无结构文件（txt）：源程序、可执行文件</li>
</ul>
</li>
<li>按文件的组织方式分类  <ul>
<li>顺序文件：可以定长可以变长，一直按顺序下去（如犯人的记录）  </li>
<li>索引文件：加张索引表  </li>
<li>索引顺序文件：分组，组内是顺序，组头有索引</li>
</ul>
</li>
</ul>
<h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><ul>
<li>顺序文件的排列方式  <ul>
<li>串结构：要从头开始找  </li>
<li>顺序结构：有个关键字</li>
</ul>
</li>
<li>顺序文件的优缺点  <ul>
<li>最高效、但交互应用中效率好差、而且增加删除一个记录困难  </li>
<li>所以要配置一个运行记录文件，按时合并</li>
</ul>
</li>
</ul>
<h3 id="记录寻址"><a href="#记录寻址" class="headerlink" title="记录寻址"></a>记录寻址</h3><ul>
<li>隐式寻址方式  <ul>
<li>一个一个读，读了（n-1）个才找到n</li>
</ul>
</li>
<li>显式寻址方式  <ul>
<li>定长就方便，直接乘索引号即可  </li>
<li>变长就要加上Li，表示一段记录的长度  </li>
<li>或者利用关键字查找</li>
</ul>
</li>
</ul>
<h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>①按关键字建立索引<br>索引文件三要素：索引号、长度、指针<br>多个索引表的索引文件：从不同属性查找同一对象  </p>
<h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><ul>
<li>索引顺序文件的特征  <ul>
<li>引入文件索引表，可以实现对索引顺序文件的随机访问；  </li>
<li>增加溢出文件，可以记录新增加、删除和修改的记录</li>
</ul>
</li>
<li>一级索引顺序文件  <ul>
<li>分组，组首进入索引顺序文件</li>
</ul>
</li>
<li>两级索引顺序文件  <ul>
<li>索引顺序表做组</li>
</ul>
</li>
</ul>
<h3 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h3><ul>
<li>直接文件  <ul>
<li>关键字本身就决定记录的物理地址，所以可以直接查找，有键值转换</li>
</ul>
</li>
<li>哈希文件  <ul>
<li>A &#x3D; H(K)，通常是指向某一目录表相应表目的指针</li>
</ul>
</li>
</ul>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>要求：<br>实现“按名存取”<br>提高对目录的检索速度<br>文件共享<br>允许文件重名  </p>
<h3 id="文件控制块和索引结点"><a href="#文件控制块和索引结点" class="headerlink" title="文件控制块和索引结点"></a>文件控制块和索引结点</h3><ul>
<li>文件控制块FCB  <ul>
<li>包含三类信息：基本信息、存取控制信息、使用信息  </li>
<li>基本信息：文件名、文件物理位置、文件逻辑结构、文件物理结构  </li>
<li>存取控制信息：各类人的存取权限  </li>
<li>使用信息类：建立时间、最近修改时间、当前使用信息<br>②索引结点  </li>
<li>引入：怕文件目录太大，只用文件名，轻量级文件目录  </li>
<li>磁盘索引结点：文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间  </li>
<li>内存索引结点：索引结点编号、状态、访问计数、文件所属文件系统的逻辑设备号、链接指针</li>
</ul>
</li>
</ul>
<h3 id="简单的文件目录"><a href="#简单的文件目录" class="headerlink" title="简单的文件目录"></a>简单的文件目录</h3><ul>
<li>单级文件目录  <ul>
<li>整个文件系统只有，一张目录表，目录项有：文件名、文件扩展名、文件长度、文件类型、文件物理地址和其他属性  </li>
<li>每次创建都要搜索有没有相同的文件名  </li>
<li>优点是简单，但只实现了“按名存取”，其他三个要求没有实现</li>
</ul>
</li>
<li>两级文件目录  <ul>
<li>MFD→UFD  </li>
<li>会有隔离，这个结构可以有效将多个用户隔开，在各个用户完全无关时，这是一个优点。  </li>
<li>但如果要合作完成一个大任务时，这种隔离就会使诸多用户之间不便于共享</li>
</ul>
</li>
</ul>
<h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><ul>
<li>树形目录  <ul>
<li>一个目录文件中的目录项，可以既作为目录文件的FCB，又是数据文件的FCB</li>
</ul>
</li>
<li>路径名和当前目录  <ul>
<li>路径名：唯一通路，用&#x2F;连接  </li>
<li>当前目录，相对路径名，绝对路径名</li>
</ul>
</li>
<li>目录操作  <ul>
<li>创建、删除、不删除非空目录、可删除非空目录  </li>
<li>改变、移动、链接目录、查找目录</li>
</ul>
</li>
<li>目录查询技术  <ul>
<li>线性检索法：在单级目录中，用用户提供的文件名，顺序查找；在树形目录中，就按路径名查找  </li>
<li>Hash方法：建立一张Hash索引文件目录，利用Hash方法查询——利用用户提供的文件名，转换为文件目录索引值，再用索引值在目录中查找  </li>
<li>注：如果使用了通配符，就无法用Hash方法检索了  </li>
<li>“冲突”：1.看目录项是否空 2.看文件名是否匹配 3. 如果不匹配，就要在Hash值加上一个常数，形成新的索引值</li>
</ul>
</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于有向无循环图实现文件共享"><a href="#基于有向无循环图实现文件共享" class="headerlink" title="基于有向无循环图实现文件共享"></a>基于有向无循环图实现文件共享</h3><ul>
<li>有向无循环图DAG  <ul>
<li>由附加操作Append来完成，而新增加的盘块只会出现在执行了操作的目录中，新增加的部分不能被共享</li>
</ul>
</li>
<li>利用索引结点  <ul>
<li>用索引结点，任何用户对共享文件所进行的Append操作或修改，都将引起相应结点内容的改变  </li>
<li>还增加一个count链接计数  </li>
<li>其他用户在使用，拥有者删了，文件依然存在</li>
</ul>
</li>
</ul>
<h3 id="利用符号链接实现文件共享"><a href="#利用符号链接实现文件共享" class="headerlink" title="利用符号链接实现文件共享"></a>利用符号链接实现文件共享</h3><ul>
<li>利用符号链接的基本思想  <ul>
<li>即允许一个文件或子目录有多个父目录，但只有一个是“主”父目录</li>
</ul>
</li>
<li>如何利用符号链实现共享  <ul>
<li>由系统创建一个LINK类型的新文件，取名为F，并将F写入链接父目录D5中，就可以实现D5与F8的链接。新文件只有被链接文件F8的路径名——所以叫做“符号链接”——新文件的路径名被看做“符号链”</li>
</ul>
</li>
<li>利用符号链实现共享的优点  <ul>
<li>用户删了链接文件，也不会删掉本来的文件；文件主删了文件，其他用户访问不了，自然会删掉符号链</li>
</ul>
</li>
<li>利用符号链的共享方式存在的问题  <ul>
<li>读盘需时、符号链太多，琐碎</li>
</ul>
</li>
</ul>
<h1 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h1><h2 id="外存的组织方式"><a href="#外存的组织方式" class="headerlink" title="外存的组织方式"></a>外存的组织方式</h2><p>连续组织方式、链接组织方式、索引组织方式  </p>
<h3 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h3><p>位于同一磁道，读写不用移动磁头<br>优点：顺序访问容易、顺序访问速度快<br>缺点：要求为一个文件分配连续的存储空间、要事先知道文件长度、不够灵活删除和插入、对于动态增长的文件，很难分配空间  </p>
<h3 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h3><p>优点：消除外部碎片，提高外存利用率；对插入、删除修改记录都非常容易；能够适应动态增长<br>隐式链接：一个跟一个，如同链表；碎片多；万一一个错，整个文件用不了<br>显式链接：将各物理块的指针显式存在内存的一个表内，每个FCB对应一个字段，因为在内存查找，所以大大提高检索速度，还减少访问磁盘的次数，而这叫做FAT  </p>
<h3 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h3><ul>
<li>单级索引组织方式  <ul>
<li>不支持高效直接存取，要对一个较大的文件进行存取，就要顺序地查找许多盘块号  </li>
<li>FAT需要占用较大内存空间  </li>
<li>所以创造“表中表”——索引分配图</li>
</ul>
</li>
<li>多级索引组织方式  <ul>
<li>就是多级，如同“全语言字典”  </li>
<li>优点：大大加快对大型文件的查找速度</li>
</ul>
</li>
<li>增量式索引组织方式  <ul>
<li>增量式索引组织方式的基本思想  </li>
<li>小的用直接寻址、中的用单级索引组织方式、大的用两三级索引组织方式  </li>
<li>Unix System V的组织方式：索引结点有13个地址项，前十个是直接地址，最大放40KB；第十一个是一次间接地址，1K个盘块号，允许文件长达4MB；如果还超过4MB+40KB，就放二次间接地址，有4GB；还超过，就放3次间接地址，有4TB</li>
</ul>
</li>
</ul>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><h3 id="空闲表法和空闲链表法"><a href="#空闲表法和空闲链表法" class="headerlink" title="空闲表法和空闲链表法"></a>空闲表法和空闲链表法</h3><ul>
<li>空闲表法  <ul>
<li>即在外存所有空闲区建立一张空闲表，每个空闲区对于一个表项，记录序号、第一空闲盘块号、空闲盘块数  </li>
<li>分配和回收与内存相似，但在外存为加快分配速度，连续分配依然有用。小的连续分配，大的离散分配，多媒体文件依然连续分配</li>
</ul>
</li>
<li>空闲链表法  <ul>
<li>空闲盘块链：一直分配，按链表分配。如果删除文件就挂在链尾  </li>
<li>优点：简单，缺点：但为一个文件分配时可能重复操作多次，分配和回收效率较低，而且盘块链会很长  </li>
<li>空闲盘区链：优点：分配回收效率较高，盘区链短；缺点复杂</li>
</ul>
</li>
</ul>
<h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><ul>
<li>位示图  <ul>
<li>利用二进制的一位来表示磁盘中一个盘块的使用情况，也可以是二维数组</li>
</ul>
</li>
<li>盘块的分配  <ul>
<li>扫描位示图，找到一个或一组0，之后计算盘块号： b &#x3D; n(i -1)+j，修改位示图&#x3D;1</li>
</ul>
</li>
<li>盘块的回收  <ul>
<li>从盘块号转换为行列号：  </li>
<li>i &#x3D; (b-1) DIV n +1  </li>
<li>j &#x3D; (b-1) MOD n + 1</li>
</ul>
</li>
</ul>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><ul>
<li>空闲盘块的组织  <ul>
<li>每组含有盘块总数N和该组所有盘块号记入前一组的第一个盘块的S.free(0)~S.free(99)，这样各组第一个盘块可链接成一条链</li>
</ul>
</li>
<li>空闲盘块的分配与回收  <ul>
<li>当栈中空闲盘块号已达100时，表示栈已满，便将先有栈中100个盘块号记入新回收的盘块中，将盘块号作为新栈底</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网英语复习笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E8%8B%B1%E8%AF%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>整理考试要考的知识点</p>
<span id="more"></span>

<h1 id="lesson1"><a href="#lesson1" class="headerlink" title="lesson1"></a>lesson1</h1><h2 id="terms-术语"><a href="#terms-术语" class="headerlink" title="terms(术语)"></a>terms(术语)</h2><ul>
<li>computer network : 计算机网络</li>
<li>TCP&#x2F;IP protocols : TCP&#x2F;IP协议</li>
<li>IP address : IP地址</li>
<li>Wikipedia : 维基百科</li>
<li>unsolicited emails : 垃圾邮件</li>
<li>social media : 社交媒体</li>
</ul>
<h2 id="Abbreviations-缩写"><a href="#Abbreviations-缩写" class="headerlink" title="Abbreviations(缩写)"></a>Abbreviations(缩写)</h2><ul>
<li>BBS : bulletin board system 电子公告板</li>
<li>DNS : Domain Name Servers  域名服务器</li>
<li>HTML : Hyper Text Markup Language 超文本标记语言</li>
<li>HTTP : Hyper Text Transfer Protocol 超文本传输协议</li>
<li>ICP : Internet Content Provider 互联网内容提供商</li>
<li>ISP : Internet Service Provider 互联网服务提供商</li>
<li>MUD : Mutil-User Dungeon 多用户网络游戏</li>
<li>URL : Uniform Resource Locator 统一资源定位符</li>
<li>WWW : World Wide Web 万维网</li>
</ul>
<h2 id="Sentences"><a href="#Sentences" class="headerlink" title="Sentences"></a>Sentences</h2><ol>
<li>Here’s a brief history of the Internet, including important dates, people, projects, sites and other information that should give you at least a partial picture of what this thing we call the Internet really is, and where it came from. <ul>
<li>下面是互联网的简史，包括重要的日期、人物、、项目、网站以及其他一些信息。这些信息可以让你对现在称作互联网的东西到底是什么或者是从哪里来的有部分了解。</li>
</ul>
</li>
<li>While the complete history of the Internet could easily fill a few books, we should familiarize you with key milestones and events related to the growth and evolution of the Internet between 1969 to 2009.<ul>
<li>由于互联网完整的历史需要几本书来介绍,我们只是让你熟悉在 1969～2009 年期间互联网的里程碑和给互联网带来变革和进步的事件。</li>
</ul>
</li>
<li>Arpanet was the first real network to run on packet switching technology(new at the time). On the October 29,1969, computers at Stanford and UCLA connected for the first time. In effect, they were the first hosts on what would one day become the Internet.<ul>
<li>Arpanet是第一个运行在分组交换技术（当时是新技术）上的真正的网络。1969年10月29日，斯坦福大学和加州大学洛杉矶分校的计算机首次连接起来。实际上，他们是有一天会成为互联网的第一批主机。</li>
</ul>
</li>
<li>1977 was a big year for the development of the Internet as we know it today. It’s the year the first PC modem, developed by Dennis Hayes and Dale Heatherington, was introduced and initially sold to computer hobbyists.<ul>
<li>1977年是我们今天所知道的互联网发展的一年。这一年，由丹尼斯·海耶斯和戴尔·希瑟林顿开发的第一台PC调制解调器被引进并最初卖给电脑爱好者</li>
</ul>
</li>
<li>1978 is also the year that brought the first unsolicited commercial email message(later known as spam), sent out to 600 California Arpanet users by Gary Thuerk.<ul>
<li>1978年也是加里·图尔克（Gary Thuerk）向600名加州Arpanet用户发送的第一封未经请求的商业电子邮件（后来称为垃圾邮件）。</li>
</ul>
</li>
<li>The domain name system was important in that it made addresses on the Internet more human-friendly compared to its numerical IP address counterparts.<ul>
<li>域名系统的重要性在于它使互联网上的地址比数字IP地址更人性化。</li>
</ul>
</li>
<li>The term “social media”, believed to be first used by Chris Sharpley, was coined in the same year that “Web 2.0” became a mainstream concept. Social media-sites and web applications that allow its users to create and share content and to connect with one another-started around this period.<ul>
<li>“社交媒体”这个词被认为是由克里斯·夏普利首先使用的，是在“web2.0”成为主流概念的同一年被创造出来的。允许用户创建和共享内容并相互联系的社交媒体网站和网络应用程序就在这一时期开始了。</li>
</ul>
</li>
<li>Project Gutenberg, for those unfamiliar with the site, is a global effort to make books and documents in the public domain available electronically-for free- in variety of eBooks and electronic formats.（#1971）<ul>
<li>古腾堡计划，为那些不熟悉该网站的人，是一个全球性的努力，使书籍和文件在公共领域免费提供各种电子书和电子格式。</li>
</ul>
</li>
<li>The first widely downloaded Internet browser, Mosaic, was released in 1993. While Mosaic wasn’t the first web browser, it is considered the first browser to make the Internet easily accessible to non-techies.<ul>
<li>第一个被广泛下载的互联网浏览器Mosaic于1993年发布。虽然Mosaic不是第一个网络浏览器，但它被认为是第一个让非技术人员可以轻松访问互联网的浏览器。</li>
</ul>
</li>
</ol>
<h1 id="lesson2"><a href="#lesson2" class="headerlink" title="lesson2"></a>lesson2</h1><h2 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h2><ul>
<li>electrical circuits : 电路</li>
<li>vacuum tubes : 真空管</li>
<li>integrated circuits : 集成电路</li>
<li>electron flows : 电子流</li>
<li>electronic and information technology : 电子信息技术</li>
</ul>
<h2 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a>Abbreviations</h2><ul>
<li>IT : Information Technology 信息技术</li>
<li>SPICE : Simulation Program with Integrated Circuit Emphasis 集成电路模拟程序</li>
</ul>
<h2 id="Sentences-1"><a href="#Sentences-1" class="headerlink" title="Sentences"></a>Sentences</h2><ol>
<li>Interconnection technologies such as circuit boards, electronics packaging technology, and other varied forms of communication infrastructure complete circuit functionality and transform the mixed components into a regular working system. <ul>
<li>诸如电路板，电子封装技术之类的互连技术以及其他各种形式的通信基础架构，可以完善电路功能并将混合后的组件转换为常规的工作系统。</li>
</ul>
</li>
<li>Electronics is distinct from Electrical and Electro-mechanical Science and Technology, which deals with the generation, distribution, switching, storage and conversion of electrical energy to and from other energy forms using wires, motors, generators, batteries, relays, transformers, resistors, and other passive components.<ul>
<li>电子学与电气和机电科学技术不同，后者涉及利用电线，电动机，发电机，电池，继电器，变压器，电阻器来产生，分配，转换，存储和转换电能与其他能源形式的电能， 和其他无源组件。</li>
</ul>
</li>
<li>Information Technology(IT) is the application of computers and telecommunications equipment to store, retrieve, transmit and manipulate data, often in the context of a business or other enterprise. The term is commonly used as a synonym for computers and computer networks, but it also encompasses other information distribution technologies, such as television and telephones.<ul>
<li>信息技术（IT）是计算机和电信设备在企业或其他企业中经常用于存储，检索，传输和处理数据的应用程序。 该术语通常用作计算机和计算机网络的同义词，但它还涵盖其他信息分发技术，例如电视和电话。</li>
</ul>
</li>
<li>From academic aspect, IT specialists assume responsibility for selecting hardware and software products appropriate for an organization, integrating those products with organizational needs and infrastructure, and installing, customizing, and maintaining those applications for the organization’s computer users.<ul>
<li>从学术角度来看，IT专家负责选择适合组织的硬件和软件产品，将这些产品与组织需求和基础架构集成在一起，并为组织的计算机用户安装，自定义和维护这些应用程序。</li>
</ul>
</li>
<li>Electronic information technology has been in-depth in the daily lives of ordinary people and has brought great convenience to people’s lives. Electronic Information Technology will also be more and more popular in the future life.<ul>
<li>电子信息技术已经深入到普通百姓的日常生活中，给人们的生活带来了极大的便利。 电子信息技术在未来的生活中也将越来越受欢迎。</li>
</ul>
</li>
</ol>
<h1 id="lesson3"><a href="#lesson3" class="headerlink" title="lesson3"></a>lesson3</h1><h2 id="terms-1"><a href="#terms-1" class="headerlink" title="terms"></a>terms</h2><p>data center(centre) : 数据中心<br>cloud computing : 云计算<br>pervasive computing : 普适计算<br>ubiquitous computing : 泛在计算<br>business process : 业务流程</p>
<h2 id="Abbreviations-1"><a href="#Abbreviations-1" class="headerlink" title="Abbreviations"></a>Abbreviations</h2><ul>
<li>IoM : Internet of Media 媒体网络</li>
<li>Ios : Internet of Services 服务网络</li>
<li>IoT : Internet of Things</li>
<li>SOA : Service Oriented Architecture 面向服务架构</li>
</ul>
<h2 id="Sentences-2"><a href="#Sentences-2" class="headerlink" title="Sentences"></a>Sentences</h2><ol>
<li>In fact, in the IoT communications will take place not only between people but also between people and their environment. <ul>
<li>实际上，在物联网中，通信不仅会发生在人与人之间，而且还将发生在人与环境之间。</li>
</ul>
</li>
<li>Communication will be seen more among terminals and data centers(e.g. home data centers, Cloud computing, etc.) than among nodes as in current networks. Growth of storage capacity at lower and lower costs will result in the local availability of most information required by people or objects.<ul>
<li>终端和数据中心（例如家庭数据中心，云计算等）之间的通信将比当前网络中的节点之间的通信更多。 以越来越低的成本增长存储容量将导致人们或物体所需的大多数信息在本地可用。</li>
</ul>
</li>
<li>For example, algorithms could be used for intelligent decision-making based on real-time readings from sensors that are used to monitor the health of patients or the condition of vehicles, in order to detect the early signs of problems or deterioration of condition.<ul>
<li>例如，算法可用于基于来自传感器的实时读数进行智能决策，该传感器用于监控患者的健康状况或车辆状况，以便检测问题的早期迹象或状况恶化。</li>
</ul>
</li>
</ol>
<h1 id="lesson4"><a href="#lesson4" class="headerlink" title="lesson4"></a>lesson4</h1><h2 id="terms-2"><a href="#terms-2" class="headerlink" title="terms"></a>terms</h2><ul>
<li>application layer : 应用层</li>
<li>network layer : 网络层</li>
<li>perception layer : 感知层</li>
<li>supply chain : 供给链</li>
<li>paradigm principle : 范式的原则</li>
</ul>
<h2 id="Abbreviations-2"><a href="#Abbreviations-2" class="headerlink" title="Abbreviations"></a>Abbreviations</h2><ul>
<li>ebXML ： electronic bussiness using Extensible Markup Language 电子商务全球化标准</li>
<li>SOAP ： Simple Object Access Protocol 简单对象访问协议</li>
<li>UBL ： Universal Business Language 通用商业语言</li>
</ul>
<h2 id="Sentences-3"><a href="#Sentences-3" class="headerlink" title="Sentences"></a>Sentences</h2><ol>
<li>When architecting the Internet of Things, it is important to remember that many things will not have permanent network connectivity-indeed some things may have no intrinsic network connectivity, but rely on supporting intelligence in their local environment or in remote information systems. <ul>
<li>在设计物联网时，重要的是要记住，许多事物不会具有永久的网络连接性-实际上，某些事物可能没有固有的网络连接性，而是依赖于其本地环境或远程信息系统中的支持智能。</li>
</ul>
</li>
<li>The memory of the handheld device can also be used to temporarily record any updates, such as modifications to the parts, symptoms observed, missing safety equipment, etc., so that those updates can be synchronized to the network as soon as the hand-held device returns within range of network connectivity, such as WiFi or a docking station.<ul>
<li>手持设备的内存还可以用于临时记录任何更新，例如对零件的修改，观察到的症状，缺少安全设备等，以便一旦手持设备将这些更新同步到网络即可。 设备返回的网络连接范围内，例如WiFi或扩展坞。</li>
</ul>
</li>
</ol>
<h1 id="lesson-5"><a href="#lesson-5" class="headerlink" title="lesson 5"></a>lesson 5</h1><h2 id="terms-3"><a href="#terms-3" class="headerlink" title="terms"></a>terms</h2><ul>
<li>superconductivity technology : 超导技术</li>
<li>electrode potential : 电极电位</li>
<li>optical fiber sensor : 光纤传感器</li>
<li>capacitor : 电容器</li>
<li>amplitude : 振幅</li>
<li>frequency : 频率</li>
<li>single chip : 单片机</li>
<li>semiconductor craft : 半导体芯片</li>
<li>instrumentation industry : 仪器仪表行业</li>
<li>quantum : 量子</li>
<li>dielectric : 电介质</li>
<li>aeronautics : 航空学</li>
</ul>
<h2 id="Abbreviations-3"><a href="#Abbreviations-3" class="headerlink" title="Abbreviations"></a>Abbreviations</h2><ul>
<li>CPU : Central Processing Unit</li>
<li>EPROM : Erasable Programmale Rom 可擦除可编程ROM</li>
<li>IC : Integrated circuit 集成电路</li>
<li>VLSI : Very Large Scale Integration 超大规模集成电路</li>
<li>NASA : National aeronautic and space administration 美国国家航空航天局</li>
</ul>
<h2 id="Sentences-4"><a href="#Sentences-4" class="headerlink" title="Sentences"></a>Sentences</h2><ol>
<li>With the rapid development of VLSI and having been developed, modern computer and communication technology, not only requests sensor precision, reliability, speed of response and quantity of information acquisition more and more high, but also request its lower cost and easy using. <ul>
<li>随着VLSI的快速发展和发展，现代计算机和通信技术不仅要求传感器的精度，可靠性，响应速度和信息获取量越来越高，而且要求其成本低廉，易于使用。</li>
</ul>
</li>
<li>Compared with traditional sensor, the optical fiber sensor has many characteristics, such as high sensitivity, small volume, anti-corrosion, excellent insulation, flexible light path, easy to tele-measuring etc. Japan has reached the top level in the field of optical fiber sensor, for example, Idec Izumi Corporation and Surx Corporation.<ul>
<li>与传统传感器相比，光纤传感器具有灵敏度高，体积小，防腐蚀，绝缘性好，光路灵活，易于远程测量等特点。日本在光学领域已达到最高水平 光纤传感器，例如Idec Izumi Corporation和Surx Corporation。</li>
</ul>
</li>
</ol>
<h1 id="lesson-6"><a href="#lesson-6" class="headerlink" title="lesson 6"></a>lesson 6</h1><h2 id="terms-4"><a href="#terms-4" class="headerlink" title="terms"></a>terms</h2><ul>
<li>packaging technology : 分组交换技术</li>
<li>active tag : 有源标签</li>
</ul>
<h2 id="Abbreviations-4"><a href="#Abbreviations-4" class="headerlink" title="Abbreviations"></a>Abbreviations</h2><ul>
<li>RFID : radio frequency identification devices 无线射频识别</li>
<li>LF : Low frequency 低频</li>
<li>HF : High frequency 高频</li>
<li>UHF : Ultra High frequency 超高频</li>
<li>ITU : International Telecommunication Union国际电信联盟</li>
</ul>
<h2 id="Sentences-5"><a href="#Sentences-5" class="headerlink" title="Sentences"></a>Sentences</h2><ol>
<li>The RFID tag features small volume, great capacity, and long term of service life and repeatable use, and supports fast reading and writing, invisible recognition, mobile recognition, multi-target recognition, positioning and long-term tracking management. RFID technology can be used together  with Internet and communication technologies and realize article tracking and information sharing within global scope.<ul>
<li>RFID标签体积小，容量大，使用寿命长且可重复使用，并支持快速读写，隐形识别，移动识别，多目标识别，定位和长期跟踪管理。 RFID技术可以与Internet和通信技术一起使用，并在全球范围内实现商品跟踪和信息共享。</li>
</ul>
</li>
<li>In recent years, the RFID technology has been applied in many social areas, and produced significant influences on improving life quality of people, increasing economic benefits of enterprises, enhancing public security and raising the level of social informationization. According to forecasts, the RFID tag technology will be gradually used in large scale in the next two or three years.<ul>
<li>近年来，RFID技术已经在许多社会领域得到应用，并且对改善人们的生活质量，增加企业的经济效益，增强公共安全和提高社会信息化水平产生了重大影响。 根据预测，RFID标签技术将在未来两三年内逐步大规模使用。</li>
</ul>
</li>
</ol>
<h1 id="lesson-7"><a href="#lesson-7" class="headerlink" title="lesson 7"></a>lesson 7</h1><h2 id="terms-5"><a href="#terms-5" class="headerlink" title="terms"></a>terms</h2><ul>
<li>access point : 接入点或访问点</li>
<li>ad hoc : 无线对等网络或无线自组织网络</li>
<li>network topology : 网络拓扑</li>
<li>intrusion detection : 入侵检测</li>
<li>peer-to-peer : 点对点</li>
<li>power consumption : 能耗</li>
<li>solar panels : 太阳能板或太阳能电池板</li>
</ul>
<h2 id="Abbreviations-5"><a href="#Abbreviations-5" class="headerlink" title="Abbreviations"></a>Abbreviations</h2><ul>
<li>ACL : Access Control List 访问控制列表</li>
<li>CSMA-CA :  载波侦听多路复用&#x2F;避免冲突</li>
<li>MSG : Message service type 报文</li>
<li>WLAN : wireless local area network 无线局域网络</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化刷视频/答题/考试[低调使用别乱传]</title>
    <url>/%E6%95%B0%E7%A0%81%E4%BA%A7%E5%93%81%E6%8E%A8%E8%8D%90/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%B7%E8%A7%86%E9%A2%91-%E7%AD%94%E9%A2%98-%E8%80%83%E8%AF%95-%E4%BD%8E%E8%B0%83%E4%BD%BF%E7%94%A8%E5%88%AB%E4%B9%B1%E4%BC%A0/</url>
    <content><![CDATA[<p>脚本可以代刷题和考试是怎么回事呢？脚本相信大家都很熟悉，但是脚本可以代刷题和考试是怎么回事呢，下面就让小编带大家一起了解吧。</p>
<p>脚本可以代刷题和考试，其实就是可以刷题，大家可能会很惊讶脚本怎么可以代刷题和考试呢？但事实就是这样，小编也感到非常惊讶。</p>
<p>这就是关于脚本可以代刷题和考试的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！</p>
<span id="more"></span>

<p>咳咳，不皮了，下面直接上教程</p>
<h1 id="下载然后解压专用浏览器"><a href="#下载然后解压专用浏览器" class="headerlink" title="下载然后解压专用浏览器"></a>下载然后解压专用浏览器</h1><p>直接下载浏览器：<a href="http://d0.ananas.chaoxing.com/download/8df820a700af0377a80124d3987801fc?fn=%E8%B6%85%E6%98%9F%E6%99%BA%E6%85%A7%E6%A0%91%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88V1.1.6.zip">超星直链</a></p>
<p>超星自带的网盘真的好用，下载还不限速，</p>
<p>因为我已经更新好了脚本，所以解压出来就可以直接用了。</p>
<h1 id="免费搜题软件"><a href="#免费搜题软件" class="headerlink" title="免费搜题软件"></a>免费搜题软件</h1><p>这里再推荐一个免费搜题app，叫学小易，可以直接在公众号搜题，但是答案过多会无法完全显示，使用最好用app：<a href="https://www.51xuexiaoyi.com/download">下载地址</a></p>
]]></content>
      <categories>
        <category>数码产品推荐</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存击穿、穿透、雪崩的区别和解决方法</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>数据获取的流程，一般是前端请求，后台先从缓存中取数据，缓存取不到则去数据库中取，数据库取到了则返回给前端，然后更新缓存，如果数据库取不到则返回空数据给前端</p>
<span id="more"></span>

<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.jpg" class="" title="流程图">

<p>假如缓存的数据没有，后台则会一直请求数据库，对数据库造成压力，如果是请求量大或者恶意请求则会导致数据库崩溃，我们一般称为缓存穿透、缓存击穿、缓存雪崩。</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>描述：缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大（不存在的数据）。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/2.png" class="" title="缓存穿透">

<p>解决：</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，比如 id&lt;&#x3D;0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，直接返回空值。缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</li>
<li>异步更新。直接返回一个空值，然后启动一个线程去数据库读数据，更新缓存，比如项目启动前先加载缓存。</li>
<li>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li>
</ol>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>描述：缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>，当一个key非常热点（类似于爆款），在不停的扛着大并发，大并发集中对这一个点进行访问；当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/3.png" class="" title="缓存击穿">
<p>解决：</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁。（或者分布式锁）</li>
</ol>
<p>如果缓存中有数据，则直接返回，如果没有，则第一个进入的线程先去查询数据库，并加上锁，其他线程则等待，这样就能防止去数据库查重复数据、重复更新缓存了。</p>
<p>关于互斥锁，可以看看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">        <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);  <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;      </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指<strong>缓存中数据大批量到过期时间，大批量数据同一时间过期</strong>，导致请求量全部请求到数据库，造成数据库宕机。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/4.png" class="" title="缓存雪崩">
<p>解决：</p>
<ol>
<li>给缓存失效时间，加上一个随机值，避免大量缓存集体失效。</li>
<li>双缓存：缓存A和B，比如A的失效时间是20分钟，B不失效。比如从A中没读到，就去B中读，然后异步起一个线程同步到A。</li>
</ol>
<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热就是系统上线后，后者系统在重启的时候，将相关的缓存数据直接加载到Redis。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>
<p>解决：</p>
<ol>
<li>上线时加个接口，手动触发加载缓存，或者定时刷新缓存。</li>
<li>数据量不大，可以在项目启动的时候自动进行加载。</li>
</ol>
<hr>
<p>相关文章：</p>
<ol>
<li><a href="https://www.iteye.com/blog/carlosfu-2269687">https://www.iteye.com/blog/carlosfu-2269687</a></li>
<li><a href="https://mp.weixin.qq.com/s/LOCLXG_mzBVQeFrtM8srmA">https://mp.weixin.qq.com/s/LOCLXG_mzBVQeFrtM8srmA</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网通信笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>知识点和作业题总结</p>
<span id="more"></span>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>通信：消息的传递<br>消息：符号、文字、语音、数据、图像等<br>信号：为了传递消息，各种消息必须转换为相应的电信号或光信号，信号是消息的载体，信息是消息的内涵。信息量即信息多少的量度，用信息熵表示<br>信息熵：<br>电信号、光信号：本质上都是电磁波，具有不同的频率和波长<br>频谱与带宽：实际上一种信号是由多个频率成分组成的，信号所包含的频率成分的范围称为频谱；信号的带宽就是该频谱的绝对宽度</p>
<p>通信系统（模型）：消息传递的过程中所经过的一系列环节构成通信系统，可抽象为一个通信系统模型</p>
<p>信源：信号的源头<br>信宿：信号的目的地<br>信道：信号传输的通道（按传输介质可分为：无线（明线、电缆光纤）和有线（微波、卫星））<br>物理信道：一个实际存在的物理实体信道称为物理信道，包含实际存在的物理设备和传输物理媒质。<br>逻辑信道：采用多路复用技术在一个物理信道中来传输多路信号而划分的信道称为逻辑信道。</p>
<p>模拟信号：信号是连续的变化状态，如语音信号<br>数字信号：信号是可数的、离散的变化状态，如数据、符号等（A：01000001）A&#x2F; D转换与D &#x2F; A转换：<br>为了更有利于信号在信道中传送，传得更远，信道中一般不直接传送原始信号即基带信号，先要将它调制（加载）到高频载波（也是电磁波）上转换为频带信号，再传送<br>度量无线通信的技术性能：有效性度量（数量方面）、可靠性度量（质量方面）<br>无失真离散信源编码方法：等长编码、变长编码</p>
<p><code>低频(LF)：30~300 KHz、中频(MF)：300~3000 KHz、高频(HF)	3~30 MHz</code></p>
<p>基带传送：在传输介质上直接传送基带信号（双绞线、传统电话线）<br>多路复用：在一条物理介质上同时传送多路信号<br>    频分复用（FDM）：将多路信号经过高频载波信号调制后在同一介质上传送，每路信号被调制到不同的载波频段上占用介质的不同频带实现复用<br>    时分复用（TDM）：将多路模拟信号分别经过PCM调制后变为数字信号，然后每路信号以时分的方式在属于自己的时间片中占用传输介质的全部带宽进行复用<br>    波分复用（WDM）：本质上是光域上的FDM技术，将光纤的低损耗窗口划分成若	干个信道，每一个信道占用不同的光波频率（或波长），在发送端采用波分复用器（合波器）将不同波长的光载信号合并起来送入一根光纤进行传输；然后在接收端用分波器将这些由不同波长光载波信号组成的光信号分离开来</p>
<p>通信的交换技术：电路交换、报文交换、分组交换<br>通信方式：单工通信、半双工通信、全双工通信</p>
<p>物联网定义：<br>    2005年ITU：物联网即物物相联的互联网<br>    2012年ITU修改物联网定义：物联网是信息社会的一个全球基础设施，它基于现有和未来可互操作的信息和通信技术，通过物理的和虚拟的物物相联，来提供更好的服务。<br>    物联网：通过射频识别（RFID）、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物体与互联网相连接，进行信息交换和通信，以实现对物体的智能化识别、定位、跟踪、监控和管理的一种网络系统。</p>
<p>物联网实现物理世界与信息世界的无缝连接<br>连接到物联网上的每个“物”应该具有4个基本的特征：地址标识、感知能力、通信能力和可以控制<br>物联网提供服务特点：任何人可以在任何时候、任何地方，通过任何网络或途径访问任何资源和任何服务</p>
<p>物联网三层框架及其通信结构：感知层、网络层、应用层<br>在物联网中，通信的主要作用是将信息可靠安全地传送到目的地。<br>物联网所采用的通信方式和通信系统也具有异构性和复杂性，采用的是以数据为主的通信手段，物联网的感知控制层的通信方式最为复杂。</p>
<p>感知控制的通信目的是将各种设备传感设备（或数据采集设备以及连同的控制设备）所感知的信息在较短的通信距离内送到信息汇聚系统，并由该系统传送（或互联）到网络传输层，其通信的特点是传输距离短，传输方式灵活、多样。</p>
<p>感知控制层所采用的通信技术主要分为短距离有线通信、短距离无线通信和无线传感器网络。<br>感知层短距离有线通信技术主要是由各种串行数据通信技术构成的，目前采用的技术有RS-232&#x2F;485、USB、CAN工业总线、及各种串行数据通信技术。<br>感知层短距离无线通信技术主要有各种低功率、中高频无线数据传输技术，目前主要采用蓝牙、红外、低功率无线数传电台、无线局域网等技术来完成短距离无线通信任务。</p>
<p>无线传感器网络（WSN）是一种部署在感知区域内的大量的微型传感器节点通过无线传输方式形成的一个多跳的自组织系统。它一种具有网络规模大、自组织、多跳路由、动态拓扑、可靠性高的以数据为中心的、能量受限的通信网络，是“狭义”上的物联网，也是物联网的核心技术之一。</p>
<p>网络传输层是由数据通信主机（或服务器）、网络交换机、路由器等构成的<br>网络传输层通信系统中支持计算机通信系统的数据传送网可由公众固定网、公众移动通信网、公众数据网及其他专用网构成。<br>目前的公众固定、移动通信网、公众数据网主要有PSTN（公众电话交换网）、GSM（全球移动通信系统）、CDMA（码分多址）、TD-SCDMA（时分同步码分多址)、DDN（数字数据网）、ATM（异步传输模式）、FR（帧中继）等，它们为物联网的网络层提供了数据传送平台</p>
<p>公众通信网和专用传送网构成的数据传送平台是物联网网络传输层的基础设施，<br>主机、网络交换机及路由器等构成的计算机网络系统是物联网网络传输层的功能设施，<br>为物联网提供各种信息存储、信息传送、信息处理等各项基础服务，为物联网的综合应用层提供了信息承载平台，保障了物联网各专业领域的应用。</p>
<p>物联网通信技术几个研究方面：频谱分配与扩频通信、异构网络融合、IP 网络技术等。<br>OSI参考模型七层：应用层、表示层、会话层、传输层、网络层、链路层、物理层<br>TCP&#x2F;IP参考模型：应用层、传输层、网络层、网络接口层</p>
<p>物联网通信体系结构：</p>
<p>RS-232串口通信最简单的三线连接法：TXD（发送数据）-RXD（接收数据）、RXD-TXD、Ground（信号地）-Ground<br>USB引脚：红（电源正5V）、白（数据-）、绿（数据+）、黑（地）（针脚顺序左往右）<br>Mini-USB引脚：与USB相比增加ID（A型与地相连、B型不接地）（针脚4是ID、5是地）</p>
<p>USB拓扑结构（分层的星型拓扑）组成：USB连接、USB设备、USB主机7层体系，最多5层USB Hub<br>USB总线结构：USB连接、USB设备、USB主机<br>USB主机系统：USB功能应用、USB设备驱动、USB总线接口<br>USB传输方式：控制传输方式、数据块传输方式、同步传输方式、中断传输方式<br>USB传输技术：2.0以前差分半双工，3.0差分全双工<br>USB的发展：3.0，4.0，无线，双机互连，主动式光纤缆线</p>
<p>CAN总线系统由三个主要功能部件组成：CAN收发器、数据传输终端、数据传输线</p>
<p>无线通信是利用电磁波信号可以在自由空间中传播的特性进行信息交换的一种通信方式<br>目前信息通信领域中，发展最快、应用最广的就是无线通信技术。在移动中实现的无线通信又通称为移动通信，人们把二者合称为无线移动通信。</p>
<p>无线个人区域网（WPAN）：蓝牙、ZigBee（低成本、低功率的无线通信）和超宽带UWB（高速近距无线通信）<br>无线局域网：WiFi<br>宽带无线接入：WiMAX<br>蜂窝电话系统——最成功的无线网络<br>卫星通信系统：广播视频、语音，卫星电话，定位</p>
<p>无线信道主要以辐射无线电波为传输方式的无线电信道和在水下传播声波的水声信道等。</p>
<p>不同频段的无线电波有不同的传播方式：<br>地波传输：地球和电离层构成波导，中长波、长波和甚长波可以在这天然波导内沿着地面传播并绕过地面的障碍物<br>天波传输：短波、超短波可以通过电离层形成的反射信道和对流层形成的散射信道进行传播<br>视距传输：对于超短波、微波等更高频率的电磁波，通常采用直接点对点的直线传输<br>无线信道举例：无线电视距中继、卫星中继信道<br>常用的无线ISM频段分为工业（902-928MHz），科学研究（2.42-2.4835GHz）和医疗（5.725-5.850GHz）<br>局域网IEEE 802.11b&#x2F;g工作在2.4～2.4835GHz频段</p>
<p>“蓝牙”是一种近距离无线连接技术标准的代称，蓝牙的实质就是要建立通用的无线电空中接口及其控制软件的公开标准。<br>蓝牙是一种近距离无线通信技术，它的标准是IEEE 802.15，工作在2.4GHz频带，带宽为1 Mbps。电子装置彼此可以通过蓝牙连接起来，省去了传统的电线。通过芯片上的无线接收器，配有蓝牙的电子产品能够在10m的距离内彼此相连，传输速率可以达到1 Mbps。<br>蓝牙技术：跳频技术（1600跳&#x2F;s跳转一个信道，传送一个时隙数据，即产生一次跳频）</p>
<p>蓝牙系统的基本术语：<br>微微网：是由采用蓝牙技术的所有设备以对等网方式组成的网络。最多由8台设备构成。<br>分布式网络：是由多个独立、非同步的微微网形成的,也叫散射网络。<br>主设备（主单元）：在微微网中，如果某台设备的时钟和跳频序列用于同步其他设备，则称它为主设备。<br>从设备（从单元）：非主设备的设备均为从设备。<br>MAC地址：用3 bit表示的地址，用于区分微微网中的设备。<br>休眠设备：在微微网中只参与同步，但没有MAC地址的设备。<br>监听及保持方式：指微微网中从设备的两种低功耗工作方式。</p>
<p>蓝牙协议体系结构:核心协议层： 基带、 链路管理协议(LMP)、 适配协议和逻辑链路控制应用协议(L2CAP)、 服务搜索协议(SDP)。</p>
<p>由ZigBee技术构建的无线传感网，是由一组ZigBee节点以Ad-Hoc自组织多跳方式构成的。部分或全部节点都是可以移动的，网络的拓扑结构也会随着节点的移动而不断发生变化。每个节点都具有动态搜索、定位跟踪和恢复连接的能力。</p>
<p>ZigBee是一种开放的协议，物理层（PHY）和MAC层则采用了IEEE 802.15.4标准，而其他上层则由ZigBee联盟自己定义。其主要特点如下：<br>低功耗。ZigBee网络节点设备工作周期较短、收发信息功率低，并且采用了休眠模式。<br>传输可靠，抗干扰强。<br>低成本。由于ZigBee协议栈设计简练，因此，它的研发成本相对较低。<br>安全。ZigBee技术提供了数据完整性检查和鉴权功能，加密算法采用AES-128&#x2F;64&#x2F;32，并且各应用可以灵活地确定其安全属性，使网络安全能够得到更有效的保障。<br>速度快，距离远。</p>
<p>ZigBee网络拓扑结构：星型网络拓扑结构、网状拓扑结构、簇-树状网络拓扑结构</p>
<p>ZigBee物理设备：全功能设备（FFD）、简化功能设备（RFD）<br>FFD适应星形、簇-树形、网状；RFD适应星形<br>FFD：具有转发与路由能力，拥有足够的存储空间来存储路由信息，具备处理控制能力，可作为协调器，可与任何ZigBee设备通信。<br>RFD：不具备转发与路由能力，内存小、功耗低，只发送与接收信号，不能作为协调器，只能与全功能设备通信。</p>
<p>ZigBee三类逻辑设备：ZigBee协调器、ZigBee路由设备、ZigBee终端设备<br>ZigBee协调器：3类设备中最复杂的一种，存储容量最大，计算能力最强，必须是全功能设备。每个ZigBee网络必须有且只有一个协调器，负责发送网络信标、建立、初始化和管理网络，确定信道，分配16位网络地址。<br>ZigBee路由设备 ：是一个全功能设备， 在接入网络后它自动获得一个16位网络地址，并允许在其通信范围内的其他节点加入或退出网络，同时还具有路由与转发数据能力。<br>ZigBee终端设备：可以由全功能设备或简化功能设备构成，它只能与父节点进行通信，并从父节点处获得网络标识和短地址信息。<br>一个节点是一个设备，有一个射频端，一个64位IEEE地址(全球唯一)，一个16位网络地址。</p>
<p>ZigBee的带宽和数据传输率：<br>2.4 GHz（ISM频带）：全世界使用、数据传输率250kbps、信道16<br>868MHz：欧洲使用、数据传输率20kbps、信道1<br>915GHz（ISM频带）：北美使用、数据传输率40kbps、信道10</p>
<p>ZigBee MAC子层数据帧格式：MHR（MAC层帧头）、MAC载荷、MFR</p>
<p>ZigBee通信可靠性保证：通信可靠机制、网络的自组织治愈能力强<br>通信可靠机制：CSMA-CA的碰撞避免机制、完全确认的数据传输机制<br>ZigBee采用了CSMA-CA的碰撞避免机制，同时为需要固定带宽的通信业务预留了专用时隙，避免了发送数据时的竞争和冲突；明晰的信道检测<br>MAC层采用了完全确认的数据传输机制，每个发送的数据包都必须等待接受方的确认信息。<br>网络的自组织自愈能力强<br>ZigBee的自组织功能：无需人工干预，网络节点能够感知其他节点的存在，并确定连结关系，组成结构化的网络；<br>ZigBee自愈功能：增加或者删除一个节点，节点位置发生变动，节点发生故障等等，网络都能够自我修复，并对网络拓扑结构进行相应的调整，无需人工干预，保证整个系统仍然能正常工作。</p>
<p>超宽带无线电是指具有很高带宽比（射频带宽与其中心频率之比）的无线电技术。<br>美国FCC对UWB的定义为：（或者总带宽不小于500 MHz）<br>其中，fH、fL分别为功率较峰值功率下降10 dB时所对应的高端频率和低端频率，fC为载波频率或中心频率。</p>
<p>UWB通信系统的主要实现方式：基带脉冲方式和载波调制方式。<br>前者是传统的UWB通信方式，后者是FCC规定了UWB通信的频率使用范围和功率限制后，在UW无线通信标准化的过程中提出的。载波调制的UWB通信系统又可分为单带和多带两种形式。（脉冲无线电、单载波方式、多带载波方式）</p>
<p>UWB的技术特点：系统结构的实现比较简单、高速的数据传输、功耗低、安全性高、多径分辨能力强、定位精确、工程简单，造价便宜</p>
<p>红外线(Infrared)是一种波长范围在750 nm<del>1 mm之间的电磁波，它的频率高于微波而低于可见光，是一种人眼看不到的光线。<br>红外通信一般采用红外波段内的近红外线，即采用波长在0.75</del>25μm之间的电磁波进行无线通信。</p>
<p>1993年成立的红外数据协会(Infrared Data Association，IrDA)，为了保证不同厂商生产的红外产品能够获得最佳的通信效果，制定的红外通信协议将红外数据通信所采用的光波波长的范围限定在850~900 nm之间。</p>
<p>红外通信特点：</p>
<ul>
<li>具有极强的保密性</li>
<li>避免常规无线电波之间的相互干扰；</li>
<li>带宽较宽，可承载高速数据传输；</li>
<li>设备结构简单、 成本低、 耗电少， 能高速数据通信；</li>
<li>依靠低成本的红外发射器与接收器就能进行高速数据通信。</li>
</ul>
<p>无线个人局域网（WPAN）是一种采用无线连接的个人局域网。它被用在诸如电话、计算机、附属设备以及小范围（个人局域网的工作范围一般是在10米以内）内的数字助理设备之间的通讯。<br>支持无线个人局域网的技术包括：蓝牙、ZigBee、超频波段（UWB）、IrDA、HomeRF等</p>
<p>近场通信（Near Field Communication，NFC）是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内。其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。<br>目前近场通信已通过成为ISO&#x2F;IEC IS 18092国际标准、ECMA-340标准与ETSI TS 102 190标准。</p>
<p>NFC采用主动和被动两种读取模式。<br>NFC工作模式：卡模式、点对点模式<br>卡模式（Card emulation）：这个模式其实就是相当于一张采用RFID技术的IC卡。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的 RF 域来供电，即便是寄主设备（如手机）没电也可以工作<br>点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输</p>
<p>NFC特征：</p>
<ul>
<li>与RFID一样，NFC信息也是通过频谱中无线频率部分的电磁感应耦合方式传递，但两者之间还是存在很大的区别。</li>
<li>NFC是一种提供轻松、安全、迅速的通信的无线连接技术，其传输范围比RFID小。</li>
<li>NFC与现有非接触智能卡技术兼容，已经成为得到越来越多主要厂商支持的正式标准。</li>
<li>NFC还是一种近距离连接协议，提供各种设备间轻松、安全、迅速而自动的通信。</li>
<li>与无线世界中的其他连接方式相比，NFC是一种近距离的私密通信方式。</li>
</ul>
<p>支持NFC的设备可以在主动或被动模式下交换数据。<br>在被动模式下，启动NFC通信的设备，也称为NFC发起设备(主设备)，在整个通信过程中提供射频场(RF-field)。它可以选择106kbps、212kbps或424kbps其中一种传输速度，将数据发送到另一台设备。另一台设备称为NFC目标设备(从设备)，不必产生射频场，而使用负载调制(load modulation)技术，即可以相同的速度将数据传回发起设备。</p>
<p>NFC与RFID区别</p>
<ul>
<li>NFC将非接触读卡器、非接触卡和点对点功能整合进一块单芯片，而RFID必须有阅读器和标签组成。 </li>
<li>NFC传输范围比RFID小 </li>
<li>应用方向不同</li>
</ul>
<p>计算机网络是利用通信线路将地理位置分散的、具有独立功能的许多计算机系统连接起来，按照某种协议进行数据通信，以实现资源共享及分布式处理的系统。</p>
<p>按网络结点分布，计算机网络可分为局域网（LAN）、广域网（WAN）和城域网（MAN）。</p>
<p>按交换方式计算机网络可分为电路交换网络、报文交换网络和分组交换网络等。</p>
<p>按网络拓扑结构计算机网络可分为星型网络、树状网络、总线型网络、环型网络和网状网络等。</p>
<p>带有冲突检测的载波侦听多路访问（CSMA&#x2F;CD）工作流程：先听后发、边发边听、冲突停止、随机延迟后重发</p>
<p>IP（v4）编址方式：网络号+主机号<br>IP编址方式-子网编址：网络地址+子网地址+主机地址<br>IP编址方式-无分类编址：IP地址&#x2F;网络位数</p>
<p>无线局域网（Wireless LAN，WLAN）是20世纪90年代计算机网络与无线通信技术相结合的产物。</p>
<p>与有线LAN相比，无线LAN具有以下主要优点：</p>
<ul>
<li>由于无线LAN不需要布线；</li>
<li>无线LAN可作为有线LAN的无线延伸，也可用于有线LAN的无线互连；</li>
<li>便于笔记本等便携式计算机的接入；</li>
<li>不受场地限制，能迅速建立局域网；例如，大型展示会、灾后网络恢复等需要短时间内建立一些临时局域网。</li>
<li>通过支持移动IP，实现移动计算机网络。</li>
</ul>
<p>无线局域网的技术要点：可靠性、兼容性、数据传输速率、通信安全、移动性</p>
<ul>
<li>可靠性：分组丢失率应该低于10-5，误码率应该低于10-8；</li>
<li>兼容性：室内应用的局域网，应尽可能与现有的有线局域网兼容，现有的网络操作系统和网络软件应能在无线局域网上不加修改地正常运行；</li>
<li>数据传输速率：为了满足局域网的业务环境，无线局域网至少应具备1 Mbit&#x2F;s的数据传输速率，802.11n可达几百Mbps；</li>
<li>通信安全：无线局域网可在不同层次采取措施来保证通信的安全性；</li>
<li>移动性：无线局域网中的网站分为全移动站与半移动站。全移动站指在网络覆盖范围内该站可在移动状态下保持与网络的通信。半移动站指在网络覆盖范围内网中的站可自由移动，但仅在静止状态下才能与网络通信。</li>
</ul>
<p>无线网卡：PCMCIA无线网卡、PCI无线网卡、USB无线网卡<br>无线网桥也称无线网关、无线接入点或无线AP(Access Point)<br>AP通过标准接口，经由集线器(hub)、路由器(router)与因特网(Intemet)相连，<br>IEEE 802.11标准无线局域网的构件</p>
<ul>
<li>无线局域网最小构件：基本服务集合（BSS）、拓展服务集（ESS）</li>
<li>基本服务集(Basic Service Set，BSS)，一个BSS包括一个AP和若干个移动站；</li>
<li>扩展服务集(ESS，Extension Service Set)：包括两个或更多的基本服务集</li>
</ul>
<p>无线局域网的拓扑结构：无中心拓扑（对等式拓扑）、单接入点方式、多接入点方式、多蜂窝漫游工作方式</p>
<p>IEEE 802.11标准规定了物理层的三种实现方法：跳频扩频、直接序列扩频、红外技术</p>
<ul>
<li>跳频扩频（Frequency Hopping Spread Spectrum，FHSS）是扩频技术中常用的一种。</li>
<li>直接序列扩频（Direct Sequence Spread Spectrum，DSSS）是另一种重要的扩频技术。	红外技术（Infrared，IR）是指使用波长为850-950 nm的红外线在室内传送数据。</li>
</ul>
<p>FHSS是一种载频不断随机改变的扩频技术。载频的变化规律受一串伪随机码的控制，发送端和接收端用相同的伪随机码控制频率的变化规律。在某一时刻，即使有特定频率的杂波进行干扰，载波频率立即改变成其他频率，因此抗干扰性强。</p>
<p>隐蔽站问题：当A和C都检测不到无线信号时，以为B是空的向B发送数据，结果B同时收到A和C发送的数据发生碰撞<br>暴露站问题：当站B向A发送数据，而C又想和D通信时，由于C检测到了媒体上有信号，于是不能向D发送数据</p>
<p>请求发送帧RTS(Request To Send) 允许发送帧CTS(Clear To Send)<br>发送端→ RTS →接收端<br>接收端→ CTS →发送端<br>发送端→数据帧→接收端<br>接收端→ ACK →发送端</p>
<p>CSMA&#x2F;CA（载波侦听多路访问／冲突避免）和CSMA&#x2F;CD（载波帧听，多路访问&#x2F;冲突检测）的区别：</p>
<ul>
<li>CSMA&#x2F;CD：可以检测冲突，但无法“避免”</li>
<li>CSMA&#x2F;CA：不能检测到信道上有无冲突，只能尽量“避免”</li>
<li>传输介质不同，CSMA&#x2F;CD用于总线式以太网，而CSMA&#x2F;CA则用于无线局域网802.11a&#x2F;b&#x2F;g&#x2F;n等等</li>
<li>检测方式不同，CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式</li>
</ul>
<p>WLAN为什么不能用CSMA&#x2F;CD协议而必须使用CSMA&#x2F;CA协议：WLAN中，信号动态变化范围大，对某个节点来说，其刚刚发出的信号强度要远高于来自其他节点的信号强度，也就是说它自己的信号会把其他的信号给覆盖掉，在WLAN中实现CSMA&#x2F;CD是比较困难</p>
<p>早期出现的本地多点分配系统LMDS（Local Multipoint Distribution System）就是一种宽带无线城域网接入技术。许多国家把27.5 GHz~29.5GHz定为LMDS频段。然而由于缺乏统一的技术标准，LMDS一直未能普及起来。<br>WiMAX是Worldwide Interoperability for Microwave Access的缩写(意思是“全球微波接入的互操作性”，AX表示Access)。在许多文献中，我们可以见到WiMAX常用来表示无线城域网WMAN，这与Wi-Fi常用来表示无线局域网WLAN相似。但应分清：IEEE的802.16工作组是无线城域网标准的制定者，而WiMAX论坛则是802.1技术的推动者。</p>
<p>无线城域网共有两个正式标准：802.16d、 802.16e</p>
<p>802.16可覆盖一个城市的部分区域，通信的距离变化很大（远的可达50公里）<br>802.16必须有不同的物理层<br>802.16的基站可能需要多个定向天线<br>802.16对差错的处理尤为重要</p>
<p>起基础性作用的是空中接口IEEE802. 16 与802. 16a</p>
<p>WiMax技术标准为IEEE 802. 16系列， WiMax采用IEEE 802. 16系列标准尤其是802. 16a，作为物理层及MAC 层技术，WiMax 技术还可具备在2～66GHz频带范围内可利用所有需要或不需要许可的频带，以及确保服务质量(QoS) 等功能。<br>WiMax 设备通常由安装在建筑物上的基站或塔式基站和家庭或办公场所内的用户接入终端组成<br>WiMAX工作原理：非视线无线上网型服务、视线型服务</p>
<p>WiMAX与WiFi的区别</p>
<ul>
<li>传输范围分析<br>  WiMAX的设计可以在需要执照的无线频段，或是公用的无线频段进行网络运作；WiFi的设计则只在公用频段中的2.4 GHz到5 GHZ之间工作<br>  一般的WiMAX的传输功率大约100千瓦，所以WiFi的功率大约是WiMAX的一百万分之一<br>  使用WiFi基地台一百万倍传输功率的WiMAX基地台，会有比WiFi终端更大的传输距离 </li>
<li>传输速度分析<br>  虽然WiMAX声称最高速度每秒324Mbyte，然而最新的WiFi MIMO理论上也有每秒108Mbyte的最高速度</li>
<li>安全性分析<br>  WiMAX使用的是与WiFi的WPA2标准相似的认证与加密方法。其中的微小区别在于WiMAX的安全机制使用3DES或AES加密，然后再加上EAP，而WiFi的WPA2则是用典型的PEAP认证与AES加密。</li>
<li>移动性分析<br>  WiMAX标准之一802.16e提供的主要是具有一定移动特性的宽带数据业务，面向的用户主要是笔记本终端和802.16e终端持有者。802.16e为了获得较高的数据接入带宽(30 Mbit&#x2F;s)，必然要牺牲覆盖和移动性，因此802.16e在相当长的时间内将主要解决热点覆盖，网络可以提供部分的移动性<br>  在移动性方面WiFi技术也是支持的，但是不支持两个WiFi基地台之间的终端的切换</li>
</ul>
<p>通信网是各种通信节点（端节点、交换节点、转接点）及连接各节点的传输链路互相依存的有机结合体，以实现两点及多个规定点间的通信体系</p>
<ul>
<li>基本功能：克服时间、空间等障碍实现有效的信息交换</li>
<li>构成要素：从硬件设施方面去看，通信网由终端设备、交换设备及传输链路三大要素组成</li>
</ul>
<p>通信系统模型：网状网、交换式网络</p>
<ul>
<li>网状网不适用于构建广域通信网<ol>
<li>每个用户之间都要有直达线路，成本太高，技术不可行</li>
<li>用户永久独占通信线路，巨大浪费资源</li>
<li>难于控制和管理</li>
</ol>
</li>
<li>交换式网络<ol>
<li>引入交换节点，用户线与交换节点相接，通信时通过交换节点进行转接交换，	交换节点之间通过中继线相连</li>
<li>通过复杂的控制机制来“按需分配”网络资源</li>
</ol>
</li>
</ul>
<p>通信网的拓扑结构：星型网、网型网、网孔型网、环型网、总线型网、树型网、复合型网<br>电话网的构成要素：终端设备、交换设备、传输系统</p>
<p>移动通信网的覆盖方式</p>
<ul>
<li>大区：1BS&#x3D;1服务区（30-50KM）</li>
<li>小区：1服务区&#x3D;n小区（2-10KM）</li>
</ul>
<p>FDMA（频分多址）：把总带宽分隔成多个正交的信道，每一个信道每一次只能分配给一个用户<br>TDMA（时分多址）：在一个带宽上，把时间分成周期性的帧，每一帧再分割成若干时隙（无论帧或时隙都是互不重叠的），每个时隙就是一个通信信道，分配给一个用户。<br>CDMA（码分多址）：利用码序列相关性实现的多址通信，每一个用户可以在同样的时间使用同样的频带进行通信。</p>
<p>GSM的网络结构：MS（移动台）、BSS（基站子系统）、NSS（网络子系统）、OSS（操作子系统）<br>移动台用IMSI（国际移动用户识别码）来标识自己时的位置登记和删除</p>
<p>GPRS网络结构：GPRS网关支持节点（GGSN）、GPRS服务支持节点（SGSN）、基站发信台（BTS）、基站控制器（BSC）、分组控制单元（PCU）、移动交换中心（MSC）、短消息中心（SMSC）、归属位置寄存器（SLR）、边界网关（BG）、计费网关（CG）、域名服务器（DNS）</p>
<p>异构网络（Heterogeneous Networks，HetNets）是指一种多协议网络，其构成主要包含不同制造商生产的网络设备和相关应用系统。<br>互联网是由多个异构网络互联组成的，用来连接异构网络的设备是路由器。<br>两个或以上采用了不同的接入技术，或者是采用相同的无线接入技术但网络设备在网络带宽、存储&#x2F;计算&#x2F;处理等资源上有明显差别的无线通信系统智能地融合在一起，构成异构无线网络。<br>异构终端以协同自组的方式密集部署而形成异构网络，同时多种异构网络也以协同自组的方式进行互联</p>
<p>切换是指移动终端之间的连接从一个信道转移到另一个信道的过程。<br>水平切换：同构网络不同小区之间的切换<br>垂直切换：异构网络之间的切换。</p>
<p>网络选择是当用户从一个网络离开的时候，如何确定其他备选网络以及选择网络以及选择哪个网络进行接入的问题。</p>
<h1 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h1><h2 id="简述频分、时分和波分复用技术工作原理。"><a href="#简述频分、时分和波分复用技术工作原理。" class="headerlink" title="简述频分、时分和波分复用技术工作原理。"></a>简述频分、时分和波分复用技术工作原理。</h2><p>答：频分复用（FDM）：将多路信号经过高频载波信号调制后在同一介质上传送，每路信号被调制到不同的载波频段上占用介质的不同频带实现复用<br>    时分复用（TDM）：将多路模拟信号分别经过PCM调制后变为数字信号，然后每路信号以时分的方式在属于自己的时间片中占用传输介质的全部带宽进行复用<br>    波分复用（WDM）：本质上是光域上的FDM技术，将光纤的低损耗窗口划分成若	干个信道，每一个信道占用不同的光波频率（或波长），在发送端采用波分复用器（合波器）将不同波长的光载信号合并起来送入一根光纤进行传输；然后在接收端用分波器将这些由不同波长光载波信号组成的光信号分离开来</p>
<h2 id="试画出RS-232C收发接口的标准连接及最简单连接方式。"><a href="#试画出RS-232C收发接口的标准连接及最简单连接方式。" class="headerlink" title="试画出RS-232C收发接口的标准连接及最简单连接方式。"></a>试画出RS-232C收发接口的标准连接及最简单连接方式。</h2><p>答：标准连接(9对9)：<br>略<br>最简单连接(3对3)：<br>略</p>
<h2 id="USB总线主要由哪几部分组成？"><a href="#USB总线主要由哪几部分组成？" class="headerlink" title="USB总线主要由哪几部分组成？"></a>USB总线主要由哪几部分组成？</h2><p>答：<br>USB总线结构：USB连接、USB设备、USB主机<br>USB设备是通过USB总线连接到USB主机上的。USB总线上的物理连接是一个分层的星形拓扑。处于每个星形拓扑中央的是hub（USB集线器）。在主机和一个hub或者一个应用之间以及在hub和其它hub或应用之间都是一个点对点的连接。<br>在USB总线中只有一个主机。USB总线与计算机主机系统的接口部分就是主机控制器，它可被看作一个硬件、固件和软件的结合体。主机系统中集成了一个根hub来提供一个或多个连接点。<br>USB互连是指USB设备与主机之间进行连接和通信的操作，它包括总线拓扑结构、通信各层的任务和相互关系、数据流模型，以及主机与多路USB设备通信时的带宽分配等内容。</p>
<h2 id="简述蓝牙技术的网络结构。"><a href="#简述蓝牙技术的网络结构。" class="headerlink" title="简述蓝牙技术的网络结构。"></a>简述蓝牙技术的网络结构。</h2><p>答：微微网。微微网是由采用蓝牙技术的设备以特定方式组成的网络。微微网的建立由两台设备的连接开始，最多由8台设备构成。<br>分布式网络，也叫散射网络。分布式网络是由多个独立、非同步的微微网形成的，它靠调频顺序识别每个微微网。<br>主设备（主单元）：在微微网中，如果某台设备的时钟和跳频序列用于同步其他设备，则称它为主设备。<br>从设备（从单元）：非主设备的设备均为从设备<br>休眠设备：在微微网中只参与同步，但没有MAC地址的设备。<br>蓝牙技术的网络结构如下图。<br>略</p>
<h2 id="简述蓝牙技术的协议体系结构。"><a href="#简述蓝牙技术的协议体系结构。" class="headerlink" title="简述蓝牙技术的协议体系结构。"></a>简述蓝牙技术的协议体系结构。</h2><p>答：蓝牙协议体系结构可以分为底层硬件模块、核心协议层、高端应用层三大部分，如下图所示。略</p>
<p>物理硬件部分：链路管理器(LM)、基带(BB)和蓝牙射频(RF)构成了蓝牙的物理模块。RF通过2.4GHz的ISM频段实现数据位流的传输。它主要定义了蓝牙收发器应满足的条件。基带负责调频和蓝牙数据与信息帧的传输。基带就是蓝牙的物理层，它负责管理物理信道和链路中除了错误纠正、数据处理、调频选择和蓝牙安全之外的所有业务。链路管理器负责连接的建立和拆除以及链路的安全和控制，其为上层软件模块提供了不同的访问入口，但是两个模块接口之间的信息和数据传输必须通过蓝牙主机控制器(HCI)的解析。<br>核心协议是蓝牙协议的关键部分，包括基带部分协议和其他低层链路功能的基带&#x2F;链路控制器协议；用于链路的建立、安全和控制的链路管理协议LMP；描述主机控制器接口的HCI协议；支持高层协议复用、帧的组装和拆分的逻辑链路控制和适配协议L2CAP；服务发现协议SDP等。核心协议层：基带、 链路管理协议(LMP)、 适配协议和逻辑链路控制应用协议(L2CAP)、 服务搜索协议(SDP)。<br>应用层协议：电缆代替协议(RFCOMM)、电话控制协议(TCS)、与Internet相关的高层协议、无线应用协议(WAP)、点对点协议(PPP)、对象交换协议(OBEX)、TCP&#x2F;UDP&#x2F;IP。</p>
<h2 id="ZigBee网络设备类型有哪些？"><a href="#ZigBee网络设备类型有哪些？" class="headerlink" title="ZigBee网络设备类型有哪些？"></a>ZigBee网络设备类型有哪些？</h2><p>答：<br>ZigBee物理设备：全功能设备（FFD）、简化功能设备（RFD）<br>FFD：具有转发与路由能力，拥有足够的存储空间来存储路由信息，具备处理控制能力，可作为协调器，可与任何ZigBee设备通信。<br>RFD：不具备转发与路由能力，内存小、功耗低，只发送与接收信号，不能作为协调器，只能与全功能设备通信。<br>ZigBee三类逻辑设备：ZigBee协调器、ZigBee路由设备、ZigBee终端设备<br>ZigBee协调器：3类设备中最复杂的一种，存储容量最大，计算能力最强，必须是全功能设备。每个ZigBee网络必须有且只有一个协调器，负责发送网络信标、建立、初始化和管理网络，确定信道，分配16位网络地址。<br>ZigBee路由设备 ：是一个全功能设备， 在接入网络后它自动获得一个16位网络地址，并允许在其通信范围内的其他节点加入或退出网络，同时还具有路由与转发数据能力。<br>ZigBee终端设备：可以由全功能设备或简化功能设备构成，它只能与父节点进行通信，并从父节点处获得网络标识和短地址信息。</p>
<h2 id="ZigBee网络拓扑有哪几种？"><a href="#ZigBee网络拓扑有哪几种？" class="headerlink" title="ZigBee网络拓扑有哪几种？"></a>ZigBee网络拓扑有哪几种？</h2><p>答：ZigBee网络拓扑结构：星型网络拓扑结构、网状拓扑结构、簇-树状网络拓扑结构<br>星形结构：星形结构是由一个ZigBee协调点和一个或多个ZigBee终端节点构成。 ZigBee 协调点必须是FFD，它位于网络的中心位置，负责建立和维护整个网络，其他节点一般为RFD，也可以为FFD，它们分布在ZigBee协调点的覆盖范围内，直接与ZigBee协调点进行通信。<br>网状结构：网状网络一般是由若干个FFD连接在一起组成的骨干网。它们之间是完全的对等通信，每一个节点都可以与其无线通信范围内的其他节点进行通信，但它们中也有一个会被推荐为ZigBee的协调点。骨干网中的节点还可以连接FFD或RFD构成以它为协调点的子网。网状网络是一种高可靠性网络，具有自动恢复的能力，可以为传输的数据包提供多条传输路径，一旦条路径出现了故障，便可选择另一条或多条路径。但正是由于两个节点之间存在多条路径，使得该网络成为一种高冗余的通信网络。<br>簇-树状结构：簇-树状网络中，节点可以采用Cluster-Tree路由来传输数据和控制信息。枝干末端的叶子节点一般为RFD。每一个在它的覆盖范围中充当协调点的FFD向与它相连的节点提供同步服务，而这些协调点又受ZigBee协调点的控制。ZigBee协调点比网络中的其他协调点具有更强的处理能力。簇-树状网络的一个显著优点是它的网络覆盖范围非常大，但随着覆盖范围的不断增大，信息-传输的延时也会逐渐变大，从而使同步变得越来越复杂。</p>
<h2 id="FCC如何定义UMB？"><a href="#FCC如何定义UMB？" class="headerlink" title="FCC如何定义UMB？"></a>FCC如何定义UMB？</h2><p>答：<br>美国FCC对UWB的定义为：<br>（或者总带宽不小于500 MHz）<br>其中，fH、fL分别为功率较峰值功率下降10 dB时所对应的高端频率和低端频率，fC为载波频率或中心频率。</p>
<h2 id="什么是IrDA？如何规定IrDA-的通信波长？"><a href="#什么是IrDA？如何规定IrDA-的通信波长？" class="headerlink" title="什么是IrDA？如何规定IrDA 的通信波长？"></a>什么是IrDA？如何规定IrDA 的通信波长？</h2><p>答：1993年成立的红外数据协会(Infrared Data Association，IrDA)，为了保证不同厂商生产的红外产品能够获得最佳的通信效果，制定的红外通信协议将红外数据通信所采用的光波波长的范围限定在850~900 nm之间。</p>
<h2 id="试述红外通信各低层协议的简要功能。"><a href="#试述红外通信各低层协议的简要功能。" class="headerlink" title="试述红外通信各低层协议的简要功能。"></a>试述红外通信各低层协议的简要功能。</h2><p>答：强制性的低层协议：<br>物理层连接协议(Infrared Physical Layer Link Specification，IrPHY)。IrPHY提供了红外设备的连接规范，涵盖了红外收发器、数据比特的编码和解码、传输距离、传输视角发光功率等。<br>链路层访问协议(Infrared Link Access Protocol，IrLAP)。IrLAP规定了红外设备一下连接过程的基本要求：</p>
<ol>
<li>设备搜索：搜寻红外辐射空间存在的设备；</li>
<li>选择连接：选择合适的传送对象，协商双方均支持的最佳通信参数并进行连接；</li>
<li>数据交换：用协商好的参数进行可靠的数据交换。</li>
<li>断开连接：关闭链路并且返回到常规断开状态，等待新的连接。</li>
</ol>
<p>链路管理层协议(Infrared Link Management Protocol，IrLMP)。链路连接管理协议(IrLMP)是IrDA设备的一部分，通过该设备上的软件可以发现另一个设备所能够提供的服务。包括探测、复用连接、控制连接。</p>
<h2 id="画图说明TCP-x2F-IP的组成。"><a href="#画图说明TCP-x2F-IP的组成。" class="headerlink" title="画图说明TCP&#x2F;IP的组成。"></a>画图说明TCP&#x2F;IP的组成。</h2><p>答：略</p>
<h2 id="试用具体例子说明为什么在运输连接建立时要使用三次握手。说明如不这样做可能会出现什么情况。"><a href="#试用具体例子说明为什么在运输连接建立时要使用三次握手。说明如不这样做可能会出现什么情况。" class="headerlink" title="试用具体例子说明为什么在运输连接建立时要使用三次握手。说明如不这样做可能会出现什么情况。"></a>试用具体例子说明为什么在运输连接建立时要使用三次握手。说明如不这样做可能会出现什么情况。</h2><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作（双方都知道彼此已准备好），也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>假定B给A发送一个连接请求分组，A收到了这个分组，并发送了确认应答分组。按照两次握手的协定，A认为连接已经成功地建立了，可以开始发送数据分组。可是，B在A的应答分组在传输中被丢失的情况下，将不知道A是否已准备好，不知道A建议什么样的序列号，B甚至怀疑A是否收到自己的连接请求分组，在这种情况下，B认为连接还未建立成功，将忽略A发来的任何数据分组，只等待连接确认应答分组。而A发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h2 id="请简述带有冲突检测的载波侦听多路访问（CSMA-x2F-CD）的工作流程。"><a href="#请简述带有冲突检测的载波侦听多路访问（CSMA-x2F-CD）的工作流程。" class="headerlink" title="请简述带有冲突检测的载波侦听多路访问（CSMA&#x2F;CD）的工作流程。"></a>请简述带有冲突检测的载波侦听多路访问（CSMA&#x2F;CD）的工作流程。</h2><p>答：带有冲突检测的载波侦听多路访问（CSMA&#x2F;CD）工作流程：先听后发、边发边听、冲突停止、随机延迟后重发<br>发送数据前先侦听信道是否空闲，若空闲，则立即发送数据。若信道忙碌，则等待一段时间至信道中的信息传输结束后再发送数据；若在上一段信息发送结束后，同时有两个或两个以上的节点都提出发送请求，则判定为冲突。若侦听到冲突，则立即停止发送数据，等待一段随机时间，再重新尝试。</p>
<h2 id="请图示无线局域网基本服务集和扩展服务集的构成。"><a href="#请图示无线局域网基本服务集和扩展服务集的构成。" class="headerlink" title="请图示无线局域网基本服务集和扩展服务集的构成。"></a>请图示无线局域网基本服务集和扩展服务集的构成。</h2><p>答：基本服务集(Basic Service Set，BSS)：一个BSS包括一个AP和若干个移动站；<br>扩展服务集(ESS，Extension Service Set)：包括两个或更多的基本服务集</p>
<h2 id="无线局域网的MAC协议有什么特点？为什么不能用CSMA-x2F-CD协议而必须使用CSMA-x2F-CA协议？"><a href="#无线局域网的MAC协议有什么特点？为什么不能用CSMA-x2F-CD协议而必须使用CSMA-x2F-CA协议？" class="headerlink" title="无线局域网的MAC协议有什么特点？为什么不能用CSMA&#x2F;CD协议而必须使用CSMA&#x2F;CA协议？"></a>无线局域网的MAC协议有什么特点？为什么不能用CSMA&#x2F;CD协议而必须使用CSMA&#x2F;CA协议？</h2><p>答：无线局域网的MAC协议的特点是：</p>
<ol>
<li>由于不实现碰撞检测，要尽可能减少碰撞。因此在监听信道时，若信道忙要执行退避算法，而不是像CSMA&#x2F;CD一直坚持监听直到信道空闲。</li>
<li>由于不可能避免所有的碰撞，同时无线信道误码率比较高，无线局域网的MAC协议采用停止等待协议，保证数据链路层数据传输的可靠性。</li>
<li>为进一步减少碰撞的概率，还采用了虚拟载波监听机制，让源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)及时通知给所有其他站，以便使其他所有站在这一段时间都停止发送数据，这样就大大减少了碰撞的机会。</li>
<li>标准规定了不同长度的帧间间隔。高优先级帧需要等待的时间较短，低优先级帧等待的时间较长。若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体，则媒体变为忙态因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li>
</ol>
<h2 id="WLAN为什么不能用CSMA-x2F-CD协议而必须使用CSMA-x2F-CA协议"><a href="#WLAN为什么不能用CSMA-x2F-CD协议而必须使用CSMA-x2F-CA协议" class="headerlink" title="WLAN为什么不能用CSMA&#x2F;CD协议而必须使用CSMA&#x2F;CA协议"></a>WLAN为什么不能用CSMA&#x2F;CD协议而必须使用CSMA&#x2F;CA协议</h2><p>WLAN中，信号动态变化范围大，对某个节点来说，其刚刚发出的信号强度要远高于来自其他节点的信号强度，也就是说它自己的信号会把其他的信号给覆盖掉，在WLAN中实现CSMA&#x2F;CD是比较困难</p>
<h2 id="结合隐藏站点和暴露站点问题说明RTS帧和CTS帧的作用。"><a href="#结合隐藏站点和暴露站点问题说明RTS帧和CTS帧的作用。" class="headerlink" title="结合隐藏站点和暴露站点问题说明RTS帧和CTS帧的作用。"></a>结合隐藏站点和暴露站点问题说明RTS帧和CTS帧的作用。</h2><p>答：隐蔽站问题：当A和C都检测不到无线信号时，以为B是空的向B发送数据，结果B同时收到A和C发送的数据发生碰撞。<br>暴露站问题：当站B向A发送数据，而C又想和D通信时，由于C检测到了媒体上有信号，于是不能向D发送数据。<br>使用RTS与CTS帧后，B处在A的传输范围可以收到A发送的RTS，当请求允许后，B将会向其余站点发送CTS。当C收到B的CTS后，在A和B通信的时间内就不能发送数据，保证了A和B的正常通信。<br>使用RTS和CTS帧后，在A和B通信的时间内，C能收到B的RTS，但是收不到A的CTS，所以C可以发送自己的数据给D，而不会干扰B。<br>可以看到通过使用RTS和CTS较好的解决了隐蔽站和暴露站的问题。</p>
<h2 id="无线局域网MAC协议中的SIFS、PIFS和DIFS的作用是什么？"><a href="#无线局域网MAC协议中的SIFS、PIFS和DIFS的作用是什么？" class="headerlink" title="无线局域网MAC协议中的SIFS、PIFS和DIFS的作用是什么？"></a>无线局域网MAC协议中的SIFS、PIFS和DIFS的作用是什么？</h2><p>答：SIFS，即短帧间间隔，SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧；<br>PIFS，即点协调功能帧间间隔(比SIFS长)，是为了在开始使用PCF方式时(在PCF方式下使用，没有争用)优先获得接入到媒体中；<br>DIFS，即分布协调功能帧间间隔(最长的IFS)，在DCF方式中用来发送数据帧和管理帧。 IFS的长度实际上表示站点发送的优先级。</p>
<h2 id="简述FHSS技术的工作原理。"><a href="#简述FHSS技术的工作原理。" class="headerlink" title="简述FHSS技术的工作原理。"></a>简述FHSS技术的工作原理。</h2><p>答：FHSS是一种载频不断随机改变的扩频技术。载频的变化规律受一串伪随机码的控制，发送端和接收端用相同的伪随机码控制频率的变化规律。在某一时刻，即使有特定频率的杂波进行干扰，载波频率立即改变成其他频率，因此抗干扰性强。</p>
<h2 id="WiMax的含义及主要技术标准有哪些？"><a href="#WiMax的含义及主要技术标准有哪些？" class="headerlink" title="WiMax的含义及主要技术标准有哪些？"></a>WiMax的含义及主要技术标准有哪些？</h2><p>答：WiMAX是Worldwide Interoperability for Microwave Access的缩写(意思是“全球微波接入的互操作性”，AX表示Access)。在许多文献中，我们可以见到WiMAX常用来表示无线城域网WMAN，这与Wi-Fi常用来表示无线局域网WLAN相似。WiMax技术标准为IEEE 802. 16系列，WiMax采用IEEE 802. 16系列标准尤其是802. 16a，作为物理层及MAC 层技术。</p>
<h2 id="什么是通信网？它由哪些要素组成？"><a href="#什么是通信网？它由哪些要素组成？" class="headerlink" title="什么是通信网？它由哪些要素组成？"></a>什么是通信网？它由哪些要素组成？</h2><p>答：通信网是各种通信节点（端节点、交换节点、转接点）及连接各节点的传输链路互相依存的有机结合体，以实现两点及多个规定点间的通信体系。<br>    构成要素：从硬件设施方面去看，通信网由终端设备、交换设备及传输链路三大要素组成</p>
<h2 id="通信网有哪些基本构成？"><a href="#通信网有哪些基本构成？" class="headerlink" title="通信网有哪些基本构成？"></a>通信网有哪些基本构成？</h2><p>答：通信网除了有传递各种用户信息的业务网之外，还需要有若干支撑网，以使网络更好地运行。</p>
<ol>
<li>业务网。业务网也就是用户信息网，它是现代通信网的主体，是向用户提供诸如电话、电报、传真、数据和图像等各种电信业务的网络。业务网按其功能又可分为用户接入网、交换网和传输网三个部分。用户接入网负责将电信业务透明地传送到用户，即用户通过接入网的传输，能灵活地接入不同的电信业务节点。</li>
<li>支撑网。支撑网是使业务网正常运行、增强网络功能、提供全网服务质量以满足用户要求的网络。支撑网包括信令网、同步网和管理网，传送控制、监测信号。</li>
<li>信令网：在采用公共信道通信令的网络后，除原有的用户业务之外，还有一个寄生并存的起支撑作用的专门传送信令的网络，其功能是实现网络节点间信令的传输和转换。</li>
<li>同步网：实现数字传输后，在数字交换局之间、数字交换局和传输设备之间均需要实现信号时钟的同步。同步网的功能就是实现这些设备之间的信号时钟同步。</li>
<li>管理网：管理网是为提高全网质量和充分利用网络设备而设置的。网络管理是实时地监视业务网的运行，必要时采取控制措施，以达到在任何情况下都可以最大限度地使用网络中一切可以利用的设备。使尽可能多的通信得以实现。</li>
</ol>
<h2 id="构成电话网时都有哪些必备的要素？各自的作用是什么？"><a href="#构成电话网时都有哪些必备的要素？各自的作用是什么？" class="headerlink" title="构成电话网时都有哪些必备的要素？各自的作用是什么？"></a>构成电话网时都有哪些必备的要素？各自的作用是什么？</h2><p>答：电话网的构成要素：终端设备、交换设备、传输系统</p>
<ol>
<li>用户终端设备：将用户声音信号转换成电信号或者将电信号还原成语言信号。</li>
<li>交换设备：用户信息的交换，按用户的要求建立通信的信道，还具有控制和监视的功能。</li>
<li>传输系统：负责在个交换点之间传输信息。传输系统还包括用户线，负责话机和交换机间传递信息。</li>
</ol>
<h2 id="移动通信中为什么要采用复杂的多址接入方式？多址方式有哪些？它们是如何区分每个用户的？"><a href="#移动通信中为什么要采用复杂的多址接入方式？多址方式有哪些？它们是如何区分每个用户的？" class="headerlink" title="移动通信中为什么要采用复杂的多址接入方式？多址方式有哪些？它们是如何区分每个用户的？"></a>移动通信中为什么要采用复杂的多址接入方式？多址方式有哪些？它们是如何区分每个用户的？</h2><p>答：移动通信与固定式有线通信的最大差异在于固定通信是静态的，而移动通信是动态的。为了满足多个移动用户进行通信，必须解决动态寻址以及对多个地址的动态划分与识别两个问题，因此移动通信需要采用复杂的多址接入方式。<br>多址方式有频分多址（FDMA）、时分多址（TDMA）、码分多址（CDMA）等方式。<br>FDMA（频分多址）：把总带宽分隔成多个正交的信道，每一个信道每一次只能分配给一个用户<br>TDMA（时分多址）：在一个带宽上，把时间分成周期性的帧，每一帧再分割成若干时隙（无论帧或时隙都是互不重叠的），每个时隙就是一个通信信道，分配给一个用户。<br>CDMA（码分多址）：利用码序列相关性实现的多址通信，每一个用户可以在同样的时间使用同样的频带进行通信。</p>
<h2 id="画图说明GPRS网络结构。"><a href="#画图说明GPRS网络结构。" class="headerlink" title="画图说明GPRS网络结构。"></a>画图说明GPRS网络结构。</h2><p>答：GPRS网络结构：GPRS网关支持节点（GGSN）、GPRS服务支持节点（SGSN）、基站发信台（BTS）、基站控制器（BSC）、分组控制单元（PCU）、移动交换中心（MSC）、短消息中心（SMSC）、归属位置寄存器（SLR）、边界网关（BG）、计费网关（CG）、域名服务器（DNS）</p>
<h2 id="无线传感器网络的特征有哪些？"><a href="#无线传感器网络的特征有哪些？" class="headerlink" title="无线传感器网络的特征有哪些？"></a>无线传感器网络的特征有哪些？</h2><p>答：无线传感器网络是一种具有网络规模大、自组织、多跳路由、动态拓扑、可靠性高的以数据为中心的、能量受限的通信网络。</p>
<h2 id="无线传感器节点由哪些模块组成？"><a href="#无线传感器节点由哪些模块组成？" class="headerlink" title="无线传感器节点由哪些模块组成？"></a>无线传感器节点由哪些模块组成？</h2><p>答：无线传感器节点由传感器模块、处理器模块、无线通信模块、能量供应模块组成。</p>
<h2 id="画图说明无线传感器网络协议结构。"><a href="#画图说明无线传感器网络协议结构。" class="headerlink" title="画图说明无线传感器网络协议结构。"></a>画图说明无线传感器网络协议结构。</h2><p>答：无线传感器网络协议栈有：应用层、传输层、网络层、数据链路层、物理层、能量管理平台、移动管理平台、任务管理平台。</p>
<h2 id="无线传感器网络有哪些MAC协议？"><a href="#无线传感器网络有哪些MAC协议？" class="headerlink" title="无线传感器网络有哪些MAC协议？"></a>无线传感器网络有哪些MAC协议？</h2><p>答：无线传感器网络MAC协议有：<br>竞争型MAC协议：S-MAC协议、T-MAC协议、Sift协议、WiseMAC协议<br>非竞争型MAC协议：DEANA协议、SMACS协议、DE-MAC协议、TRAMA协议<br>混合型MAC协议：Z-MAC协议、Funneling-MAC协议</p>
<h2 id="简述物联网中异构网络网络模型的特点？"><a href="#简述物联网中异构网络网络模型的特点？" class="headerlink" title="简述物联网中异构网络网络模型的特点？"></a>简述物联网中异构网络网络模型的特点？</h2><p>答：是由无线广域网、无线传感器网络、无线局域网、无限个域网组成的异构网络系统。不同网络物联网应用系统通过网关连接到核心网，最后连接到Internet网络上，最终融合成为一个整体。</p>
<h2 id="物联网中异构网络的资源管理主要包括哪些方面？"><a href="#物联网中异构网络的资源管理主要包括哪些方面？" class="headerlink" title="物联网中异构网络的资源管理主要包括哪些方面？"></a>物联网中异构网络的资源管理主要包括哪些方面？</h2><p>答：在异构物联网系统网络中，无线资源管理的目标主要包括接入控制、负债均衡、功率控制、信道分配，以及为用户提供无处不在的服务和进行无缝切换，并提供无线资源的利用率。</p>
<h2 id="什么是网络选择？介绍几种典型的网路选择方案。"><a href="#什么是网络选择？介绍几种典型的网路选择方案。" class="headerlink" title="什么是网络选择？介绍几种典型的网路选择方案。"></a>什么是网络选择？介绍几种典型的网路选择方案。</h2><p>答：网络选择是当用户从一个网络离开的时候，如何确定其他备选网络以及选择网络以及选择哪个网络进行接入的问题。<br>典型的网络选择方案：基于接收信号强度的网络选择算法、基于模糊逻辑和神经网络的网络选择算法、基于博弈论的网络选择算法、基于优化理论的网络选择算法、基于策略的网络选择算法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>物联网</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>记账姬后端API V1设计</title>
    <url>/%E8%AE%BE%E8%AE%A1/%E8%AE%B0%E8%B4%A6%E5%A7%AC%E5%90%8E%E7%AB%AFAPI%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>后端的api接口全部采用RESTful API风格</p>
<span id="more"></span>

<h1 id="V1版本"><a href="#V1版本" class="headerlink" title="V1版本"></a>V1版本</h1><p>第一个API接口版本</p>
<h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><ul>
<li>除了登录和注册，其他都要在http头里加上Token做校验。比如在下面的curl示例加上 <code>-H &#39;Authorization: Bearer xxx&#39;</code></li>
<li>返回的数据遵循以下规则</li>
</ul>
<table>
<thead>
<tr>
<th>数据项</th>
<th>值内容</th>
</tr>
</thead>
<tbody><tr>
<td>状态码：code</td>
<td>0：成功，-1：失败，-2：服务器出错</td>
</tr>
<tr>
<td>信息：msg</td>
<td>返回的一些提示信息</td>
</tr>
<tr>
<td>数据：data</td>
<td>返回的一些数据</td>
</tr>
</tbody></table>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>路由地址：<code>/user/register</code></p>
<p>可以采用 <code>GET</code> 或者 <code>POST</code> 方法，需要的提交的信息：</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>属性名</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>账号</td>
<td>passport</td>
<td>长度位于4~16位之间，所有账号唯一，必填</td>
</tr>
<tr>
<td>密码</td>
<td>password</td>
<td>长度位于6~16位之间，支持弱密码，必填</td>
</tr>
<tr>
<td>昵称</td>
<td>nickname</td>
<td>长度小于16，选填，不发送则和账号相同</td>
</tr>
<tr>
<td>邮箱</td>
<td>email</td>
<td>用于密码找回，选填，如果填了会验证唯一性</td>
</tr>
<tr>
<td>手机</td>
<td>phone</td>
<td>用于密码找回，选填，如果填了会验证唯一性</td>
</tr>
</tbody></table>
<p>实例：<br>使用 <code>POST</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;passport=1234&amp;password=123456&#x27; -X POST https://v1.jizhangji.io/user/register</span><br></pre></td></tr></table></figure>
<p>使用 <code>GET</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://v1.jizhangji.io/user/register?passport=1234&amp;password=123456</span><br></pre></td></tr></table></figure>


<p>例如：注册失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;账号 1234 已被注册&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;邮箱 123@qq.com 已被注册&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;服务器正在开小差，请联系管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注册成功：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;注册成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一串登录校验用的Token&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>路由地址：<code>/user/login</code></p>
<p>可以采用 <code>GET</code> 或者 <code>POST</code> 方法，需要的提交的信息：</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>属性名</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>账号</td>
<td>passport</td>
<td>注册时的账号，必填</td>
</tr>
<tr>
<td>密码</td>
<td>password</td>
<td>注册时的密码，必填</td>
</tr>
</tbody></table>
<p>实例：<br>使用 <code>POST</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;passport=1234&amp;password=123456&#x27; -X POST https://v1.jizhangji.io/user/login</span><br></pre></td></tr></table></figure>
<p>使用 <code>GET</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://v1.jizhangji.io/user/login?passport=1234&amp;password=123456</span><br></pre></td></tr></table></figure>

<p>响应数据：登陆失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;账号或密码错误了哦&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;姬正在开小差，请联系管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>登录成功：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;登录成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一串登录校验用的Token&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="忘记账号"><a href="#忘记账号" class="headerlink" title="忘记账号"></a>忘记账号</h3><p>路由地址：<code>/user/forget-passport</code> , 参数带上email或者phone其中一个，即可发送账号。</p>
<h3 id="重设密码"><a href="#重设密码" class="headerlink" title="重设密码"></a>重设密码</h3><p>路由地址：<code>/user/set-password</code> ，参数带上email或者phone其中一个，发送验证码，再次带上code和验证码即可。</p>
<ol>
<li><code>GET https://xxx/user/set-password?email=xxx@qq.com</code> 或者使用POST方式发送请求</li>
<li>得到验证码xxx， <code>GET https://xxx/user/set-password?code=xxx</code></li>
<li>验证码正确修改成功，否则失败</li>
</ol>
<h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><h3 id="新增账本"><a href="#新增账本" class="headerlink" title="新增账本"></a>新增账本</h3><p>支持一个用户多账本，但一个用户只能新建6个账本。</p>
<p>路由地址：<code>/ledger/new</code> ,可以采用 <code>GET</code> 或者 <code>POST</code> 方法，需要的提交的信息:</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>属性名</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>账本名称:name</td>
<td>passport</td>
<td>注册时的账号，必填</td>
</tr>
</tbody></table>
<p>实例：<br>使用 <code>POST</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;name=姬的账本&#x27; -H &#x27;Authorization: Bearer xxx&#x27; -X POST https://v1.jizhangji.io/ledger/new</span><br></pre></td></tr></table></figure>
<p>使用 <code>GET</code> 方法(记得加Token):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://v1.jizhangji.io/user/ledger/new?name=姬的账本</span><br></pre></td></tr></table></figure>

<p>响应数据：失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;账本重名了哦&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的账本太多啦，姬的大脑记不了这么多哦&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;姬正在开小差，请联系管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;账本新增成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;账本的id&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="获取用户拥有的账本"><a href="#获取用户拥有的账本" class="headerlink" title="获取用户拥有的账本"></a>获取用户拥有的账本</h3><p>路由地址：<code>/ledger/get</code> ，直接访问即可获取账本的名称和id</p>
<p>响应数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ledger&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我的账本&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;姬的账本&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="清空账本"><a href="#清空账本" class="headerlink" title="清空账本"></a>清空账本</h3><p>路由地址：<code>/ledger/clear</code> 发送账本的id即可清空，可以用post或者get</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;id=1&#x27; -X POST https://v1.jizhangji.io/ledger/clear</span><br><span class="line">或者</span><br><span class="line">curl http://v1.jizhangji.io/ledger/clear?id=1</span><br></pre></td></tr></table></figure>
<p>响应数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    code<span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    msg<span class="punctuation">:</span> <span class="string">&quot;姬找不到这个账本了&quot;</span><span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    code<span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">    msg<span class="punctuation">:</span> <span class="string">&quot;该账本不属于你的哦&quot;</span><span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    code<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    msg<span class="punctuation">:</span> <span class="string">&quot;账本成功被姬清空了&quot;</span><span class="punctuation">,</span></span><br><span class="line">    data<span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除账本"><a href="#删除账本" class="headerlink" title="删除账本"></a>删除账本</h3><p>路由地址：<code>/ledger/delete</code> 发送账本的id即可删除，可以用post或者get，用法同上清除账本。</p>
<h3 id="账本改名"><a href="#账本改名" class="headerlink" title="账本改名"></a>账本改名</h3><p>路由地址：<code>/ledger/rename</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;id=1&amp;newname=姬的账本&#x27; -X POST https://v1.jizhangji.io/ledger/rename </span><br><span class="line">或者</span><br><span class="line">curl http://v1.jizhangji.io/ledger/clear?id=1&amp;newname=姬的账本 </span><br></pre></td></tr></table></figure>

<h2 id="记账"><a href="#记账" class="headerlink" title="记账"></a>记账</h2><h3 id="增加记录"><a href="#增加记录" class="headerlink" title="增加记录"></a>增加记录</h3><p>路由地址：<code>/account/new</code></p>
<p>一个记录包括以下信息：</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>属性名</th>
<th>说明和要求</th>
</tr>
</thead>
<tbody><tr>
<td>对应账本</td>
<td>ledger</td>
<td>对应的账本id，必填</td>
</tr>
<tr>
<td>类型</td>
<td>type</td>
<td>支出还在收入，支出可以使用0或者”支出“或者”expenditure“，收入可以使用1或者”收入“或者”income“，必填</td>
</tr>
<tr>
<td>金额</td>
<td>money</td>
<td>对应的金额，必填</td>
</tr>
<tr>
<td>分类</td>
<td>categories</td>
<td>分类的id，选填，不填一概用1代替（未分类）</td>
</tr>
<tr>
<td>时间</td>
<td>time</td>
<td>记录时间，值为时间戳，选填，不填使用现在时刻代替。</td>
</tr>
</tbody></table>
<p>实例：<br>使用 <code>POST</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;ledger=1&amp;type=0&amp;money=123.12&#x27; -X POST https://v1.jizhangji.io/account/new</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>GET</code> 方法，在路由后面带上查询即可。</p>
<h3 id="删除一个记录"><a href="#删除一个记录" class="headerlink" title="删除一个记录"></a>删除一个记录</h3><p>路由地址：<code>/account/delete</code> ，提交记录的id即可删除，不多赘述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;id=1&#x27; -X POST https://v1.jizhangji.io/account/delete</span><br><span class="line"></span><br><span class="line">curl http://v1.jizhangji.io/account/delete?id=1</span><br></pre></td></tr></table></figure>

<h3 id="获取账目信息"><a href="#获取账目信息" class="headerlink" title="获取账目信息"></a>获取账目信息</h3><p>需要指定一个账本进行获取，默认获取最近30天内的记录，或者指定日期的前30天记录。</p>
<h3 id="修改一个记录"><a href="#修改一个记录" class="headerlink" title="修改一个记录"></a>修改一个记录</h3><p>和增加记录差不多，需要多一个记录id来指定。</p>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><h3 id="获取统计信息"><a href="#获取统计信息" class="headerlink" title="获取统计信息"></a>获取统计信息</h3><p>支持日、周、月统计，月支持收入与支出统计。</p>
<p>（上面三天后续跟进）</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>记账姬</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>解决AndroidStudio下载SDK被墙</title>
    <url>/%E6%95%99%E7%A8%8B/%E8%A7%A3%E5%86%B3AndroidStudio%E4%B8%8B%E8%BD%BDSDK%E8%A2%AB%E5%A2%99/</url>
    <content><![CDATA[<p>众所周知，谷歌的国内服务经常被墙，有时候会导致 android studio 里无法正常下载 sdk，这里简单讲解一下原因和解决方法</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>因为 as 里下载 sdk 是直接访问 dl.google.com 这个域名的，而国内的有些运行商可能会直接屏蔽了这个域名的 DNS 解析，导致没办法正确解析出 IP。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>解决办法很简单，就是通过 <a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> 该检测网站对进行域名 dl.google.com 进行解析，找出能用国内 IP。</p>
<p>只需要打开这个网页，将 dl.google.com 复制进去点击 Ping 检测，就能拿到很多国内的谷歌服务 IP，比如我拿到一个： 180.163.151.161 ，然后打开命令行工具使用<code>ping 180.163.151.161</code> 进行检测，如果能正常 ping 通就说明该 ip 可以使用</p>
<p>接下来就是使用这个 ip 了，windows 用户打开：<code>C:\Windows\System32\drivers\etc</code> 文件夹，可以看到 hosts 文件，使用记事本之类的工具打开进行编辑，添加上一行：<code>180.163.151.161 dl.google.com</code> 然后保存。这时候只需要再<code>ping dl.google.com</code>就能发现这时候是直接 ping 180.163.151.161 这个 ip，不在需要 DNS 解析。</p>
<p>然后重新打开你点 as 就能发现可以正常下载 sdk 了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个新的语言-1</title>
    <url>/uncategorized/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%AF%AD%E8%A8%80-1/</url>
    <content><![CDATA[<blockquote>
<p>由于兴趣原因想设计一个新的语言。这是一个类似C和Go的语言，为了代码简洁简化一些代码，语言内建大量函数，可以直接调用。允许一定程度的指针访问，提供布尔型，数字型，字符串，指针类型，数组类型，结构化类型，函数类型，切片类型。这是一门静态语言，内存管理模型和c一样需要手工管理。接口使用非侵入的duck type模式。</p>
</blockquote>
<span id="more"></span>


<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><p>int8    （-128 -&gt; 127）<br>int16   （-32768 -&gt; 32767）<br>int32   （-2,147,483,648 -&gt; 2,147,483,647）<br>int64   （-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）<br>int     （32 位操作系统上32位,64 位操作系统64 位）</p>
<h3 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h3><p>uint8   （0 -&gt; 255）<br>uint16  （0 -&gt; 65,535）<br>uint32  （0 -&gt; 4,294,967,295）<br>uint64  （0 -&gt; 18,446,744,073,709,551,615）<br>uint    （32位操作系统上32 位,64位操作系统64位）</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float32 （+- 1.2e-38 -&gt; +- 3.4 * 1e38）<br>float64 （+- 2.3e-308 -&gt; 1.7e308）<br>float128（+- 3.5e-4932 -&gt; 1.1e4932）<br>建议使用float64</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>complex64 (32 位实数和虚数)<br>complex128 (64 位实数和虚数)</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><h3 id="byte类型"><a href="#byte类型" class="headerlink" title="byte类型"></a>byte类型</h3><p>byte类型：等同于uint8，有三种表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte ch = &#x27;A&#x27;</span><br><span class="line">byte ch = 65        //或者byte ch = 0x41</span><br><span class="line">byte ch = &#x27;\x41&#x27;    //字符表达，\x后接两位16进制</span><br></pre></td></tr></table></figure>
<p>rune类型：等同于int32，最少需要int16来储存一个Unicode，两个字节的utf8使用\u前缀，四个字节utf8mb4使用\U来表示。\u紧接四个16进制数，\U紧接八个16进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ch = &#x27;\u0041&#x27;</span><br><span class="line">int ch = &#x27;\u03B2&#x27;</span><br><span class="line">int ch = &#x27;\U00101234&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串定义：<br>struct string<br>{<br>    byte*   str;<br>    int64   len;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string str1 = &quot;This is a string&quot;</span><br><span class="line">str2 := str1 + &quot;Hello World&quot;</span><br><span class="line">// 声明字符串时可以自动根据右边的语句构造一个字符串，但是一个string就是一个原子所以不能像C语言那样用string[x]对第x-1个值进行修改，只能修改地址值，如：</span><br><span class="line">str1 = &quot;This is another string&quot;</span><br><span class="line">// 这样结构体内的str和len值就发生了改变</span><br></pre></td></tr></table></figure>

<h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 | slice"></a>切片 | slice</h2><p>相当于Java或者Python中的list，能记录长度和容量，也可以理解成一个滑动窗口,但是slice是引用类型所以使用需要注意不要踩坑。<br>底层定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">    pointer array       // pointer是无类型的指针，建议不会用就不要使用，在开发时不应直接使用</span><br><span class="line">    int     len</span><br><span class="line">    int     cap</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 := []string&#123;&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>在for中，去掉()，加入range用法，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[10]</span><br><span class="line">for int i = 0; i &lt; 10; i++ &#123;</span><br><span class="line">    arr[i] = i</span><br><span class="line">&#125;</span><br><span class="line">for index, value := range arr &#123;</span><br><span class="line">    printf(&quot;index = %d, value = %d&quot;, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>switch默认在句尾加入break，如果需要继续判断下面语句则需要加入<code>fallthrough</code>，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 90</span><br><span class="line">switch i &#123;</span><br><span class="line">    case 90: </span><br><span class="line">        printf(&quot;等于90&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">    case 80: printf(&quot;等于80&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：由于switch是需要对类型进行判等操作，case后的无符号的表达式结果可以转换成switch后的表达式的类型，反之switch后的无符号的表达式结果不能转换成case后的表达式结果的类型而是转换成该值的默认类型（比如无类型的123转换成int类型，3.14转换成float64类型），所以想让编译通过也是有条件的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int8 arr[] = &#123;0, 1, 2, 3, 4, 5&#125;</span><br><span class="line">switch 1+2 &#123;</span><br><span class="line">    case arr[0], arr[1]:</span><br><span class="line">        printf(&quot;0 or 1&quot;)</span><br><span class="line">    case arr[2], arr[3]:</span><br><span class="line">        printf(&quot;2 or 3&quot;)</span><br><span class="line">    case arr[4], arr[5]:</span><br><span class="line">        printf(&quot;4 or 5&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 编译不通过，1+3是无符号类型，转换成默认类型是int，而case后是int8类型</span><br><span class="line">switch arr[3] &#123;</span><br><span class="line">    case 0, 1:</span><br><span class="line">        printf(&quot;0 or 1&quot;)</span><br><span class="line">    case 2, 3:</span><br><span class="line">        printf(&quot;2 or 3&quot;)</span><br><span class="line">    case 4, 5:</span><br><span class="line">        printf(&quot;4 or 5&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 编译通过，因为case后的无类型值可以转换成int8类型。</span><br><span class="line">// 注意：case后的类型只有在无类型时才能发生类型自动转换</span><br></pre></td></tr></table></figure>

<h1 id="象牙运算符"><a href="#象牙运算符" class="headerlink" title="象牙运算符"></a>象牙运算符</h1><p>直接由编译器判断类型，同时声明和定义一个变量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 10</span><br><span class="line">str := &quot;string&quot;</span><br><span class="line">arr := &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>和函数不一样，必须拥有一个接收者，代码操作和接收者绑定，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (int i)returnANum() &#123;       // i为接收者，操作与i绑定</span><br><span class="line">    return i</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h1><p>一个函数或者方法可以返回多个值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(int, float32)returnANum()&#123;</span><br><span class="line">    float32 f = 13.14</span><br><span class="line">    i = 1</span><br><span class="line">    return i, f</span><br><span class="line">&#125;</span><br><span class="line">(string str, int i)(int i)returnAString() &#123;</span><br><span class="line">    string str = &quot;This is a string&quot;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">i, f := returnANum()          // i=1, f=13.14</span><br><span class="line">str, j := i.returnAString()     //str=&quot;This is a string&quot;, j = 1</span><br></pre></td></tr></table></figure>

<h1 id="多返回值取其中一个"><a href="#多返回值取其中一个" class="headerlink" title="多返回值取其中一个"></a>多返回值取其中一个</h1><p>可以在函数或者方法后接<code>.返回值</code>可以只取一个，或者用<code>_</code>来抛弃返回值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// func()返回</span><br><span class="line">max := func(a, b, c).max</span><br><span class="line">sum, _ := func(a, b, c)</span><br></pre></td></tr></table></figure>

<h1 id="单条语句代码换行-（待定）"><a href="#单条语句代码换行-（待定）" class="headerlink" title="单条语句代码换行 （待定）"></a>单条语句代码换行 （待定）</h1><p>如果不是双引号的代码可以在逗号后面直接换行，如果是字符串需要多行可以用反单引号或者加号，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;a = %d, b = %d&quot;, </span><br><span class="line">        a, b)</span><br><span class="line"></span><br><span class="line">str := `&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;` +</span><br><span class="line">&quot;this is a html5 code&quot;</span><br></pre></td></tr></table></figure>

<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>可以声明一个匿名函数，还可以把他赋值给一个变量，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func := void &#123;</span><br><span class="line">    printf(&quot;hello world!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func()          // 输出hello world！</span><br><span class="line"></span><br><span class="line">void (int x, int y)&#123;</span><br><span class="line">    printf(&quot;sum = %d&quot;, x, y)</span><br><span class="line">&#125;(10, 20)       // 输出sum = 30</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef operate int (int, int)      // 定义一个返回值为int，参数列表为两个int值的函数类型</span><br><span class="line">typedef calculate int (int, int)</span><br><span class="line"></span><br><span class="line">calculate getSum(op operate) &#123;</span><br><span class="line">    return  int(int x, int y)&#123;</span><br><span class="line">                return op(x, y)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">add := int (int x, int y)&#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">addFunc := getSum(add)</span><br><span class="line">printf(&quot;sum = %d&quot;, addFunc(10, 20))     // 输出sum=30</span><br></pre></td></tr></table></figure>

<h1 id="包管理和引入"><a href="#包管理和引入" class="headerlink" title="包管理和引入"></a>包管理和引入</h1><p>待定</p>
<h1 id="使用结构体代替类"><a href="#使用结构体代替类" class="headerlink" title="使用结构体代替类"></a>使用结构体代替类</h1><p>这个得看怎么解决包管理</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>空接口</p>
]]></content>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础知识总结</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A 地区的方言可能 B 地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。</p>
<span id="more"></span>

<p>计算机网络协议同我们的语言一样，多种多样。而 ARPA 公司与 1977 年到 1979 年推出了一种名为 ARPANET 的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的 TCP&#x2F;IP 标准网络协议。目前 TCP&#x2F;IP 协议已经成为 Internet 中的 “通用语言”，下图为不同计算机群之间利用 TCP&#x2F;IP 进行通信的示意图。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/1.webp" class="">

<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在 1978 年提出了 “开放系统互联参考模型”，即著名的 OSI&#x2F;RM 模型（Open System Interconnection&#x2F;Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p>
<p>除了标准的 OSI 七层模型以外，常见的网络层次划分还有 TCP&#x2F;IP 四层协议以及 TCP&#x2F;IP 五层协议，它们之间的对应关系如下图所示：</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/2.webp" class="">

<h1 id="OSI-七层网络模型"><a href="#OSI-七层网络模型" class="headerlink" title="OSI 七层网络模型"></a>OSI 七层网络模型</h1><p>TCP&#x2F;IP 协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开 TCP&#x2F;IP 协议。不管是 OSI 七层模型还是 TCP&#x2F;IP 的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于 OSI 七层模型为网络的标准层次划分，所以我们以 OSI 七层模型为例从下向上进行一一介绍。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/3.webp" class="">

<h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h2><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输</strong>。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p>
<h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h2><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<p>有关数据链路层的重要知识点：</p>
<ol>
<li><strong>数据链路层为网络层提供可靠的数据传输；</strong></li>
<li><strong>基本数据单位为帧；</strong></li>
<li><strong>主要的协议：以太网协议；</strong></li>
<li><strong>两个重要设备名称：网桥和交换机。</strong></li>
</ol>
<h2 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h2><p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是 “路径选择、路由及逻辑寻址”。</p>
<p>网络层中涉及众多的协议，其中包括最重要的协议，也是 TCP&#x2F;IP 的核心协议 ——IP 协议。IP 协议非常简单，仅仅提供不可靠、无连接的传送服务。IP 协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与 IP 协议配套使用实现其功能的还有地址解析协议 ARP、逆地址解析协议 RARP、因特网报文协议 ICMP、因特网组管理协议 IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p>
<ol>
<li>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</li>
<li>基本数据单位为 IP 数据报；</li>
<li>包含的主要协议：<ul>
<li>IP 协议（Internet Protocol，因特网互联协议）;</li>
<li>ICMP 协议（Internet Control Message Protocol，因特网控制报文协议）;</li>
<li>ARP 协议（Address Resolution Protocol，地址解析协议）;</li>
<li>RARP 协议（Reverse Address Resolution Protocol，逆地址解析协议）。</li>
</ul>
</li>
<li>重要的设备：路由器。</li>
</ol>
<h2 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h2><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p>传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p>
<p>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</p>
<p>有关网络层的重点：</p>
<ol>
<li>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</li>
<li>包含的主要协议：TCP 协议（Transmission Control Protocol，传输控制协议）、UDP 协议（User Datagram Protocol，用户数据报协议）；</li>
<li>重要设备：网关。</li>
</ol>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
<p>会话层、表示层和应用层重点：</p>
<ol>
<li>数据传输基本单位为报文；</li>
<li>包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3 协议（邮局协议），HTTP 协议（Hyper Text Transfer Protocol）。</li>
</ol>
<blockquote>
<p>上面是传统的协议，比较有前途的新协议有：MQTT协议、HTTP&#x2F;2、HTTP3、WebSocket、Socket5、VMess协议等等</p>
</blockquote>
<h1 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h1><h2 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h2><p>IP 地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全 0，网络地址代表着整个网络。</p>
<blockquote>
<p>不过目前在公网已经不区分网络号和主机号了，下面详细讲</p>
</blockquote>
<h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p>
<p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全 1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p>
<h2 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h2><p>先回忆下 A，B，C，D 类地址吧：</p>
<p>A 类地址以 00 开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p>
<p>B 类地址以 10 开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p>
<p>C 类地址以 110 开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p>
<p>D 类地址以 1110 开头，地址范围是 224.0.0.0~239.255.255.255，D 类地址作为组播地址（一对多的通信）；</p>
<p>E 类地址以 1111 开头，地址范围是 240.0.0.0~255.255.255.255，E 类地址为保留地址，供以后使用。</p>
<p>注：只有 A,B,C 有网络号和主机号之分，D 类地址和 E 类地址没有划分网络号和主机号。</p>
<h2 id="255-255-255-255"><a href="#255-255-255-255" class="headerlink" title="255.255.255.255"></a>255.255.255.255</h2><p>该 IP 地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机 192.168.1.1&#x2F;30 上的直接广播数据包后，另外一个网段 192.168.1.5&#x2F;30 也能收到该数据报；若发送受限广播数据报，则不能收到。</p>
<p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p>
<h2 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h2><p>常用于寻找自己的 IP 地址（在某些软件的设置也可以代表任何的IP），例如在我们的 RARP，BOOTP 和 DHCP 协议中，若某个未知 IP 地址的机器想要知道自己的 IP 地址，它就以 255.255.255.255 为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送 IP 请求分组。</p>
<h2 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h2><p>127.0.0.0&#x2F;8 被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是 127.0.0.1。</p>
<h2 id="A、B、C-类私有地址"><a href="#A、B、C-类私有地址" class="headerlink" title="A、B、C 类私有地址"></a>A、B、C 类私有地址</h2><p>私有地址 (private address) 也叫专用地址，它们不会在全球使用，只具有本地意义。</p>
<p>A 类私有地址：10.0.0.0&#x2F;8，范围是：10.0.0.0~10.255.255.255</p>
<p>B 类私有地址：172.16.0.0&#x2F;12，范围是：172.16.0.0~172.31.255.255</p>
<p>C 类私有地址：192.168.0.0&#x2F;16，范围是：192.168.0.0~192.168.255.255</p>
<blockquote>
<p>上面之所以说现在不区分网络号和主机号的原因是IP资源紧缺，不能为所有设备分配一个私有地址以外的IP，所有现在不区分IP的类别，每一个私有地址以外的IP都可以作为一个主机号。然后通过NAT（地址转换）将一个局域网连接到一个IP。不过现在的情况可能会有好几层地址转换，比如ISP（网络服务提供商）会给你所在的楼层或者所在的整个小区分配一个IP，然后通过NAT连接到整个楼层或者整个小区，当然网线拉进你的家里，还会通过路由器NAT之后再分配出一个局域网，所有你使用的设备可能位于局域网中的局域网中的…(套娃实锤了)。<strong>NAT可以理解为将一个IP地址分出多个局域网IP</strong></p>
</blockquote>
<h2 id="子网掩码及网络划分"><a href="#子网掩码及网络划分" class="headerlink" title="子网掩码及网络划分"></a>子网掩码及网络划分</h2><p>因为现在普遍使用的都是NAT技术，子网划分变得比较少用，所以这里不详细讲了（主要是那玩意计算起来是真的麻烦），如果有兴趣可以百度了解划分的方法。</p>
<h1 id="ARP-x2F-RARP-协议"><a href="#ARP-x2F-RARP-协议" class="headerlink" title="ARP&#x2F;RARP 协议"></a>ARP&#x2F;RARP 协议</h1><p><strong>地址解析协议，即 ARP（Address Resolution Protocol），是根据 IP 地址获取物理地址的一个 TCP&#x2F;IP 协议</strong>。主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送 ARP 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 ARP 缓存；<strong>由此攻击者就可以向某一主机发送伪 ARP 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 ARP 欺骗</strong>。<strong>ARP 命令可用于查询本机 ARP 缓存中 IP 地址和 MAC 地址的对应关系、添加或删除静态对应关系等</strong>。</p>
<p>ARP 工作流程举例：</p>
<p>主机 A 的 IP 地址为 192.168.1.1，MAC 地址为 0A-11-22-33-44-01；<br>主机 B 的 IP 地址为 192.168.1.2，MAC 地址为 0A-11-22-33-44-02；</p>
<p>当主机 A 要与主机 B 通信时，地址解析协议可以将主机 B 的 IP 地址（192.168.1.2）解析成主机 B 的 MAC 地址，以下为工作流程：</p>
<ol>
<li>根据主机 A 上的路由表内容，IP 确定用于访问主机 B 的转发 IP 地址是 192.168.1.2。然后 A 主机在自己的本地 ARP 缓存中检查主机 B 的匹配 MAC 地址。</li>
<li>如果主机 A 在 ARP 缓存中没有找到映射，它将询问 192.168.1.2 的硬件地址，从而将 ARP 请求帧广播到本地网络上的所有主机。源主机 A 的 IP 地址和 MAC 地址都包括在 ARP 请求中。本地网络上的每台主机都接收到 ARP 请求并且检查是否与自己的 IP 地址匹配。如果主机发现请求的 IP 地址与自己的 IP 地址不匹配，它将丢弃 ARP 请求。</li>
<li>主机 B 确定 ARP 请求中的 IP 地址与自己的 IP 地址匹配，则将主机 A 的 IP 地址和 MAC 地址映射添加到本地 ARP 缓存中。</li>
<li>主机 B 将包含其 MAC 地址的 ARP 回复消息直接发送回主机 A。</li>
<li>当主机 A 收到从主机 B 发来的 ARP 回复消息时，会用主机 B 的 IP 和 MAC 地址映射更新 ARP 缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机 B 的 MAC 地址一旦确定，主机 A 就能向主机 B 发送 IP 通信了。</li>
</ol>
<p><strong>逆地址解析协议，即 RARP，功能和 ARP 协议相对，其将局域网中某个主机的物理地址转换为 IP 地址</strong>，比如局域网中有一台主机只知道物理地址而不知道 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。</p>
<p>RARP 协议工作流程：</p>
<ol>
<li>给主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址；</li>
<li>本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址；</li>
<li>如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用；</li>
<li>如果不存在，RARP 服务器对此不做任何的响应；</li>
<li>源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。</li>
</ol>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p>常见的路由选择协议有：<strong>RIP 协议、OSPF 协议</strong>。</p>
<p>RIP 协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric) 是跳数，最大跳数是 15 跳，如果大于 15 跳，它就会丢弃数据包。</p>
<p>OSPF 协议 ：Open Shortest Path First 开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p>
<p>这两种算法有点复杂但是理解起来并不难，有兴趣可以上网查一下详细是怎样工作的。</p>
<h1 id="TCP-x2F-IP-协议"><a href="#TCP-x2F-IP-协议" class="headerlink" title="TCP&#x2F;IP 协议"></a>TCP&#x2F;IP 协议</h1><p><strong>TCP&#x2F;IP 协议是 Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的 TCP 协议组成</strong>。通俗而言：TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而 IP 是给因特网的每一台联网设备规定一个地址。</p>
<p>IP 层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层 —TCP 或 UDP 层；相反，IP 层也把从 TCP 或 UDP 层接收来的数据包传送到更低层。IP 数据包是不可靠的，因为 IP 并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP 数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p>
<p>TCP 是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于 TCP 是面向连接的所以只能用于端到端的通讯。TCP 提供的是一种可靠的数据流服务，采用 “带重传的肯定确认” 技术来实现传输的可靠性。TCP 还采用一种称为 “滑动窗口” 的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p>
<p><strong>TCP 报文首部格式</strong>：</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/4.webp" class="">

<p>关于报头中的各部分的简介概括：</p>
<h2 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h2><p>各占2个字节，分别写入源端口号和目的端口号，TCP的分用功能是通过端口实现的。</p>
<p>比如一般网站都是80端口，那么向一个网站发送请求数据的话，tcp包里面的目的端口就是80，源地址由你的浏览器提供，端口号不确定，比如你的浏览器提供了一个12345的端口号那么这个tcp包的源端口就是12345。当然请求后会发送一个响应数据回来，因为由网页那边发过来浏览器拿到的tcp包的源端口就是80，目的端口就是12345。</p>
<h2 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h2><p>因为一个tcp包不能放下太多信息所以会将tcp拆开，打上序号将多个tcp包同时发送。系统会根据自己的算法处理，进行拥塞控制，比如新版的Linux系统（4.9开始）就内置了两种算法：默认的TCP控制、谷歌的BBR算法</p>
<p>两个算法的区别可以看知乎上一个<a href="https://www.zhihu.com/question/53559433">中国科学技术大学的计算机软件与理论博士的高赞回答</a></p>
<p>不过想看懂这个回答你可能还需要百度查一下比较简单的拥塞控制算法</p>
<h2 id="确认ACK（ACKnowledgment）"><a href="#确认ACK（ACKnowledgment）" class="headerlink" title="确认ACK（ACKnowledgment）"></a>确认ACK（ACKnowledgment）</h2><p>仅当ACK&#x3D;1是确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置为1</p>
<h2 id="复位RST（ReSeT）"><a href="#复位RST（ReSeT）" class="headerlink" title="复位RST（ReSeT）"></a>复位RST（ReSeT）</h2><p>当RST&#x3D;1时，表明TCP连接中出现较为严重的差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可以称为重建位或重置位。</p>
<h2 id="同步SYN（SYNchronization）"><a href="#同步SYN（SYNchronization）" class="headerlink" title="同步SYN（SYNchronization）"></a>同步SYN（SYNchronization）</h2><p>在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接报文请求段。对方若是同意建立连接，则应在响应的报文段中使用SYN&#x3D;1和ACK&#x3D;1。因此，SYN置为1就表示这是一个连接请求或连接接收报文。</p>
<h2 id="终止FIN（FINis，意思是“完”、“终”）"><a href="#终止FIN（FINis，意思是“完”、“终”）" class="headerlink" title="终止FIN（FINis，意思是“完”、“终”）"></a>终止FIN（FINis，意思是“完”、“终”）</h2><p>用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p>
<blockquote>
<p>上面几个最常用到而且需要了解的，其他的有时候也需要用到，可以百度查看详细说明</p>
</blockquote>
<h2 id="最经典的面试题：TCP-协议的三次握手和四次挥手"><a href="#最经典的面试题：TCP-协议的三次握手和四次挥手" class="headerlink" title="最经典的面试题：TCP 协议的三次握手和四次挥手"></a>最经典的面试题：TCP 协议的三次握手和四次挥手</h2><p>只要涉及到网络开发，基本上这个问题的必问的，TCP经过几次握手建立连接，断开时要经过几次挥手？</p>
<p>这里用一张图来详细说明每一步：</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/5.webp" class="">

<p><strong>TCP 连接建立过程 - 三次握手</strong>：</p>
<ol>
<li>首先 Client 端发送连接请求报文（SYN位为1）</li>
<li>Server 端接受连接后回复 ACK（ACK位为1） 报文，并为这次连接分配资源</li>
<li>Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。</li>
</ol>
<p>然后服务端和客户端就可以开心的交流♂了</p>
<p><strong>TCP 连接断开过程 - 四次挥手</strong>：</p>
<ol>
<li>假设 Client 端发起中断连接请求，也就是发送 FIN（FIN位为1） 报文</li>
<li>Server 端接到 FIN 报文后，意思是说 “我 Client 端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，”告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”</li>
<li>这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，”告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了”</li>
<li>Client 端收到 FIN 报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传</li>
<li>Server 端收到 ACK 后，就知道可以断开连接了，Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。</li>
</ol>
<p>Ok，TCP 连接就这样关闭了！</p>
<p><strong>为什么要三次挥手？</strong></p>
<p>在只有两次 “握手” 的情形下，假设 Client 想跟 Server 建立连接，但是却因为中途连接请求的数据报丢失了，故 Client 端不得不重新发送一遍；这个时候 Server 端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候 Client 端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下 Server 端将先后收到 2 次请求，并持续等待两个 Client 请求向他发送数据… 问题就在这里，Cient 端实际上只有一次请求，而 Server 端却有 2 个响应，极端的情况可能由于 Client 端多次重新发送请求数据而导致 Server 端最后建立了 N 多个响应在等待，因而造成极大的资源浪费！所以，“三次握手” 很有必要！</p>
<p><strong>为什么要四次挥手？</strong></p>
<p>试想一下，假如现在你是客户端你想断开跟 Server 的所有连接该怎么做？第一步，你自己先停止向 Server 端发送数据，并等待 Server 的回复。但事情还没有完，虽然你自身不往 Server 发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故 Server 端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p>
<h1 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h1><p><strong>UDP 用户数据报协议，是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送</strong>,简单来说就是数据会直接想目的端口发送，而且不管对方有没有收到。</p>
<p><strong>UDP 通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</strong></p>
<p>UDP 与 TCP 位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP 不被应用于那些使用虚电路的面向连接的服务，UDP 主要用于那些面向查询 — 应答的服务，例如 NFS。相对于 FTP 或 Telnet，这些服务需要交换的信息量较小。</p>
<p>每个 UDP 报文分 UDP 报头和 UDP 数据区两部分。报头由四个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP 报头由 4 个域组成，其中每个域各占用 2 个字节，具体如下：</p>
<ol>
<li>源端口号；</li>
<li>目标端口号；</li>
<li>数据报长度；</li>
<li>校验值。</li>
</ol>
<p><strong>TCP 与 UDP 的区别</strong>：TCP 是面向连接的，可靠的字节流服务；UDP 是面向无连接的，不可靠的数据报服务。</p>
<blockquote>
<p>不过由于现代的网络服务质量大幅度提高，已经有很多公司比如谷歌和微软都在研究如何使用UDP代替某些TCP服务，因为UDP有一些无与伦比的优势，比如不需要三次握手，能大幅度降低网络延迟，一定程度上减少流量消耗（在网络质量较好的情况）。比如微软和谷歌就在几年前开始一直为可以使用UDP的HTTP&#x2F;3协议努力，希望几年后能用上更先进从网络技术。</p>
</blockquote>
<h1 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h1><p>DNS 是域名系统 (DomainNameSystem) 的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将 URL 转换为 IP 地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的 IP 地址，在 Internet 上域名与 IP 地址之间是一一对应的，DNS 就是进行域名解析的服务器。DNS 命名用于 Internet 等 TCP&#x2F;IP 网络中，通过用户友好的名称查找计算机和服务。</p>
<blockquote>
<p>要记住在网络世界只能使用IP地址，而访问一个域名，比如 <code>baidu.com</code> ，系统会向DNS服务器（通过服务器IP地址）发送数据，询问 <code>baidu.com</code> 的IP地址是多少，然后想百度的服务器IP发送数据，从而实现访问百度首页。</p>
</blockquote>
<h1 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a>NAT 协议</h1><p>这个上面提到了这个技术，其实原理很简单，路由器能将外网的IP绑定到局域网的IP上面，比如路由器拿到的外网ip是123.123.123.123，局域网里面有两台主机分别是：192.168.1.1和192.168.1.2，那么这两个IP通过NAT绑定后，只要是内部想发送到局域网外部的数据包都会将局域网IP改为外网IP。比如：</p>
<ol>
<li>你想访问百度，你在局域网里面的IP是192.168.1.1，那么你发送到百度的数据包的源地址是192.168.1.1</li>
<li>数据包到达你家的路由器，路由器发现192.168.1.1这个地址在NAT映射表里面，对应的值是123.123.123.123</li>
<li>那么你的路由器会将数据包里面的源地址192.168.1.1修改为123.123.123.123，并向百度的服务器发送</li>
<li>那么百度就会看到一个来自地址为123.123.123.123的机器的请求，然后按照上面的方法建立TCP连接，然后响应数据</li>
</ol>
<p>你的浏览器就能展示百度的网页了。不过你是否发现了一个弊端？</p>
<p>百度只能知道由123.123.123.123发送的数据，并不知道是这个局域网下那个机器发送的，所以百度并不能主动向你请求建立连接。所以假如我在另一个局域网下，想将一个文件传输给你，是没办法将我的电脑跟你的电脑直接连接的，这时候有一个解决方法就是通过NAT服务器进行代理，你和我都先与服务器进行连接，然后数据就能通过服务器到达你的电脑，这种技术也成为子网穿透。详细方法可以查询百度</p>
<h1 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h1><p>DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。</p>
<p>一次HTTP数据传输报错请求和访问，请求包括：</p>
<ul>
<li>请求URL（地址）</li>
<li>请求方法</li>
<li>HTTP协议版本</li>
<li>可能会有的一些其他的请求标头和请求信息</li>
</ul>
<p>有请求就会有响应（除非网络不通或者服务器不想响应你），那么响应数据包括：</p>
<ul>
<li>HTTP协议版本</li>
<li>状态码（通过这个码判断是否成功等等）</li>
<li>一些其他的标头信息，比如时间、服务器的名称、数据是否压缩过等等</li>
</ul>
<p>HTTP还能涉及到很多方面的知识，详细信息可以查百度</p>
<p>那是那上面的例子，你想访问百度的首页：</p>
<ol>
<li>首先浏览器通过 DNS 解析到 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址 220.181.27.48，通过这个 IP 地址找到客户端到服务器的路径。客户端浏览器发起一个 HTTP 会话到 220.161.27.48，然后通过 TCP 进行封装数据包，输入到网络层。</li>
<li>在客户端的传输层，把 HTTP 会话请求分成报文段，添加源和目的端口，如服务器使用 80 端口监听客户端的请求，客户端由系统随机选择一个端口如 5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用 IP 层的 IP 地址查找目的端。</li>
<li>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li>
<li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。</li>
</ol>
<blockquote>
<p><strong>如果看完并理解这篇文章，详细你已经对计算机网络有一定的了解了，不过这这是基础知识哦，像HTTP这样的协议还包含大量的知识，比如如何加密，选择什么方式进行请求等等，如果需要做网络开发，这些都是需要去了解的，后面我可能会再写一篇HTTP的文章来让你完全了解HTTP到底是怎样的。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：装饰者模式(Go)</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-Go/</url>
    <content><![CDATA[<h1 id="什么是装饰者模式"><a href="#什么是装饰者模式" class="headerlink" title="什么是装饰者模式"></a>什么是装饰者模式</h1><p>装饰者模式有以下特点：</p>
<ul>
<li>理论上它们是可以无限包装的(无限套娃)</li>
<li>装饰者和被装饰者们有相同的超类型(super)</li>
<li>想要拓展功能无需修改原有的代码, 定义一个装饰者就可以</li>
</ul>
<p>装饰者模式使用了下面的设计原则：</p>
<ul>
<li>从”包装”我们可以看到”多用组合,少用继承”</li>
<li>从”拓展”我们可以看到”开闭原则”</li>
</ul>
<blockquote>
<p>在不必改变原类文件和使用继承的情况下, 动态地扩展一个对象的功能. 它是通过创建一个包装对象, 也就是装饰来包裹真实的对象</p>
</blockquote>
<span id="more"></span>

<h1 id="描述环节"><a href="#描述环节" class="headerlink" title="描述环节"></a>描述环节</h1><p>上面bb完特点和原则之后，我们开始使用这个模式来解决实际问题。</p>
<p>我们以游戏中角色叠buff为例，如果我们需要很多重buff，怎么用代码描述？</p>
<p>首先定义一个超类型，在Go中用接口实现，用来规范描述角色的几个方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Heros <span class="keyword">interface</span> &#123;</span><br><span class="line">    Description()   <span class="type">string</span></span><br><span class="line">    DEF()   <span class="type">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这两个方法一个是描述叠上什么buff，一个是叠上buff后的防御力。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mage <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    def     <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m mage)</span></span> Description() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m mage)</span></span> DEF() <span class="type">float32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.def</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们上面定义了一个法师类型，下面我们再写个buff的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> buff <span class="keyword">struct</span> &#123;</span><br><span class="line">    heros   Heros</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    def     <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b buff)</span></span> Description() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.heros.Description()+<span class="string">&quot;+&quot;</span>+b.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b buff)</span></span> DEF() <span class="type">float32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.heros.DEF() + b.def</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了我们写完了加防御力buff的类型，那么使用一下看看。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hero := mage&#123;name: <span class="string">&quot;战斗法师&quot;</span>, def: <span class="number">10</span>&#125;</span><br><span class="line">buff1 := buff&#123;heros: hero, name: <span class="string">&quot;魔法结界·神圣&quot;</span>, def: <span class="number">12.2</span>&#125;</span><br><span class="line">buff2 := buff&#123;heros: buff1, name: <span class="string">&quot;生命精髓&quot;</span>, def: <span class="number">3.5</span>&#125;</span><br><span class="line">buff3 := buff&#123;heros: buff2, name: <span class="string">&quot;高阶全属性强化&quot;</span>, def: <span class="number">8</span>&#125;</span><br><span class="line">buff4 := buff&#123;heros: buff3, name: <span class="string">&quot;虚假情报·生命&quot;</span>, def: <span class="number">0</span>&#125;</span><br><span class="line">buff5 := buff&#123;heros: buff4, name: <span class="string">&quot;高阶抵抗力强化&quot;</span>, def: <span class="number">15.7</span>&#125;</span><br><span class="line">fmt.Println(buff5.Description())</span><br><span class="line">fmt.Println(buff5.DEF())</span><br></pre></td></tr></table></figure>
<img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-Go/1.png" class="">
<p>可以看出套了几层buff后防御力也涨了好多啊。当然如果想在这个基础上加上可以提供攻击力加成的buff的话，只需要再写一个拥有攻击力加成的结构体，然后实现上面的接口，就可以再套娃下去，这样就一个接口，只需要不断地写出装设者的结构体和方法，就能实现非常多的功能。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Go</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>部署docker镜像服务器</title>
    <url>/%E7%AC%94%E8%AE%B0/%E9%83%A8%E7%BD%B2docker%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>这里基于Registry搭建私有仓库，需要准备两台服务器。</p>
<span id="more"></span>

<h1 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h1><ol>
<li><p>下载registry镜像并启动：<code>docker pull registry</code>,最新tag：2.7.1</p>
</li>
<li><p>启动一个容器实例：<code>docker run -d -p 5000:5000 --restart always --name registry registry:latest</code></p>
</li>
</ol>
<p>p.s. 如果使用-v会导致重启而且重启失败，所有建议不要使用，不知道因为什么问题</p>
<ol start="3">
<li>可以在另一台服务器上使用<code>curl http://your-server-ip:5000/v2/_catalog</code>拿到json数据，或者浏览器直接访问这个地址，这时候一般显示：<code>&#123;&quot;repositories&quot;:[]&#125;</code></li>
</ol>
<h1 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h1><ol>
<li>为了能快速访问搭建的镜像仓库，需要修改&#x2F;etc&#x2F;docker&#x2F;daemon.json，改为：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;your-server-ip:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
记得改成你的服务器ip或者域名</li>
</ol>
<blockquote>
<p>PS：如果不设置可信任源，又没有配置HTTPS证书，那么会遇到这个错误：<code>error: Get https://ip:port/v1/_ping: http: server gave HTTP response to HTTPS client.</code></p>
</blockquote>
<ol start="2">
<li><p>为了使得配置生效，重新启动docker服务：<code>systemctl restart docker</code></p>
</li>
<li><p>为需要上传的镜像打上tag:<code>docker tag your-image-name:tagname your-server-ip:5000/your-image-name:tagname</code></p>
</li>
<li><p>正式上传镜像：<code>docker push your-registry-server-ip:5000/your-image-name:tagname</code></p>
</li>
<li><p>再次访问一下&#x2F;v2&#x2F;_catalog这个API拿到仓库内容列表，或者通过&#x2F;v2&#x2F;your-image&#x2F;tags&#x2F;list，查看镜像都有哪些tag</p>
</li>
</ol>
<h1 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h1><p>下载直接使用pull即可：<code>docker pull your-server-ip:5000/your-image-name:tagname</code></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
        <tag>registery</tag>
      </tags>
  </entry>
  <entry>
    <title>重学操作系统笔记-1</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="“如何把程序写好”这个问题是可计算的吗？"><a href="#“如何把程序写好”这个问题是可计算的吗？" class="headerlink" title="“如何把程序写好”这个问题是可计算的吗？"></a>“如何把程序写好”这个问题是可计算的吗？</h1><h2 id="公理化体系和不完备性定理"><a href="#公理化体系和不完备性定理" class="headerlink" title="公理化体系和不完备性定理"></a>公理化体系和不完备性定理</h2><p>最早在 19 世纪初，德国著名数学家希尔伯特提出：这个世界可以建立一套完善的公理体系，由少数几个公理出发，推导出所有的定理和推论。这样就可以逐渐通过这种方法将世界上的万事万物都统一到一个体系中。</p>
<p>但在不久后，美籍数学家哥德尔就提出了哥德尔不完备性定理，内容是：即便在完善的公理体系中仍然可以找到不能被证明也不能被证伪的命题。</p>
<p><strong>计算机能力也是有边界的。哥德尔的不完备性定理，让大家看到了世界上还有大量不可计算的问题。</strong></p>
<h2 id="图灵机和可计算理论"><a href="#图灵机和可计算理论" class="headerlink" title="图灵机和可计算理论"></a>图灵机和可计算理论</h2><p>于是人们意识到了需要一个理论，专门回答这样的问题：哪些问题可以被计算，哪些不可以被计算，这就是可计算性理论，该理论是计算机科学的理论基础之一。</p>
<p>图灵发现如果一个问题是可计算的，那么它的解决方案就必须可以被具化成一条条的指令，也就是可以使用图灵机处理。因此，不能使用图灵机处理的问题，都是不可计算的问题。</p>
<p>比如一个马达的控制程序是可计算的，因为控制过程是可以被抽象成一条条指令的（即可以写程序实现）。比如程序可以先读入传感器的数据，然后根据数据计算出下面要进行加速还是减速。</p>
<h2 id="不可计算问题"><a href="#不可计算问题" class="headerlink" title="不可计算问题"></a>不可计算问题</h2><p>但当图灵机遇到“素数是不是有无穷多个？”这样的问题时，事情就变得复杂了。虽然，我们可以通过有限的步骤计算出下一个素数。比如可以每次尝试一个更大的数字，然后通过一系列计算过程判断该数字是不是素数，直到找到一个更大的素数。古希腊数学家埃拉托斯特尼就发明了筛选出给定范围内所有素数的方法。</p>
<img src="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-1/1.gif" class="">

<p>如上图所示，我们利用埃拉托斯特尼筛法找到的素数越来越多。但是，我们还是不能回答“素数是不是有无穷多个”这样的问题。因为要回答这样的问题，我们会不停地寻找下一个素数。如果素数是无穷的，那么我们的计算就是无穷无尽的，所以这样的问题不可计算。</p>
<h2 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h2><p>我们无法实现用一个通用程序去判断另一个程序是否会停止。不能因为这个程序执行了1天就判定它不会停止，也不能因为这个程序执行了 10 年，从而得出它不会停止的结论。这个问题放到图灵机领域，叫作停机问题，我们无法给出一个判断图灵机是否会停机的通用方法，因此停机问题是一个经典的不可计算问题。</p>
<h2 id="回到最初的问题：“可不可以计算一个人程序写得好不好？”"><a href="#回到最初的问题：“可不可以计算一个人程序写得好不好？”" class="headerlink" title="回到最初的问题：“可不可以计算一个人程序写得好不好？”"></a>回到最初的问题：“可不可以计算一个人程序写得好不好？”</h2><p>虽然这个是一个不可计算问题，但是可以通过设立一些规则，比如：检查缩减、检查函数复用情况、检查类的命名情况等，给写程序的人更好的建议。另外，我们也可以通过 AI 技术，让机器在“程序写得好不好”这个问题的判定能力上，达到人类的水平，通过图灵测试。</p>
<h1 id="相比-32-位，64-位的优势是什么？"><a href="#相比-32-位，64-位的优势是什么？" class="headerlink" title="相比 32 位，64 位的优势是什么？"></a>相比 32 位，64 位的优势是什么？</h1><p>32 位宽的CPU最多操作 23^2 个内存地址，也就是 2^32&#x3D;4G，当然数据总线也是32条。但是64位的CPU并不意味着处理速度会比32位的快，因为在日常处理的数据中，比如一个用户的金额不会超过10万，而2^32约等于20亿，所以这样的计算一般是不会有什么却别的。而64位意味着可以操作更大的内存，更高速的通讯，所以在计算大数据时会比32位更有优势。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>重学数据结构笔记（1）</title>
    <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>离上数据结构课已经一年了，对于很多知识点都忘得差不多了（当初也没认真学，应付完考试就算了，这么想来确实有点惭愧），那么现在开始复习一波数据结构吧，数据结构搞定了继续出下一系列的笔记：算法之美。</p>
<span id="more"></span>

<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><blockquote>
<p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p>
</blockquote>
<p>其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，<strong><strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</strong></strong></p>
<h2 id="为什么要复杂度分析"><a href="#为什么要复杂度分析" class="headerlink" title="为什么要复杂度分析"></a>为什么要复杂度分析</h2><p>你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？</p>
<p>首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫<strong>事后统计法</strong>。但是，这种统计方法有非常大的局限性。</p>
<h3 id="测试结果非常依赖测试环境"><a href="#测试结果非常依赖测试环境" class="headerlink" title="测试结果非常依赖测试环境"></a>测试结果非常依赖测试环境</h3><p>测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。</p>
<h3 id="测试结果受数据规模的影响很大"><a href="#测试结果受数据规模的影响很大" class="headerlink" title="测试结果受数据规模的影响很大"></a>测试结果受数据规模的影响很大</h3><p>比如排序算法，对于同一个排序算法，待排序的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。</p>
<h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
